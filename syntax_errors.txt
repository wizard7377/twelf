
File "lib/compress/parse.ml", line 15, characters 44-48:
15 | let rec vardec ()  = id << tick COLON && ($ term wth Some) || id wth (fun s -> (s, None))
                                                 ^^^^
Error: Syntax error: ) expected
File "lib/compress/parse.ml", line 15, characters 41-42:
15 | let rec vardec ()  = id << tick COLON && ($ term wth Some) || id wth (fun s -> (s, None))
                                              ^
  This ( might be unmatched
File "lib/int_inf/int_inf.ml", line 102, characters 420-422:
102 | let rec scanBin (getc : (char, 'a) StringCvt.reader) cs  = (match (scanPrefix getc cs) with None -> None | (Some {neg; next; rest}) -> ( let rec isDigit (d : Word32.word)  = (d < 0x2L) in let chkOverflow = chkOverflow 0x80000000L in let rec cvt (w, rest)  = (match (getc rest) with None -> Some {neg = neg; word = w; rest = rest} | Some (c, rest') -> ( let d = code c in  if (isDigit d) then (chkOverflow w; cvt (W.+ (W.<< (w, 0x1L), d), rest')) else Some {neg = neg; word = w; rest = rest} )(* end case *)
                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
Error: Syntax error
File "lib/cover/cover.ml", line 120, characters 72-73:
120 | let rec missingToString (Vs, ci)  = F.makestring_fmt (F.Hbox [F.Vbox0 0 1 (formatCGoals (Vs, ci)); F.String "."])
                                                                              ^
Error: Syntax error: ] expected
File "lib/cover/cover.ml", line 120, characters 61-62:
120 | let rec missingToString (Vs, ci)  = F.makestring_fmt (F.Hbox [F.Vbox0 0 1 (formatCGoals (Vs, ci)); F.String "."])
                                                                   ^
  This [ might be unmatched
File "lib/terminate/checking.ml", line 96, characters 195-196:
96 | let rec fmtOrder (G, O)  = ( let rec fmtOrder' = function (R.Arg (Us, Vs)) -> F.Hbox [F.String "("; Print.formatExp (G, I.EClo Us); F.String ")"] | (R.Lex L) -> F.Hbox [F.String "{"; F.HOVbox0 1 0 1 (fmtOrders L); F.String "}"] | (R.Simul L) -> F.Hbox [F.String "["; F.HOVbox0 1 0 1 (fmtOrders L); F.String "]"]
                                                                                                                                                                                                        ^
Error: Syntax error: ] expected
File "lib/terminate/checking.ml", line 96, characters 168-169:
96 | let rec fmtOrder (G, O)  = ( let rec fmtOrder' = function (R.Arg (Us, Vs)) -> F.Hbox [F.String "("; Print.formatExp (G, I.EClo Us); F.String ")"] | (R.Lex L) -> F.Hbox [F.String "{"; F.HOVbox0 1 0 1 (fmtOrders L); F.String "}"] | (R.Simul L) -> F.Hbox [F.String "["; F.HOVbox0 1 0 1 (fmtOrders L); F.String "]"]
                                                                                                                                                                             ^
  This [ might be unmatched
File "lib/modes/modeprint.ml", line 20, characters 59-60:
20 | let rec modesToString mdecs  = F.makestring_fmt (F.Vbox0 0 1 (fmtModeDecs mdecs))
                                                                ^
Error: Syntax error: ) expected
File "lib/modes/modeprint.ml", line 20, characters 48-49:
20 | let rec modesToString mdecs  = F.makestring_fmt (F.Vbox0 0 1 (fmtModeDecs mdecs))
                                                     ^
  This ( might be unmatched
File "lib/solvers/cs_eq_field.ml", line 180, characters 195-196:
180 | let rec unifySum (G, sum1, sum2)  = ( let rec invertMon = function (G, Mon (n, [(LHS, s)]), sum) -> if Whnf.isPatSub s then ( let ss = Whnf.invert s in let RHS = toFgn (timesSum (Sum (~ (inverse n), []), sum)) in  if Unify.invertible (G, (RHS, id), ss, r) then Some (G, LHS, RHS, ss) else None ) else None | _ -> None in  match minusSum (sum2, sum1) with Sum (m, []) -> if (m = zero) then Succeed [] else Fail | sum -> (match findMon invertMon (G, sum) with Some assignment -> Succeed [Assign assignment] | None -> ( let U = toFgn sum in let cnstr = ref (Eqn (G, U, numberExp (zero))) in  Succeed [Delay (U, cnstr)] )) )
                                                                                                                                                                                                         ^
Error: Syntax error
File "lib/solvers/cs_eq_integers.ml", line 173, characters 94-95:
173 | and solveSum = function (G, sum) -> if Whnf.isPatSub s then [Assign (G, X, numberExp (~ (quot (m, n))), Whnf.invert s)] else [delaySum (G, sum)] | (G, sum) -> ( let rec invertMon = function (G, mon, sum) -> if Whnf.isPatSub s then ( let ss = Whnf.invert s in let RHS = toFgn sum in  if Unify.invertible (G, (RHS, id), ss, r) then Some (mon, ss, sum) else None ) else None | (G, mon, sum) -> None in  match findMon invertMon (G, sum) with Some (Mon (n1, [(X1, s1)]), ss1, sum1) -> (match findMon invertMon (G, sum1) with Some (Mon (n2, [(X2, s2)]), ss2, sum2) -> ( let s = Unify.intersection (s1, s2) in let ss = Whnf.invert s in let G' = Whnf.strengthen (ss, G) in let g = gcd (n1, n2) in let (x1, x2) = solve_gcd (n1, n2) in let K = newEVar (G', number ()) in let Z = newEVar (G', number ()) in  Assign (G, X1, toFgn (plusSum (Sum (zero, [Mon (quot (n2, g), [(K, ss)])]), timesSum (Sum (x1, []), Sum (zero, [Mon (one, [(Z, ss)])])))), ss1) :: Assign (G, X2, toFgn (plusSum (Sum (zero, [Mon (~ (quot (n1, g)), [(K, ss)])]), timesSum (Sum (x2, []), Sum (zero, [Mon (one, [(Z, ss)])])))), ss2) :: solveSum (G, plusSum (Sum (zero, [Mon (g, [(Z, ss)])]), sum2)) ) | None -> (match divideSum (sum1, n1) with Some (sum1') -> [Assign (G, X1, toFgn (unaryMinusSum (sum1')), ss1)] | None -> [delaySum (G, sum)])) | None -> [delaySum (G, sum)] )
                                                                                                    ^
Error: Syntax error
File "lib/solvers/cs_eq_strings.ml", line 148, characters 1507-1508:
148 | let rec unifyString = function (G, Concat (String prefix :: AL), str, cnstr) -> if (String.isPrefix prefix str) then ( let suffix = String.extract (str, String.size prefix, None) in  unifyString (G, Concat AL, suffix, cnstr) ) else Failure | (G, Concat AL, str, cnstr) -> ( let rec unifyString' = function (AL, []) -> (Failure, []) | ([], [Decomp (parse, parsedL)]) -> (MultAssign [], parse :: parsedL) | ([], candidates) -> (MultDelay ([], cnstr), []) | ((Exp Us1) :: (Exp Us2) :: AL, _) -> (MultDelay ([EClo Us1; EClo Us2], cnstr), []) | ((Exp (U, s)) :: AL, candidates) -> if (Whnf.isPatSub s) then ( let rec assign = function (r, []) -> None | (r, ((_, EVar (r', _, _, _), Root (FgnConst (cs, conDec), Nil), _) :: L)) -> if (r = r') then fromString (conDecName (conDec)) else assign r L | (r, (_ :: L)) -> assign r L in  (match unifyString' (AL, candidates) with (MultAssign L, parsed :: parsedL) -> (match (assign r L) with None -> ( let ss = Whnf.invert s in let W = stringExp (parsed) in  (MultAssign ((G, U, W, ss) :: L), parsedL) ) | Some (parsed') -> if (parsed = parsed') then (MultAssign L, parsedL) else (Failure, [])) | (MultDelay (UL, cnstr), _) -> (MultDelay ((EClo (U, s)) :: UL, cnstr), []) | (Failure, _) -> (Failure, [])) ) else (MultDelay ([EClo (U, s)], cnstr), []) | ((Exp Us) :: AL, _) -> (MultDelay ([EClo Us], cnstr), []) | ([String str], candidates) -> ( let rec successors (Decomp (parse, parsedL))  = List.mapPartial (fun (Split (prefix, "")) -> Some (Decomp (prefix, parsedL)) | (Split (prefix, suffix)) -> None) (split (str, parse)) in let candidates' = List.foldr @ [] (List.map successors candidates) in  unifyString' ([], candidates') ) | ((String str) :: AL, candidates) -> ( let rec successors (Decomp (parse, parsedL))  = List.map (fun (Split (prefix, suffix)) -> Decomp (suffix, prefix :: parsedL)) (split (str, parse)) in let candidates' = List.foldr @ [] (List.map successors candidates) in  unifyString' (AL, candidates') ) in  (match unifyString' (AL, [Decomp (str, [])]) with (result, []) -> result | (result, [""]) -> result | (result, parsedL) -> Failure) )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
Error: Syntax error: ) expected
File "lib/solvers/cs_eq_strings.ml", line 148, characters 1446-1447:
148 | let rec unifyString = function (G, Concat (String prefix :: AL), str, cnstr) -> if (String.isPrefix prefix str) then ( let suffix = String.extract (str, String.size prefix, None) in  unifyString (G, Concat AL, suffix, cnstr) ) else Failure | (G, Concat AL, str, cnstr) -> ( let rec unifyString' = function (AL, []) -> (Failure, []) | ([], [Decomp (parse, parsedL)]) -> (MultAssign [], parse :: parsedL) | ([], candidates) -> (MultDelay ([], cnstr), []) | ((Exp Us1) :: (Exp Us2) :: AL, _) -> (MultDelay ([EClo Us1; EClo Us2], cnstr), []) | ((Exp (U, s)) :: AL, candidates) -> if (Whnf.isPatSub s) then ( let rec assign = function (r, []) -> None | (r, ((_, EVar (r', _, _, _), Root (FgnConst (cs, conDec), Nil), _) :: L)) -> if (r = r') then fromString (conDecName (conDec)) else assign r L | (r, (_ :: L)) -> assign r L in  (match unifyString' (AL, candidates) with (MultAssign L, parsed :: parsedL) -> (match (assign r L) with None -> ( let ss = Whnf.invert s in let W = stringExp (parsed) in  (MultAssign ((G, U, W, ss) :: L), parsedL) ) | Some (parsed') -> if (parsed = parsed') then (MultAssign L, parsedL) else (Failure, [])) | (MultDelay (UL, cnstr), _) -> (MultDelay ((EClo (U, s)) :: UL, cnstr), []) | (Failure, _) -> (Failure, [])) ) else (MultDelay ([EClo (U, s)], cnstr), []) | ((Exp Us) :: AL, _) -> (MultDelay ([EClo Us], cnstr), []) | ([String str], candidates) -> ( let rec successors (Decomp (parse, parsedL))  = List.mapPartial (fun (Split (prefix, "")) -> Some (Decomp (prefix, parsedL)) | (Split (prefix, suffix)) -> None) (split (str, parse)) in let candidates' = List.foldr @ [] (List.map successors candidates) in  unifyString' ([], candidates') ) | ((String str) :: AL, candidates) -> ( let rec successors (Decomp (parse, parsedL))  = List.map (fun (Split (prefix, suffix)) -> Decomp (suffix, prefix :: parsedL)) (split (str, parse)) in let candidates' = List.foldr @ [] (List.map successors candidates) in  unifyString' (AL, candidates') ) in  (match unifyString' (AL, [Decomp (str, [])]) with (result, []) -> result | (result, [""]) -> result | (result, parsedL) -> Failure) )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
  This ( might be unmatched
File "lib/table/red_black_set.ml", line 155, characters 677-679:
155 | let rec diffMod F (Set (_, s1), Set (_, s2))  = ( let rec ins = function ((Empty, _), n, result) -> (n, result) | ((Red (x, _, _), r), n, result) -> ins (next r, n + 1, addItem (x, result)) | ((Black (x, _, _), r), n, result) -> ins (next r, n + 1, addItem (x, result)) in let rec diff (t1, t2, (n1, result1), (n2, result2))  = (match (next t1, next t2) with ((Empty, _), t2) -> ((n1, result1), ins (t2, n2, result2)) | (t1, (Empty, _)) -> (ins (t1, n1, result1), (n2, result2)) | ((tree1, r1), (tree2, r2)) -> ( let e1 = getEntry tree1 in let e2 = getEntry tree2 in  match compare (x, y) with Lt -> diff (r1, t2, (n1 + 1, addItem (e1, result1)), (n2, result2)) | Eq -> ((F d1 d2); diff (r1, r2, (n1, result1), (n2, result2))) | Gt -> diff (t1, r2, (n1, result1), (n2 + 1, addItem (e2, result2))) )) in let ((n1, result1), (n2, result2)) = diff (start s1, start s2, (0, ZERO), (0, ZERO)) in  (Set (n1, linkAll result1), Set (n2, linkAll result2)) )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
Error: Syntax error: ) expected
File "lib/table/red_black_set.ml", line 155, characters 671-672:
155 | let rec diffMod F (Set (_, s1), Set (_, s2))  = ( let rec ins = function ((Empty, _), n, result) -> (n, result) | ((Red (x, _, _), r), n, result) -> ins (next r, n + 1, addItem (x, result)) | ((Black (x, _, _), r), n, result) -> ins (next r, n + 1, addItem (x, result)) in let rec diff (t1, t2, (n1, result1), (n2, result2))  = (match (next t1, next t2) with ((Empty, _), t2) -> ((n1, result1), ins (t2, n2, result2)) | (t1, (Empty, _)) -> (ins (t1, n1, result1), (n2, result2)) | ((tree1, r1), (tree2, r2)) -> ( let e1 = getEntry tree1 in let e2 = getEntry tree2 in  match compare (x, y) with Lt -> diff (r1, t2, (n1 + 1, addItem (e1, result1)), (n2, result2)) | Eq -> ((F d1 d2); diff (r1, r2, (n1, result1), (n2, result2))) | Gt -> diff (t1, r2, (n1, result1), (n2 + 1, addItem (e2, result2))) )) in let ((n1, result1), (n2, result2)) = diff (start s1, start s2, (0, ZERO), (0, ZERO)) in  (Set (n1, linkAll result1), Set (n2, linkAll result2)) )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  This ( might be unmatched
File "lib/print/print.ml", line 352, characters 41-42:
352 | let rec formatCnstr (Cnstr)  = F.Vbox0 0 1 (fmtCnstr Cnstr)
                                               ^
Error: Syntax error: end expected
File "lib/print/print.ml", line 10, characters 146-152:
10 | module Print (Whnf : WHNF) (Abstract : ABSTRACT) (Constraints : CONSTRAINTS) (Names : NAMES) (Formatter' : FORMATTER) (Symbol : SYMBOL) : PRINT = struct (*! structure IntSyn = IntSyn' !*)
                                                                                                                                                       ^^^^^^
  This struct might be unmatched
File "lib/solvers/cs_ineq_field.ml", line 65, characters 0-1:
65 | ; tag: int ref; (* tag: used to keep track of the    *)
     ^
Error: Syntax error
File "lib/solvers/cs_ineq_integers.ml", line 71, characters 0-1:
71 | ; clabels: label Array.array; (* column labels                     *)
     ^
Error: Syntax error
File "lib/solvers/cs_integers_word.ml", line 25, characters 26-28:
25 | let rec numCheck (d)  = W.<= (d, max)
                               ^^
Error: Syntax error
File "lib/solvers/cs_manager.ml", line 55, characters 24-33:
55 | and useSolver name  = ( exception Found of IntSyn.csid in let rec findSolver name  = try (ArraySlice.appi (fun (cs, Solver (solver, _)) -> if (name (solver) = name) then raise (Found cs) else ()) (ArraySlice.slice (csArray, 0, Some (! nextCS))); None) with Found cs -> Some (cs) in  match findSolver name with Some (cs) -> ( let Solver (solver, active) = Array.sub (csArray, cs) in  if ! active then () else if List.exists (fun s -> s = keywords (solver)) (! activeKeywords) then raise (Error ("solver " ^ name ^ " is incompatible with a currently active solver")) else (active := true; activeKeywords := keywords (solver) :: (! activeKeywords); List.app useSolver (needs (solver)); init (solver) (cs, ! installFN)) ) | None -> raise (Error ("solver " ^ name ^ " not found")) )
                             ^^^^^^^^^
Error: Syntax error: operator expected.
File "lib/terminate/reduces.ml", line 29, characters 195-196:
29 | let rec fmtOrder (G, O)  = ( let rec fmtOrder' = function (R.Arg (Us, Vs)) -> F.Hbox [F.String "("; Print.formatExp (G, I.EClo Us); F.String ")"] | (R.Lex L) -> F.Hbox [F.String "{"; F.HOVbox0 1 0 1 (fmtOrders L); F.String "}"] | (R.Simul L) -> F.Hbox [F.String "["; F.HOVbox0 1 0 1 (fmtOrders L); F.String "]"]
                                                                                                                                                                                                        ^
Error: Syntax error: ] expected
File "lib/terminate/reduces.ml", line 29, characters 168-169:
29 | let rec fmtOrder (G, O)  = ( let rec fmtOrder' = function (R.Arg (Us, Vs)) -> F.Hbox [F.String "("; Print.formatExp (G, I.EClo Us); F.String ")"] | (R.Lex L) -> F.Hbox [F.String "{"; F.HOVbox0 1 0 1 (fmtOrders L); F.String "}"] | (R.Simul L) -> F.Hbox [F.String "["; F.HOVbox0 1 0 1 (fmtOrders L); F.String "]"]
                                                                                                                                                                             ^
  This [ might be unmatched
File "lib/meta/funprint.ml", line 70, characters 375-376:
70 | let rec nameLookup index  = List.nth (names, index) in let rec formatFor1 = function (index, G, (F.And (F1, F2), s)) -> formatFor1 (index, G, (F1, s)) @ [Fmt.Break] @ formatFor1 (index + 1, G, (F2, s)) | (index, G, (F, s)) -> [Fmt.String (nameLookup index); Fmt.Space; Fmt.String "::"; Fmt.Space; Fmt.HVbox (formatFor' (G, (F, s)))] in let rec formatFor0 Args  = Fmt.Vbox0 0 1 (formatFor1 Args) in  (Names.varReset I.Null; formatFor0 (0, F.makectx Psi, (F, I.id))) )
                                                                                                                                                                                                                                                                                                                                                                                            ^
Error: Syntax error
File "lib/meta/funtypecheck.ml", line 21, characters 28-37:
21 | let rec conv (Gs, Gs')  = ( exception Conv in let rec conv = function ((I.Null, s), (I.Null, s')) -> (s, s') | ((I.Decl (G, I.Dec (_, V)), s), (I.Decl (G', I.Dec (_, V')), s')) -> ( let (s1, s1') = conv ((G, s), (G', s')) in let ps = (I.dot1 s1, I.dot1 s1') in  if Conv.conv ((V, s1), (V', s1')) then ps else raise (Conv) ) | _ -> raise (Conv) in  try (conv (Gs, Gs'); true) with Conv -> false )
                                 ^^^^^^^^^
Error: Syntax error: operator expected.
File "lib/opsem/tmachine.ml", line 87, characters 141-150:
87 | let tag = T.tagGoal () in let _ = T.signal (G, T.SolveGoal (tag, Ha, I.EClo ps')) in let deterministic = C.detTableCheck (cidFromHead Ha) in exception SucceedOnce of I.spine in let rec matchSig = function [] -> (T.signal (G, T.FailGoal (tag, Ha, I.EClo ps')); ()) | (Hc :: sgn') -> ( let C.SClause (r) = C.sProgLookup (cidFromHead Hc) in  (* trail to undo EVar instantiations *)
                                                                                                                                                  ^^^^^^^^^
Error: Syntax error
File "lib/meta/inference.ml", line 43, characters 264-265:
43 | let rec forward = function (G, B, V) -> ( let _ = if ! Global.doubleCheck then TypeCheck.typeCheck (G, (V, I.Uni I.Type)) else () in let (Xs, (V', s')) = createEVars (G, (V, I.id)) in  try (match UniqueSearch.searchEx (2, Xs, fun [] -> [(Whnf.normalize (V', s'))] | _ -> raise (UniqueSearch.Error "Too many solutions")) with [VF''] -> Some VF'' | [] -> None) with UniqueSearch.Error _ -> None ) | (G, B, V) -> None
                                                                                                                                                                                                                                                                             ^
Error: Syntax error: ) expected
File "lib/meta/inference.ml", line 43, characters 218-219:
43 | let rec forward = function (G, B, V) -> ( let _ = if ! Global.doubleCheck then TypeCheck.typeCheck (G, (V, I.Uni I.Type)) else () in let (Xs, (V', s')) = createEVars (G, (V, I.id)) in  try (match UniqueSearch.searchEx (2, Xs, fun [] -> [(Whnf.normalize (V', s'))] | _ -> raise (UniqueSearch.Error "Too many solutions")) with [VF''] -> Some VF'' | [] -> None) with UniqueSearch.Error _ -> None ) | (G, B, V) -> None
                                                                                                                                                                                                                               ^
  This ( might be unmatched
File "lib/meta/print.ml", line 23, characters 184-185:
23 | let rec formatOrder = function (G, S.Arg (Us, Vs)) -> [Print.formatExp (G, I.EClo Us); Fmt.String ":"; Print.formatExp (G, I.EClo Vs)] | (G, S.Lex Os) -> [Fmt.String "{"; Fmt.HVbox0 1 0 1 (formatOrders (G, Os)); Fmt.String "}"] | (G, S.Simul Os) -> [Fmt.String "["; Fmt.HVbox0 1 0 1 (formatOrders (G, Os)); Fmt.String "]"]
                                                                                                                                                                                             ^
Error: Syntax error: ] expected
File "lib/meta/print.ml", line 23, characters 154-155:
23 | let rec formatOrder = function (G, S.Arg (Us, Vs)) -> [Print.formatExp (G, I.EClo Us); Fmt.String ":"; Print.formatExp (G, I.EClo Vs)] | (G, S.Lex Os) -> [Fmt.String "{"; Fmt.HVbox0 1 0 1 (formatOrders (G, Os)); Fmt.String "}"] | (G, S.Simul Os) -> [Fmt.String "["; Fmt.HVbox0 1 0 1 (formatOrders (G, Os)); Fmt.String "]"]
                                                                                                                                                               ^
  This [ might be unmatched
File "lib/meta/mpi.ml", line 36, characters 347-348:
36 | let rec printFillResult (_, P)  = ( let rec formatTuple (G, P)  = ( let rec formatTuple' = function (F.Unit) -> [] | (F.Inx (M, F.Unit)) -> [Print.formatExp (G, M)] | (F.Inx (M, P')) -> (Print.formatExp (G, M) :: Fmt.String "," :: Fmt.Break :: formatTuple' P') in  match P with (F.Inx (_, F.Unit)) -> Fmt.Hbox (formatTuple' P) | _ -> Fmt.HVbox0 1 1 1 (Fmt.String "(" :: (formatTuple' P @ [Fmt.String ")"])) ) in let S.State (n, (G, B), (IH, OH), d, O, H, F) = current () in  TextIO.print ("Filling successful with proof term:\n" ^ (Formatter.makestring_fmt (formatTuple (G, P))) ^ "\n") )
                                                                                                                                                                                                                                                                                                                                                                ^
Error: Syntax error: ) expected
File "lib/meta/mpi.ml", line 36, characters 66-67:
36 | let rec printFillResult (_, P)  = ( let rec formatTuple (G, P)  = ( let rec formatTuple' = function (F.Unit) -> [] | (F.Inx (M, F.Unit)) -> [Print.formatExp (G, M)] | (F.Inx (M, P')) -> (Print.formatExp (G, M) :: Fmt.String "," :: Fmt.Break :: formatTuple' P') in  match P with (F.Inx (_, F.Unit)) -> Fmt.Hbox (formatTuple' P) | _ -> Fmt.HVbox0 1 1 1 (Fmt.String "(" :: (formatTuple' P @ [Fmt.String ")"])) ) in let S.State (n, (G, B), (IH, OH), d, O, H, F) = current () in  TextIO.print ("Filling successful with proof term:\n" ^ (Formatter.makestring_fmt (formatTuple (G, P))) ^ "\n") )
                                                                       ^
  This ( might be unmatched
File "lib/opsem/tabled.ml", line 199, characters 124-132:
199 |  with T.NewEntry (answRef) -> matchAtom ((p, s), dp, (fun pskeleton -> match MT.answerCheck (s', answRef, pskeleton) with T.repeated -> () | T.new_ -> (sc pskeleton))) | T.RepeatedEntry (asub, answRef, T.Incomplete) -> if T.noAnswers answRef then (* loop detected
                                                                                                                                  ^^^^^^^^
Error: Syntax error
File "lib/meta/splitting.ml", line 49, characters 28-37:
49 | let rec conv (Gs, Gs')  = ( exception Conv in let rec conv = function ((I.Null, s), (I.Null, s')) -> (s, s') | ((I.Decl (G, I.Dec (_, V)), s), (I.Decl (G', I.Dec (_, V')), s')) -> ( let (s1, s1') = conv ((G, s), (G', s')) in let ps = (I.dot1 s1, I.dot1 s1') in  if Conv.conv ((V, s1), (V', s1')) then ps else raise (Conv) ) | _ -> raise (Conv) in  try (conv (Gs, Gs'); true) with Conv -> false )
                                 ^^^^^^^^^
Error: Syntax error: operator expected.
File "lib/m2/splitting.ml", line 221, characters 1-3:
221 |  && not (isIndex 1) && checkDec (M, D) then (makeAddress 1, split (M.Prefix (G', M', B'), (D, s'), abstract)) :: ops else ops in  (M.Prefix (G', M', B'), I.Dot (I.Exp (X), s'), ops') ) | (M.Prefix (I.Decl (G, D), I.Decl (M, mode), I.Decl (B, b)), isIndex, abstract, makeAddress) -> ( let (M.Prefix (G', M', B'), s', ops) = expand' (M.Prefix (G, M, B), isIndexSucc (D, isIndex)(* -###- *)
       ^^
Error: Syntax error
File "lib/tomega/coverage.ml", line 64, characters 650-652:
64 | let rec coverageCheckPrg = function (W, Psi, T.Lam (D, P)) -> coverageCheckPrg (W, I.Decl (Psi, D), P) | (W, Psi, T.New P) -> coverageCheckPrg (W, Psi, P) | (W, Psi, T.PairExp (U, P)) -> coverageCheckPrg (W, Psi, P) | (W, Psi, T.PairBlock (B, P)) -> coverageCheckPrg (W, Psi, P) | (W, Psi, T.PairPrg (P1, P2)) -> (coverageCheckPrg (W, Psi, P1); coverageCheckPrg (W, Psi, P2)) | (W, Psi, T.Unit) -> () | (W, Psi, T.Var _) -> () | (W, Psi, T.Const _) -> () | (W, Psi, T.Rec (D, P)) -> coverageCheckPrg (W, I.Decl (Psi, D), P) | (W, Psi, T.Case (T.Cases Omega)) -> coverageCheckCases (W, Psi, Omega, []) | (W, Psi, P) -> (coverageCheckPrg (W, Psi, P1); (* chatter 5 ("fn () => TomegaPrint.prgToString (Psi, P)); *)

File "lib/tomega/tomegaprint.ml", line 310, characters 349-350:
310 | and formatTuple (Psi, P)  = ( let rec formatTuple' = function (T.Unit) -> [] | (T.PairExp (M, T.Unit)) -> [Print.formatExp (T.coerceCtx Psi, M)] | (T.PairExp (M, P')) -> (Print.formatExp (T.coerceCtx Psi, M) :: Fmt.String "," :: Fmt.Break :: formatTuple' P') in  match P with (T.PairExp (_, T.Unit)) -> Fmt.Hbox (formatTuple' P) | _ -> Fmt.HVbox0 1 1 1 (Fmt.String "(" :: (formatTuple' P @ [Fmt.String ")"])) )
                                                                                                                                                                                                                                                                                                                                                                   ^
Error: Syntax error: ) expected
File "lib/tomega/tomegaprint.ml", line 310, characters 28-29:
310 | and formatTuple (Psi, P)  = ( let rec formatTuple' = function (T.Unit) -> [] | (T.PairExp (M, T.Unit)) -> [Print.formatExp (T.coerceCtx Psi, M)] | (T.PairExp (M, P')) -> (Print.formatExp (T.coerceCtx Psi, M) :: Fmt.String "," :: Fmt.Break :: formatTuple' P') in  match P with (T.PairExp (_, T.Unit)) -> Fmt.Hbox (formatTuple' P) | _ -> Fmt.HVbox0 1 1 1 (Fmt.String "(" :: (formatTuple' P @ [Fmt.String ")"])) )
                                  ^
  This ( might be unmatched
File "lib/prover/stateprint.ml", line 87, characters 63-64:
87 | let rec formatState (S.State (W, Psi, P, F, _))  = Fmt.Vbox0 0 1 [Fmt.String "------------------------"; Fmt.Break; Fmt.String "------------------------"; Fmt.Break; TomegaPrint.formatPrg (Psi, P)]
                                                                    ^
Error: Syntax error: end expected
File "lib/prover/stateprint.ml", line 7, characters 153-159:
7 | module StatePrint (Global : GLOBAL) (State' : STATE) (Names : NAMES) (Formatter' : FORMATTER) (Print : PRINT) (TomegaPrint : TOMEGAPRINT) : STATEPRINT = struct module Formatter = Formatter'
                                                                                                                                                             ^^^^^^
  This struct might be unmatched
File "lib/frontend/lexer.ml", line 73, characters 0-3:
73 | let _ = P.resetLines ()
     ^^^
Error: Syntax error
File "lib/frontend/recon_query.ml", line 27, characters 19-21:
27 | type solve = solve of string option * T.term * Paths.region
                        ^^
Error: Syntax error: end expected
File "lib/frontend/recon_query.ml", line 10, characters 192-198:
10 | module ReconQuery (Global : GLOBAL) (Names : NAMES) (Abstract : ABSTRACT) (ReconTerm' : RECON_TERM) (TypeCheck : TYPECHECK) (Strict : STRICT) (Timers : TIMERS) (Print : PRINT) : RECON_QUERY = struct (*! structure IntSyn = IntSyn' !*)
                                                                                                                                                                                                     ^^^^^^
  This struct might be unmatched
File "lib/frontend/solve.ml", line 10, characters 13-23:
10 | module Solve ReconQuery.queryParser.ExtQuery.query ReconQuery.solveParser.ExtQuery.solve ReconQuery.defineParser.ExtQuery.define (Global : GLOBAL) (Names : NAMES) (Parser : PARSER) (ReconQuery : RECON_QUERY) (Timers : TIMERS) (Compile : COMPILE) (CPrint : CPRINT) (AbsMachine : ABSMACHINE) (AbsMachineSbt : ABSMACHINESBT) (PtRecon : PTRECON) (Tabled : TABLED) (Print : PRINT) (Msg : MSG) : SOLVE = struct (*! structure IntSyn = IntSyn' !*)
                  ^^^^^^^^^^
Error: Syntax error
File "lib/frontend/twelf.ml", line 13, characters 13-22:
13 | module Twelf ReconTerm.termParser.ExtSyn.term ReconConDec.condecParser.ExtConDec.condec ReconMode.modedecParser.ExtModes.modedec Solve.ExtQuery.queryParser.ExtQuery.query Solve.ExtQuery.defineParser.ExtQuery.define Solve.ExtQuery.solveParser.ExtQuery.solve Fquery.ExtQuery.queryParser.ExtQuery.query Fquery.ExtQuery.defineParser.ExtQuery.define Fquery.ExtQuery.solveParser.ExtQuery.solve ReconThm.tdeclParser.ThmExtSyn.tdecl ReconThm.rdeclParser.ThmExtSyn.rdecl ReconThm.tableddeclParser.ThmExtSyn.tableddecl ReconThm.keepTabledeclParser.ThmExtSyn.keepTabledecl ReconThm.wdeclParser.ThmExtSyn.wdecl ReconThm.theoremParser.ThmExtSyn.theorem ReconThm.theoremdecParser.ThmExtSyn.theoremdec ReconThm.proveParser.ThmExtSyn.prove ReconThm.establishParser.ThmExtSyn.establish ReconThm.assertParser.ThmExtSyn.assert_ml ReconModule.sigdefParser.ModExtSyn.sigdef ReconModule.structdecParser.ModExtSyn.structdec ReconModule.sigexpParser.ModExtSyn.sigexp ReconModule.strexpParser.ModExtSyn.strexp (Global : GLOBAL) (Timers : TIMERS) (Whnf : WHNF) (Print : PRINT) (Names : NAMES) (Origins : ORIGINS) (Lexer : LEXER) (Parser : PARSER) (TypeCheck : TYPECHECK) (Strict : STRICT) (Constraints : CONSTRAINTS) (Abstract : ABSTRACT) (ReconTerm : RECON_TERM) (ReconConDec : RECON_CONDEC) (ReconQuery : RECON_QUERY) (ModeTable : MODETABLE) (ModeCheck : MODECHECK) (ReconMode : RECON_MODE) (ModePrint : MODEPRINT) (ModeDec : MODEDEC) (StyleCheck : STYLECHECK) (Unique : UNIQUE) (UniqueTable : MODETABLE) (Cover : COVER) (Converter : CONVERTER) (TomegaPrint : TOMEGAPRINT) (TomegaCoverage : TOMEGACOVERAGE) (TomegaTypeCheck : TOMEGATYPECHECK) (Total : TOTAL) (Reduces : REDUCES) (Index : INDEX) (IndexSkolem : INDEX) (Subordinate : SUBORDINATE) (Compile : COMPILE) (AbsMachine : ABSMACHINE) (Tabled : TABLED) (Solve : SOLVE) (Fquery : FQUERY) (ThmSyn : THMSYN) (Thm : THM) (ReconThm : RECON_THM) (ThmPrint : THMPRINT) (TabledSyn : TABLEDSYN) (WorldSyn : WORLDSYN) (Worldify : WORLDIFY) (ModSyn : MODSYN) (ReconModule : RECON_MODULE) (MetaGlobal : METAGLOBAL) (Skolem : SKOLEM) (Prover : PROVER) (ClausePrint : CLAUSEPRINT) (Trace : TRACE) (PrintTeX : PRINT) (ClausePrintTeX : CLAUSEPRINT) (CSManager : CS_MANAGER) (CSInstaller : CS_INSTALLER) (Compat : COMPAT) (UnknownExn : UNKNOWN_EXN) (Msg : MSG) : TWELF = struct (*! structure IntSyn = IntSyn' !*)
                  ^^^^^^^^^
Error: Syntax error
File "lib/frontend/recon_term.ml", line 83, characters 21-23:
83 | type term = internal of IntSyn.exp * IntSyn.exp * Paths.region | constant of IntSyn.head * Paths.region | bvar of int * Paths.region | evar of string * Paths.region | fvar of string * Paths.region | typ of Paths.region | arrow of term * term | pi of dec * term | lam of dec * term | app of term * term | hastype of term * term | mismatch of term * term * string * string | omitted of Paths.region | lcid of string list * string * Paths.region | ucid of string list * string * Paths.region | quid of string list * string * Paths.region | scon of string * Paths.region | omitapx of Apx.exp * Apx.exp * Apx.uni * Paths.region | omitexact of IntSyn.exp * IntSyn.exp * Paths.region and dec = dec of string option * term * Paths.region
                          ^^
Error: Syntax error: end expected
File "lib/frontend/recon_term.ml", line 22, characters 146-152:
22 | module ReconTerm (Names : NAMES) (Approx : APPROX) (Whnf : WHNF) (Unify : UNIFY) (Abstract : ABSTRACT) (Print : PRINT) (Msg : MSG) : RECON_TERM = struct (*! structure IntSyn = IntSyn' !*)
                                                                                                                                                       ^^^^^^
  This struct might be unmatched
File "lib/frontend/recon_module.ml", line 24, characters 21-27:
24 | type sigexp = ModSyn.module option -> ModSyn.module * whereclause list
                          ^^^^^^
Error: Syntax error
File "lib/delphin/parse_prg.ml", line 7, characters 13-20:
7 | module Parse Parserr.argInterface.arg Parserr.posInterface.pos Parserr.resultDextSyn.ast Tokens.tokenParserr.Token.token Tokens.svalueParserr.svalue (DextSyn : DEXTSYN) (Interface : INTERFACE) (Parserr : PARSERR) (Tokens : Delphin_TOKENS) : PARSE = struct module DextSyn = DextSyn
                 ^^^^^^^
Error: Syntax error
File "lib/frontend/unknownexn.ml", line 4, characters 19-22:
4 | module UnknownExn (val exnHistory : exn -> string list) : UNKNOWN_EXN = struct let rec unknownExn exn  = ( let history = rev (exnHistory exn) in let rec wrap1 x  = "  raised at: " ^ x ^ "\n" in let rec wrapn x  = "             " ^ x ^ "\n" in  concat ("Unrecognized exception " :: (exnName exn) :: "\n" :: (match history with [] -> [""] | x :: xs -> (wrap1 x :: map wrapn xs))) )
                       ^^^
Error: Syntax error
File "lib/delphin/interface.ml", line 14, characters 33-34:
14 | let rec error (errmsg, line : pos, _)  = TextIO.output (TextIO.stdOut, "Line " ^ (Int.toString (line)) ^ ": " ^ errmsg ^ "\n")
                                      ^
Error: Syntax error: ) expected
File "lib/delphin/interface.ml", line 14, characters 14-15:
14 | let rec error (errmsg, line : pos, _)  = TextIO.output (TextIO.stdOut, "Line " ^ (Int.toString (line)) ^ ": " ^ errmsg ^ "\n")
                   ^
  This ( might be unmatched

File "lib/modules/modsyn.mli", line 14, characters 7-13:
14 |   type module
            ^^^^^^
Error: Syntax error

File "lib/lambda/approx.mli", line 11, characters 6-10:
11 |   val Type : uni
           ^^^^
Error: Syntax error
File "lib/domains/rationals.mli", line 6, characters 10-23:
Error: Unbound module type ORDERED_FIELD
File "lib/frontend/recon_module.mli", line 33, characters 55-61:
33 |   type structDec = StructDec of string option * ModSyn.module * whereclause list | StructDef of string option * IntSyn.mid
                                                            ^^^^^^
Error: Syntax error
