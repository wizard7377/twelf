{
open Delphin_parser (* The parser module generated by Menhir *)
open Interface
open Lexer

let pos = ref 0
let inc z = z := !z + 1
}

let ws = [' ' '\t']
let uiden = (['#']['A'-'Z']['_']|['_''A'-'Z''a'-'z'])(['a'-'z''A'-'Z''0'-'9''_''-''!''@''#''$''/''\\' '^''&''*''+''|'';''\'' ]*)

rule token = parse
  | ws+                      { token lexbuf }
  | '\n'                     { next_line (); token lexbuf }
  | "(*"                     { comment lexbuf }
  | '@'                      { AT }
  | '*'                      { TIMES }
  | '+'                      { PLUS }
  | "::"                     { DBLCOLON }
  | ':'                      { COLON }
  | '.'                      { DOT }
  | "->"                     { RTARROW }
  | "<-"                     { LTARROW }
  | "=>"                     { DBLARROW }
  | '='                      { EQUAL }
  | "<>"                     { UNIT }
  | '<'                      { LTANGLE }
  | '>'                      { RTANGLE }
  | '('                      { LTPAREN }
  | ')'                      { RTPAREN }
  | "[["                     { LLAM }
  | "]]"                     { RLAM }
  | '['                      { LTBRACKET }
  | ']'                      { RTBRACKET }
  | '{'                      { LTBRACE }
  | '}'                      { RTBRACE }
  | ','                      { COMMA }
  | "||"                     { PAR }
  | '|'                      { BAR }
  | "type"                   { TYPE }
  | "world"                  { WORLD }
  | "val"                    { VAL }
  | "fun"                    { FUN }
  | "case"                   { CASE }
  | "of"                     { OF }
  | "let"                    { LET }
  | "in"                     { IN }
  | "end"                    { END }
  | "new"                    { NEW }
  | "choose"                 { CHOOSE }
  | "%block"                 { BLOCKDEC }
  | "some"                   { SOME (Lexing.lexeme lexbuf) }
  | "block"                  { BLOCK (Lexing.lexeme lexbuf) }
  | "create"                 { CREATE }
  | "all"                    { ALL }
  | "all^"                   { ALLOMITTED }
  | "exists"                 { EXISTS }
  | "exists^"                { EXISTSOMITTED }
  | "true"                   { TRUE }
  | "and"                    { AND }
  | '_'                      { UNDERSCORE }
  | (uiden as id) ws+ "::"   { FORMID id }
  | uiden as id              { ID id }
  | _                        { error ("ignoring bad character " ^ Lexing.lexeme lexbuf, !line, !line); token lexbuf }
  | eof                      { EOF }

and comment = parse
  | ws+                      { comment lexbuf }
  | '\n'                     { next_line (); comment lexbuf }
  | "*)"                     { token lexbuf }
  | _                        { comment lexbuf }
