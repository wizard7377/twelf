Code parsed successfully: setExamplesDir "/usr0/stuff/twelf-cvs/examples"
let rec httpServer _  = (httpServer 1066 "/usr0/stuff/twelf-cvs/src/netserver/htdocs"; success)
exportFn ("netserver.heap", httpServer)

('Error parsing code:', 'module type NETSERVER = sig (* int argument is which port number to run on *) val flashServer : int -> unit(* Macromedia Flash XMLSocket interface *) val humanServer : int -> unit(* Human-readable interface, suitable for telnet *) (* second argument is what directory server.html is kept in *) val httpServer : int -> string -> unit(* HTTP interface, suitable for javascript XMLHttpRequest *) val setExamplesDir : string -> unit(* filesystem directory where twelf examples are kept *)  end(* signature SERVER *) module NetServer (module Timing : TIMINGmodule Twelf : TWELFmodule Msg : MSG)NETSERVER = struct let rec join delim []  = "" | join delim [x]  = x | join delim (h :: tl)  = h ^ delim ^ (join delim tl) type server = {send: string -> unit; exec: string -> unit} type protocol = {init: unit -> unit; reset: unit -> unit; recv: server -> string -> unit; send: server -> string -> unit; done: unit -> unit} module S = Socket let maxConnections = 128 (* queue size for waiting connections in listen *)  (* below --- set to some arbitrary high value. *)  (* fun loop f state = loop f (f state) *)  let rec loop f  = (f (); loop f) let rec vec2str v  = implode (map (chr o toInt) (foldr :: nil v)) let rec str2vec l  = fromList (map (fromInt o ord) (explode l)) let rec fileText fname  = let s = openIn fname let txt = inputAll s let _ = closeIn s in txt let rec fileData fname  = let s = openIn fname let data = inputAll s let _ = closeIn s in vec2str data exception EOF exception Quit let rec send conn str  = (sendVec (conn, str2vec str); ()) module SS = Substringlet rec parseCmd s  = let (c, a) = position " " (full s) in (string c, string (dropl isSpace a))  let rec quote (string)  = "`" ^ string ^ "\'" let examplesDir : string option ref = ref NONE let rec setExamplesDir s  = examplesDir := SOME s (* exception Error for server errors *)  exception Error of string let rec error (msg)  = raise (Error (msg)) let rec serveExample e  = if (match e with "ccc" -> true | "cut-elim" -> true | "handbook" -> true | "lp-horn" -> true | "prop-calc" -> true | "units" -> true | "church-rosser" -> true | "fj" -> true | "incll" -> true | "mini-ml" -> true | "small-step" -> true | "alloc-sem" -> true | "compile" -> true | "fol" -> true | "kolm" -> true | "modal" -> true | "tabled" -> true | "arith" -> true | "cpsocc" -> true | "guide" -> true | "lp" -> true | "polylam" -> true | "tapl-ch13" -> true | _ -> false) then (try  with ) else (raise (Error ("Unknown example " ^ quote e))) (* Natural numbers *)  let rec getNat (t :: nil)  = (try  with ) | getNat (nil)  = error "Missing natural number" | getNat (ts)  = error "Extraneous arguments" (* Example specifiers *)  let rec getExample (t :: nil)  = t | getExample (nil)  = error "Missing example" | getExample (ts)  = error "Extraneous arguments" (* Setting Twelf parameters *)  let rec setParm ("chatter" :: ts)  = chatter := getNat ts | setParm (t :: ts)  = error ("Unknown parameter " ^ quote t) | setParm (nil)  = error ("Missing parameter") let rec exec\' conn ("quit", args)  = (message "goodbye.\\n"; raise (Quit)) | exec\' conn ("set", args)  = (setParm (tokens isSpace args); OK) | exec\' conn ("readDecl", args)  = loadString args | exec\' conn ("decl", args)  = decl args | exec\' conn ("example", args)  = serveExample (getExample (tokens isSpace args)) | exec\' conn (t, args)  = raise (Error ("Unrecognized command " ^ quote t)) let rec exec conn str  = (match try  with  with OK -> message "%%% OK %%%\\n" | ABORT -> message "%%% ABORT %%%\\n") let rec stripcr s  = string (dropr (fun x -> x = \'\\r\') (full s)) let rec flashProto ()  = let buf : string ref = ref "" let rec isnull \'\\000\'  = true | isnull _  = false let rec recv (u : server) s  = let _ = buf := ! buf ^ s let (rem :: cmds) = rev (fields isnull (! buf)) let _ = app (exec u) (rev cmds) in buf := rem let rec send (u : server) s  = (send u) (s ^ "\\000") in {init = (fun () -> message (version ^ "\\n%%% OK %%%\\n")); reset = (fun () -> buf := ""); send = send; recv = recv; done = (fun () -> ())} let rec humanProto ()  = let buf : string ref = ref "" let rec isnewl \'\\n\'  = true | isnewl \'\\r\'  = false | isnewl _  = false let rec recv (u : server) s  = let _ = buf := ! buf ^ s let (rem :: cmds) = rev (fields isnewl (! buf)) let _ = app (exec u) (map stripcr (rev cmds)) in buf := rem let rec send (u : server) s  = (send u) ("> " ^ s) in {init = (fun () -> message (version ^ "\\n%%% OK %%%\\n")); reset = (fun () -> buf := ""); send = send; recv = recv; done = (fun () -> ())} let rec httpProto dir  = let ibuf : string ref = ref "" let obuf : string ref = ref "" let parsingHeaders = ref true let contentLength = ref 0 let method : string ref = ref "" let url : string ref = ref "" let headers : string list ref = ref [] let rec isnewl \'\\n\'  = true | isnewl _  = false let rec handlePostRequest (u : server)  = let shouldQuit = try  with  let response = ! obuf let clmsg = "Content-Length: " ^ toString (size response) ^ "\\n" in send u ("HTTP/1.1 200 OK\\nContent-Type: text/plain\\n" ^ clmsg ^ "\\n"); send u response; if shouldQuit then raise (Quit) else raise (EOF) let rec handleGetRequest (u : server)  = let ok = "200 OK" let missing = "404 Not Found" let (content, ctype, rcode) = (match ! url with "/" -> (fileText (dir ^ "/server.html"), "application/xhtml+xml", ok) | "/server.js" -> (fileText (dir ^ "/server.js"), "text/plain", ok) | "/server.css" -> (fileText (dir ^ "/server.css"), "text/css", ok) | "/grad.png" -> (fileData (dir ^ "/grad.png"), "image/png", ok) | "/twelfguy.png" -> (fileData (dir ^ "/twelfguy.png"), "image/png", ok) | "/input.png" -> (fileData (dir ^ "/input.png"), "image/png", ok) | "/output.png" -> (fileData (dir ^ "/output.png"), "image/png", ok) | "/floral.png" -> (fileData (dir ^ "/floral.png"), "image/png", ok) | _ -> ("Error 404", "text/plain", missing)) let clmsg = "Content-Length: " ^ toString (size content) ^ "\\r\\n" let ctmsg = "Content-Type: " ^ ctype ^ "\\r\\n" let resp = "HTTP/1.1 " ^ rcode ^ "\\r\\n" in send u (resp ^ ctmsg ^ clmsg ^ "\\r\\n"); send u content; raise (EOF); () let rec handleRequest (u : server)  = if ! method = "GET" then handleGetRequest u else if ! method = "POST" then handlePostRequest u else send u "HTTP/1.1 500 Server Error\\n\\n" let rec headerExec s  = headers := (s :: ! headers) let rec recvContent u  = (if (size (! ibuf) >= ! contentLength) then handleRequest u else ()) let rec parseHeaders ()  = (try  with ) let rec interp (u : server) []  = raise (Match) | interp u [x]  = ibuf := x | interp u (h :: tl)  = let sch = stripcr h in if sch = "" then (ibuf := join "\\n" tl; parseHeaders (); recvContent u) else (headerExec (stripcr h); interp u tl) let rec recv (u : server) s  = (ibuf := ! ibuf ^ s; if ! parsingHeaders then interp u (fields isnewl (! ibuf)) else recvContent u) let rec send (u : server) s  = obuf := ! obuf ^ s let rec reset ()  = (parsingHeaders := true; ibuf := ""; obuf := ""; contentLength := 0; headers := []; url := ""; method := "") in {init = (fun () -> ()); reset = reset; send = send; recv = recv; done = (fun () -> ())} let rec protoServer (proto : protocol) portNum  = let sock = socket () let _ = setREUSEADDR (sock, true) let _ = bind (sock, any portNum) let _ = listen (sock, maxConnections) let rec read_one conn u ()  = (* arbitrary buffer size *) let v = recvVec (conn, 1024) in if length v = 0 then raise (EOF) else (recv proto) u (vec2str v) let rec accept_one ()  = let (conn, addr) = accept sock let _ = (reset proto) () let u = {send = send conn; exec = exec conn} let _ = setMessageFunc ((send proto) u) let _ = (init proto) () in try  with in try  with let rec flashServer port  = protoServer (flashProto ()) port let rec humanServer port  = protoServer (humanProto ()) port let rec httpServer port dir  = protoServer (httpProto dir) port endmodule NetServer = NetServer(struct module Timing = Timing module Twelf = Twelf module Msg = Msg end)\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Mode Table *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning, Roberto Virga *) module ModeTable ((*! structure IntSyn' : INTSYN !*) (* structure Names : NAMES *) (*! sharing Names.IntSyn = IntSyn' !*) module Table : TABLE where keyint(* structure Index : INDEX *) (*! sharing Index.IntSyn = IntSyn' !*) ) : MODETABLE = struct (*! structure IntSyn = IntSyn' !*)  exception Error of string module I = IntSynmodule M = ModeSynlet modeSignature : ModeSpine list Table = new (0) (* reset () = ()\n\n       Effect: Resets mode array\n    *) let rec reset ()  = clear modeSignature (* modeLookup a = mSOpt\n\n       Looks up the mode of a in the mode array (if they are multiple, returns the last one\n       inserted.\n    *) let rec modeLookup a  = match (lookup modeSignature a) with SOME (mS :: _) -> SOME (mS) | NONE -> NONE (* mmodeLookup a = mSs\n\n       Looks up the modes of a in the mode array.\n    *) let rec mmodeLookup a  = match (lookup modeSignature a) with SOME mSs -> mSs | NONE -> nil (* installMode (a, mS) = ()\n\n       Effect: the ModeSpine mS is stored with the type family a; if there were previous\n               modes stored with a, they are replaced by mS\n    *) let rec installMode (a, mS)  = insert modeSignature (a, [mS]) (* uninstallMode a = true iff a was declared in mode table\n       Effect: the mode stored with a is removed\n    *) let rec uninstallMode a  = match modeLookup a with NONE -> false | SOME _ -> (delete modeSignature a; true) (* installMmode (a, mS) = ()\n\n       Effect: the ModeSpine mS is stored with the type family a; if there were previous\n               models stored with a, the new mode mS is added to them.\n    *) let rec installMmode (a, mS)  = let mSs = mmodeLookup a in insert modeSignature (a, mS :: mSs) let reset = reset let installMode = installMode let modeLookup = modeLookup let uninstallMode = uninstallMode let installMmode = installMmode let mmodeLookup = mmodeLookup  end\n(* functor ModeTable *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Modes: short and full mode declarations *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning *) module ModeDec ((*! structure ModeSyn\' : MODESYN !*) (*! structure Paths\' : PATHS !*) ) : MODEDEC = struct (*! structure ModeSyn = ModeSyn\' !*)  (*! structure Paths = Paths\' !*)  exception Error of string module M = ModeSynmodule I = IntSynmodule P = Pathstype Arg = Implicit | Explicit | Local (* Representation invariant:\n\n       The modes of parameters are represented in the following mode list\n\n       M ::= . | M, <Marg, Arg>\n\n       G corresponds to a context. We say M is a mode list for U, if\n       G |- U : V and M assigns modes to parameters in G\n         (and similarly for all other syntactic categories)\n\n       The main function of this module is to\n        (a) assign modes to implicit arguments in a type family\n        (b) check the mode specification for consistency\n\n       Example:\n\n         a : type.\n         b : a -> a -> type.\n         c : b X X -> b X Y -> type.\n\n       Then\n\n         %mode c +M -N.\n\n       will infer X to be input and Y to be output\n\n         %mode +{X:a} -{Y:a} +{M:b X Y} -{N:b X Y} (c M N).\n\n       Generally, it is inconsistent\n       for an unspecified ( * ) or output (-) argument to occur\n       in the type of an input (+) argument\n    *) let rec error (r, msg)  = raise (Error (wrap (r, msg))) (* checkname mS = ()\n\n       Invariant:\n       mS modeSpine, all modes are named.\n       If mS contains two entries with the same name\n       then Error is raised\n    *) let rec checkName (Mnil)  = () | checkName (Mapp (Marg (_, SOME name), mS))  = let rec checkName\' (Mnil)  = () | checkName\' (Mapp (Marg (_, SOME name\'), mS))  = if name = name\' then raise (Error ("Variable name clash: " ^ name ^ " is not unique")) else checkName\' mS in checkName\' mS (* modeConsistent (m1, m2) = true\n       iff it is consistent for a variable x with mode m1\n           to occur as an index object in the type of a variable y:V(x) with mode m2\n\n       m1\\m2 + * - -1\n        +    Y Y Y Y\n        *    N y n n\n        -    N y Y n\n        -1   N Y Y Y\n\n       The entries y,n constitute a bug fix, Wed Aug 20 11:50:27 2003 -fp\n       The entry n specifies that the type\n    *) let rec modeConsistent (Star, Plus)  = false | modeConsistent (Star, Minus)  = false | modeConsistent (Star, Minus1)  = false | modeConsistent (Minus, Plus)  = false | modeConsistent (Minus, Minus1)  = false | modeConsistent (Minus1, Plus)  = false | modeConsistent _  = true (* empty (k, ms, V) = (ms\', V\')\n\n       Invariant:\n       If    V = {A_1} .. {A_n} V1   in Sigma\n       and   V has k implicit arguments\n       then  ms\' = ms, <( *, NONE), Implicit>  ... <( *, NONE), Implicit>   (k times)\n       and   V\' = V1\n    *) let rec empty (0, ms, V)  = (ms, V) | empty (k, ms, Pi (_, V))  = empty (k - 1, Decl (ms, (Marg (Star, NONE), Implicit)), V) (* inferVar (ms, m, k) = ms\'\n\n       Invariant:\n       If  ms is a mode list,\n       and k is declared with mode mk in ms\n       and m is the mode for a variable y in whose type k occurs\n       then ms\' is the same as ms replacing only mk by\n       mk\' = m o mk\n\n        m o mk  + * - -1\n        ----------------\n        +       + + + +\n        *       + * - -1\n        -       + - - -1\n        -1      + -1-1-1\n\n        Effect: if the mode mk for k was explicitly declared and inconsistent\n                with m o mk, an error is raised\n    *) let rec inferVar (Decl (ms, (Marg (Star, nameOpt), Implicit)), mode, 1)  = Decl (ms, (Marg (mode, nameOpt), Implicit)) | inferVar (Decl (ms, (Marg (_, nameOpt), Implicit)), Plus, 1)  = Decl (ms, (Marg (Plus, nameOpt), Implicit)) | inferVar (Decl (ms, (Marg (Minus, nameOpt), Implicit)), Minus1, 1)  = Decl (ms, (Marg (Minus1, nameOpt), Implicit)) | inferVar (ms as Decl (_, (_, Implicit)), _, 1)  = ms | inferVar (ms as Decl (_, (_, Local)), _, 1)  = ms | inferVar (ms as Decl (_, (Marg (mode\', SOME name), Explicit)), mode, 1)  = if modeConsistent (mode\', mode) then ms else raise (Error ("Mode declaration for " ^ name ^ " expected to be " ^ modeToString mode)) | inferVar (Decl (ms, md), mode, k)  = Decl (inferVar (ms, mode, k - 1), md) (* inferExp (ms, m, U) = ms\'\n\n       Invariant:\n       If  ms is a mode list for U,   (U in nf)\n       and m is a mode\n       then ms\' is the mode list consistently updated for all parameters occurring in U,\n         wrt. to m. (see inferVar)\n    *) let rec inferExp (ms, mode, Root (BVar (k), S))  = inferSpine (inferVar (ms, mode, k), mode, S) | inferExp (ms, mode, Root (Const (cid), S))  = inferSpine (ms, mode, S) | inferExp (ms, mode, Root (Def (cid), S))  = inferSpine (ms, mode, S) | inferExp (ms, mode, Root (FgnConst (cs, conDec), S))  = inferSpine (ms, mode, S) | inferExp (ms, mode, Lam (D as Dec (nameOpt, _), U))  = ctxPop (inferExp (Decl (inferDec (ms, mode, D), (Marg (mode, nameOpt), Local)), mode, U)) | inferExp (ms, mode, Pi ((D as Dec (nameOpt, _), _), V))  = ctxPop (inferExp (Decl (inferDec (ms, mode, D), (Marg (mode, nameOpt), Local)), mode, V)) | inferExp (ms, mode, FgnExp _)  = ms(* inferSpine (ms, m, S) = ms\'\n\n       Invariant:\n       If  ms is a mode list for S,   (S in nf)\n       and m is a mode\n       then ms\' is the mode list consistently updated for all parameters occurring in S,\n         wrt. to m. (see inferVar)\n    *) inferSpine (ms, mode, Nil)  = ms | inferSpine (ms, mode, App (U, S))  = inferSpine (inferExp (ms, mode, U), mode, S)(* inferDec (ms, m, x:V) = ms\'\n\n       Invariant:\n       If  ms is a mode list for V,   (V in nf)\n       and m is a mode\n       then ms\' is the mode list consistently updated for all parameters occurring in V,\n         wrt. to m.   (see inferVar)\n    *) inferDec (ms, mode, Dec (_, V))  = inferExp (ms, mode, V) (* inferMode ((ms, V), mS) = ms\'\n\n       Invariant:\n       If  ms is a mode list for V,\n       and mS is a mode spine,\n       then ms\' is the mode list for V which is consistent with V.\n    *) let rec inferMode ((ms, Uni (Type)), Mnil)  = ms | inferMode ((_, Uni (Type)), _)  = raise (Error "Too many modes specified") | inferMode ((ms, Pi ((Dec (name, V1), _), V2)), Mapp (Marg (mode, _), mS))  = ctxPop (inferMode ((Decl (inferExp (ms, mode, V1), (Marg (mode, name), Explicit)), V2), mS)) | inferMode ((ms, Root _), _)  = raise (Error "Expected type family, found object constant") | inferMode _  = raise (Error "Not enough modes specified") (* abstractMode (ms, mS) = mS\'\n\n       Invariant:\n       If    V = {A1} .. {An} V1  is a type (with n implicit parameter)\n       and   ms is a mode list for V,\n       then  mS\' = {m1} .. {mn} mS\n       where m1 .. mn are the infered modes for the implicit parameters\n    *) let rec abstractMode (ms, mS)  = let rec abstractMode\' (Null, mS, _)  = mS | abstractMode\' (Decl (ms, (marg, _)), mS, k)  = abstractMode\' (ms, Mapp (marg, mS), k + 1) in abstractMode\' (ms, mS, 1) (* shortToFull (cid, mS, r) = mS\'\n\n       Invariant:\n       mS modeSpine, all modes are named.\n       r is the text region of the mode declaration\n       if mS is a mode spine in short form (implicit parameters are not moded),\n       then mS\' is a mode spine in full form (all parameters are moded)\n\n       Full form can be different then intended by the user.\n    *) let rec shortToFull (a, mS, r)  = let rec calcImplicit\' (ConDec (_, _, k, _, V, _))  = abstractMode (inferMode (empty (k, Null, V), mS), mS) | calcImplicit\' (ConDef (_, _, k, _, V, _, _))  = (* ignore definition for defined type family since they are opaque *)  abstractMode (inferMode (empty (k, Null, V), mS), mS) in try  with (* re-raise Error with location *) (* checkFull (a, mS, r) = ()\n\n       Invariant:\n       mS modeSpine, all modes are named.\n       r is the text region of the mode declaration\n       if mS is not a valid mode spine in full form then\n       exception Error is raised.\n    *) let rec checkFull (a, mS, r)  = try  with (* re-raise error with location *) (* checkPure (a, mS, r) = ()\n       Effect: raises Error(msg) if the modes in mS mention (-1)\n    *) let rec checkPure ((a, Mnil), r)  = () | checkPure ((a, Mapp (Marg (Minus1, _), mS)), r)  = error (r, "Uniqueness modes (-1) not permitted in `%mode\' declarations (use `%unique\')") | checkPure ((a, Mapp (_, mS)), r)  = checkPure ((a, mS), r) let shortToFull = shortToFull let checkFull = checkFull let checkPure = checkPure  end\n(* functor ModeDec *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Printing Mode Declarations *) (* Author: Carsten Schuermann *) module ModePrint ((*! structure ModeSyn\' : MODESYN !*) module Names : NAMES(*! sharing Names.IntSyn = ModeSyn\'.IntSyn !*) module Formatter : FORMATTERmodule Print : PRINT(*! sharing Print.IntSyn = ModeSyn\'.IntSyn !*) PrintFormatterFormatter) : MODEPRINT = struct (* structure ModeSyn = ModeSyn\' *)  module I = IntSynmodule M = ModeSynmodule F = Formattermodule P = Printlet rec modeToString Plus  = "+" | modeToString Star  = "*" | modeToString Minus  = "-" | modeToString Minus1  = "-1" let rec argToString (Marg (m, _))  = modeToString m let rec nameDec (Dec (_, V), Marg (_, name as SOME _))  = Dec (name, V) | nameDec (D, Marg (_, NONE))  = D let rec makeSpine (G)  = let rec makeSpine\' (Null, _, S)  = S | makeSpine\' (Decl (G, _), k, S)  = makeSpine\' (G, k + 1, App (Root (BVar k, Nil), S)) in makeSpine\' (G, 1, Nil) let rec fmtModeDec (cid, mS)  = let V = constType cid let rec fmtModeDec\' (G, _, Mnil)  = [String "("; formatExp (G, Root (Const (cid), makeSpine G)); String ")"] | fmtModeDec\' (G, Pi ((D, _), V\'), Mapp (marg, S))  = let D\' = nameDec (D, marg) let D\'\' = decEName (G, D\') in [String (argToString marg); String "{"; formatDec (G, D\'\'); String "}"; Break] @ (fmtModeDec\' (Decl (G, D\'\'), V\', S)) in HVbox (fmtModeDec\' (Null, V, mS)) let rec fmtModeDecs ((cid, mS) :: nil)  = fmtModeDec (cid, mS) :: nil | fmtModeDecs ((cid, mS) :: mdecs)  = fmtModeDec (cid, mS) :: Break :: fmtModeDecs mdecs let rec modeToString cM  = makestring_fmt (fmtModeDec cM) let rec modesToString mdecs  = makestring_fmt (Vbox0 0 1 (fmtModeDecs mdecs)) let modeToString = modeToString let modesToString = modesToString  (* local *)  end\n(* functor ModePrint *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Modes: short and long forms *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning *) module type MODEDEC = sig exception Error of stringval shortToFull : cid * ModeSpine * region -> ModeSpineval checkFull : cid * ModeSpine * region -> unitval checkPure : (cid * ModeSpine) * region -> unit end\n(* signature MODEDEC *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Mode Table *) (* Author: Frank Pfenning *) module type MODETABLE = sig exception Error of stringval reset : unit -> unit(* single mode installation and lookup *) val installMode : (cid * ModeSpine) -> unitval modeLookup : cid -> ModeSpine optionval uninstallMode : cid -> bool(* true: was declared, false: not *) (* multiple mode installation and lookup *) val installMmode : (cid * ModeSpine) -> unitval mmodeLookup : cid -> ModeSpine list end\n(* signature MODETABLE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Mode Checking *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning, Roberto Virga *) module ModeCheck ((*! structure IntSyn : INTSYN !*) module ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = IntSyn !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn !*) (*! structure Paths : PATHS !*) module Origins : ORIGINS(*! sharing Origins.Paths = Paths !*) (*! sharing Origins.IntSyn = IntSyn !*) ) : MODECHECK = struct (*! structure IntSyn = IntSyn !*)  (*! structure ModeSyn = ModeSyn !*)  (*! structure Paths = Paths !*)  exception Error of string module I = IntSynmodule M = ModeSynmodule P = Pathstype Uniqueness = Unique | Ambig (*     | Ambig            *) type Info = Free | Unknown | Ground of Uniqueness (*     | Ground               *) type Status = Existential of (* S ::= Existential (I, xOpt) *) Info * string option | Universal (*     | Universal             *) (* hack: if true, check freeness of output arguments in subgoals *) let checkFree = ref false (* Representation invariant:\n\n       Groundness information:\n       T stands for ground, B stands for unknown\n       Ex  for a named existential variable\n       Par for a parameter\n\n       Mode context   D ::= . | D, S\n\n       If D contains Status information for variables in\n       a context G, we write G ~ D\n       We write D\' >= D if for all i\n         D(i) par iff D\'(i) par\n         D(i) bot implies D\'(i) bot or D\'(i) top\n         D(i) top implies D\'(i) top\n    *) (* copied from worldcheck/worldsyn.fun *) let rec wrapMsg (c, occ, msg)  = (match originLookup c with (fileName, NONE) -> (fileName ^ ":" ^ msg) | (fileName, SOME occDec) -> (wrapLoc\' (Loc (fileName, occToRegionClause occDec occ), linesInfoLookup (fileName), "Constant " ^ qidToString (constQid c) ^ "\\n" ^ msg))) let rec wrapMsg\' (fileName, r, msg)  = wrapLoc (Loc (fileName, r), msg) exception ModeError of occ * string exception Error\' of occ * string (* lookup (a, occ) = mSs\n\n       Invariant: mS are the argument modes for a\n       Raises an error if no mode for a has declared.\n       (occ is used in error message)\n    *) let rec lookup (a, occ)  = match mmodeLookup a with nil -> raise (Error\' (occ, "No mode declaration for " ^ conDecName (sgnLookup a))) | sMs -> sMs (* nameOf S, selects a name for S *) let rec nameOf (Existential (_, NONE))  = "?" | nameOf (Existential (_, SOME name))  = name | nameOf _  = "?" (* unique (k, ks) = B\n\n       Invariant:\n       B iff k does not occur in ks\n    *) let rec unique (k, nil)  = true | unique (k, k\' :: ks)  = (k <> k\') && unique (k, ks) (* isUniversal S = B\n\n       Invariant:\n       B iff S = Par\n    *) let rec isUniversal Universal  = true | isUniversal _  = false (* isGround S = B\n\n       Invariant:\n       B iff S = Ex (T x)\n    *) let rec isGround (Existential (Ground _, _))  = true | isGround _  = false (* uniqueness S = u\n       where u is the uniqueness property of status S\n    *) let rec uniqueness (Existential (Ground (u), _))  = u | uniqueness (Universal)  = Unique (* ambiguate (mode) = mode\'\n       where mode\' forgets uniqueness properties\n    *) let rec ambiguate (Plus)  = Plus | ambiguate (Minus)  = Minus | ambiguate (Minus1)  = Minus (* andUnique (u1, u2) = Unique if u1 = u2 = Unique\n       = Ambig otherwise\n    *) let rec andUnique (Unique, Unique)  = Unique | andUnique _  = Ambig (* isFree S = b\n\n       Invariant:\n       b iff S = Ex (B x)\n    *) let rec isFree (Existential (Free, _))  = true | isFree _  = false exception Eta (* etaContract (U, n) = k\n\n       if lam V1... lam Vn. U =eta*=> k\n       otherwise raise exception Eta\n\n       Invariant: G, V1,..., Vn |- U : V for some G, Vi, V.\n                  U in NF\n    *) let rec etaContract (Root (BVar (k), S), n)  = if k > n then (etaSpine (S, n); k - n) else raise (Eta) | etaContract (Lam (D, U), n)  = etaContract (U, n + 1) | etaContract _  = raise (Eta)(* etaSpine (S, n) = ()\n       if S =eta*=> n ; n-1 ; ... ; 1 ; Nil\n       otherwise raise exception Eta\n\n       Invariant: G |- S : V1 >> V2 for some G, V1, V2\n                  S in NF\n    *) etaSpine (Nil, 0)  = () | etaSpine (App (U, S), n)  = if etaContract (U, 0) = n then etaSpine (S, n - 1) else raise (Eta) (* S[s] should be impossible *) (* isPattern (D, k, mS) = B\n\n       Invariant:\n       B iff k > k\' for all k\' in mS\n         and for all k in mS: k is parameter\n         and for all k\', k\'\' in mS: k\' <> k\'\'\n    *) let rec checkPattern (D, k, args, Nil)  = () | checkPattern (D, k, args, App (U, S))  = (let k\' = etaContract (U, 0) in if (k > k\') && isUniversal (ctxLookup (D, k\')) && unique (k\', args) then checkPattern (D, k, k\' :: args, S) else raise (Eta)) let rec isPattern (D, k, S)  = try  with (* ------------------------------------------- strictness check *) (* This repeats some code from ../typecheck/strict.fun *) (* Interface here is somewhat different *) (* strictExpN (D, p, U) = B\n\n       Invariant:\n       If  D |- U : V\n       and U is in nf (normal form)\n       then B iff U is strict in p\n    *) let rec strictExpN (D, _, Uni _)  = false | strictExpN (D, p, Lam (_, U))  = (* checking D in this case should be redundant -fp *)  (* strictDecN (D, p, D) orelse *)  strictExpN (Decl (D, Universal), p + 1, U) | strictExpN (D, p, Pi ((D\', _), U))  = strictDecN (D, p, D\') || strictExpN (Decl (D, Universal), p + 1, U) | strictExpN (D, p, Root (H, S))  = (match H with (BVar (k\')) -> if (k\' = p) then isPattern (D, k\', S) else if isUniversal (ctxLookup (D, k\')) then strictSpineN (D, p, S) else false(* equivalently: isUniversal .. andalso strictSpineN .. *)  | (Const (c)) -> strictSpineN (D, p, S) | (Def (d)) -> strictSpineN (D, p, S) | (FgnConst (cs, conDec)) -> strictSpineN (D, p, S)) | strictExpN (D, p, FgnExp (cs, ops))  = false(* this is a hack - until we investigate this further   -rv *) (* no other cases possible *) (* strictSpineN (D, S) = B\n\n       Invariant:\n       If  D |- S : V > W\n       and S is in nf (normal form)\n       then B iff S is strict in k\n    *) strictSpineN (_, _, Nil)  = false | strictSpineN (D, p, App (U, S))  = strictExpN (D, p, U) || strictSpineN (D, p, S)strictDecN (D, p, Dec (_, V))  = strictExpN (D, p, V) (*\n    fun strictAtom (D, p, mode, I.Nil, (V, s), M.Mnil) = false\n      | strictAtom (D, p, M.Minus, I.App (U, S), (I.Pi ((I.Dec (_, V1), _), V2), s),\n                     M.Mapp (M.Marg (M.Minus, _), mS)) =\n          strictExpN (D, p, Whnf.normalize (V1, s))\n          orelse strictAtom (D, p, M.Minus, S, Whnf.whnfExpandDef (V2, I.Dot (I.Exp U, s)), mS)\n      | strictAtom (D, p, mode, I.App (U, S), (I.Pi (_, V2), s), M.Mapp(_, mS)) =\n          strictAtom (D, p, mode, S, Whnf.whnfExpandDef (V2, I.Dot (I.Exp U, s)), mS)\n    *) (* ------------------------------------------- freeness check *) (* freeExpN (D, mode, U, occ = ()\n\n       If G |- U : V  (U in nf)\n       and G ~ D\n       then freeExpN terminates with () if D |- U free\n       else exception ModeError is raised\n\n       (occ and mode are used in error messages)\n    *) let rec freeExpN (D, d, mode, Root (BVar k, S), occ, strictFun)  = (freeVar (D, d, mode, k, head occ, strictFun); freeSpineN (D, d, mode, S, (1, occ), strictFun)) | freeExpN (D, d, mode, Root (Const _, S), occ, strictFun)  = freeSpineN (D, d, mode, S, (1, occ), strictFun) | freeExpN (D, d, mode, Root (Def _, S), occ, strictFun)  = freeSpineN (D, d, mode, S, (1, occ), strictFun) | freeExpN (D, d, mode, Root (FgnConst (cs, conDec), S), occ, strictFun)  = freeSpineN (D, d, mode, S, (1, occ), strictFun) | freeExpN (D, d, mode, Lam (_, U), occ, strictFun)  = freeExpN (Decl (D, Universal), d + 1, mode, U, body occ, strictFun) | freeExpN (D, d, mode, FgnExp csfe, occ, strictFun)  = apply csfe (fun U -> freeExpN (D, d, mode, normalize (U, id), occ, strictFun))(* punting on the occ here  - ak *) (* freeSpineN (D, mode, S, occ, strictFun)  = ()\n\n       If   G |- S : V1  > V2   (S in nf)\n       and  G ~ D\n       then freeSpineN terminates with () if  D |- S free\n       else exception ModeError is raised\n\n       (occ and mode are used in error messages)\n    *) freeSpineN (D, d, mode, Nil, _, strictFun)  = () | freeSpineN (D, d, mode, App (U, S), (p, occ), strictFun)  = (freeExpN (D, d, mode, U, arg (p, occ), strictFun); freeSpineN (D, d, mode, S, (p + 1, occ), strictFun))(* freeVar (D, mode, k, occ, strictFun)  = ()\n\n       If   G |- k : V1\n       and  G ~ D\n       then freeVar terminates with () if  D |- S free\n       else exception ModeError is raised\n\n       (occ and mode are used in error messages)\n    *) freeVar (D, d, mode, k, occ, strictFun)  = let status = ctxLookup (D, k) in if isFree status || isUniversal status || strictFun (k - d) then () else raise (ModeError (occ, "Occurrence of variable " ^ (nameOf status) ^ " in " ^ (modeToString mode) ^ " argument not free")) (* -------------------------------- non-strict mode context update *) (* nonStrictExpN (D, U) = D\'\n\n       If   G |- U : V     (U in nf)\n       and  D ~ G\n       then D\' >= D where D\'(k) Unknown for all existential variables k\n            in U that are free in D\n    *) let rec nonStrictExpN (D, Root (BVar (k), S))  = nonStrictSpineN (nonStrictVarD (D, k), S) | nonStrictExpN (D, Root (Const c, S))  = nonStrictSpineN (D, S) | nonStrictExpN (D, Root (Def d, S))  = nonStrictSpineN (D, S) | nonStrictExpN (D, Root (FgnConst (cs, conDec), S))  = nonStrictSpineN (D, S) | nonStrictExpN (D, Lam (_, U))  = ctxPop (nonStrictExpN (Decl (D, Universal), U)) | nonStrictExpN (D, FgnExp _)  = raise (Error ("Foreign expressions not permitted when checking freeness"))(* nonStrictSpineN (D, S) = D\'\n\n       If   G |- S : V1 > V2      (S in nf)\n       and  D ~ G\n       then D\' >= D\' where D\'(k) Unkown for all existential variables k\n            in S that are Free in D\n    *) nonStrictSpineN (D, Nil)  = D | nonStrictSpineN (D, App (U, S))  = nonStrictSpineN (nonStrictExpN (D, U), S)(* nonStrictVarD (D, k) = D\'\n\n       If   G |- k : V\n       and  D ~ G\n       and  k is an existential variable\n       then D\' >= D where k is nonStrictd as described in  nonStrictExpN\n    *) nonStrictVarD (Decl (D, Existential (Free, name)), 1)  = Decl (D, Existential (Unknown, name)) | nonStrictVarD (D, 1)  = (* Universal, or already Unknown or Ground - leave unchanged *)  D | nonStrictVarD (Decl (D, status), k)  = Decl (nonStrictVarD (D, k - 1), status) (* ------------------------------------------- mode context update *) (* updateExpN (D, U, u) = D\'\n\n       If   G |- U : V     (U in nf)\n       and  D ~ G\n       then D\' >= D where D\'(k) Ground for all existential variables k\n            with a strict occurrence in U\n            and D\'(k) Unkown for all existential variable k\n            with a non-strict occurrence, but no strict occurrence in U\n            (if !checkFree is true)\n\n       u is the uniqueness property for the new ground assumptions\n    *) let rec updateExpN (D, Root (BVar (k), S), u)  = if isUniversal (ctxLookup (D, k)) then updateSpineN (D, S, u) else if isPattern (D, k, S) then updateVarD (D, k, u) else if ! checkFree then nonStrictSpineN (nonStrictVarD (D, k), S) else D | updateExpN (D, Root (Const c, S), u)  = updateSpineN (D, S, u) | updateExpN (D, Root (Def d, S), u)  = updateSpineN (D, S, u) | updateExpN (D, Root (FgnConst (cs, conDec), S), u)  = updateSpineN (D, S, u) | updateExpN (D, Lam (_, U), u)  = ctxPop (updateExpN (Decl (D, Universal), U, u)) | updateExpN (D, FgnExp _, u)  = D(* updateSpineN (D, S, u) = D\'\n\n       If   G |- S : V1 > V2      (S in nf)\n       and  D ~ G\n       then D\' >= D\' where D\'(k) Ground for all existential variables k\n            with a strict occurrence in S\n    *) updateSpineN (D, Nil, u)  = D | updateSpineN (D, App (U, S), u)  = updateSpineN (updateExpN (D, U, u), S, u)(* updateVarD (D, k, u) = D\'\n\n       If   G |- k : V\n       and  D ~ G\n       and  k is an existential variable\n       then D\' >= D where k is updated as described in  updateExpN\n    *) updateVarD (Decl (D, Existential (_, name)), 1, u)  = Decl (D, Existential (Ground (u), name)) | updateVarD (Decl (D, status), k, u)  = Decl (updateVarD (D, k - 1, u), status) (* ----------------------- mode context update by argument modes *) (* updateAtom (D, m, S, mS, (p,occ)) = D\'\n\n       If   G |- S : V > V\'   ( S = U1 ; .. ; Un)\n       and  D ~ G\n       and  S ~ mS            (mS = m1 , .. , mn)\n       and  m mode\n       then D\' >= D where\n            all Ui are updated if mi = m (mod uniqueness)\n\n       The new ground variables are marked Unique\n         if m = (-1) and mi = (-1) (when updating from subgoals with unique inputs)\n         or m = mi = (+) (when updating from the clause head)\n       Otherwise they are marked Ambig.\n\n       (p,occ) is used in error message if freeness is to be checked\n    *) let rec updateAtom\' (D, mode, Nil, Mnil, _)  = D | updateAtom\' (D, Plus, App (U, S), Mapp (Marg (Plus, _), mS), (p, occ))  = updateAtom\' (updateExpN (D, U, Unique), Plus, S, mS, (p + 1, occ)) | updateAtom\' (D, Minus, App (U, S), Mapp (Marg (Minus, _), mS), (p, occ))  = updateAtom\' (updateExpN (D, U, Ambig), Minus, S, mS, (p + 1, occ)) | updateAtom\' (D, Minus, App (U, S), Mapp (Marg (Minus1, _), mS), (p, occ))  = updateAtom\' (updateExpN (D, U, Ambig), Minus, S, mS, (p + 1, occ)) | updateAtom\' (D, Minus1, App (U, S), Mapp (Marg (Minus, _), mS), (p, occ))  = updateAtom\' (updateExpN (D, U, Ambig), Minus1, S, mS, (p + 1, occ)) | updateAtom\' (D, Minus1, App (U, S), Mapp (Marg (Minus1, _), mS), (p, occ))  = updateAtom\' (updateExpN (D, U, Unique), Minus1, S, mS, (p + 1, occ)) | updateAtom\' (D, mode, App (U, S), Mapp (_, mS), (p, occ))  = updateAtom\' (D, mode, S, mS, (p + 1, occ)) (* freeAtom (D, m, S, (V,s), mS, (p, occ)) = ()\n\n       checks if all output arguments in S according to mS are free.\n       Invariant: G |- S : V[s] >> P for some G and P  (S in nf)\n                  G ~ D\n                  mode = (-) or (+); ( * ) or (-1) are excluded\n    *) let rec freeAtom (D, mode, Nil, Vs, Mnil, _)  = () | freeAtom (D, Minus, App (U, S), (Pi ((Dec (_, V1), _), V2), s), Mapp (Marg (Minus, _), mS), (p, occ))  = (freeExpN (D, 0, Minus, U, arg (p, occ), (fun q -> strictExpN (D, q, normalize (V1, s)))); freeAtom (D, Minus, S, whnfExpandDef (V2, Dot (Exp U, s)), mS, (p + 1, occ))) | freeAtom (D, mode, App (U, S), (Pi (_, V2), s), Mapp (_, mS), (p, occ))  = freeAtom (D, mode, S, whnfExpandDef (V2, Dot (Exp U, s)), mS, (p + 1, occ)) (* updateAtom (D, m, S, a, mS, (p, occ))\n       see updateAtom\', and performs additional freeness check if required\n    *) let rec updateAtom (D, mode, S, a, mS, (p, occ))  = let _ = if ! checkFree then freeAtom (D, ambiguate mode, S, (constType a, id), mS, (p, occ)) else () in updateAtom\' (D, mode, S, mS, (p, occ)) (* ------------------------------------------- groundness check *) (* groundExpN (D, mode, U, occ)  = u\n\n       If   G |- U : V    (U in nf)\n       and  G ~ D\n       then if mode = (+) or (-)\n            then groundExpN terminates with u if  D |- U ground\n                 else exception ModeError is raised\n            if mode = (-1) then D |- U ground and U unique\n                           else exception ModeError is raised\n\n       u = Unique if all known variables in U are Unique\n       u = Ambig otherwise\n\n       (occ and mode are used in error messages)\n    *) let rec groundExpN (D, mode, Root (BVar k, S), occ)  = andUnique (groundVar (D, mode, k, head occ), groundSpineN (D, mode, S, (1, occ))) | groundExpN (D, mode, Root (Const c, S), occ)  = groundSpineN (D, mode, S, (1, occ)) | groundExpN (D, mode, Root (Def d, S), occ)  = groundSpineN (D, mode, S, (1, occ)) | groundExpN (D, mode, Root (FgnConst (cs, conDec), S), occ)  = groundSpineN (D, mode, S, (1, occ)) | groundExpN (D, mode, Lam (_, U), occ)  = groundExpN (Decl (D, Universal), mode, U, body occ) | groundExpN (D, mode, FgnExp csfe, occ)  = fold csfe (fun (U, u) -> andUnique (groundExpN (D, mode, normalize (U, id), occ), u)) Unique(* punting on occ here  - ak *) (* groundSpineN (D, mode, S, occ)  = u\n\n       If   G |- S : V1  > V2   (S in nf)\n       and  G ~ D\n       then if mode = (+) or (-)\n            then groundSpineN terminates with u if  D |- S ground\n                 else exception ModeError is raised\n            if mode = (-1) then D |- S ground and S unique\n                           else exception ModeError is raised\n\n       u = Unique if all known variables in S are Unique\n       u = Ambig otherwise\n\n       (occ and mode are used in error messages)\n    *) groundSpineN (D, mode, Nil, _)  = Unique | groundSpineN (D, mode, App (U, S), (p, occ))  = andUnique (groundExpN (D, mode, U, arg (p, occ)), groundSpineN (D, mode, S, (p + 1, occ)))(* groundVar (D, mode, k, occ)  = u\n\n       If   G |- k : V1\n       and  G ~ D\n       then if mode = (+) or (-)\n            then groundVar terminates with u if  D |- k ground\n                 else exception ModeError is raised\n            if mode = (-1) then D |- k ground and k unique\n                           else exception ModeError is raised\n\n       u = Unique if k is known to be unique, Ambig otherwise\n\n       (occ and mode are used in error messages)\n    *) groundVar (D, Minus1, k, occ)  = (match ctxLookup (D, k) with Existential (Ground (Unique), _) -> Unique | Universal -> Unique | s as Existential (Ground (Ambig), x) -> raise (ModeError (occ, "Occurrence of variable " ^ nameOf s ^ " in " ^ modeToString Minus1 ^ " argument not necessarily unique")) | s -> (* Existential (Free, _) or Existential (Unknown, _) *) raise (ModeError (occ, "Occurrence of variable " ^ (nameOf s) ^ " in " ^ (modeToString Minus1) ^ " argument not necessarily ground"))) | groundVar (D, mode, k, occ)  = let status = ctxLookup (D, k) in if isGround status || isUniversal status then uniqueness status else raise (ModeError (occ, "Occurrence of variable " ^ (nameOf status) ^ " in " ^ (modeToString mode) ^ " argument not necessarily ground")) (* ------------------------------------------- groundness check by polarity *) (* groundAtom (D, m, S, mS, (p,occ))  = u\n\n       If   G |- S : V > V\'   ( S = U1 ; .. ; Un)\n       and  D ~ G\n       and  S ~ mS            (mS = m1 , .. , mn)\n       and  m mode = (+) or (-1)\n       then groundAtom returns u if  D |- Ui ground\n            for all i s.t. mi = m (mod uniqueness)\n            and checks that D |- Ui unique if mi = (-1) and m = (-)\n       otherwise exception ModeError is raised\n\n       u = Unique if all mi = m (mod uniqueness) are unique,\n       u = Ambig otherwise\n\n       ((p,occ) used in error messages)\n    *) let rec groundAtom (D, _, Nil, Mnil, _)  = Unique | groundAtom (D, Plus, App (U, S), Mapp (Marg (Plus, _), mS), (p, occ))  = andUnique (groundExpN (D, Plus, U, arg (p, occ)), groundAtom (D, Plus, S, mS, (p + 1, occ))) | groundAtom (D, Minus, App (U, S), Mapp (Marg (Minus, _), mS), (p, occ))  = (groundExpN (D, Minus, U, arg (p, occ)); (* ignore uniqueness result here *) groundAtom (D, Minus, S, mS, (p + 1, occ))) | groundAtom (D, Minus, App (U, S), Mapp (Marg (Minus1, _), mS), (p, occ))  = (groundExpN (D, Minus1, U, arg (p, occ)); (* ignore uniqueness result here *) groundAtom (D, Minus, S, mS, (p + 1, occ))) | groundAtom (D, mode, App (U, S), Mapp (_, mS), (p, occ))  = groundAtom (D, mode, S, mS, (p + 1, occ)) (* ------------------------------------------- mode checking first phase *) (* ctxPush (Ds, m) = Ds\'\n       raises the contexts Ds prepending m\n    *) let rec ctxPush (m, Ds)  = map (fun D -> Decl (D, m)) Ds (* ctxPop Ds = Ds\'\n       lowers the contexts Ds\n    *) let rec ctxPop Ds  = map (fun Decl (D, m) -> D) Ds (* checkD1 (D, V, occ, k) = ()\n\n       Invariant:\n         if G |- V : L\n         and  V does not contain Skolem constants\n         and  D ~ G\n         then\n            for each  mode mS of the head of V\n              exists  some Di s.t. all (-) evars of mS are ground\n                where  D\' ~ G, D\' >= D is obtained by updating D\n                  and  k D\' = [D1, ..., Di, ..., Dn]\n                  and  Di ~ G, Di >= D\' is obtained by mode checking on the subgoals of V\n\n       exception ModeError is raised if the expression does not mode check\n       exception Error\' is raised if the expression contains type families\n       that have no mode information associated with them\n       (occ used in error messages)\n    *) let rec checkD1 (D, Pi ((Dec (name, _), Maybe), V), occ, k)  = checkD1 (Decl (D, Existential (Free, name)), V, body occ, fun (Decl (D\', m)) -> ctxPush (m, k D\')) | checkD1 (D, Pi ((Dec (name, V1), No), V2), occ, k)  = checkD1 (Decl (D, Existential (Free, name)), V2, body occ, fun (Decl (D\', m)) -> ctxPush (m, checkG1 (D\', V1, label occ, k))) | checkD1 (D, Root (Const a, S), occ, k)  = (* for a declaration, all modes must be satisfied *) let rec checkAll nil  = () | checkAll (mS :: mSs)  = let rec checkSome [D\']  = (* D\' is the only (last) possibility; on failure, we raise ModeError *)  (groundAtom (D\', Minus, S, mS, (1, occ)); (* ignore return *) checkAll mSs) | checkSome (D\' :: Ds)  = (* try D\', if it doesn\'t work, try another context in the Ds *)  ((try  with ); checkAll mSs) in checkSome (k (updateAtom (D, Plus, S, a, mS, (1, occ)))) in checkAll (lookup (a, occ)) | checkD1 (D, Root (Def d, S), occ, k)  = (* for a declaration, all modes must be satisfied *) let rec checkAll nil  = () | checkAll (mS :: mSs)  = let rec checkSome [D\']  = (* D\' is the only (last) possibility; on failure, we raise ModeError *)  (groundAtom (D\', Minus, S, mS, (1, occ)); (* ignore return *) checkAll mSs) | checkSome (D\' :: Ds)  = (* try D\', if it doesn\'t work, try another context in the Ds *)  ((try  with ); checkAll mSs) in checkSome (k (updateAtom (D, Plus, S, d, mS, (1, occ)))) in checkAll (lookup (d, occ))(* checkG1 (D, V, occ, k) = Ds\n\n       Invariant:\n         if G |- V : L\n         and  V does not contain Skolem constants\n         and  D ~ G\n         then forall D\' >= D that mode checks V, (k D\') is a sublist of Ds\n         and for each Di in Ds, Di ~ G and Di >= D\'\n\n       exception ModeError is raised if the expression does not mode check\n       exception Error\' is raised if the expression contains type families\n       that have no mode information associated with them\n       (occ used in error messages)\n     *) checkG1 (D, Pi ((_, Maybe), V), occ, k)  = ctxPop (checkG1 (Decl (D, Universal), V, body occ, fun (Decl (D\', m)) -> ctxPush (m, k D\'))) | checkG1 (D, Pi ((Dec (_, V1), No), V2), occ, k)  = ctxPop (checkD1 (D, V1, label occ, fun D\' -> [D\']); checkG1 (Decl (D, Universal), V2, body occ, fun (Decl (D\', m)) -> ctxPush (m, k D\'))) | checkG1 (D, Root (Const a, S), occ, k)  = (* for a goal, at least one mode must be satisfied *) let rec checkList found nil  = nil | checkList false [mS]  = (* mS is the last possible mode to check;\n                    if the check fails, we don\'t catch ModeError *)  (match groundAtom (D, Plus, S, mS, (1, occ)) with Unique -> k (updateAtom (D, Minus1, S, a, mS, (1, occ))) | Ambig -> k (updateAtom (D, Minus, S, a, mS, (1, occ)))) | checkList found (mS :: mSs)  = (* uniqueness not permitted on multiple modes right now *)  (* Wed Aug 20 21:52:31 2003 -fp *)  (* found\' is true iff D satisfies mS *) (* compute all other mode contexts *) let found\' = (try  with ) let Ds\' = checkList (found || found\') mSs in if found\' then k (updateAtom (D, Minus, S, a, mS, (1, occ))) @ Ds\' else Ds\' in checkList false (lookup (a, occ)) | checkG1 (D, Root (Def d, S), occ, k)  = (* for a goal, at least one mode must be satisfied *) let rec checkList found nil  = nil | checkList false [mS]  = (* mS is the last possible mode to check;\n                    if the check fails, we don\'t catch ModeError *)  (match groundAtom (D, Plus, S, mS, (1, occ)) with Unique -> k (updateAtom (D, Minus1, S, d, mS, (1, occ))) | Ambig -> k (updateAtom (D, Minus, S, d, mS, (1, occ)))) | checkList found (mS :: mSs)  = (* uniqueness not permitted on multiple modes right now *)  (* Wed Aug 20 21:52:31 2003 -fp *)  (* found\' is true iff D satisfies mS *) (* compute all other mode contexts *) let found\' = (try  with ) let Ds\' = checkList (found || found\') mSs in if found\' then k (updateAtom (D, Minus, S, d, mS, (1, occ))) @ Ds\' else Ds\' in checkList false (lookup (d, occ)) (* checkDlocal (D, V, occ) = ()\n\n       Invariant:\n       If   G |- V : L\n       and  D ~ G\n       then checkD terminates with ()  iff V is mode correct.\n\n       otherwise exception ModeError is raised (occ used in error messages)\n    *) let rec checkDlocal (D, V, occ)  = (try  with ) (* --------------------------------------------------------- mode checking *) let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a (* checkD (ConDec, occOpt)  = ()\n\n       checkD terminates with () if ConDec is mode correct\n       otherwise exception Error is raised\n\n       (occOpt is used in error messages)\n    *) let rec checkD (conDec, fileName, occOpt)  = let _ = (checkFree := false) let rec checkable (Root (Ha, _))  = (match (mmodeLookup (cidFromHead Ha)) with nil -> false | _ -> true) | checkable (Uni _)  = false | checkable (Pi (_, V))  = checkable V let V = conDecType conDec in if (checkable V) then try  with  else () let rec checkAll (nil)  = () | checkAll (Const (c) :: clist)  = (if ! chatter > 3 then print (qidToString (constQid c) ^ " ") else (); try  with ; checkAll clist) | checkAll (Def (d) :: clist)  = (if ! chatter > 3 then print (qidToString (constQid d) ^ " ") else (); try  with ; checkAll clist) let rec checkMode (a, ms)  = let _ = if ! chatter > 3 then print ("Mode checking family " ^ qidToString (constQid a) ^ ":\\n") else () let clist = lookup a let _ = (checkFree := false) let _ = checkAll clist let _ = if ! chatter > 3 then print "\\n" else () in () let rec checkFreeOut (a, ms)  = let _ = if ! chatter > 3 then print ("Checking output freeness of " ^ qidToString (constQid a) ^ ":\\n") else () let clist = lookup a let _ = (checkFree := true) let _ = checkAll clist let _ = if ! chatter > 3 then print "\\n" else () in () let checkD = checkD let checkMode = checkMode let checkFreeOut = checkFreeOut  end\n(* functor ModeCheck *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Mode Checking *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning *) module type MODECHECK = sig exception Error of string(* for new declarations *) val checkD : ConDec * string * occConDec option -> unit(* raises Error (msg) *) (* for prior declarations *) val checkMode : cid * ModeSpine -> unit(* raises Error(msg) *) (* for output coverage of prior declarations *) val checkFreeOut : cid * ModeSpine -> unit(* raises Error(msg) *)  end\n(* signature MODECHECK *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Printing Mode Declarations *) (* Author: Carsten Schuermann *) module type MODEPRINT = sig (*! structure ModeSyn : MODESYN !*) val modeToString : cid * ModeSpine -> stringval modesToString : cid * ModeSpine list -> string end\n(* signature MODEPRINT *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* structure ModeSyn  in modesyn.sml *) module ModeTable = ModeTable(module Table = IntRedBlackTree)\nmodule ModeDec = ModeDec()\nmodule ModeCheck = ModeCheck(struct module ModeTable = ModeTable module Whnf = Whnf module Index = Index module Origins = Origins end)\nmodule ModePrint = ModePrint(struct module Names = Names module Formatter = Formatter module Print = Print end)\n', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Mode Syntax *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning, Roberto Virga *) module type MODESYN = sig (*! structure IntSyn : INTSYN !*) type ModePlusStarMinusMinus1type ModeSpineMnilMappMarg * ModeSpine and MargMargMode * string optionval modeEqual : Mode * Mode -> boolval modeToString : Mode -> string end\n(* signature MODESYN *) module ModeSynMODESYN = struct exception Error of string type Mode = Plus | Star | Minus | Minus1 type ModeSpine = Mnil | Mapp of Marg * ModeSpine and Marg = Marg of Mode * string option (* modeEqual (M1, M2) = true iff M1 = M2 *)  let rec modeEqual (Plus, Plus)  = true | modeEqual (Star, Star)  = true | modeEqual (Minus, Minus)  = true | modeEqual (Minus1, Minus1)  = true | modeEqual (_, _)  = false (* modeToString M = string\n    \n       converts a mode into a string for error messages\n  *)  let rec modeToString Plus  = "input (+)" | modeToString Star  = "unrestricted (*)" | modeToString Minus  = "output (-)" | modeToString Minus1  = "unique output (-1)" end\n(* structure ModeSyn *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Construct a 20041109-workalike MLton.Thread for previous MLton versions *) module MLton = struct open MLton module Thread = struct open MLtonThread let rec prepare (f, x)  = f end end
Code parsed successfully: module SigINTSIGINT = struct let rec interruptLoop (loop : unit -> unit)  = (*
	val _ = print
"Upon interrupt at prompt => type\n\
\f to return to top-level of Twelf server\n\
\c to continue Twelf execution\n\
\q to quit the Twelf server\n"
        *) let origIntHandler = signal (int, SIG_HANDLE (fun n -> (print "\ninterrupt\n"; interruptConsoleProcesses ()))) in loop () end
(* structure SigINT *) 
('Error parsing code:', 'module SigINTSIGINT = struct let rec interruptLoop (loop : unit -> unit)  = (* open MLton *) let _ = callcc (fun k -> setHandler (int, handler (fun _ -> prepare (new (fun () -> throw (k, ())), ())))) in loop () end\n', 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: module SigINTSIGINT = struct let rec interruptLoop (loop : unit -> unit)  = (callcc (fun k -> (setHandler (sigINT, HANDLER (fun _ -> (print "\ninterrupt\n"; k))); ())); loop ()) end
(* structure SigINT *) 
('Error parsing code:', 'module type SERVER = sig val server : string * string list -> status end(* signature SERVER *) module Server (module SigINT : SIGINTmodule Timing : TIMINGmodule Lexer : LEXERmodule Twelf : TWELF)SERVER = struct let globalConfig : config option ref = ref NONE (* readLine () = (command, args)\n     reads a command and and its arguments from the command line.\n  *)  let rec readLine ()  = (* val line = TextIO.inputLine (TextIO.stdIn) *) (* Fix for MLton, Fri Dec 20 21:50:22 2002 -sweeks (fp) *) let rec getLine ()  = try  with let line = getLine () let rec triml ss  = dropl isSpace ss let rec trimr ss  = dropr isSpace ss let line\' = triml (trimr (full line)) in if line = "" then ("OS.exit", "") else if size (line\') = 0 then readLine () else let (command\', args\') = position " " line\' in (string command\', string (triml args\')) (* tokenize (args) = [token1, token2, ..., tokenn]\n     splits the arguments string into a list of space-separated\n     tokens\n  *)  let rec tokenize (args)  = tokens isSpace args (* exception Error for server errors *)  exception Error of string let rec error (msg)  = raise (Error (msg)) let rec quote (string)  = "`" ^ string ^ "\'" (* Print the OK or ABORT messages which are parsed by Emacs *)  let rec issue (OK)  = print ("%% OK %%\\n") | issue (ABORT)  = print ("%% ABORT %%\\n") (* Checking if there are no extraneous arguments *)  let rec checkEmpty ("")  = () | checkEmpty (args)  = error "Extraneous arguments" (* Command argument types *)  (* File names, given a default *)  let rec getFile ("", default)  = default | getFile (fileName, default)  = fileName (* File names, not defaults *)  let rec getFile\' ("")  = error "Missing filename" | getFile\' (fileName)  = fileName (* Identifiers, used as a constant *)  let rec getId (id :: nil)  = id | getId (nil)  = error "Missing identifier" | getId (ts)  = error "Extraneous arguments" (* Identifiers, used as a trace specification *)  let rec getIds (ids)  = ids (* Strategies for %prove, %establish *)  let rec getStrategy ("FRS" :: nil)  = FRS | getStrategy ("RFS" :: nil)  = RFS | getStrategy (nil)  = error "Missing strategy" | getStrategy (t :: nil)  = error (quote t ^ " is not a strategy (must be FRS or RFS)") | getStrategy (ts)  = error "Extraneous arguments" let rec strategyToString (FRS)  = "FRS" | strategyToString (RFS)  = "RFS" (* Booleans *)  let rec getBool ("true" :: nil)  = true | getBool ("false" :: nil)  = false | getBool (nil)  = error "Missing boolean value" | getBool (t :: nil)  = error (quote t ^ " is not a boolean") | getBool (ts)  = error "Extraneous arguments" (* Natural numbers *)  let rec getNat (t :: nil)  = (try  with ) | getNat (nil)  = error "Missing natural number" | getNat (ts)  = error "Extraneous arguments" (* Limits ( *, or natural number) *)  let rec getLimit ("*" :: nil)  = NONE | getLimit (t :: ts)  = SOME (getNat (t :: ts)) | getLimit (nil)  = error "Missing `*\' or natural number" let rec limitToString (NONE)  = "*" | limitToString (SOME (i))  = toString i (* Tabling strategy *)  let rec getTableStrategy ("Variant" :: nil)  = Variant | getTableStrategy ("Subsumption" :: nil)  = Subsumption | getTableStrategy (nil)  = error "Missing tabling strategy" | getTableStrategy (t :: nil)  = error (quote t ^ " is not a tabling strategy (must be Variant or Subsumption)") | getTableStrategy (ts)  = error "Extraneous arguments" let rec tableStrategyToString (Variant)  = "Variant" | tableStrategyToString (Subsumption)  = "Subsumption" (* Tracing mode for term reconstruction *)  let rec getReconTraceMode ("Progressive" :: nil)  = Progressive | getReconTraceMode ("Omniscient" :: nil)  = Omniscient | getReconTraceMode (nil)  = error "Missing tracing reconstruction mode" | getReconTraceMode (t :: nil)  = error (quote t ^ " is not a tracing reconstruction mode\\n(must be Progressive or Omniscient)") | getReconTraceMode (ts)  = error "Extraneous arguments" let rec reconTraceModeToString (Progressive)  = "Progressive" | reconTraceModeToString (Omniscient)  = "Omniscient" (* Compile options *)  let rec getCompileOpt ("No" :: nil)  = No | getCompileOpt ("LinearHeads" :: nil)  = LinearHeads | getCompileOpt ("Indexing" :: nil)  = Indexing | getCompileOpt (nil)  = error "Missing tabling strategy" | getCompileOpt (t :: nil)  = error (quote t ^ " is not a compile option (must be No, LinearHeads, or Indexing ") | getCompileOpt (ts)  = error "Extraneous arguments" let rec compOptToString (No)  = "No" | compOptToString (LinearHeads)  = "LinearHeads" | compOptToString (Indexing)  = "Indexing" (* Setting Twelf parameters *)  let rec setParm ("chatter" :: ts)  = chatter := getNat ts | setParm ("doubleCheck" :: ts)  = doubleCheck := getBool ts | setParm ("unsafe" :: ts)  = unsafe := getBool ts | setParm ("autoFreeze" :: ts)  = autoFreeze := getBool ts | setParm ("Print.implicit" :: ts)  = implicit := getBool ts | setParm ("Print.depth" :: ts)  = depth := getLimit ts | setParm ("Print.length" :: ts)  = length := getLimit ts | setParm ("Print.indent" :: ts)  = indent := getNat ts | setParm ("Print.width" :: ts)  = width := getNat ts | setParm ("Trace.detail" :: ts)  = detail := getNat ts | setParm ("Compile.optimize" :: ts)  = optimize := getCompileOpt ts | setParm ("Recon.trace" :: ts)  = trace := getBool ts | setParm ("Recon.traceMode" :: ts)  = traceMode := getReconTraceMode ts | setParm ("Prover.strategy" :: ts)  = strategy := getStrategy ts | setParm ("Prover.maxSplit" :: ts)  = maxSplit := getNat ts | setParm ("Prover.maxRecurse" :: ts)  = maxRecurse := getNat ts | setParm ("Table.strategy" :: ts)  = strategy := getTableStrategy ts | setParm ("Table.strengthen" :: ts)  = strengthen := getBool ts | setParm (t :: ts)  = error ("Unknown parameter " ^ quote t) | setParm (nil)  = error ("Missing parameter") (* Getting Twelf parameter values *)  let rec getParm ("chatter" :: ts)  = toString (! chatter) | getParm ("doubleCheck" :: ts)  = toString (! doubleCheck) | getParm ("unsafe" :: ts)  = toString (! unsafe) | getParm ("autoFreeze" :: ts)  = toString (! autoFreeze) | getParm ("Print.implicit" :: ts)  = toString (! implicit) | getParm ("Print.depth" :: ts)  = limitToString (! depth) | getParm ("Print.length" :: ts)  = limitToString (! length) | getParm ("Print.indent" :: ts)  = toString (! indent) | getParm ("Print.width" :: ts)  = toString (! width) | getParm ("Trace.detail" :: ts)  = toString (! detail) | getParm ("Compile.optimize" :: ts)  = compOptToString (! optimize) | getParm ("Recon.trace" :: ts)  = toString (! trace) | getParm ("Recon.traceMode" :: ts)  = reconTraceModeToString (! traceMode) | getParm ("Prover.strategy" :: ts)  = strategyToString (! strategy) | getParm ("Prover.maxSplit" :: ts)  = toString (! maxSplit) | getParm ("Prover.maxRecurse" :: ts)  = toString (! maxRecurse) | getParm ("Table.strategy" :: ts)  = tableStrategyToString (! strategy) | getParm (t :: ts)  = error ("Unknown parameter " ^ quote t) | getParm (nil)  = error ("Missing parameter") (* extracted from doc/guide/twelf.texi *)  let helpString = "Commands:\\n\\\n\\  set <parameter> <value>     - Set <parameter> to <value>\\n\\\n\\  get <parameter>             - Print the current value of <parameter>\\n\\\n\\  Trace.trace <id1> ... <idn> - Trace given constants\\n\\\n\\  Trace.traceAll              - Trace all constants\\n\\\n\\  Trace.untrace               - Untrace all constants\\n\\\n\\  Trace.break <id1> ... <idn> - Set breakpoint for given constants\\n\\\n\\  Trace.breakAll              - Break on all constants\\n\\\n\\  Trace.unbreak               - Remove all breakpoints\\n\\\n\\  Trace.show                  - Show current trace and breakpoints\\n\\\n\\  Trace.reset                 - Reset all tracing and breaking\\n\\\n\\  Print.sgn                   - Print current signature\\n\\\n\\  Print.prog                  - Print current signature as program\\n\\\n\\  Print.subord                - Print current subordination relation\\n\\\n\\  Print.domains               - Print registered constraint domains\\n\\\n\\  Print.TeX.sgn               - Print signature in TeX format\\n\\\n\\  Print.TeX.prog              - Print signature in TeX format as program\\n\\\n\\  Timers.show                 - Print and reset timers\\n\\\n\\  Timers.reset                - Reset timers\\n\\\n\\  Timers.check                - Print, but do not reset timers.\\n\\\n\\  OS.chDir <file>             - Change working directory to <file>\\n\\\n\\  OS.getDir                   - Print current working directory\\n\\\n\\  OS.exit                     - Exit Twelf server\\n\\\n\\  quit                        - Quit Twelf server (same as exit)\\n\\\n\\  Config.read <file>          - Read current configuration from <file>\\n\\\n\\  Config.load                 - Load current configuration\\n\\\n\\  Config.append               - Load current configuration without prior reset\\n\\\n\\  make <file>                 - Read and load configuration from <file>\\n\\\n\\  reset                       - Reset global signature.\\n\\\n\\  loadFile <file>             - Load Twelf file <file>\\n\\\n\\  decl <id>                   - Show constant declaration for <id>\\n\\\n\\  top                         - Enter interactive query loop\\n\\\n\\  Table.top                   - Enter interactive loop for tables queries\\n\\\n\\  version                     - Print Twelf server\'s version\\n\\\n\\  help                        - Print this help message\\n\\\n\\\\n\\\n\\Parameters:\\n\\\n\\  chatter <nat>               - Level of verbosity (0 = none, 3 = default)\\n\\\n\\  doubleCheck <bool>          - Perform additional internal type-checking\\n\\\n\\  unsafe <bool>               - Allow unsafe operations (%assert)\\n\\\n\\  autoFreeze <bool>           - Freeze families involved in meta-theorems\\n\\\n\\  Print.implicit <bool>       - Print implicit arguments\\n\\\n\\  Print.depth <limit>         - Cut off printing at depth <limit>\\n\\\n\\  Print.length <limit>        - Cut off printing at length <limit>\\n\\\n\\  Print.indent <nat>          - Indent by <nat> spaces\\n\\\n\\  Print.width <nat>           - Line width for formatting\\n\\\n\\  Trace.detail <nat>          - Detail of tracing\\n\\\n\\  Compile.optimize <bool>     - Optimize during translation to clauses\\n\\\n\\  Recon.trace <bool>          - Trace term reconstruction\\n\\\n\\  Recon.traceMode <reconTraceMode> - Term reconstruction tracing mode\\n\\\n\\  Prover.strategy <strategy>  - Prover strategy\\n\\\n\\  Prover.maxSplit <nat>       - Prover splitting depth bound\\n\\\n\\  Prover.maxRecurse <nat>     - Prover recursion depth bound\\n\\\n\\  Table.strategy <tableStrategy>   - Tabling strategy\\n\\\n\\\\n\\\n\\Server types:\\n\\\n\\  file                        - File name, relative to working directory\\n\\\n\\  id                          - A Twelf identifier\\n\\\n\\  bool                        - Either `true\' or `false\'\\n\\\n\\  nat                         - A natural number (starting at `0\')\\n\\\n\\  limit                       - Either `*\' (no limit) or a natural number\\n\\\n\\  reconTraceMode              - Either `Progressive\' or `Omniscient\'\\n\\\n\\  strategy                    - Either `FRS\' or `RFS\'\\n\\\n\\  tableStrategy               - Either `Variant\' or `Subsumption\'\\n\\\n\\\\n\\\n\\See http://www.cs.cmu.edu/~twelf/guide-1-4/ for more information,\\n\\\n\\or type M-x twelf-info (C-c C-h) in Emacs.\\n\\\n\\" (* serve\' (command, args) = ()\n     executes the server commands represented by `tokens\', \n     issues success or failure and then reads another command line.\n     Invariant: tokens must be non-empty.\n\n     All input for one command must be on the same line.\n  *)  let rec serve\' ("set", args)  = (setParm (tokenize args); serve (OK)) | serve\' ("get", args)  = (print (getParm (tokenize args) ^ "\\n"); serve (OK)) | serve\' ("Style.check", args)  = (checkEmpty args; check (); serve (OK)) | serve\' ("Print.sgn", args)  = (checkEmpty args; sgn (); serve (OK)) | serve\' ("Print.prog", args)  = (checkEmpty args; prog (); serve (OK)) | serve\' ("Print.subord", args)  = (checkEmpty args; subord (); serve (OK)) | serve\' ("Print.domains", args)  = (checkEmpty args; domains (); serve (OK)) | serve\' ("Print.TeX.sgn", args)  = (checkEmpty args; sgn (); serve (OK)) | serve\' ("Print.TeX.prog", args)  = (checkEmpty args; prog (); serve (OK)) | serve\' ("Trace.trace", args)  = (trace (Some (getIds (tokenize args))); serve (OK)) | serve\' ("Trace.traceAll", args)  = (checkEmpty args; trace (All); serve (OK)) | serve\' ("Trace.untrace", args)  = (checkEmpty args; trace (None); serve (OK)) | serve\' ("Trace.break", args)  = (break (Some (getIds (tokenize args))); serve (OK)) | serve\' ("Trace.breakAll", args)  = (checkEmpty args; break (All); serve (OK)) | serve\' ("Trace.unbreak", args)  = (checkEmpty args; break (None); serve (OK)) | serve\' ("Trace.show", args)  = (checkEmpty args; show (); serve (OK)) | serve\' ("Trace.reset", args)  = (checkEmpty args; reset (); serve (OK)) | serve\' ("Timers.show", args)  = (checkEmpty args; show (); serve (OK)) | serve\' ("Timers.reset", args)  = (checkEmpty args; reset (); serve (OK)) | serve\' ("Timers.check", args)  = (checkEmpty args; reset (); serve (OK)) | serve\' ("OS.chDir", args)  = (chDir (getFile\' args); serve (OK)) | serve\' ("OS.getDir", args)  = (checkEmpty args; print (getDir () ^ "\\n"); serve (OK)) | serve\' ("OS.exit", args)  = (checkEmpty args; ()) | serve\' ("quit", args)  = () | serve\' ("Config.read", args)  = let fileName = getFile (args, "sources.cfg") in globalConfig := SOME (read fileName); serve (OK) | serve\' ("Config.load", args)  = (match ! globalConfig with NONE -> (globalConfig := SOME (read "sources.cfg")) | _ -> (); serve (load (valOf (! globalConfig)))) | serve\' ("Config.append", args)  = (match ! globalConfig with NONE -> (globalConfig := SOME (read "sources.cfg")) | _ -> (); serve (append (valOf (! globalConfig)))) | serve\' ("make", args)  = let fileName = getFile (args, "sources.cfg") in globalConfig := SOME (read fileName); serve (load (valOf (! globalConfig))) | serve\' ("reset", args)  = (checkEmpty args; reset (); serve (OK)) | serve\' ("loadFile", args)  = serve (loadFile (getFile\' args)) | serve\' ("readDecl", args)  = (checkEmpty args; serve (readDecl ())) | serve\' ("decl", args)  = serve (decl (getId (tokenize args))) | serve\' ("top", args)  = (checkEmpty args; top (); serve (OK)) | serve\' ("Table.top", args)  = (checkEmpty args; top (); serve (OK)) | serve\' ("version", args)  = (print (version ^ "\\n"); serve (OK)) | serve\' ("help", args)  = (print (helpString); serve (OK)) | serve\' (t, args)  = error ("Unrecognized command " ^ quote t)serveLine ()  = serve\' (readLine ())serve (OK)  = (issue (OK); serveLine ()) | serve (ABORT)  = (issue (ABORT); serveLine ()) let rec serveTop (status)  = try  with let rec server (name, _)  = (* ignore server name and arguments *)  (print (version ^ "\\n"); init (); (* initialize timers *) interruptLoop (fun () -> serveTop (OK)); success) end\n(* functor Server *) module Server = Server(struct module SigINT = SigINT module Timing = Timing module Lexer = Lexer module Twelf = Twelf end)\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module type SIGINT = sig val interruptLoop : (unit -> unit) -> unit end
(* signature SIGINT *) 
Code parsed successfully: module SigINTSIGINT = struct let rec interruptLoop (loop : unit -> unit)  = in loop () end

('Error parsing code:', '(* Heuristics : Version 1.3 *) (* Author: Carsten Schuermann *) module HeuristicHEURISTIC = struct type index = {sd: int; (* Splitting depth *) ; ind: int option; (* Induction variable *) ; c: int; (* Number of cases *) ; m: int; (* maximal number of cases *) ; r: int; (* 0 = non-recursive\n                                           1 = recursive *) ; p: int} (* Position (left to right) *)  let rec compare ({sd = k1; ind = NONE; c = c1; m = m1; r = r1; p = p1}, {sd = k2; ind = NONE; c = c2; m = m2; r = r2; p = p2})  = (match (compare (c1 * m2, c2 * m1), compare (k2, k1), compare (r1, r2), compare (p1, p2)) with (EQUAL, EQUAL, EQUAL, result) -> result | (EQUAL, EQUAL, result, _) -> result | (EQUAL, result, _, _) -> result | (result, _, _, _) -> result) | compare ({sd = k1; ind = NONE; c = c1; m = m1; r = r1; p = p1}, {sd = k2; ind = SOME (i2); c = c2; m = m2; r = r2; p = p2})  = (match (compare (c1 * m2, c2 * m1)) with LESS -> LESS | EQUAL -> GREATER | GREATER -> GREATER) | compare ({sd = k1; ind = SOME (i1); c = c1; m = m1; r = r1; p = p1}, {sd = k2; ind = NONE; c = c2; m = m2; r = r2; p = p2})  = (match (compare (c1 * m2, c2 * m1)) with LESS -> LESS | EQUAL -> LESS | GREATER -> GREATER) | compare ({sd = k1; ind = SOME (i1); c = c1; m = m1; r = r1; p = p1}, {sd = k2; ind = SOME (i2); c = c2; m = m2; r = r2; p = p2})  = (match (compare (c1 * m2, c2 * m1), compare (k2, k1), compare (r1, r2), compare (i1, i2), compare (p1, p2)) with (EQUAL, EQUAL, EQUAL, EQUAL, result) -> result | (EQUAL, EQUAL, EQUAL, result, _) -> result | (EQUAL, EQUAL, result, _, _) -> result | (EQUAL, result, _, _, _) -> result | (result, _, _, _, _) -> result) let rec recToString 0  = "non-rec" | recToString 1  = "rec" let rec realFmt (r)  = fmt (FIX (SOME (2))) r let rec ratio (c, m)  = (fromInt c) / (fromInt m) let rec sum {sd = k1; ind = NONE; c = c1; m = m1; r = r1; p = p1}  = realFmt ((fromInt k1) + ratio (m1, c1) + (fromInt r1)) | sum {sd = k1; ind = SOME (i1); c = c1; m = m1; r = r1; p = p1}  = realFmt ((fromInt k1) + ratio (1, i1) + ratio (m1, c1) + (fromInt r1)) let rec indexToString {sd = s1; ind = NONE; c = c1; m = m1; r = r1; p = p1}  = "(c/m=" ^ (toString c1) ^ "/" ^ (toString m1) ^ "=" ^ (realFmt (ratio (c1, m1))) ^ ", ind=., sd=" ^ (toString s1) ^ ", " ^ (recToString r1) ^ ", p=" ^ (toString p1) ^ "sum = " ^ (sum {sd = s1; ind = NONE; c = c1; m = m1; r = r1; p = p1}) ^ " )" | indexToString {sd = s1; ind = SOME (idx); c = c1; m = m1; r = r1; p = p1}  = "(c/m=" ^ (toString c1) ^ "/" ^ (toString m1) ^ "=" ^ (realFmt (ratio (c1, m1))) ^ ", ind=" ^ (toString idx) ^ ", sd=" ^ (toString s1) ^ ", " ^ (recToString r1) ^ ", p=" ^ (toString p1) ^ " sum = " ^ (sum {sd = s1; ind = SOME (idx); c = c1; m = m1; r = r1; p = p1}) ^ ")" let compare = compare let indexToString = indexToString  end\n(* functor Heuristic *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Heuristics : Version 1.3 *) (* Author: Carsten Schuermann *) module HeuristicHEURISTIC = struct type index = {sd: int; (* Splitting depth *) ; ind: int option; (* Induction variable *) ; c: int; (* Number of cases *) ; m: int; (* maximal number of cases *) ; r: int; (* 0 = non-recursive\n                                           1 = recursive *) ; p: int} (* Position (left to right) *)  let rec recToString 0  = "non-rec = 2" | recToString 1  = "rec = 1" let rec realFmt (r)  = fmt (FIX (SOME (2))) r let rec ratio (0, 0)  = 1.0 | ratio (c, 0)  = 1.1 | ratio (c, m)  = (fromInt c) / (fromInt m) let rec sqr (x : real)  = x * x (* sum of the parameters k1 + m1/c1 + 1/ind + r1 *) (* the higher the sum the more preferred it is;  *) (* - bp Sep 21 1999 - weight splitting depth higher *) let rec sum {sd = k1; ind = NONE; c = c1; m = m1; r = r1; p = p1}  = if (c1 = 0) then (sqr (fromInt k1)) + (5.0 - ratio (c1, m1)) + (fromInt r1) else (sqr (fromInt k1)) + (1.0 - ratio (c1, m1)) + (fromInt r1) | sum {sd = k1; ind = SOME (0); c = c1; m = m1; r = r1; p = p1}  = if (c1 = 0) then (sqr (fromInt k1)) + (5.0 - ratio (c1, m1)) + (fromInt r1) else (sqr (fromInt k1)) + ratio (3, 2) + (1.0 - ratio (c1, m1)) + (fromInt r1) | sum {sd = k1; ind = SOME (i1); c = c1; m = m1; r = r1; p = p1}  = if (c1 = 0) then (sqr (fromInt k1)) + (5.0 - ratio (c1, m1)) + (fromInt r1) else (sqr (fromInt k1)) + ratio (1, i1) + (1.0 - ratio (c1, m1)) + (fromInt r1) (* associate a higher value to non-rec than to rec  *) let rec conv {sd = k1; ind = i; c = c1; m = m1; r = 1; p = p1}  = {sd = k1; ind = i; c = c1; m = m1; r = 1; p = p1} | conv {sd = k1; ind = i; c = c1; m = m1; r = 0; p = p1}  = {sd = k1; ind = i; c = c1; m = m1; r = 2; p = p1} let rec ccompare ({sd = k1; ind = i1; c = c1; m = m1; r = r1; p = p1}, {sd = k2; ind = i2; c = c2; m = m2; r = r2; p = p2})  = (match (compare (sum {sd = k2; ind = i2; c = c2; m = m2; r = r2; p = p2}, sum {sd = k1; ind = i1; c = c1; m = m1; r = r1; p = p1}), compare (p1, p2))(* p                 *)  with (EQUAL, result) -> result | (result, _) -> result) let rec compare ({sd = k1; ind = i1; c = c1; m = m1; r = r1; p = p1}, {sd = k2; ind = i2; c = c2; m = m2; r = r2; p = p2})  = ccompare (conv ({sd = k1; ind = i1; c = c1; m = m1; r = r1; p = p1}), conv ({sd = k2; ind = i2; c = c2; m = m2; r = r2; p = p2})) let rec indexToString {sd = s1; ind = NONE; c = c1; m = m1; r = 0; p = p1}  = "(sd * r =" ^ (toString (s1 * 3)) ^ ", sd=" ^ (toString s1) ^ ", " ^ (recToString 0) ^ " = 2" ^ ", c/m=" ^ (toString c1) ^ "/" ^ (toString m1) ^ "=" ^ (realFmt (1.0 - ratio (c1, m1))) ^ ", ind=.," ^ ", p=" ^ (toString p1) ^ " sum = " ^ realFmt (sum {sd = s1; ind = NONE; c = c1; m = m1; r = 2; p = p1}) ^ " )" | indexToString {sd = s1; ind = NONE; c = c1; m = m1; r = 1; p = p1}  = "(sd * r =" ^ (toString (s1 * 1)) ^ ", sd=" ^ (toString s1) ^ ", " ^ (recToString 1) ^ " = 1" ^ ", c/m=" ^ (toString c1) ^ "/" ^ (toString m1) ^ "=" ^ (realFmt (1.0 - ratio (c1, m1))) ^ ", ind=.," ^ ", p=" ^ (toString p1) ^ " sum = " ^ realFmt (sum {sd = s1; ind = NONE; c = c1; m = m1; r = 1; p = p1}) ^ " )" | indexToString {sd = s1; ind = SOME (idx); c = c1; m = m1; r = 0; p = p1}  = let i = if idx = 0 then 0.0 else (ratio (1, idx)) in "(sd * r =" ^ (toString (s1 * 3)) ^ ", sd=" ^ (toString s1) ^ ", " ^ (recToString 0) ^ " = 2" ^ ", c/m=" ^ (toString c1) ^ "/" ^ (toString m1) ^ "=" ^ (realFmt (1.0 - ratio (c1, m1))) ^ ", ind=" ^ (toString idx) ^ " = " ^ realFmt (i) ^ ", p=" ^ (toString p1) ^ " sum = " ^ realFmt (sum {sd = s1; ind = SOME (idx); c = c1; m = m1; r = 2; p = p1}) ^ ")" | indexToString {sd = s1; ind = SOME (idx); c = c1; m = m1; r = 1; p = p1}  = let i = if idx = 0 then 0.0 else (ratio (1, idx)) in "(sd * r =" ^ (toString (s1 * 1)) ^ ", sd=" ^ (toString s1) ^ ", " ^ (recToString 1) ^ " =  1" ^ ", c/m=" ^ (toString c1) ^ "/" ^ (toString m1) ^ "=" ^ (realFmt (1.0 - ratio (c1, m1))) ^ ", ind=" ^ (toString idx) ^ " = " ^ (realFmt i) ^ ", p=" ^ (toString p1) ^ " sum = " ^ realFmt (sum {sd = s1; ind = SOME (idx); c = c1; m = m1; r = 1; p = p1}) ^ ")" let compare = compare let indexToString = indexToString  end\n(* functor Heuristic *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Heuristics : Version 1.3 *) (* Author: Carsten Schuermann *) module type HEURISTIC = sig type index = {sd: int; (* Splitting depth *) ; ind: int option; (* Induction variable *) ; c: int; (* Number of cases *) ; m: int; (* maximal number of cases *) ; r: int; (* 0 = non-recursive\n\t\t\t\t\t   1 = recursive *) ; p: int}(* Position (left to right) *) val compare : index * index -> orderval indexToString : index -> string end\n(* signature HEURISTIC *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* ELIM: Version 1.4 *) (* Author: Carsten Schuermann *) module type ELIM = sig module State : STATEexception Error of stringtype operatorval expand : Focus -> operator listval apply : operator -> unitval menu : operator -> string end\n(* signature ELIM *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Weakening substitutions *) (* Author: Carsten Schuermann *) module Weaken ((*! structure IntSyn' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn' !*) ) : WEAKEN = struct (*! structure IntSyn = IntSyn' !*)  module I = IntSyn(* strengthenExp (U, s) = U'\n\n       Invariant:\n       If   G |- s : G'\n       and  G |- U : V\n       then G' |- U' = U[s^-1] : V [s^-1]\n    *) let rec strengthenExp (U, s)  = normalize (cloInv (U, s), id) (* strengthenDec (x:V, s) = x:V'\n\n       Invariant:\n       If   G |- s : G'\n       and  G |- V : L\n       then G' |- V' = V[s^-1] : L\n    *) let rec strengthenDec (Dec (name, V), s)  = Dec (name, strengthenExp (V, s)) (* strengthenCtx (G, s) = (G', s')\n\n       If   G0 |- G ctx\n       and  G0 |- s G1\n       then G1 |- G' = G[s^-1] ctx\n       and  G0 |- s' : G1, G'\n    *) let rec strengthenCtx (Null, s)  = (Null, s) | strengthenCtx (Decl (G, D), s)  = let (G', s') = strengthenCtx (G, s) in (Decl (G', strengthenDec (D, s')), dot1 s') let rec strengthenSub (s, t)  = compInv (s, t) let rec strengthenSpine (Nil, t)  = Nil | strengthenSpine (App (U, S), t)  = App (strengthenExp (U, t), strengthenSpine (S, t)) let strengthenExp = strengthenExp let strengthenSpine = strengthenSpine let strengthenDec = strengthenDec let strengthenCtx = strengthenCtx let strengthenSub = strengthenSub  end(* functor Weaken *) ", 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Elim *) (* Author: Carsten Schuermann *) (* Date: Thu Mar 16 13:39:26 2006 *) module Elim (module Data : DATA(*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module State\' : STATE(*! sharing State\'.IntSyn = IntSyn\' !*) (*! sharing State\'.Tomega = Tomega\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) (*! sharing Abstract.Tomega = Tomega\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) ) : ELIM = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module State = State\' exception Error of string type Operator = Local of Prg * int type operator = Operator module S = Statemodule T = Tomegamodule I = IntSynexception Success of int (* These lines need to move *) (* fun stripTC (T.Abs (_, TC)) = TC *) let rec stripTC TC  = TC let rec stripTCOpt NONE  = NONE | stripTCOpt (SOME TC)  = SOME (stripTC TC) let rec stripDec (UDec D)  = UDec D | stripDec (PDec (name, F, TC1, TC2))  = PDec (name, F, TC1, stripTCOpt TC2) let rec strip Null  = Null | strip (Decl (Psi, D))  = Decl (strip Psi, stripDec D) (* expand\' S = op\'\n\n       Invariant:\n       If   |- S state\n       then op\' is an operator which performs the filling operation\n    *) let rec expand (Focus (Y as EVar (Psi, r, G, V, _, _), W))  = (* Y is lowered *)  let rec matchCtx (Null, _, Fs)  = Fs | matchCtx (Decl (G, PDec (x, F, _, _)), n, Fs)  = matchCtx (G, n + 1, Local (Y, n) :: Fs) | matchCtx (Decl (G, UDec _), n, Fs)  = matchCtx (G, n + 1, Fs) in matchCtx (Psi, 1, nil) (* apply op = B\'\n\n       Invariant:\n       If op is a filling operator\n       then B\' holds iff the filling operation was successful\n    *) let rec apply (Local (R as EVar (Psi, r, G, NONE, NONE, _), n))  = let PDec (_, F0, _, _) = ctxDec (Psi, n) in (match F0 with All ((UDec (Dec (_, V)), _), F) -> (* the NONE, NONE may breach an invariant *) (* revisit when we add subterm orderings *) let X = newEVar (coerceCtx (strip Psi), V) let NDec x = decName (coerceCtx Psi, NDec NONE) let D = PDec (x, forSub (F, Dot (Exp X, id)), NONE, NONE) let Psi\' = Decl (Psi, D) let Y = newEVar (strip Psi\', forSub (G, shift)) in (r := SOME (Let (D, Redex (Var n, AppExp (X, Nil)), Y))) | Ex ((D1, _), F) -> let D1\' = decName (coerceCtx Psi, D1) let Psi\' = Decl (Psi, UDec D1\') let NDec x = decName (coerceCtx (Psi\'), NDec NONE) let D2 = PDec (x, F, NONE, NONE) let Psi\'\' = Decl (Psi\', D2) let Y = newEVar (strip Psi\'\', forSub (G, Shift 2)) in (r := SOME (LetPairExp (D1\', D2, Var n, Y))) | True -> let Y = newEVar (strip Psi, G) in (r := SOME (LetUnit (Var n, Y)))) | apply (Local (EVar (Psi, r, FClo (F, s), TC1, TC2, X), n))  = apply (Local (EVar (Psi, r, forSub (F, s), TC1, TC2, X), n)) (* menu op = s\'\n\n       Invariant:\n       If op is a filling operator\n       then s\' is a string describing the operation in plain text\n    *) let rec menu (Local (X as EVar (Psi, _, _, _, _, _), n))  = (match (ctxLookup (Psi, n)) with PDec (SOME x, _, _, _) -> ("Elim " ^ nameEVar X ^ " with variable " ^ x)) (* Invariant: Context is named  --cs Fri Mar  3 14:31:08 2006 *) let expand = expand let apply = apply let menu = menu  (* local *)  end\n(* functor elim *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Meta Prover Interface *) (* Author: Carsten Schuermann *) module type INTERACTIVE = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) module State : STATEexception Error of stringval init : string list -> unitval select : int -> unitval print : unit -> unitval stats : unit -> unitval focus : string -> unitval return : unit -> unit(*   val next   : unit -> unit *) val reset : unit -> unit(*  val undo   : unit -> unit *)  end\n(* signature Interactive *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Recurse: Version 1.4 *) (* Author: Carsten Schuermann *) module type RECURSE = sig module State : STATEexception Error of stringtype operatorval expand : Focus -> operator listval apply : operator -> unitval menu : operator -> string end\n(* signature RECURSE *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* State definition for Proof Search *) (* Author: Carsten Schuermann *) module Split (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module State\' : STATE(*! sharing State\'.IntSyn = IntSyn\' !*) (*! sharing State\'.Tomega = Tomega\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) (*! sharing Abstract.Tomega = Tomega\' !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) ) : SPLIT = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module State = State\' exception Error of string module T = Tomegamodule I = IntSynmodule S = State\'type Operator = Split of Prg option ref * Prg * string (* weaken (G, a) = w\'\n\n       Invariant:\n       If   a is a type family\n       then G |- w\' : G\'\n       and  forall x:A in G\'  A subordinate to a\n     *) let rec weaken (Null, a)  = id | weaken (Decl (G\', D as Dec (name, V)), a)  = let w\' = weaken (G\', a) in if belowEq (targetFam V, a) then dot1 w\' else comp (w\', shift) (* added next case, probably should not arise *) (* Sun Dec 16 10:42:05 2001 -fp !!! *) (*\n      | weaken (I.Decl (G\', D as I.BDec _), a) =\n           I.dot1 (weaken (G\', a))\n      *) (* createEVar (G, V) = X[w] where G |- X[w] : V\n\n       Invariant:\n       If G |- V : L\n       then G |- X[w] : V\n    *) let rec createEVar (G, V)  = (* G |- V : L *) (* G  |- w  : G\'    *) (* G\' |- iw : G     *) (* G\' |- X\' : V[iw] *) (* G  |- X  : V     *) let w = weaken (G, targetFam V) let iw = invert w let G\' = strengthen (iw, G) let X\' = newEVar (G\', EClo (V, iw)) let X = EClo (X\', w) in X (* instEVars ({x1:V1}...{xp:Vp} V, p, nil) = (V[s], [X1,...,Xn])\n       where . |- s : {x1:V1}...{xp:Vp}\n       and s = Xp...X1.id, all Xi are new EVars\n    *) let rec instEVars (Vs, p, XsRev)  = instEVarsW (whnf Vs, p, XsRev)instEVarsW (Vs, 0, XsRev)  = (Vs, XsRev) | instEVarsW ((Pi ((Dec (xOpt, V1), _), V2), s), p, XsRev)  = (* p > 0 *) (* all EVars are global *) let X1 = newEVar (Null, EClo (V1, s)) in instEVars ((V2, Dot (Exp (X1), s)), p - 1, SOME (X1) :: XsRev) | instEVarsW ((Pi ((BDec (_, (l, t)), _), V2), s), p, XsRev)  = (* G0 |- t : Gsome *)  (* . |- s : G0 *)  (* p > 0 *) (* --cs Sun Dec  1 06:33:27 2002 *) let L1 = newLVar (Shift (0), (l, comp (t, s))) in instEVars ((V2, Dot (Block (L1), s)), p - 1, NONE :: XsRev) (* caseList is a list of possibilities for a variables\n       to be split.  Maintained as a mutable reference so it\n       can be updated in the success continuation.\n    *) let caseList : Dec Ctx * Sub list ref = ref nil let rec resetCases ()  = (caseList := nil) let rec addCase (Psi, t)  = (caseList := (Psi, t) :: ! caseList) let rec getCases ()  = (! caseList) (* createEVarSpine (G, (V, s)) = (S\', (V\', s\'))\n\n       Invariant:\n       If   G |- s : G1   and  G1 |- V = Pi {V1 .. Vn}. W : L\n       and  G1, V1 .. Vn |- W atomic\n       then G |- s\' : G2  and  G2 |- V\' : L\n       and  S = X1; ...; Xn; Nil\n       and  G |- W [1.2...n. s o ^n] = V\' [s\']\n       and  G |- S : V [s] >  V\' [s\']\n    *) let rec createEVarSpine (G, Vs)  = createEVarSpineW (G, whnf Vs)createEVarSpineW (G, Vs as (Root _, s))  = (Nil, Vs) | createEVarSpineW (G, (Pi ((D as Dec (_, V1), _), V2), s))  = (* G |- V1[s] : L *) let X = createEVar (G, EClo (V1, s)) let (S, Vs) = createEVarSpine (G, (V2, Dot (Exp (X), s))) in (App (X, S), Vs) (* Uni or other cases should be impossible *) (* createAtomConst (G, c) = (U\', (V\', s\'))\n\n       Invariant:\n       If   S |- c : Pi {V1 .. Vn}. V\n       then . |- U\' = c @ (X1; .. Xn; Nil)\n       and  . |- U\' : V\' [s\']\n    *) let rec createAtomConst (G, H as Const (cid))  = let V = constType cid let (S, Vs) = createEVarSpine (G, (V, id)) in (Root (H, S), Vs) (* createAtomBVar (G, k) = (U\', (V\', s\'))\n\n       Invariant:\n       If   G |- k : Pi {V1 .. Vn}. V\n       then . |- U\' = k @ (Xn; .. Xn; Nil)\n       and  . |- U\' : V\' [s\']\n    *) let rec createAtomBVar (G, k)  = let Dec (_, V) = ctxDec (G, k) let (S, Vs) = createEVarSpine (G, (V, id)) in (Root (BVar (k), S), Vs) (* createAtomProj (G, #i(l), (V, s)) = (U\', (V\', s\'))\n\n       Invariant:\n       If   G |- #i(l) : Pi {V1 .. Vn}. Va\n       and  G |- Pi {V1..Vn}. Va = V[s] : type\n       then . |- U\' = #i(l) @ (X1; .. Xn; Nil)\n       and  . |- U\' : V\' [s\']\n    *) let rec createAtomProj (G, H, (V, s))  = let (S, Vs\') = createEVarSpine (G, (V, s)) in (Root (H, S), Vs\') let rec constCases (G, Vs, nil, sc)  = () | constCases (G, Vs, Const (c) :: sgn\', sc)  = let (U, Vs\') = createAtomConst (G, Const c) let _ = trail (fun () -> if unifiable (G, Vs, Vs\') then sc U else ()) in constCases (G, Vs, sgn\', sc) let rec paramCases (G, Vs, 0, sc)  = () | paramCases (G, Vs, k, sc)  = let (U, Vs\') = createAtomBVar (G, k) let _ = trail (fun () -> if unifiable (G, Vs, Vs\') then sc U else ()) in paramCases (G, Vs, k - 1, sc) (* createEVarSub G\' = s\n\n       Invariant:\n       If   . |- G\' ctx\n       then . |- s : G\' and s instantiates each x:A with an EVar . |- X : A\n\n       Update: Always use empty context. Sat Dec  8 13:19:58 2001 -fp\n    *) let rec createEVarSub (Null)  = id | createEVarSub (Decl (G\', D as Dec (_, V)))  = let s = createEVarSub G\' let V\' = EClo (V, s) let X = newEVar (Null, V\') in Dot (Exp X, s) (* hack *) let rec blockName (cid)  = conDecName (sgnLookup (cid)) (* blockCases (G, Vs, B, (Gsome, piDecs), sc) =\n\n       If G |- V[s] : type\n          . |- Gsome ctx and Gsome |- piDecs decList\n       then sc is called for any x:A in piDecs such thtat\n            G |- V[s] = A[t] : type\n            where t instantiates variable in Gsome with new EVars\n    *) let rec blockCases (G, Vs, cid, (Gsome, piDecs), sc)  = (* accounts for subordination *) (* . |- t : Gsome *) (* --cs Sun Dec  1 06:33:41 2002 *) (* G |- t\' : Gsome *) let t = createEVarSub Gsome let sk = Shift (ctxLength (G)) let t\' = comp (t, sk) let lvar = newLVar (sk, (cid, t\')) in blockCases\' (G, Vs, (lvar, 1), (t\', piDecs), sc)blockCases\' (G, Vs, (lvar, i), (t, nil), sc)  = () | blockCases\' (G, Vs, (lvar, i), (t, Dec (_, V\') :: piDecs), sc)  = (* G |- t : G\' and G\' |- ({_:V\'},piDecs) decList *) (* so G |- V\'[t\'] : type *) let (U, Vs\') = createAtomProj (G, Proj (lvar, i), (V\', t)) let _ = trail (fun () -> if unifiable (G, Vs, Vs\') then sc U else ()) let t\' = Dot (Exp (Root (Proj (lvar, i), Nil)), t) in blockCases\' (G, Vs, (lvar, i + 1), (t\', piDecs), sc) let rec worldCases (G, Vs, Worlds (nil), sc)  = () | worldCases (G, Vs, Worlds (cid :: cids), sc)  = (blockCases (G, Vs, cid, constBlock cid, sc); worldCases (G, Vs, Worlds (cids), sc)) let rec lowerSplit (G, Vs, W, sc)  = lowerSplitW (G, whnf Vs, W, sc)lowerSplitW (G, Vs as (Root (Const a, _), s), W, sc)  = (* will trail *) (* will trail *) (* will trail *) let _ = constCases (G, Vs, lookup a, sc) let _ = paramCases (G, Vs, ctxLength G, sc) let _ = worldCases (G, Vs, W, sc) in () (*     | lowerSplitW (G, (I.Pi ((D, P), V), s), W, sc) =\n        let\n          val D\' = I.decSub (D, s)\n        in\n          lowerSplit (I.Decl (G, D\'), (V, I.dot1 s), W, fn U => sc (I.Lam (D\', U)))\n        end\n      we assume that all EVars are lowere :-)\n*) (* splitEVar (X, W, sc) = ()\n\n       calls sc () for all cases, after instantiation of X\n       W are the currently possible worlds\n    *) let rec splitEVar ((X as EVar (_, GX, V, _)), W, sc)  = (* GX = I.Null *)  lowerSplit (Null, (V, id), W, fun U -> if unifiable (Null, (X, id), (U, id)) then sc () else ()) (* createSub (Psi) = s\n\n       Invariant:\n       If   Psi is a meta context\n       then s = Xp...X1.id, all Xi are new EVars/LVars/MVars\n       and  . |- s : Psi\n    *) let rec createSub (Null)  = (id) | createSub (Decl (Psi, UDec (Dec (xOpt, V1))))  = (* all EVars are global and lowered *) let (t\') = createSub Psi let X = newEVar (Null, EClo (whnf (V1, coerceSub t\'))) in (Dot (Exp X, t\')) | createSub (Decl (Psi, UDec (BDec (_, (l, s)))))  = (* Psi0 |- t : Gsome *)  (* . |- s : Psi0 *)  (* --cs Sun Dec  1 06:34:00 2002 *) let (t\') = createSub Psi let L = newLVar (Shift (0), (l, comp (s, coerceSub t\'))) in (Dot (Block L, t\')) | createSub (Decl (Psi, PDec (_, F, TC1, TC2)))  = (* p > 0 *) let t\' = createSub Psi let Y = newEVarTC (Null, FClo (F, t\'), TC1, TC2) in (Dot (Prg Y, t\')) (* mkCases L F= Ss\n\n       Invariant:\n       If   L is a list of cases (Psi1, t1) .... (Psin, tn)\n       and  Psii |- ti : Psi\n       and  Psi  |- F formula\n       then Ss is a list of States S1 ... Sn\n       and  Si = (Psii, Fi)\n       where  Psii |- Fi = F [ti]  formula\n    *) let rec mkCases (nil, F)  = nil | mkCases ((Psi, t) :: cs, F)  = let X = newEVar (Psi, FClo (F, t)) in (Psi, t, X) :: mkCases (cs, F) (* split S = S1 ... Sn\n\n       Invariant:\n       If   S = (P |> F)\n       then Si = (Pi |> Fi)\n       s.t. there exists substitution si\n            and  Pi |- si : P\n            and  Pi |- Fi = F[si]\n            and  for every G |- t : P,\n\n                 there ex. an i among 1..n\n                 and a substitution t\',\n                 s.t. G |- t\' : Pi\n                 and  t = t\' [si]\n    *) let rec split (Focus (EVar (Psi, r, F, NONE, NONE, _), W))  = (* splitXs (G, i) (Xs, F, W, sc) = Os\n           Invariant:\n           If   Psi is a CONTEXT\n           and  G ~ Psi a context,\n           and  G |- i : V\n           and  Psi |- F formula\n           and  Xs are all logic variables\n           then Os is a list of splitting operators\n        *) (* . |- t :: Psi *) let rec splitXs (G, i) (nil, _, _, _)  = nil | splitXs (G, i) (X :: Xs, F, W, sc)  = (* returns a list of operators *) (*            val I.Dec (SOME s, _) = I.ctxLookup (G, i) *) let _ = if ! chatter >= 6 then print ("Split " ^ expToString (Null, X) ^ ".\\n") else () let Os = splitXs (G, i + 1) (Xs, F, W, sc) let _ = resetCases () let s = expToString (G, X) let Os\' = try  with  in Os\' let t = createSub Psi let Xs = collectLFSub t let rec init ()  = (addCase (abstractTomegaSub t)) let G = coerceCtx Psi let Os = splitXs (G, 1) (Xs, F, W, init) in Os let rec expand (S as Focus (EVar (Psi, r, F, NONE, NONE, _), W))  = if closedCTX Psi then split S else [] (* apply (Op) = Sl\'\n\n       Invariant:\n       If   Op = (_, Sl)\n       then Sl\' = Sl\n\n       Side effect: If Sl contains inactive states, an exception is raised\n    *) let rec apply (Split (r, P, s))  = (r := SOME P) (* trailing required -cs Thu Apr 22 12:05:04 2004 *) let rec menu (Split (_, _, s))  = "Split " ^ s type operator = Operator let expand = expand let apply = apply let menu = menu  end(* functor Split *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Splitting: Version 1.4 *) (* Author: Carsten Schuermann *) module type SPLIT = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) module State : STATEexception Error of stringtype operatorval expand : Focus -> operator listval apply : operator -> unitval menu : operator -> string end\n(* signature Split *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Filling: Version 1.4 *) (* Author: Carsten Schuermann *) module type FILL = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) module State : STATEexception Error of stringtype operatorval expand : Focus -> operator listval apply : operator -> unitval menu : operator -> string end\n(* signature FILL *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Fixed Point *) (* Author: Carsten Schuermann *) module FixedPoint ((*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module State\' : STATE(*! sharing State\'.IntSyn = IntSyn\' !*) (*! sharing State\'.Tomega = Tomega\' !*) ) : FIXEDPOINT = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module State = State\' module S = State\'module T = Tomegamodule I = IntSynexception ErrorError type operator = (Prg option ref * Prg) (* expand S = S\'\n\n       Invariant:\n       If   S = (Psi |>  F)\n       and  F does not start with an all quantifier\n       then S\' = (Psi, xx :: F |> F)\n    *) let rec expand (Focus (EVar (Psi, r, F, _, TCs, _), W), O)  = (*        val D = T.PDec (SOME "IH" , F, SOME O, SOME O) *) let NDec x = decName (coerceCtx Psi, NDec NONE) let D = PDec (x, F, NONE, NONE) let X = newEVar (Decl (Psi, D), forSub (F, Shift 1)) in (r, Rec (D, X)) (* apply O = S\n\n       Invariant:\n       O = S\n    *) let rec apply (r, P)  = (r := SOME P) (* should be trailed -cs Thu Apr 22 11:20:32 2004 *) (* menu O = s\n\n       Invariant:\n       s = "Apply universal introduction rules"\n    *) let rec menu _  = "Recursion introduction" exception ErrorError type operator = operator let expand = expand let apply = apply let menu = menu  end', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Search (based on abstract machine ) : Version 1.3 *) (* Author: Carsten Schuermann *) module Search (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module State\' : STATE(*! sharing State\'.IntSyn = IntSyn\' !*) (*! sharing State\'.Tomega = Tomega\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) (*! sharing Abstract.Tomega = Tomega\' !*) module Data : DATAmodule CompSyn\' : COMPSYN(*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Assign : ASSIGN(*! sharing Assign.IntSyn = IntSyn\' !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module Compile : COMPILE(*! sharing Compile.IntSyn = IntSyn\' !*) (*! sharing Compile.CompSyn = CompSyn\' !*) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module CSManager : CS_MANAGER(*! sharing CSManager.IntSyn = IntSyn\' !*) ) : SEARCH = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module State = State\' (*! structure CompSyn = CompSyn\' !*)  exception Error of string module I = IntSynmodule C = CompSyn(* isInstantiated (V) = SOME(cid) or NONE\n       where cid is the type family of the atomic target type of V,\n       NONE if V is a kind or object or have variable type.\n    *) let rec isInstantiated (Root (Const (cid), _))  = true | isInstantiated (Pi (_, V))  = isInstantiated V | isInstantiated (Root (Def (cid), _))  = true | isInstantiated (Redex (V, S))  = isInstantiated V | isInstantiated (Lam (_, V))  = isInstantiated V | isInstantiated (EVar (ref (SOME (V)), _, _, _))  = isInstantiated V | isInstantiated (EClo (V, s))  = isInstantiated V | isInstantiated _  = false let rec compose\' (Null, G)  = G | compose\' (Decl (G, D), G\')  = Decl (compose\' (G, G\'), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) (* exists P K = B\n       where B iff K = K1, Y, K2  s.t. P Y  holds\n    *) let rec exists P K  = let rec exists\' (Null)  = false | exists\' (Decl (K\', Y))  = P (Y) || exists\' (K\') in exists\' K (* occursInExp (r, (U, s)) = B,\n\n       Invariant:\n       If    G |- s : G1   G1 |- U : V\n       then  B holds iff r occurs in (the normal form of) U\n    *) let rec occursInExp (r, Vs)  = occursInExpW (r, whnf Vs)occursInExpW (r, (Uni _, _))  = false | occursInExpW (r, (Pi ((D, _), V), s))  = occursInDec (r, (D, s)) || occursInExp (r, (V, dot1 s)) | occursInExpW (r, (Root (_, S), s))  = occursInSpine (r, (S, s)) | occursInExpW (r, (Lam (D, V), s))  = occursInDec (r, (D, s)) || occursInExp (r, (V, dot1 s)) | occursInExpW (r, (EVar (r\', _, V\', _), s))  = (r = r\') || occursInExp (r, (V\', s))(*      | occursInExpW (r, (I.FgnExp (cs, ops), s)) =\n          occursInExp (r, (#toInternal(ops)(), s)) *) (* hack - should consult cs  -rv *) occursInSpine (_, (Nil, _))  = false | occursInSpine (r, (SClo (S, s\'), s))  = occursInSpine (r, (S, comp (s\', s))) | occursInSpine (r, (App (U, S), s))  = occursInExp (r, (U, s)) || occursInSpine (r, (S, s))occursInDec (r, (Dec (_, V), s))  = occursInExp (r, (V, s)) (* nonIndex (r, GE) = B\n\n       Invariant:\n       B hold iff\n        r does not occur in any type of EVars in GE\n    *) let rec nonIndex (_, nil)  = true | nonIndex (r, EVar (_, _, V, _) :: GE)  = (not (occursInExp (r, (V, id)))) && nonIndex (r, GE) (* select (GE, (V, s), acc) = acc\'\n\n       Invariant:\n    *) (* Efficiency: repeated whnf for every subterm in Vs!!! *) let rec selectEVar (nil)  = nil | selectEVar ((X as EVar (r, _, _, ref nil)) :: GE)  = let Xs = selectEVar (GE) in if nonIndex (r, Xs) then Xs @ [X] else Xs | selectEVar ((X as EVar (r, _, _, cnstrs)) :: GE)  = (* Constraint case *)  let Xs = selectEVar (GE) in if nonIndex (r, Xs) then X :: Xs else Xs (* pruneCtx (G, n) = G\'\n\n       Invariant:\n       If   |- G ctx\n       and  G = G0, G1\n       and  |G1| = n\n       then |- G\' = G0 ctx\n    *) let rec pruneCtx (G, 0)  = G | pruneCtx (Decl (G, _), n)  = pruneCtx (G, n - 1) let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a | cidFromHead (Skonst a)  = a (* only used for type families of compiled clauses *) let rec eqHead (Const a, Const a\')  = a = a\' | eqHead (Def a, Def a\')  = a = a\' | eqHead _  = false (* solve ((g,s), (G,dPool), sc, (acc, k)) => ()\n     Invariants:\n       G |- s : G\'\n       G\' |- g :: goal\n       G ~ dPool  (context G matches dPool)\n       acc is the accumulator of results\n       and k is the max search depth limit\n           (used in the existential case for iterative deepening,\n            used in the universal case for max search depth)\n       if  G |- M :: g[s] then G |- sc :: g[s] => Answer, Answer closed\n  *) let rec solve (max, depth, (Atom p, s), dp, sc)  = matchAtom (max, depth, (p, s), dp, sc) | solve (max, depth, (Impl (r, A, Ha, g), s), DProg (G, dPool), sc)  = let D\' = Dec (NONE, EClo (A, s)) in solve (max, depth + 1, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (fun M -> sc (Lam (D\', M)))) | solve (max, depth, (All (D, g), s), DProg (G, dPool), sc)  = let D\' = decSub (D, s) in solve (max, depth + 1, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Parameter)), (fun M -> sc (Lam (D\', M))))(* rsolve (max, depth, (p,s\'), (r,s), (G,dPool), sc, (acc, k)) = ()\n     Invariants:\n       G |- s : G\'\n       G\' |- r :: resgoal\n       G |- s\' : G\'\'\n       G\'\' |- p :: atom\n       G ~ dPool\n       acc is the accumulator of results\n       and k is the max search depth limit\n           (used in the existential case for iterative deepening,\n            used in the universal case for max search depth)\n       if G |- S :: r[s] then G |- sc : (r >> p[s\']) => Answer\n  *) rSolve (max, depth, ps\', (Eq Q, s), DProg (G, dPool), sc)  = if unifiable (G, ps\', (Q, s)) then sc Nil else () | rSolve (max, depth, ps\', (Assign (Q, eqns), s), dp as DProg (G, dPool), sc)  = (match assignable (G, ps\', (Q, s)) with SOME (cnstr) -> aSolve ((eqns, s), dp, cnstr, (fun () -> sc Nil)) | NONE -> ()) | rSolve (max, depth, ps\', (And (r, A, g), s), dp as DProg (G, dPool), sc)  = (* is this EVar redundant? -fp *) let X = newEVar (G, EClo (A, s)) in rSolve (max, depth, ps\', (r, Dot (Exp (X), s)), dp, (fun S -> solve (max, depth, (g, s), dp, (fun M -> sc (App (M, S)))))) | rSolve (max, depth, ps\', (In (r, A, g), s), dp as DProg (G, dPool), sc)  = (* G |- g goal *) (* G |- A : type *) (* G, A |- r resgoal *) (* G0, Gl  |- s : G *) (* G0, Gl  |- w : G0 *) (* G0 |- iw : G0, Gl *) (* G0 |- w : G *) (* G0 |- X : A[s\'] *) (* G0, Gl |- X\' : A[s\'][w] = A[s] *) let G0 = pruneCtx (G, depth) let dPool0 = pruneCtx (dPool, depth) let w = Shift (depth) let iw = invert w let s\' = comp (s, iw) let X = newEVar (G0, EClo (A, s\')) let X\' = EClo (X, w) in rSolve (max, depth, ps\', (r, Dot (Exp (X\'), s)), dp, (fun S -> if isInstantiated X then sc (App (X\', S)) else solve (max, 0, (g, s\'), DProg (G0, dPool0), (fun M -> (try  with ))))) | rSolve (max, depth, ps\', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), sc)  = let X = newEVar (G, EClo (A, s)) in rSolve (max, depth, ps\', (r, Dot (Exp (X), s)), dp, (fun S -> sc (App (X, S)))) | rSolve (max, depth, ps\', (Axists (ADec (SOME (X), d), r), s), dp as DProg (G, dPool), sc)  = let X\' = newAVar () in rSolve (max, depth, ps\', (r, Dot (Exp (EClo (X\', Shift (~ d))), s)), dp, sc)(* we don\'t increase the proof term here! *)(* aSolve ((ag, s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       if G |- ag[s] auxgoal\n       then sc () is evaluated with return value res\n       else res = Fail\n     Effects: instantiation of EVars in ag[s], dp and sc () *) aSolve ((Trivial, s), dp, cnstr, sc)  = (if solveCnstr cnstr then sc () else ()) | aSolve ((UnifyEq (G\', e1, N, eqns), s), dp as DProg (G, dPool), cnstr, sc)  = let (G\'\') = compose\' (G\', G) let s\' = shift (G\', s) in if unifiable (G\'\', (N, s\'), (e1, s\')) then aSolve ((eqns, s), dp, cnstr, sc) else ()(* matchatom ((p, s), (G, dPool), sc, (acc, k)) => ()\n     G |- s : G\'\n     G\' |- p :: atom\n     G ~ dPool\n     acc is the accumulator of results\n     and k is the max search depth limit\n         (used in the existential case for iterative deepening,\n          used in the universal case for max search depth)\n     if G |- M :: p[s] then G |- sc :: p[s] => Answer\n  *) matchAtom (0, _, _, _, _)  = () | matchAtom (max, depth, ps\' as (Root (Ha, _), _), dp as DProg (G, dPool), sc)  = let rec matchSig\' nil  = () | matchSig\' (Hc :: sgn\')  = let SClause (r) = sProgLookup (cidFromHead Hc) let _ = trail (fun () -> rSolve (max - 1, depth, ps\', (r, id), dp, (fun S -> sc (Root (Hc, S))))) in matchSig\' sgn\' let rec matchBlock (nil, (n, i))  = () | matchBlock ((r, s, H\') :: RGs\', (n, i))  = if eqHead (Ha, H\') then let _ = trail (fun () -> rSolve (max - 1, depth, ps\', (r, comp (s, Shift n)), dp, (fun S -> sc (Root (Proj (Bidx n, i), S))))) in matchBlock (RGs\', (n, i + 1)) else matchBlock (RGs\', (n, i + 1)) let rec matchDProg (Null, _)  = matchSig\' (lookup (cidFromHead Ha)) | matchDProg (Decl (dPool\', Dec (r, s, Ha\')), n)  = if eqHead (Ha, Ha\') then let _ = trail (fun () -> rSolve (max - 1, depth, ps\', (r, comp (s, Shift n)), dp, (fun S -> sc (Root (BVar n, S))))) in matchDProg (dPool\', n + 1) else matchDProg (dPool\', n + 1) | matchDProg (Decl (dPool\', Parameter), n)  = matchDProg (dPool\', n + 1) | matchDProg (Decl (dPool\', BDec RGs), n)  = (matchBlock (RGs, (n, 1)); matchDProg (dPool\', n + 1)) | matchDProg (Decl (dPool\', PDec), n)  = matchDProg (dPool\', n + 1) in matchDProg (dPool, 1)(* searchEx\' max (GE, sc) = acc\'\n\n       Invariant:\n       If   GE is a list of EVars to be instantiated\n       and  max is the maximal number of constructors\n       then if an instantiation of EVars in GE is found Success is raised\n            otherwise searchEx\' terminates with []\n    *) (* contexts of EVars are recompiled for each search depth *) searchEx\' max (nil, sc)  = sc max | searchEx\' max ((X as EVar (r, G, V, _)) :: GE, sc)  = solve (max, 0, (compileGoal (G, V), id), compileCtx false G, (fun U\' -> try  with )) (* deepen (f, P) = R\'\n\n       Invariant:\n       If   f function expecting parameters P\n         checking the variable MTPGlobal.maxLevel\n       then R\' is the result of applying f to P and\n         traversing all possible numbers up to MTPGlobal.maxLevel\n    *) let rec deepen depth f P  = let rec deepen\' level  = if level > depth then () else (if ! chatter > 5 then print "#" else (); (f level P; deepen\' (level + 1))) in deepen\' 1 (* searchEx (G, GE, (V, s), sc) = acc\'\n       Invariant:\n       If   G |- s : G\'   G\' |- V : level\n       and  GE is a list of EVars contained in V[s]\n         where G |- X : VX\n       and  sc is a function to be executed after all non-index variables have\n         been instantiated\n       then acc\' is a list containing the one result from executing the success continuation\n         All EVar\'s got instantiated with the smallest possible terms.\n    *) let rec searchEx (it, depth) (GE, sc)  = (if ! chatter > 5 then print "[Search: " else (); deepen depth searchEx\' (selectEVar (GE), fun max -> (if ! chatter > 5 then print "OK]\\n" else (); let GE\' = foldr (fun (X as EVar (_, G, _, _), L) -> collectEVars (G, (X, id), L)) nil GE let gE\' = length GE\' in if gE\' > 0 then if it > 0 then searchEx (it - 1, 1) (GE\', sc) else () else sc max(* warning: iterative deepening depth is not propably updated.\n                                             possible that it runs into an endless loop ? *) )); if ! chatter > 5 then print "FAIL]\\n" else (); ()) (* search (GE, sc) = ()\n\n       Invariant:\n       GE is a list of uninstantiated EVars\n       and sc is a success continuation : int -> unit\n\n       Side effect:\n       success continuation will raise exception\n    *) (* Shared contexts of EVars in GE may recompiled many times *) let rec search (maxFill, GE, sc)  = searchEx (1, maxFill) (GE, sc) let searchEx = search  (* local ... *)  end\n(* functor Search *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Meta Prover Interface *) (* Author: Carsten Schuermann *) module Interactive (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module State\' : STATE(*! sharing State\'.IntSyn = IntSyn\' !*) (*! sharing State\'.Tomega = Tomega\' !*) module Formatter : FORMATTERmodule Trail : TRAILmodule Ring : RINGmodule Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Weaken : WEAKEN(*! sharing Weaken.IntSyn = IntSyn\' !*) (* structure ModeSyn : MODESYN *) (*! sharing ModeSyn.IntSyn = IntSyn\' !*) module WorldSyn : WORLDSYN(*! sharing WorldSyn.IntSyn = IntSyn\' !*) (*! sharing WorldSyn.Tomega = Tomega\' !*) module Introduce : INTRODUCE(*! sharing Introduce.IntSyn = IntSyn\' !*) (*! sharing Introduce.Tomega = Tomega\' !*) IntroduceStateState\'module Elim : ELIM(*! sharing Elim.IntSyn = IntSyn\' !*) (*! sharing Elim.Tomega = Tomega\' !*) ElimStateState\'module Split : SPLIT(*! sharing Split.IntSyn = IntSyn\' !*) (*! sharing Split.Tomega = Tomega\' !*) SplitStateState\'module FixedPoint : FIXEDPOINT(*! sharing FixedPoint.IntSyn = IntSyn\' !*) (*! sharing FixedPoint.Tomega = Tomega\' !*) FixedPointStateState\'module Fill : FILL(*! sharing Fill.IntSyn = IntSyn\' !*) (*! sharing Fill.Tomega = Tomega\' !*) FillStateState\') : INTERACTIVE = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module State = State\' exception ErrorError module I = IntSynmodule T = Tomegamodule S = Statemodule M = ModeSynmodule W = WorldSynlet rec abort s  = (print ("* " ^ s ^ "\\n"); raise (Error s)) (* this is pretty preliminary:\n       I think we should just adapt the internal representation for formulas\n    *) let rec convertOneFor cid  = (* convertFor\' (V, mS, w1, w2, n) = (F\', F\'\')\n\n           Invariant:\n           If   G |- V = {{G\'}} type :kind\n           and  G |- w1 : G+\n           and  G+, G\'+, G- |- w2 : G\n           and  G+, G\'+, G- |- ^n : G+\n           and  mS is a spine for G\'\n           then F\'  is a formula excepting a another formula as argument s.t.\n                If G+, G\'+ |- F formula,\n                then . |- F\' F formula\n           and  G+, G\'+ |- F\'\' formula\n        *) (* shiftPlus (mS) = s\'\n\n         Invariant:\n         s\' = ^(# of +\'s in mS)\n         *) let V = match sgnLookup cid with ConDec (name, _, _, _, V, Kind) -> V | _ -> raise (Error "Type Constant declaration expected") let mS = match modeLookup cid with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let rec convertFor\' (Pi ((D, _), V), Mapp (Marg (Plus, _), mS), w1, w2, n)  = let (F\', F\'\') = convertFor\' (V, mS, dot1 w1, Dot (Idx n, w2), n - 1) in (fun F -> All ((UDec (strengthenDec (D, w1)), Explicit), F\' F), F\'\') | convertFor\' (Pi ((D, _), V), Mapp (Marg (Minus, _), mS), w1, w2, n)  = let (F\', F\'\') = convertFor\' (V, mS, comp (w1, shift), dot1 w2, n + 1) in (F\', Ex ((decSub (D, w2), Explicit), F\'\')) | convertFor\' (Uni Type, Mnil, _, _, _)  = (fun F -> F, True) | convertFor\' _  = raise (Error "type family must be +/- moded") let rec shiftPlus mS  = let rec shiftPlus\' (Mnil, n)  = n | shiftPlus\' (Mapp (Marg (Plus, _), mS\'), n)  = shiftPlus\' (mS\', n + 1) | shiftPlus\' (Mapp (Marg (Minus, _), mS\'), n)  = shiftPlus\' (mS\', n) in shiftPlus\' (mS, 0) let n = shiftPlus mS let (F, F\') = convertFor\' (V, mS, id, Shift n, n) in F F\' (* convertFor L = F\'\n\n       Invariant:\n       If   L is a list of type families\n       then F\' is the conjunction of the logical interpretation of each\n            type family\n     *) let rec convertFor nil  = raise (Error "Empty theorem") | convertFor [a]  = convertOneFor a | convertFor (a :: L)  = And (convertOneFor a, convertFor L) (* here ends the preliminary stuff *) type MenuItem = Split of operator | Fill of operator | Introduce of operator | Fix of operator | Elim of operator let Focus : State list ref = ref [] let Menu : MenuItem list option ref = ref NONE let rec SplittingToMenu (O, A)  = Split O :: A let rec initFocus ()  = (Focus := []) let rec normalize ()  = (match (! Focus) with (State (W, Psi, P, F) :: Rest) -> (Focus := (State (W, Psi, derefPrg P, F) :: Rest)) | _ -> ()) let rec reset ()  = (initFocus (); Menu := NONE) let rec format k  = if k < 10 then (toString k) ^ ".  " else (toString k) ^ ". " let rec menuToString ()  = (*          | menuToString\' (k, Inference O :: M,kOopt) =\n              let\n                val (kopt, s) = menuToString\' (k+1, M, kOopt)\n              in\n                (kopt, s ^ "\\n  " ^ (format k) ^ (Inference.menu O))\n              end\n*) let rec menuToString\' (k, nil)  = "" | menuToString\' (k, Split O :: M)  = let s = menuToString\' (k + 1, M) in s ^ "\\n  " ^ (format k) ^ (menu O) | menuToString\' (k, Introduce O :: M)  = let s = menuToString\' (k + 1, M) in s ^ "\\n  " ^ (format k) ^ (menu O) | menuToString\' (k, Fill O :: M)  = let s = menuToString\' (k + 1, M) in s ^ "\\n  " ^ (format k) ^ (menu O) | menuToString\' (k, Fix O :: M)  = let s = menuToString\' (k + 1, M) in s ^ "\\n  " ^ (format k) ^ (menu O) | menuToString\' (k, Elim O :: M)  = let s = menuToString\' (k + 1, M) in s ^ "\\n  " ^ (format k) ^ (menu O) in match ! Menu with NONE -> raise (Error "Menu is empty") | SOME M -> menuToString\' (1, M) let rec printStats ()  = let nopen = 0 let nsolved = 0 in (print "Statistics:\\n\\n"; print ("Number of goals : " ^ (toString (nopen + nsolved)) ^ "\\n"); print ("     open goals : " ^ (toString (nopen)) ^ "\\n"); print ("   solved goals : " ^ (toString (nsolved)) ^ "\\n")) let rec printmenu ()  = (match ! Focus with [] -> abort "QED" | (State (W, Psi, P, F) :: R) -> (print ("\\n======================="); print ("\\n= META THEOREM PROVER =\\n"); print (ctxToString (Psi)); print ("\\n-----------------------\\n"); print (forToString (Psi, F)); print ("\\n-----------------------\\n"); print (prgToString (Psi, P)); print ("\\n-----------------------"); print (menuToString ()); print ("\\n=======================\\n")) | (StateLF (X as EVar (r, G, V, Cs)) :: R) -> (print ("\\n======================="); print ("\\n=== THEOREM PROVER ====\\n"); print (ctxToString (Null, G)); print ("\\n-----------------------\\n"); print (expToString (G, V)); print ("\\n-----------------------\\n"); print (expToString (G, X)); print ("\\n-----------------------"); print (menuToString ()); print ("\\n=======================\\n"))) let rec menu ()  = (match (! Focus) with [] -> print "Please initialize first\\n" | (State (W, Psi, P, F) :: _) -> let Xs = collectT P let F1 = map (fun (EVar (Psi, r, F, TC, TCs, X)) -> (varReset Null; Focus (EVar (nameCtx Psi, r, F, TC, TCs, X), W))) Xs let Ys = collectLF P let F2 = map (fun Y -> FocusLF Y) Ys let rec splitMenu []  = [] | splitMenu (operators :: l)  = map Split operators @ splitMenu l let _ = doubleCheck := true let rec introMenu []  = [] | introMenu ((SOME oper) :: l)  = (Introduce oper) :: introMenu l | introMenu (NONE :: l)  = introMenu l let intro = introMenu (map expand F1) let fill = foldr (fun (S, l) -> l @ map (fun O -> Fill O) (expand S)) nil F2 let rec elimMenu []  = [] | elimMenu (operators :: l)  = map Elim operators @ elimMenu l let elim = elimMenu (map expand F1) let split = splitMenu (map expand F1) in Menu := SOME (intro @ split @ fill @ elim) | (StateLF Y :: _) -> let Ys = collectEVars (Null, (Y, id), nil) let F2 = map (fun Y -> FocusLF Y) Ys let fill = foldr (fun (S, l) -> l @ map (fun O -> Fill O) (expand S)) nil F2 in Menu := SOME (fill)) let rec select k  = let rec select\' (k, nil)  = abort ("No such menu item") | select\' (1, Split O :: _)  = (time splitting apply) O | select\' (1, Introduce O :: _)  = apply O | select\' (1, Elim O :: _)  = apply O | select\' (1, Fill O :: _)  = (time filling apply) O | select\' (k, _ :: M)  = select\' (k - 1, M) in (match ! Menu with NONE -> raise (Error "No menu defined") | SOME M -> try  with ) let rec init names  = (* so far omitted:  make sure that all parts of the theorem are\n             declared in the same world\n          *) let _ = evarReset () let cL = map (fun x -> valOf (constLookup (valOf (stringToQid x)))) names let F = convertFor cL let Ws = map lookup cL let rec select c  = (try  with ) let TC = transformTC (Null, F, map select cL) let (W :: _) = Ws let _ = Focus := [init (F, W)] let P = (match (! Focus) with [] -> abort "Initialization of proof goal failed\\n" | (State (W, Psi, P, F) :: _) -> P) let Xs = collectT P let F = map (fun (EVar (Psi, r, F, TC, TCs, X)) -> (varReset Null; Focus (EVar (nameCtx Psi, r, F, TC, TCs, X), W))) Xs let [Ofix] = map (fun f -> (expand (f, TC))) F let _ = apply Ofix let _ = normalize () let _ = menu () let _ = printmenu () in () (* focus n = ()\n\n       Invariant:\n       Let n be a string.\n       Side effect: Focus on selected subgoal.\n    *) let rec focus n  = (match (! Focus) with [] -> print "Please initialize first\\n" | (State (W, Psi, P, F) :: _) -> let rec findIEVar nil  = raise (Error ("cannot focus on " ^ n)) | findIEVar (Y :: Ys)  = if evarName (coerceCtx Psi, Y) = n then (Focus := (StateLF Y :: ! Focus); normalize (); menu (); printmenu ()) else findIEVar Ys let rec findTEVar nil  = findIEVar (collectLF P) | findTEVar ((X as EVar (Psi, r, F, TC, TCs, Y)) :: Xs)  = if evarName (coerceCtx Psi, Y) = n then (Focus := (State (W, nameCtx Psi, X, F) :: ! Focus); normalize (); menu (); printmenu ()) else findTEVar Xs in findTEVar (collectT P) | (StateLF (U) :: _) -> (* Invariant: U has already been printed, all EVars occuring\n                 in U are already named.\n              *) (match (getEVarOpt n) with NONE -> raise (Error ("cannot focus on " ^ n)) | SOME Y -> (Focus := (StateLF Y :: ! Focus); normalize (); menu (); printmenu ()))) let rec return ()  = (match (! Focus) with [S] -> if close S then print "[Q.E.D.]\\n" else () | (S :: Rest) -> (Focus := Rest; normalize (); menu (); printmenu ())) let init = init let select = select let print = printmenu let stats = printStats let reset = reset let focus = focus let return = return  end(* functor Interactive *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', "(* State definition for Proof Search *) (* Author: Carsten Schuermann *) module State (module Formatter : FORMATTER) : STATE = struct (*! structure IntSyn = IntSyn' !*)  (*! structure Tomega = Tomega' !*)  module Formatter = Formatter type State = State of Worlds * Dec Ctx * Prg * For | StateLF of Exp (* StateLF X, X is always lowered *)  type Focus = Focus of Prg * Worlds | FocusLF of Exp (* datatype State\n    = State of (Tomega.Dec IntSyn.Ctx * Tomega.For) * Tomega.Worlds\n *)  (*  datatype SideCondition  (* we need some work here *)\n    = None\n    | All   of SideCondition\n    | And   of SideCondition * SideCondition\n    | Order of Order.Predicate\n*)  exception Error of string module T = Tomegamodule I = IntSyn(* find P = [X1 .... Xn]\n       Invariant:\n       If   P is a well-typed program\n       then [X1 .. Xn] are all the open subgoals that occur within P\n    *) let rec findPrg (Lam (_, P))  = findPrg P | findPrg (New P)  = findPrg P | findPrg (Choose P)  = findPrg P | findPrg (PairExp (_, P))  = findPrg P | findPrg (PairBlock (B, P))  = findPrg P | findPrg (PairPrg (P1, P2))  = findPrg P1 @ findPrg P2 | findPrg (Unit)  = [] | findPrg (Rec (_, P))  = findPrg P | findPrg (Case (Cases C))  = findCases C | findPrg (PClo (P, t))  = findPrg P @ findSub t | findPrg (Let (D, P1, P2))  = findPrg P1 @ findPrg P2 | findPrg (LetPairExp (D1, D2, P1, P2))  = findPrg P1 @ findPrg P2 | findPrg (LetUnit (P1, P2))  = findPrg P1 @ findPrg P2 | findPrg (X as EVar (_, ref NONE, _, _, _, _))  = [X] | findPrg (X as EVar (_, ref (SOME P), _, _, _, _))  = findPrg P | findPrg (Const _)  = [] | findPrg (Var _)  = [] | findPrg (Redex (P, S))  = findPrg P @ findSpine SfindCases nil  = [] | findCases ((_, _, P) :: C)  = findPrg P @ findCases CfindSub (Shift _)  = [] | findSub (Dot (F, t))  = findFront F @ findSub tfindFront (Idx _)  = [] | findFront (Prg P)  = findPrg P | findFront (Exp _)  = [] | findFront (Block _)  = [] | findFront (Undef)  = []findSpine (Nil)  = [] | findSpine (AppPrg (P, S))  = findPrg P @ findSpine S | findSpine (AppExp (_, S))  = findSpine S | findSpine (AppBlock (_, S))  = findSpine S (* by invariant: blocks don't contain free evars *) (* find P = [X1 .... Xn]\n       Invariant:\n       If   P is a well-typed program\n       then [X1 .. Xn] are all the open subgoals that occur within P\n    *) let rec findExp (Psi, Lam (D, P)) K  = findExp (Decl (Psi, D), P) K | findExp (Psi, New P) K  = findExp (Psi, P) K | findExp (Psi, Choose P) K  = findExp (Psi, P) K | findExp (Psi, PairExp (M, P)) K  = findExp (Psi, P) (collectEVars (coerceCtx Psi, (M, id), K)) | findExp (Psi, PairBlock (B, P)) K  = findExp (Psi, P) K | findExp (Psi, PairPrg (P1, P2)) K  = findExp (Psi, P2) (findExp (Psi, P1) K) | findExp (Psi, Unit) K  = K | findExp (Psi, Rec (D, P)) K  = findExp (Psi, P) K | findExp (Psi, Case (Cases C)) K  = findExpCases (Psi, C) K | findExp (Psi, PClo (P, t)) K  = findExpSub (Psi, t) (findExp (Psi, P) K) | findExp (Psi, Let (D, P1, P2)) K  = findExp (Decl (Psi, D), P2) (findExp (Psi, P1) K) | findExp (Psi, LetPairExp (D1, D2, P1, P2)) K  = findExp (Decl (Decl (Psi, UDec D1), D2), P2) (findExp (Psi, P1) K) | findExp (Psi, LetUnit (P1, P2)) K  = findExp (Psi, P2) (findExp (Psi, P1) K) | findExp (Psi, X as EVar _) K  = K | findExp (Psi, Const _) K  = K | findExp (Psi, Var _) K  = K | findExp (Psi, Redex (P, S)) K  = findExpSpine (Psi, S) KfindExpSpine (Psi, Nil) K  = K | findExpSpine (Psi, AppPrg (_, S)) K  = findExpSpine (Psi, S) K | findExpSpine (Psi, AppExp (M, S)) K  = findExpSpine (Psi, S) (collectEVars (coerceCtx Psi, (M, id), K)) | findExpSpine (Psi, AppBlock (_, S)) K  = findExpSpine (Psi, S) KfindExpCases (Psi, nil) K  = K | findExpCases (Psi, (_, _, P) :: C) K  = findExpCases (Psi, C) (findExp (Psi, P) K)findExpSub (Psi, Shift _) K  = K | findExpSub (Psi, Dot (F, t)) K  = findExpSub (Psi, t) (findExpFront (Psi, F) K)findExpFront (Psi, Idx _) K  = K | findExpFront (Psi, Prg P) K  = findExp (Psi, P) K | findExpFront (Psi, Exp M) K  = collectEVars (coerceCtx Psi, (M, id), K) | findExpFront (Psi, Block _) K  = K | findExpFront (Psi, Undef) K  = K (* init F = S\n\n       Invariant:\n       S = (. |> F) is the initial state\n    *) let rec init (F, W)  = let X = newEVar (Null, F) in State (W, Null, X, F) (* close S = B\n\n       Invariant:\n       If  B holds iff S  doesn't contain any free subgoals\n    *) let rec close (State (W, _, P, _))  = (match (findPrg P, findExp (Null, P) []) with (nil, nil) -> true | _ -> false) let close = close let init = init let collectT = findPrg let collectLF = fun P -> findExp (Null, P) [] let collectLFSub = fun s -> findExpSub (Null, s) []  end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "module State = State(struct module WorldSyn' = WorldSyn module Formatter = Formatter end)module Introduce = Introduce(struct module TomegaNames = TomegaNames module State' = State end)module Elim = Elim(struct module Data = Data module State' = State module Whnf = Whnf module Abstract = Abstract module Unify = UnifyTrail module Constraints = Constraints module Index = Index module TypeCheck = TypeCheck end)module FixedPoint = FixedPoint(module State' = State)module Split = Split(struct module Global = Global module State' = State module Whnf = Whnf module Abstract = Abstract module Unify = UnifyTrail module Constraints = Constraints module Index = Index module Names = Names module Print = Print module TypeCheck = TypeCheck module Subordinate = Subordinate end)module Search = Search(struct module Global = Global module Data = Data module State' = State module Abstract = Abstract module Conv = Conv module CompSyn' = CompSyn module Compile = Compile module Whnf = Whnf module Unify = UnifyTrail module Index = IndexSkolem module Assign = Assign module CPrint = CPrint module Print = Print module Names = Names module CSManager = CSManager end)\nmodule Fill = Fill(struct module Data = Data module State' = State module Whnf = Whnf module Abstract = Abstract module Unify = UnifyTrail module Constraints = Constraints module Index = Index module Search = Search module TypeCheck = TypeCheck end)module Weaken = Weaken(module Whnf = Whnf)(*\nstructure Recurse = Recurse\n  (structure Global = Global\n   structure Data = Data\n   structure State' = State\n   structure Whnf = Whnf\n   structure Conv = Conv\n   structure Names = Names\n   structure Subordinate = Subordinate\n   structure Print = Print\n   structure Formatter = Formatter\n   structure TomegaPrint = TomegaPrint\n   structure Abstract = Abstract\n   structure Unify = UnifyTrail\n   structure Constraints = Constraints\n   structure Index = Index\n   structure Search = Search\n   structure TypeCheck = TypeCheck)\n*) module Interactive = Interactive(struct module Global = Global module State' = State module Ring = Ring module Formatter = Formatter module Trail = Trail module Names = Names module Weaken = Weaken module ModeSyn = ModeSyn module WorldSyn = WorldSyn module Introduce = Introduce module FixedPoint = FixedPoint module Split = Split module Fill = Fill module Elim = Elim end)", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Weakening substitutions *) (* Author: Carsten Schuermann *) module type WEAKEN = sig (*! structure IntSyn : INTSYN !*) val strengthenExp : (Exp * Sub) -> Expval strengthenSpine : (Spine * Sub) -> Spineval strengthenCtx : (dctx * Sub) -> (dctx * Sub)val strengthenDec : (Dec * Sub) -> Decval strengthenSub : (Sub * Sub) -> Sub end(* signature PRUNE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* State definition for Proof Search *) (* Author: Carsten Schuermann *) module type STATE = sig exception Error of stringtype StateStateWorlds * Dec Ctx * Prg * ForStateLFExptype FocusFocusPrg * WorldsFocusLFExp(* focus EVar *) val init : For * Worlds -> Stateval close : State -> boolval collectT : Prg -> Prg listval collectLF : Prg -> Exp listval collectLFSub : Sub -> Exp list end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Basic search engine: Version 1.3*) (* Author: Carsten Schuermann *) module type SEARCH = sig (*! structure IntSyn   : INTSYN !*) (*! structure Tomega   : TOMEGA !*) module State : STATEexception Error of stringval searchEx : int * Exp list(*      * (StateSyn.FunSyn.IntSyn.Exp * StateSyn.FunSyn.IntSyn.Sub) *)  * (int -> unit) -> unit end\n(* signature SEARCH *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Splitting: Version 1.4 *) (* Author: Carsten Schuermann *) module type FIXEDPOINT = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) module State : STATEexception Error of stringtype operatorval expand : (Focus * TC) -> operatorval apply : operator -> unitval menu : operator -> string end\n(* signature Fixed Point *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Printer Version 1.3 *) (* Author: Carsten Schuermann *) module type STATEPRINT = sig module Formatter : FORMATTER(*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) module State : STATEexception Error of stringval nameState : State -> Stateval formatState : State -> formatval stateToString : State -> string end\n(* signature STATEPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Introduce: Version 1.4 *) (* Author: Carsten Schuermann *) module type INTRODUCE = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) module State : STATEexception Error of stringtype operatorval expand : Focus -> operator optionval apply : operator -> unitval menu : operator -> string end\n(* signature INTRODUCE *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Introduce *) (* Author: Carsten Schuermann *) module Introduce ((*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module State\' : STATEmodule TomegaNames : TOMEGANAMES(*! sharing State\'.IntSyn = IntSyn\' !*) (*! sharing State\'.Tomega = Tomega\' !*) ) : INTRODUCE = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module State = State\' module S = State\'module T = Tomegamodule I = IntSynexception ErrorError type operator = Prg * Prg (*    fun stripTC (T.Abs (_, TC)) = TC *) let rec stripTC TC  = TC let rec stripTCOpt NONE  = NONE | stripTCOpt (SOME TC)  = SOME (stripTC TC) let rec stripDec (UDec D)  = UDec D | stripDec (PDec (name, F, TC1, TC2))  = PDec (name, F, TC1, stripTCOpt TC2) let rec strip Null  = Null | strip (Decl (Psi, D))  = Decl (strip Psi, stripDec D) (* expand S = S\'\n\n       Invariant:\n       If   S = (Psi |> all x1:A1 .... xn: An. F)\n       and  F does not start with an all quantifier\n       then S\' = (Psi, x1:A1, ... xn:An |> F)\n    *) let rec expand (Focus (R as EVar (Psi, r, All ((D, _), F), NONE, NONE, _), W))  = let D\' = decName (Psi, D) in SOME (R, Lam (D\', newEVar (Decl (strip Psi, D\'), F))) | expand (Focus (R as EVar (Psi, r, Ex ((D as Dec (_, V), _), F), NONE, NONE, _), W))  = let X = newEVar (coerceCtx (Psi), V) let Y = newEVar (Psi, forSub (F, Dot (Exp X, id))) in SOME (R, PairExp (X, Y)) | expand (Focus (R as EVar (Psi, r, True, NONE, NONE, _), W))  = (SOME (R, Unit)) | expand (Focus (EVar (Psi, r, FClo (F, s), TC1, TC2, X), W))  = expand (Focus (EVar (Psi, r, forSub (F, s), TC1, TC2, X), W)) | expand (Focus (EVar (Psi, r, _, _, _, _), W))  = NONE (* apply O = S\n\n       Invariant:\n       O = S\n    *) let rec apply (EVar (_, r, _, _, _, _), P)  = (r := SOME P) (* need to trail for back *) (* menu O = s\n\n       Invariant:\n       s = "Apply universal introduction rules"\n    *) let rec menu (r, P)  = "Intro " ^ nameEVar r exception ErrorError type operator = operator let expand = expand let apply = apply let menu = menu  end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Data Global parameters *) (* Author: Carsten Schuermann *) module type DATA = sig val maxFill : int refval maxSplit : int refval maxRecurse : int ref end\n(* signature DATA *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Meta data parameters *) (* Author: Carsten Schuermann *) module DataDATA = struct let maxFill = ref 5 let maxSplit = ref 5 let maxRecurse = ref 2 end
(* structure Data *) 
('Error parsing code:', '(* Filling *) (* Author: Carsten Schuermann *) (* Date: Thu Mar 16 13:08:33 2006 *) module Fill (module Data : DATA(*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module State\' : STATE(*! sharing State\'.IntSyn = IntSyn\' !*) (*! sharing State\'.Tomega = Tomega\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) (*! sharing Abstract.Tomega = Tomega\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) module Search : SEARCH(*! sharing Search.IntSyn = IntSyn\' !*) (*! sharing Search.Tomega = Tomega\' !*) SearchStateState\'module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) ) : FILL = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module State = State\' exception Error of string type Operator = FillWithConst of Exp * cid | FillWithBVar of Exp * int (* Representation Invariant:  FillWithBVar (X, n) :\n           X is an evar GX |- X : VX\n           GX |- n : W\n           and VX and W are unifiable\n       *)  type operator = Operator module S = Statemodule T = Tomegamodule I = IntSynexception Success of int (* expand\' S = op\'\n\n       Invariant:\n       If   |- S state\n       then op\' satifies representation invariant.\n    *) let rec expand (FocusLF (Y as EVar (r, G, V, _)))  = (* Y is lowered *)  (* matchCtx (G, n, Fs) = Fs\'\n\n           Invariant:\n           If G0 = G, G\' and |G\'| = n and Fs a list of filling operators that\n           satisfy the representation invariant, then Fs\' is a list of filling operators\n           that satisfy the representation invariant.\n        *) let rec try (Vs as (Root _, _), Fs, O)  = (try  with ) | try ((Pi ((Dec (_, V1), _), V2), s), Fs, O)  = let X = newEVar (G, EClo (V1, s)) in try ((V2, Dot (Exp X, s)), Fs, O) | try ((EClo (V, s\'), s), Fs, O)  = try ((V, comp (s\', s)), Fs, O) let rec matchCtx (Null, _, Fs)  = Fs | matchCtx (Decl (G, Dec (x, V)), n, Fs)  = matchCtx (G, n + 1, try ((V, Shift (n + 1)), Fs, FillWithBVar (Y, n + 1))) | matchCtx (Decl (G, NDec _), n, Fs)  = matchCtx (G, n + 1, Fs) let rec matchSig (nil, Fs)  = Fs | matchSig (Const (c) :: L, Fs)  = matchSig (L, try ((constType (c), id), Fs, FillWithConst (Y, c))) in matchCtx (G, 0, matchSig (lookup (targetFam V), nil)) (* apply op = ()\n\n       Invariant:\n       If op is a filling operator that satisfies the representation invariant.\n       The apply operation is guaranteed to always succeed.\n    *) let rec apply (FillWithBVar (Y as EVar (r, G, V, _), n))  = (* Y is lowered *)  (* Invariant : G |- s : G\'   G\' |- V : type *) let rec doit (Vs as (Root _, _), k)  = (unify (G, Vs, (V, id)); (k Nil)) | doit ((Pi ((Dec (_, V1), _), V2), s), k)  = let X = newEVar (G, EClo (V1, s)) in doit ((V2, Dot (Exp X, s)), (fun S -> k (App (X, S)))) | doit ((EClo (V, t), s), k)  = doit ((V, comp (t, s)), k) let Dec (_, W) = ctxDec (G, n) in doit ((W, id), fun S -> unify (G, (Y, id), (Root (BVar n, S), id))) | apply (FillWithConst (Y as EVar (r, G0, V, _), c))  = let rec doit (Vs as (Root _, _), k)  = (unify (G0, Vs, (V, id)); (k Nil)) | doit ((Pi ((Dec (_, V1), _), V2), s), k)  = let X = newEVar (G0, EClo (V1, s)) in doit ((V2, Dot (Exp X, s)), (fun S -> k (App (X, S)))) let W = constType c in doit ((W, id), fun S -> unify (G0, (Y, id), (Root (Const c, S), id))) (* menu op = s\'\n\n       Invariant:\n       If op is a filling operator\n       then s\' is a string describing the operation in plain text\n    *) let rec menu (FillWithBVar (X as EVar (_, G, _, _), n))  = (match (ctxLookup (ctxName G, n)) with Dec (SOME x, _) -> ("Fill " ^ evarName (G, X) ^ " with variable " ^ x)) | menu (FillWithConst (X as EVar (_, G, _, _), c))  = ("Fill " ^ evarName (G, X) ^ " with constant " ^ conDecName (sgnLookup c)) let expand = expand let apply = apply let menu = menu  (* local *)  end\n(* functor Filling *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Meta Printer Version 1.3 *) (* Author: Carsten Schuermann *) module StatePrint (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module State\' : STATE(*! sharing State\'.IntSyn = IntSyn\' !*) (*! sharing State\'.Tomega = Tomega\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Formatter\' : FORMATTERmodule Print : PRINTPrintFormatterFormatter\'(*! sharing Print.IntSyn = IntSyn\' !*) module TomegaPrint : TOMEGAPRINT(*! sharing TomegaPrint.IntSyn = IntSyn\' !*) (*! sharing TomegaPrint.Tomega = Tomega\' !*) TomegaPrintFormatterFormatter\') : STATEPRINT = struct module Formatter = Formatter\' (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module State = State\' exception Error of string module I = IntSynmodule T = Tomegamodule S = State\'module N = Namesmodule Fmt = Formatter(*\n    fun nameCtx I.Null = I.Null\n      | nameCtx (I.Decl (Psi, T.UDec D)) =\n          I.Decl (nameCtx Psi,\n                  T.UDec (Names.decName (T.coerceCtx Psi, D)))\n      | nameCtx (I.Decl (Psi, T.PDec (_, F, TC))) =\n          I.Decl (nameCtx Psi,\n                  T.PDec (SOME "s", F, TC))   (* to be fixed! --cs *)\n\n*) let rec nameCtx Psi  = Psi (* nameState S = S\'\n\n       Invariant:\n       If   |- S state     and S unnamed\n       then |- S\' State    and S\' named\n       and  |- S = S\' state\n    *) let rec nameState (S)  = S (*\n    fun formatOrder (G, S.Arg (Us, Vs)) =\n          [Print.formatExp (G, I.EClo Us), Fmt.String ":",\n           Print.formatExp (G, I.EClo Vs)]\n      | formatOrder (G, S.Lex Os) =\n          [Fmt.String "{", Fmt.HVbox0 1 0 1 (formatOrders (G, Os)), Fmt.String "}"]\n      | formatOrder (G, S.Simul Os) =\n          [Fmt.String "[", Fmt.HVbox0 1 0 1 (formatOrders (G, Os)), Fmt.String "]"]\n\n    and formatOrders (G, nil) = nil\n      | formatOrders (G, O :: nil) = formatOrder (G, O)\n      | formatOrders (G, O :: Os) = formatOrder (G, O) @\n          [Fmt.String ",", Fmt.Break]  @ formatOrders (G, Os)\n\n    (* format T = fmt\'\n\n       Invariant:\n       If   T is a tag\n       then fmt\' is a a format descibing the tag T\n    *)\n    fun formatTag (G, S.Parameter l) = [Fmt.String "<p>"]\n      | formatTag (G, S.Lemma (S.Splits k)) = [Fmt.String "<i",\n                                                 Fmt.String (Int.toString k),\n                                                 Fmt.String ">"]\n      | formatTag (G, S.Lemma (S.RL)) = [Fmt.String "<i >"]\n      | formatTag (G, S.Lemma (S.RLdone)) = [Fmt.String "<i*>"]\n(*      | formatTag (G, S.Assumption k) = [Fmt.String "<a",\n                                         Fmt.String (Int.toString k),\n                                         Fmt.String ">"] *)\n\n*) (* formatCtx (Psi) = fmt\'\n\n       Invariant:\n       If   |- Psi ctx       and Psi is already named\n       then fmt\' is a format describing the context Psi\n    *) let rec formatCtx (Null)  = [] | formatCtx (Decl (Null, UDec D))  = if ! chatter >= 4 then [HVbox ([Break; formatDec (Null, D)])] else [formatDec (Null, D)] | formatCtx (Decl (Null, PDec (SOME s, F, _)))  = if ! chatter >= 4 then [HVbox ([Break; String s; Space; String "::"; Space; formatFor (Null, F)])] else [String s; Space; String "::"; Space; formatFor (Null, F)] | formatCtx (Decl (Psi, UDec D))  = let G = coerceCtx Psi in if ! chatter >= 4 then formatCtx Psi @ [String ","; Break; Break] @ [HVbox ([Break; formatDec (G, D)])] else formatCtx Psi @ [String ","; Break] @ [Break; formatDec (G, D)] | formatCtx (Decl (Psi, PDec (SOME s, F, _)))  = if ! chatter >= 4 then formatCtx Psi @ [String ","; Break; Break] @ [HVbox ([Break; String s; Space; String "::"; Space; formatFor (Psi, F)])] else formatCtx Psi @ [String ","; Break] @ [Break; String s; Space; String "::"; Space; formatFor (Psi, F)] (* formatState S = fmt\'\n\n       Invariant:\n       If   |- S state      and  S named\n       then fmt\' is a format describing the state S\n    *) let rec formatState (State (W, Psi, P, F, _))  = Vbox0 0 1 [String "------------------------"; Break; String "------------------------"; Break; formatPrg (Psi, P)] (* formatState S = S\'\n\n       Invariant:\n       If   |- S state      and  S named\n       then S\' is a string descring state S in plain text\n    *) let rec stateToString S  = (makestring_fmt (formatState S)) let nameState = nameState let formatState = formatState let stateToString = stateToString  (* local *)  end(* functor MTPrint *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: module Names = Names(struct module Global = Global module Constraints = Constraints module HashTable = StringHashTable module StringTree = StringRedBlackTree end)

('Error parsing code:', '(* Names of Constants and Variables *) (* Author: Frank Pfenning *) (* Modified: Jeff Polakow *) module type FIXITY = sig type associativityLeftRightNonetype precedenceStrengthintval maxPrec : precedenceval minPrec : precedenceval less : precedence * precedence -> boolval leq : precedence * precedence -> boolval compare : precedence * precedence -> orderval inc : precedence -> precedenceval dec : precedence -> precedencetype fixityNonfixInfixprecedence * associativityPrefixprecedencePostfixprecedenceval prec : fixity -> precedenceval toString : fixity -> string(* returns integer for precedence such that lower values correspond to higher precedence, useful for exports *) val precToIntAsc : fixity -> int end\n(* signature FIXITY *) module type NAMES = sig (*! structure IntSyn : INTSYN !*) exception Error of stringexception Unprintablemodule Fixity : FIXITY(* Constant names and fixities *) type QidQidstring list * stringval qidToString : Qid -> stringval stringToQid : string -> Qid optionval unqualified : Qid -> string optiontype namespaceval newNamespace : unit -> namespaceval insertConst : namespace * cid -> unit(* shadowing disallowed *) val insertStruct : namespace * mid -> unit(* shadowing disallowed *) val appConsts : (string * cid -> unit) -> namespace -> unitval appStructs : (string * mid -> unit) -> namespace -> unitval reset : unit -> unitval resetFrom : cid * mid -> unit(* The following functions have to do with the mapping from names\n     to cids/mids only. *) val installConstName : cid -> unitval installStructName : mid -> unitval constLookup : Qid -> cid optionval structLookup : Qid -> mid optionval constUndef : Qid -> Qid option(* shortest undefined prefix of Qid *) val structUndef : Qid -> Qid optionval constLookupIn : namespace * Qid -> cid optionval structLookupIn : namespace * Qid -> mid optionval constUndefIn : namespace * Qid -> Qid optionval structUndefIn : namespace * Qid -> Qid option(* This function maps cids/mids to names.  It uses the information in\n     the IntSyn.ConDec or IntSyn.StrDec entries only, and only considers\n     the name->cid/mid mapping defined above in order to tell whether a\n     name is shadowed (any constant or structure whose canonical name\n     would map to something else, or to nothing at all, in the case of\n     an anonymous structure, is shadowed). *) val conDecQid : ConDec -> Qidval constQid : cid -> Qid(* will mark if shadowed *) val structQid : mid -> Qid(* will mark if shadowed *) val installFixity : cid * fixity -> unitval getFixity : cid -> fixityval fixityLookup : Qid -> fixity(* Nonfix if undefined *) (* Name preferences for anonymous variables: a, EPref, UPref *) val installNamePref : cid * (string list * string list) -> unitval getNamePref : cid -> string list * string list optionval installComponents : mid * namespace -> unitval getComponents : mid -> namespace(* EVar and BVar name choices *) val varReset : dctx -> unit(* context in which EVars are created *) val addEVar : Exp * string -> unit(* assumes name not already used *) val getEVarOpt : string -> Exp option(* NONE, if undefined or not EVar *) val evarName : dctx * Exp -> string(* create, if undefined *) val bvarName : dctx * int -> string(* raises Unprintable if undefined *) val decName : dctx * Dec -> Dec(* status unknown, like decEName *) val decEName : dctx * Dec -> Dec(* assign existential name *) val decUName : dctx * Dec -> Dec(* assign universal name *) val decLUName : dctx * Dec -> Dec(* assign local universal name *) val ctxName : dctx -> dctx(* assign global existential names *) val ctxLUName : dctx -> dctx(* assign local universal names *) val nameConDec : ConDec -> ConDec(* Skolem constants *) val skonstName : string -> string(* Named EVars, used for queries *) val namedEVars : unit -> Exp * string list(* Uninstantiated named EVars with constraints *) val evarCnstr : unit -> Exp * string list end\n(* signature NAMES *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module Names = Names(struct module Global = Global module Constraints = Constraints module HashTable = StringHashTable module StringTree = StringRedBlackTree end)

('Error parsing code:', "(* Delphin Front End Interface *) (* Author: Carsten Schuermann *) module DextSynDEXTSYN = DextSyn(struct module Stream' = Stream module ParseTerm' = ParseTerm module ExtSyn' = ParseTermExtSyn module Parsing' = Parsing module Lexer' = Lexer end)\nmodule DelphinLrValsDelphin_LRVALS = DelphinLrValsFun(struct module Token = LrParserToken module DextSyn' = DextSyn module Stream = Stream module Lexer' = Lexer module Parsing' = Parsing end)\nmodule InterfaceINTERFACE = Interface()\nmodule DelphinLexLEXERR = DelphinLexFun(struct module Tokens = DelphinLrValsTokens module Interface = Interface module Lexer = Lexer end)\nmodule DelphinParserPARSERR = Join(struct module ParserData = DelphinLrValsParserData module Lex = DelphinLex module LrParser = LrParser end)\nmodule ParsePARSE = Parse(struct module DextSyn = DextSyn module Interface = Interface module Parserr = DelphinParser module Tokens = DelphinLrValsTokens end)\nmodule TransTRANS = Trans(module DextSyn' = DextSyn)module Delphin = Delphin(struct module Twelf = Twelf module Parse = Parse module DextSyn = DextSyn module Trans = Trans module Parser = Parser end)\n(*\nstructure Tomega =\n  Tomega (structure IntSyn' = IntSyn\n\t  structure Whnf = Whnf\n\t  structure Conv = Conv);\n\nstructure Normalize =\n  Normalize (structure Tomega' = Tomega);\n*) (*structure Opsem =\n  Opsem (structure Tomega' = Tomega\n\t structure Unify = UnifyTrail\n\t structure Normalize = Normalize);\n*) ", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Delphin Frontend *) (* Author: Carsten Schuermann *) module type DELPHIN = sig val version : stringval loadFile : string * string -> unitval top : unit -> unitval runSimpleTest : string -> (string list) -> string list -> unitval eval : Prg -> Prg end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Delphin external syntax *) module type DEXTSYN = sig (* structure Lexer : LEXER *) type AstAstDecs and DecsEmptyFunDeclFunDecl * DecsFormDeclFormDecl * DecsValDeclValDecl * DecsNewDeclDec * DecsTwelfDeclDec * DecsCreateDeclCreateDecl * Decs and CreateDeclCreateTerm * CreateDeclDecsDecs and FormDeclFormstring * Form and FunDeclFunHead * ProgBarHead * ProgFunAndHead * Prog and ValDeclValPat * Prog * Form option and WorldWorldIdentstringPlusWorld * WorldConcatWorld * WorldTimesWorld and FormTrueForallDec * FormForallOmittedDec * FormExistsDec * FormExistsOmittedDec * FormAndForm * FormWorldWorld * Form and ProgUnitPairProg * ProgAppProgProg * ProgAppTermProg * TermInxTerm * ProgLamDec * ProgConststringCasePat list * Prog listLetDecs * ProgParProg * ProgNewDec list * ProgChooseDec * Prog and CasesFirstPat * ProgAltCases * Pat * Prog and HeadHeadstringAppLFHead * TermAppMetaHead * Pat and PatPatInxTerm * PatPatPairPat * PatPatVarMDecPatUnderscorePatUnit and MDecMDecstring * (Form option) and BlockBlockstring list and TermRtarrowTerm * TermLtarrowTerm * TermTypeIdstringPiDec * TermFnDec * TermAppTerm * TermDotTerm * stringParenTermOmitOfTerm * Term and DecDecstring * Term end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Delphin external syntax *) (* Author: Richard Fontana *) module DextSyn ((* structure Stream' : STREAM *) module ExtSyn' : EXTSYNmodule Parsing' : PARSING(*                    sharing Parsing'.Lexer.Paths = ExtSyn'.Paths  *) (*                  structure Lexer' : LEXER *) (*                    sharing Lexer' = Parsing'.Lexer *) ) : DEXTSYN = struct (*  structure Stream = Stream' *)  module ExtSyn = ExtSyn' module Parsing = Parsing' (*  structure Paths = ExtSyn.Paths\n  structure Lexer = Lexer' *)  module L = Lexer (*  structure S = Parsing'.Lexer.Stream *)  module S = Stream type Ast = Ast of Decs and Decs = Empty | FunDecl of FunDecl * Decs | FormDecl of FormDecl * Decs | ValDecl of ValDecl * Decs | NewDecl of Dec * Decs | TwelfDecl of Dec * Decs | CreateDecl of CreateDecl * Decs and CreateDecl = Create of Term * CreateDecl | Decs of Decs and FormDecl = Form of string * Form and FunDecl = Fun of Head * Prog | Bar of Head * Prog | FunAnd of Head * Prog and ValDecl = Val of Pat * Prog * Form option and Cases = First of Pat * Prog | Alt of Cases * Pat * Prog and World = WorldIdent of string | Plus of World * World | Concat of World * World | Times of World and Form = True | Forall of Dec * Form | ForallOmitted of Dec * Form | Exists of Dec * Form | ExistsOmitted of Dec * Form | And of Form * Form | World of World * Form and Prog = Unit | Pair of Prog * Prog | AppProg of Prog * Prog | AppTerm of Prog * Term | Inx of Term * Prog | Lam of Dec * Prog | Par of Prog * Prog | Const of string | Case of Pat list * Prog list | Let of Decs * Prog | New of Dec list * Prog | Choose of Dec * Prog and Head = Head of string | AppLF of Head * Term | AppMeta of Head * Pat and Pat = PatInx of Term * Pat | PatPair of Pat * Pat | PatVar of MDec | PatUnderscore | PatUnit and MDec = MDec of string * (Form option) and Block = Block of string list and Term = Rtarrow of Term * Term | Ltarrow of Term * Term | Type | Id of string | Pi of Dec * Term | Fn of Dec * Term | App of Term * Term | Dot of Term * string | Paren of Term | Omit | Of of Term * Term and Dec = Dec of string * Term (*\nfun parseLFDecs (Ast dl) =\n  let val tf = OS.FileSys.tmpName ()\n      val tos = TextIO.openOut tf\n      fun parseLFDecs' [] = ()\n       |  parseLFDecs' ((LFConDec ld) ::ds) =\n           (TextIO.output(tos, ld);\n           parseLFDecs' ds)\n       |  parseLFDecs' (_ ::ds) = parseLFDecs' ds\n      val _ = parseLFDecs' dl\n      val _ = TextIO.closeOut tos\n      val _ = Twelf.loadFile tf\n      val _ = OS.FileSys.remove tf\n  in ()\n  end\n\n*) (*\n\nfun rulesToCase (Ast decs) =\n   let\n      fun rulesToCase' [] = []\n      |   rulesToCase' (ProgDec (Head (s,pts), prg) :: ds) =\n            let val cds = rulesToCase' ds\n            in\n               case cds of\n                  ProgDec (Head (s',_), Case ps) ::ds'' =>\n                     if s = s'\n                     then ProgDec (Head (s, []), Case ((pts,prg)::ps))::ds''\n                     else\n                         ProgDec (Head (s,[]), Case [(pts,prg)]):: cds\n                | _ => ProgDec (Head (s,[]), Case [(pts,prg)]):: cds\n             end\n      |   rulesToCase' (d::ds) =\n             let val cds = rulesToCase' ds\n             in\n                (d::cds)\n             end\n\n   in\n      Ast (rulesToCase' decs)\n   end\n\n\n (* Invariant:  all programs in ast have been put in case form *)\n  fun abstractProgs' [] = []\n    | abstractProgs' (ProgDec (Head (nm,e), cp)::ds) =\n         ProgDec (Head (nm,e), Rec (MDec (nm, NONE), cp))::\n                 (abstractProgs' ds)\n    | abstractProgs' (d::ds) = (d::(abstractProgs' ds))\n\n\n fun abstractProgs ast =\n      let\n          val ast' = rulesToCase ast\n          val (Ast decs) = ast'\n          val decs' = abstractProgs' decs\n      in (Ast decs')\n      end\n\n*) (*     val appendPats = appendPats\n     val parseLFDecs = parseLFDecs\n     val abstractProgs = abstractProgs\n*)  end(* functor DextSyn *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* The Parser *) (* Author: Richard Fontana *) module Parse (module DextSyn : DEXTSYNmodule Interface : INTERFACEmodule Parserr : PARSERRargargposposresultAstmodule Tokens : Delphin_TOKENStokentokensvaluesvalue) : PARSE = struct module DextSyn = DextSyn module Interface = Interface module Parserr = Parserr module Tokens = Tokens module Streamm = ParserrStreamm module Token = ParserrToken (* Given a lexer, invoke parser *)  let rec invoke lexstream  = parse (0, lexstream, error, nothing) (* Parse a named input file *)  let rec fparse fname  = let _ = init_line () let infile = openIn (fname) let lexer = makeLexer (fun _ -> inputLine97 infile) let empty = ! line let dummyEOF = EOF (empty, empty) let rec loop lexer  = let (result, lexer) = invoke lexer let (nextToken, lexer) = get lexer in if sameToken (nextToken, dummyEOF) then () else loop lexer; (* DextSyn.printAst result; *) (* Invoke the term parser on the Term nodes in the\n                 generated syntax tree *) (* DextSyn.termparse result; *) () in loop lexer let rec sparse ()  = let _ = init_line () let infile = openString (input stdIn) let lexer = makeLexer (fun _ -> inputLine97 infile) let empty = ! line let dummyEOF = EOF (empty, empty) let rec loop lexer  = let (result, lexer) = invoke lexer let (nextToken, lexer) = get lexer in if sameToken (nextToken, dummyEOF) then (* () *) result else loop lexer in loop lexer let rec gparse fname  = let _ = init_line () let infile = openIn (fname) let lexer = makeLexer (fun _ -> inputLine97 infile) let empty = ! line let dummyEOF = EOF (empty, empty) let rec loop lexer  = let (result, lexer) = invoke lexer let (nextToken, lexer) = get lexer in if sameToken (nextToken, dummyEOF) then (* () *) result else loop lexer(* DextSyn.printAst result; *) (* Invoke the term parser on the Term nodes in the\n                 generated syntax tree *) (* DextSyn.termparse result; *) (*   ()  *) in loop lexer end(* functor Parse *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Translator from Delphin external syntax to Delphin internal syntax *) (* Author:  Carsten Schuermann *) module Trans (module DextSyn\' : DEXTSYN)(* : TRANS *)  = struct module DextSyn = DextSyn\' module D = DextSyn\' module L = Lexer module I = IntSyn module LS = Stream module T = Tomega module TA = TomegaAbstract exception Error of string type Internal = Empty | Const of int * int | Type of int let maxCid = maxCid let internal = array (maxCid + 1, Empty) : Internal array (* Invariant   for each cid which has been internalize out of a block,\n       internal(cid) = Const(n, i), where n is the number of some variables and\n       i is the projection index\n       for each type family\n       internal(cid) = Type (cid\'), where cid\' is the orginial type family.\n    *) (* checkEOF f = r\n\n      Invariant:\n      If   f is the end of stream\n      then r is a region\n\n      Side effect: May raise Parsing.Error\n    *) let rec checkEOF (Cons ((EOF, r), s\'))  = r | checkEOF (Cons ((t, r), _))  = error (r, "Expected `}\', found " ^ toString t) (* Note that this message is inapplicable when we use\n            checkEOF in stringToterm --rf *) (* stringToDec s = dec\n\n       Invariant:\n       If   s is a string representing a declaration,\n       then dec is the result of parsing it\n       otherwise Parsing.error is raised.\n    *) let rec stringTodec s  = let f = expose (lexStream (openString s)) let ((x, yOpt), f\') = parseDec\' f let r2 = checkEOF f\' let dec = (match yOpt(* below use region arithmetic --cs !!!  *)  with NONE -> dec0 (x, r2) | SOME y -> dec (x, y, r2)) in dec let rec stringToblocks s  = let f = expose (lexStream (openString s)) let (dl, f\') = parseCtx\' f in dl (* stringToWorlds s = W\n\n       Invariant:\n       If   s is a string representing an expression,\n       then W is the result of parsing it\n       otherwise Parsing.error is raised.\n    *) let rec stringToWorlds s  = let f = expose (lexStream (openString s)) let (t, f\') = parseQualIds\' f let r2 = checkEOF f\' in t (* closure (G, V) = V\'\n\n       Invariant:\n       {G}V = V\'\n    *) let rec closure (Null, V)  = V | closure (Decl (G, D), V)  = closure (G, Pi ((D, Maybe), V)) (* internalizeBlock  (n, G, Vb, S) (L2, s) = ()\n\n       Invariant:\n       If   |- G ctx                the context of some variables\n       and  G |- Vb :  type         the type of the block\n       and  G |- L1, L2 decs\n       and  G1, L1 |- L2 decs       block declarations still to be traversed\n       and  G, b:Vb |- s : G1, L1\n       and  n is the current projection\n       then internalizeBlock adds new declarations into the signature that\n              correspond to the block declarations.\n    *) let rec internalizeBlock _ (nil, _)  = () | internalizeBlock (n, G, Vb, S) (Dec (SOME name, V) :: L2, s)  = (* G, B |- V\' : type *) (* G |- {B} V\' : type *) let name\' = "o_" ^ name let V1 = EClo (V, s) let V2 = Pi ((Dec (NONE, Vb), Maybe), V1) let V3 = closure (G, V2) let m = ctxLength G let condec = ConDec (name\', NONE, m, Normal, V3, Type) let _ = check (V3, Uni Type) let _ = if ! chatter >= 4 then print (conDecToString condec ^ "\\n") else () let cid = sgnAdd condec let _ = installConstName cid let _ = update (internal, cid, Const (m, n)) in internalizeBlock (n + 1, G, Vb, S) (L2, Dot (Exp (Root (Const cid, S)), s)) (* makeSpine (n, G, S) = S\'\n\n       Invariant:\n       If  G0 = G, G\'\n       and |G\'| = n\n       and G0 |- S : V >> V\'   for some V, V\'\n       then S\' extends S\n       and G0 |- S\' : V >> type.\n    *) let rec makeSpine (_, Null, S)  = S | makeSpine (n, Decl (G, D), S)  = makeSpine (n + 1, G, App (Root (BVar (n + 1), Nil), S)) (* interalizeCondec condec = ()\n\n       Invariant:\n       If   condec is a condec,\n       then all pi declarations are internalized if condec was a blockdec\n    *) let rec internalizeCondec (cid, ConDec _)  = () | internalizeCondec (cid, ConDef _)  = () | internalizeCondec (cid, AbbrevDef _)  = () | internalizeCondec (cid, BlockDec (name, _, Gsome, Lpi))  = let V\' = closure (Gsome, Uni Type) let C = ConDec (name ^ "\'", NONE, 0, Normal, V\', Kind) let a = sgnAdd C let _ = update (internal, a, Type cid) let _ = installConstName a let S = makeSpine (0, Gsome, Nil) let Vb = Root (Const a, S) let S\' = makeSpine (0, Decl (Gsome, Dec (NONE, Vb)), Nil) in internalizeBlock (1, Gsome, Vb, S\') (Lpi, shift) | internalizeCondec (cid, SkoDec _)  = () (* sigToCtx () = ()\n\n       Invariant:\n       G is the internal representation of the global signature\n       It converts every block declaration to a type family (stored in the global\n       signature) and a list of declarations.\n    *) let rec internalizeSig ()  = (* we might want to save max, here to restore the original\n                 signature after parsing is over  --cs Thu Apr 17 09:46:29 2003 *) let (max, _) = sgnSize () let rec internalizeSig\' n  = if n >= max then () else (internalizeCondec (n, sgnLookup n); internalizeSig\' (n + 1)) in internalizeSig\' 0 (* Externalization *) let rec dropSpine (0, S)  = S | dropSpine (n, App (_, S))  = dropSpine (n - 1, S) let rec makeSub (Nil, s)  = s | makeSub (App (U, S), s)  = makeSub (S, Dot (Exp U, s)) let rec externalizeExp\' (U as Uni _)  = U | externalizeExp\' (Pi ((D, DP), U))  = Pi ((externalizeDec D, DP), externalizeExp U) | externalizeExp\' (Root (H as BVar _, S))  = Root (H, externalizeSpine S) | externalizeExp\' (Root (H as Const c, S))  = (match constUni c with Kind -> Root (H, externalizeSpine S) | Type -> let Const (n, i) = sub (internal, c) let (App (Root (BVar b, Nil), S\')) = dropSpine (n, S) in Root (Proj (Bidx b, i), externalizeSpine S\')) | externalizeExp\' (Root (Proj _, _))  = raise (Domain) | externalizeExp\' (Root (Skonst _, _))  = raise (Domain) | externalizeExp\' (Root (Def _, _))  = raise (Domain) | externalizeExp\' (Root (NSDef _, _))  = raise (Domain) | externalizeExp\' (Root (FVar _, _))  = raise (Domain) | externalizeExp\' (Root (FgnConst _, _))  = raise (Domain) | externalizeExp\' (Redex (U, S))  = Redex (externalizeExp U, externalizeSpine S) | externalizeExp\' (Lam (D, U))  = Lam (externalizeDec D, externalizeExp U)externalizeExp (U)  = externalizeExp\' (normalize (U, id))(* Check : the translators hould only generate normal forms. Fix during the next pass --cs Thu Apr 17 17:06:24 2003 *) externalizeBlock (B as Bidx _)  = BexternalizeDec (Dec (name, V))  = Dec (name, externalizeExp V)externalizeSpine Nil  = Nil | externalizeSpine (App (U, S))  = App (externalizeExp U, externalizeSpine S)externalizeSub (s as Shift n)  = s | externalizeSub (Dot (F, s))  = Dot (externalizeFront F, externalizeSub s)externalizeFront (F as Idx _)  = F | externalizeFront (Exp U)  = Exp (externalizeExp U) | externalizeFront (Block B)  = Block (externalizeBlock B) | externalizeFront (F as Undef)  = F let rec externalizePrg (n, Lam (D, P))  = Lam (externalizeMDec (n, D), externalizePrg (n + 1, P)) | externalizePrg (n, New P)  = New (externalizePrg (n, P)) | externalizePrg (n, Box (W, P))  = Box (W, externalizePrg (n, P)) | externalizePrg (n, Choose P)  = Choose (externalizePrg (n, P)) | externalizePrg (n, PairExp (U, P))  = PairExp (externalizeExp U, externalizePrg (n, P)) | externalizePrg (n, PairPrg (P1, P2))  = PairPrg (externalizePrg (n, P1), externalizePrg (n, P2)) | externalizePrg (n, PairBlock (B, P))  = PairBlock (externalizeBlock B, externalizePrg (n, P)) | externalizePrg (n, Unit)  = Unit | externalizePrg (n, Var k)  = Var k | externalizePrg (n, Const c)  = Const c | externalizePrg (n, Redex (P, S))  = Redex (externalizePrg (n, P), externalizeMSpine (n, S)) | externalizePrg (n, Rec (D, P))  = Rec (externalizeMDec (n, D), externalizePrg (n + 1, P)) | externalizePrg (n, Case (Cases O))  = Case (Cases (externalizeCases O)) | externalizePrg (n, Let (D, P1, P2))  = Let (externalizeMDec (n, D), externalizePrg (n, P1), externalizePrg (n + 1, P2))(* PClo should not be possible, since by invariant, parser\n         always generates a program in normal form  --cs Thu Apr 17 16:56:07 2003\n      *) externalizeMDec (n, UDec (D as Dec (name, V as Root (Const a, S))))  = (match sub (internal, a) with Type (a\') -> UDec (BDec (name, (a\', makeSub (externalizeSpine S, Shift n)))) | _ -> UDec (externalizeDec D)) | externalizeMDec (n, UDec D)  = UDec (externalizeDec D) | externalizeMDec (n, PDec (s, F))  = PDec (s, externalizeFor (n, F))externalizeFor (n, World (W, F))  = World (W, externalizeFor (n, F)) | externalizeFor (n, All ((D, Q), F))  = All ((externalizeMDec (n, D), Q), externalizeFor (n + 1, F)) | externalizeFor (n, Ex ((D, Q), F))  = Ex ((externalizeDec D, Q), externalizeFor (n + 1, F)) | externalizeFor (n, True)  = True | externalizeFor (n, And (F1, F2))  = And (externalizeFor (n, F1), externalizeFor (n, F2))externalizeMSpine (n, Nil)  = Nil | externalizeMSpine (n, AppExp (U, S))  = AppExp (externalizeExp U, externalizeMSpine (n, S)) | externalizeMSpine (n, AppBlock (B, S))  = AppBlock (externalizeBlock B, externalizeMSpine (n, S)) | externalizeMSpine (n, AppPrg (P, S))  = AppPrg (externalizePrg (n, P), externalizeMSpine (n, S))externalizeCases nil  = nil | externalizeCases ((Psi, t, P) :: O)  = let n = ctxLength Psi in (externalizeMCtx Psi, externalizeMSub (n, t), externalizePrg (n, P)) :: externalizeCases OexternalizeMSub (n, t as (Shift _))  = t | externalizeMSub (n, Dot (F, t))  = Dot (externalizeMFront (n, F), externalizeMSub (n, t))externalizeMFront (n, F as (Idx _))  = F | externalizeMFront (n, Prg P)  = Prg (externalizePrg (n, P)) | externalizeMFront (n, Exp U)  = Exp (externalizeExp U) | externalizeMFront (n, Block B)  = Block (externalizeBlock B) | externalizeMFront (n, F as Undef)  = FexternalizeMCtx Null  = Null | externalizeMCtx (Decl (Psi, D))  = Decl (externalizeMCtx Psi, externalizeMDec (ctxLength Psi, D)) (* Translation starts here *) let rec transTerm (Rtarrow (t1, t2))  = let (s1, c1) = transTerm t1 let (s2, c2) = transTerm t2 in (s1 ^ " -> " ^ s2, c1 @ c2) | transTerm (Ltarrow (t1, t2))  = let (s1, c1) = transTerm t1 let (s2, c2) = transTerm t2 in (s1 ^ " <- " ^ s2, c1 @ c2) | transTerm (Type)  = ("type", nil) | transTerm (Id s)  = let qid = Qid (nil, s) in match constLookup qid with NONE -> (s, nil) | SOME cid -> (match (sgnLookup cid) with BlockDec _ -> (s ^ "\'", nil) | _ -> (s, nil)) | transTerm (Pi (D, t))  = let (s1, c1) = transDec D let (s2, c2) = transTerm t in ("{" ^ s1 ^ "}" ^ s2, c1 @ c2) | transTerm (Fn (D, t))  = let (s1, c1) = transDec D let (s2, c2) = transTerm t in ("[" ^ s1 ^ "]" ^ s2, c1 @ c2) | transTerm (App (t1, t2))  = let (s1, c1) = transTerm t1 let (s2, c2) = transTerm t2 in (s1 ^ " " ^ s2, c1 @ c2) | transTerm (Omit)  = ("_", nil) | transTerm (Paren (t))  = let (s, c) = transTerm t in ("(" ^ s ^ ")", c) | transTerm (Of (t1, t2))  = let (s1, c1) = transTerm t1 let (s2, c2) = transTerm t2 in (s1 ^ ":" ^ s2, c1 @ c2) | transTerm (Dot (t, s2))  = let (s1, c1) = transTerm t in ("o_" ^ s2 ^ " " ^ s1, c1)(*      | transTerm (D.Dot (D.Id s1, s2)) =\n        ("PROJ#" ^ s1 ^ "#" ^ s2, nil)\n      | transTerm (D.Dot (D.Paren (D.Of (D.Id s1, t)), s2)) =\n        ("PROJ#" ^ s1 ^ "#" ^ s2, [(s1, t)])\n*) transDec (Dec (s, t))  = let (s\', c) = transTerm t in (s ^ ":" ^ s\', c) let rec transWorld (WorldIdent s)  = (* We should use the worlds we have defined in Tomega, but this\n              is not good enough, because worlds are not defined\n              by a regualar expression.  Therefore this is a patch *)  let qid = Qid (nil, s) let cid = (match constLookup qid with NONE -> raise (Error ("Undeclared label " ^ qidToString (valOf (constUndef qid)) ^ ".")) | SOME cid -> cid) in [cid] | transWorld (Plus (W1, W2))  = transWorld W1 @ transWorld W2 | transWorld (Concat (W1, W2))  = transWorld W1 @ transWorld W2 | transWorld (Times W)  = transWorld W let rec transFor\' (Psi, D)  = let G = Decl (Null, D) let JWithCtx (Decl (Null, D\'), JNothing) = reconWithCtx (Psi, jwithctx (G, jnothing)) in D\' (* transFor (ExtDctx, ExtF) = (Psi, F)\n\n       Invariant:\n       If   |- ExtDPsi extdecctx\n       and  |- ExtF extfor\n       then |- Psi <= ExtDPsi\n       and  Psi |- F <= ExtF\n    *) let rec transFor (Psi, True)  = True | transFor (Psi, And (EF1, EF2))  = And (transFor (Psi, EF1), transFor (Psi, EF2)) | transFor (Psi, Forall (D, F))  = let (D\'\', nil) = transDec D let D\' = transFor\' (Psi, stringTodec (D\'\')) in All ((UDec D\', Explicit), transFor (Decl (Psi, D\'), F)) | transFor (Psi, Exists (D, F))  = let (D\'\', nil) = transDec D let D\' = transFor\' (Psi, stringTodec (D\'\')) in Ex ((D\', Explicit), transFor (Decl (Psi, D\'), F)) | transFor (Psi, ForallOmitted (D, F))  = let (D\'\', nil) = transDec D let D\' = transFor\' (Psi, stringTodec (D\'\')) in All ((UDec D\', Implicit), transFor (Decl (Psi, D\'), F)) | transFor (Psi, ExistsOmitted (D, F))  = let (D\'\', nil) = transDec D let D\' = transFor\' (Psi, stringTodec (D\'\')) in Ex ((D\', Implicit), transFor (Decl (Psi, D\'), F)) | transFor (Psi, World (W, EF))  = World (Worlds (transWorld W), transFor (Psi, EF)) (* stringToTerm s = U\n\n       Invariant:\n       If   s is a string representing an expression,\n       then U is the result of parsing it\n       otherwise Parsing.error is raised.\n    *) let rec stringToterm s  = let f = expose (lexStream (openString s)) let (t, f\') = parseTerm\' f let r2 = checkEOF f\' in t (* head (dH) = n\n\n       Invariant:\n       n is the name of the function head dH\n    *) let rec head (Head s)  = s | head (AppLF (H, _))  = head H | head (AppMeta (H, _))  = head H (* lamClosure (F, P) = P\'\n\n       Invariant:\n       If   . |- F formula\n       and  . |- F = all D1. ... all Dn. F\' formula\n         for  . |- F\' formula that does not commence with a universal quantifier\n       and . |- P :: F\'\n       then P\' = lam D1 ... lam Dn P\n    *) let rec lamClosure (All ((D, _), F), P)  = Lam (D, lamClosure (F, P)) | lamClosure (World (_, F), P)  = lamClosure (F, P) | lamClosure (Ex _, P)  = P let rec exists (c, [])  = raise (Error "Current world is not subsumed") | exists (c, c\' :: cids)  = if c = c\' then () else exists (c, cids) let rec subsumed ([], cids\')  = () | subsumed (c :: cids, cids\')  = (exists (c, cids\'); subsumed (cids, cids\')) let rec checkForWorld (World (W as Worlds cids, F), t\', Worlds cids\')  = (* check that W is at least as large as W\' *) let _ = subsumed (cids\', cids) in (F, t\', W) | checkForWorld FtW  = FtW (* dotn (t, n) = t\'\n\n       Invariant:\n       If   Psi0 |- t : Psi\n       and  |G| = n   for any G\n       then Psi0, G[t] |- t : Psi, G\n    *) let rec dotn (t, 0)  = t | dotn (t, n)  = dot1 (dotn (t, n - 1)) (* append (Psi1, Psi2) = Psi3\n\n       Invariant:\n       If   |- Psi1 ctx\n       and  |- Psi2 ctx\n       then |- Psi3 = Psi1, Psi2 ctx\n    *) let rec append (Psi, Null)  = Psi | append (Psi, Decl (Psi\', D))  = Decl (append (Psi, Psi\'), D) let rec parseTerm (Psi, (s, V))  = let (term\', c) = transTerm s let term = stringToterm (term\') let JOf ((U, occ), (_, _), L) = reconWithCtx (coerceCtx Psi, jof\' (term, V)) in U let rec parseDec (Psi, s)  = let (dec\', c) = transDec s let dec = stringTodec (dec\') let JWithCtx (Decl (Null, D), JNothing) = reconWithCtx (coerceCtx Psi, jwithctx (Decl (Null, dec), jnothing)) let Dec (SOME n, _) = D in D (* transDecs ((Psi, t), dDs, sc, W) = x\n\n       Invariant:\n       If   . |- t :: Psi\n       and  Psi |- dDs decs\n       and  W is the valid world\n       and  sc is the success continuation that expects\n            as input: (Psi\', env\')\n                      where Psi\' is the context after translating dDs\n                      and   Psi\' |- env\' environment\n                            are all variables introduced until this point\n            as output: anything.\n       then eventually x = ().     --cs\n    *) let rec transDecs (Psi, Empty, sc, W)  = sc (Psi, W) | transDecs (Psi, FormDecl (FormD, Ds), sc, W)  = (transForDec (Psi, FormD, Ds, sc, W)) | transDecs (Psi, ValDecl (ValD, Ds), sc, W)  = (transValDec (Psi, ValD, Ds, sc, W)) | transDecs (Psi, NewDecl (D, Ds), sc, W)  = let D\' = UDec (parseDec (Psi, D)) in (*          T.Let (T.PDec (NONE, T.True), T.Lam (D\', transDecs (I.Decl (Psi, D\'), Ds, sc, W)), T.Unit) *) Let (PDec (NONE, True), Lam (D\', transDecs (Decl (Psi, D\'), Ds, sc, W)), Var 1)(* T.True is not right! -- cs Sat Jun 28 11:43:30 2003  *) | transDecs _  = raise (Error "Constant declaration must be followed by a constant definition")lookup (Null, n, s)  = raise (Error ("Undeclared constant " ^ s)) | lookup (Decl (G, PDec (NONE, _)), n, s)  = lookup (G, n + 1, s) | lookup (Decl (G, UDec _), n, s)  = lookup (G, n + 1, s) | lookup (Decl (G, PDec (SOME s\', F)), n, s)  = if s = s\' then (n, forSub (F, Shift n)) else lookup (G, n + 1, s)(* transHead (G, T, S) = (F\', t\')\n\n       Invariant:\n       If   G |- T : F\n       and  G |- S : world{W}all{G\'}F\' >> F\'\n       then G |- t\' : G\'\n    *) transHead (Psi, Head s, args)  = let (n, F) = lookup (Psi, 1, s) in transHead\' ((F, id), Nil, args) | transHead (Psi, AppLF (h, t), args)  = transHead (Psi, h, t :: args)transHead\' ((World (_, F), s), S, args)  = transHead\' ((F, s), S, args) | transHead\' ((All ((UDec (Dec (_, V)), Implicit), F\'), s), S, args)  = let X = newEVar (Decl (Null, NDec), EClo (V, coerceSub s)) in transHead\' ((F\', Dot (Exp X, s)), App (X, S), args) | transHead\' ((All ((UDec (Dec (_, V)), Explicit), F\'), s), S, t :: args)  = let (term\', c) = transTerm t let term = stringToterm (term\') let JOf ((U, occ), (_, _), L) = reconWithCtx (Null, jof\' (term, EClo (V, coerceSub s))) in transHead\' ((F\', Dot (Exp U, s)), App (U, S), args) | transHead\' ((F, s), S, nil)  = ((F, s), S)(* spineToSub ((S, t), s) = s\'\n\n       Invariant:\n       If  Psi\' |- S spine\n       and Psi\'\' |- t: Psi\'\n       and Psi\'\' |- s : Psi\'\'\'\n       then  Psi\'\' |- s\' : Psi\'\'\', Psi\'\'\'\'\n    *) spineToSub ((Nil, _), s\')  = s\' | spineToSub ((App (U, S), t), s\')  = Dot (Exp (EClo (U, t)), spineToSub ((S, t), s\'))transPattern (p, (Ex ((Dec (_, V), Implicit), F\'), s))  = transPattern (p, (F\', Dot (Exp (EVar (ref NONE, Null, EClo (V, coerceSub s), ref nil)), s))) | transPattern (PatInx (t, p), (Ex ((Dec (_, V), Explicit), F\'), s))  = let (term\', c) = transTerm t let term = stringToterm (term\') let JOf ((U, occ), (_, _), L) = reconWithCtx (Null, jof\' (term, EClo (V, coerceSub s))) in PairExp (U, transPattern (p, (F\', Dot (Exp U, s)))) | transPattern (PatUnit, (F, s))  = Unit(* other cases should be impossible by invariant\n                                         F should be F.True\n                                         --cs Sun Mar 23 10:38:57 2003 *) (* transFun1 ((Psi, env), dDs, sc, W) = x\n\n       Invariant:\n       If   Psi |- dDs :: Psi\'\n       and  Psi |- env environment\n       and  the top declaration is a function declaration\n       and  W is the valid world\n       and  sc is the success continuation that expects\n            as input: (Psi\', env\')\n                      where Psi\' is the context after translating dDs\n                      and   Psi\' |- env\' environment\n                            are all variables introduced until this point\n            as output: anything.\n       then eventually x = ().     --cs\n    *) transFun1 (Psi, (s\', F), FunDecl (Fun (eH, eP), Ds), sc, W)  = let s = head eH let _ = if s = s\' then () else raise (Error "Function defined is different from function declared.") in transFun2 (Psi, (s, F), FunDecl (Bar (eH, eP), Ds), sc, fun Cs -> Case (Cases Cs), W) | transFun1 (Psi, (s\', F), FunDecl (FunAnd (eH, eP), Ds), sc, W)  = raise (Error "Mutual recursive functions not yet implemented") | transFun1 _  = raise (Error "Function declaration expected")(* transFun2 ((Psi, env), s, dDs, sc, k, W) = x\n\n       Invariant:\n       If   Psi |- dDs :: Psi\'\n       and  Psi |- env environment\n       and  s is the name of the function currently being translated\n       and  the top declaration is a function declaration\n       and  the top declaration is a function declaration\n       and  W is the valid world\n       and  sc is the success continuation that expects\n            as input: (Psi\', env\')\n                      where Psi\' is the context after translating dDs\n                      and   Psi\' |- env\' environment\n                            are all variables introduced until this point\n            as output: anything.\n       and  k is the continuation that expects\n            as input: Cs a list of cases\n            as ouput: A program P that corresponds to the case list Cs\n       then eventually x = ().     --cs\n    *) transFun2 (Psi, (s, F), FunDecl (Bar (eH, eP), Ds), sc, k, W)  = transFun3 (Psi, (s, F), eH, eP, Ds, sc, k, W) | transFun2 (Psi, (s, F), Ds, sc, k, W)  = let D = PDec (SOME s, F) let P\' = Rec (D, lamClosure (F, k nil)) in (P\', Ds)(* transFun3 ((Psi, env), s, eH, eP, Ds, sc, k, W) = x\n\n       Invariant:\n       If   Psi |- dDs :: Psi\'\n       and  Psi |- env environment\n       and  s is the name of the function currently being translated\n       and  eH is the head of the function\n       and  eP its body\n       and  W is the valid world\n       and  Ds are the remaining declarations\n       and  sc is the success continuation that expects\n            as input: (Psi\', env\')\n                      where Psi\' is the context after translating dDs\n                      and   Psi\' |- env\' environment\n                            are all variables introduced until this point\n            as output: anything.\n       and  k is the continuation that expects\n            as input: Cs a list of cases\n            as ouput: A program P that corresponds to the case list Cs\n       then eventually x = ().     --cs\n    *) transFun3 (Psi, (s, F), eH, eP, Ds, sc, k, W)  = (*                val F\' = T.forSub (F, t) *) (* |Psi\'\'| = m0 + m\' *) (* Psi0, Psi\'[^m0] |- t0 : Psi\' *) (*        val t1 = T.Dot (T.Prg (T.Root (T.Var (m\'+1), T.Nil)), T.Shift (m\'))   (* BUG !!!! Wed Jun 25 11:23:13 2003 *)\n                                        (* Psi0, Psi\'[^m0] |- t1 : F[^m0]  *)\n*) (*        val _ = print (TomegaPrint.forToString (Names.ctxName (T.coerceCtx Psi\'\'), myF) ^ "\\n") *) let _ = if (head eH) <> s then raise (Error "Functions don\'t all have the same name") else () let _ = varReset (Null) let Psi0 = Decl (Psi, PDec (SOME s, F)) let ((F\', t\'), S) = transHead (Psi0, eH, nil) let (Psi\', S\') = abstractSpine (S, id) let Psi\'\' = append (Psi0, embedCtx Psi\') let m0 = ctxLength Psi0 let m\' = ctxLength Psi\' let t0 = dotn (Shift m0, m\') let t\'\' = spineToSub ((S\', t0), Shift m\') let P = transProgI (Psi\'\', eP, (F\', t\'), W) in transFun2 (Psi, (s, F), Ds, sc, fun Cs -> k ((Psi\'\', t\'\', P) :: Cs), W)(* transForDec ((Psi, env), eDf, dDs, sc, W) = x\n\n       Invariant:\n       If   Psi |- dDs :: Psi\'\n       and  Psi |- env environment\n       and  Psi |- eDf is a theorem declaration.\n       and  W is the valid world\n       and  dDs are the remaining declarations\n       and  sc is the success continuation that expects\n            as input: (Psi\', env\')\n                      where Psi\' is the context after translating dDs\n                      and   Psi\' |- env\' environment\n                            are all variables introduced until this point\n            as output: anything.\n       then eventually x = ().     --cs\n    *) transForDec (Psi, Form (s, eF), Ds, sc, W)  = (*        val _ = print s\n          val _ = print " :: "\n          val _ = print (TomegaPrint.forToString (T.embedCtx G, F\'\') ^ "\\n") *) let G = ctxName (coerceCtx Psi) let F = transFor (G, eF) let (F\'\' as World (W, F\')) = forSub (F, id) let _ = checkFor (Psi, F\'\') let (P, Ds\') = transFun1 (Psi, (s, F\'), Ds, sc, W) let D = PDec (SOME s, F\'\') in Let (D, Box (W, P), transDecs (Decl (Psi, D), Ds\', (fun P\' -> sc P\'), W))(* transValDec ((Psi, env), dDv, dDs, sc, W) = x\n\n       Invariant:\n       If   Psi |- dDs :: Psi\'\n       and  Psi |- env environment\n       and  Psi |- dDv value declaration\n       and  W is the valid world\n       and  dDs are the remaining declarations\n       and  sc is the success continuation that expects\n            as input: (Psi\', env\')\n                      where Psi\' is the context after translating dDs\n                      and   Psi\' |- env\' environment\n                            are all variables introduced until this point\n            as output: anything.\n       then eventually x = ().     --cs\n    *) transValDec (Psi, Val (EPat, eP, eFopt), Ds, sc, W)  = (*        val t = T.Dot (T.Prg Pat\', T.id)  was --cs Tue Jun 24 13:04:55 2003 *) let (P, (F\', t\')) = (match eFopt with NONE -> transProgS (Psi, eP, W, nil) | SOME eF -> let F\' = transFor (coerceCtx Psi, eF) let P\' = transProgIN (Psi, eP, F\', W) in (P\', (F\', id))) let F\'\' = forSub (F\', t\') let Pat = transPattern (EPat, (F\', t\')) let D = PDec (NONE, F\'\') let (Psi\', Pat\') = abstractTomegaPrg (Pat) let m = ctxLength Psi\' let t = Dot (Prg Pat\', Shift m) let Psi\'\' = append (Psi, Psi\') let P\'\' = transDecs (Psi\'\', Ds, sc, W) in Let (D, P, Case (Cases [(Psi\'\', t, P\'\')]))(* transProgS ((Psi, env), ExtP, F, W) = P\n       transProgI ((Psi, env), ExtP, W) = (P, F)\n       Invariant:\n       If   ExtP contains free variables among (Psi, env)\n       and  ExtP is a program defined in (Psi, env)\n       and  W is a world\n       and  Exists Psi |- F : formula\n       then Psi |- P :: F\n    *) transProgI (Psi, eP, Ft, W)  = transProgIN (Psi, eP, forSub Ft, W)transProgIN (Psi, Unit, True, W)  = Unit | transProgIN (Psi, P as Inx (s, EP), Ex ((Dec (_, V), Explicit), F\'), W)  = let U = parseTerm (Psi, (s, V)) let P\' = transProgI (Psi, EP, (F\', Dot (Exp U, id)), W) in PairExp (U, P\') | transProgIN (Psi, Let (eDs, eP), F, W)  = transDecs (Psi, eDs, fun (Psi\', W\') -> transProgI (Psi\', eP, (F, Shift (ctxLength Psi\' - ctxLength Psi)), W\'), W) | transProgIN (Psi, Choose (eD, eP), F, W)  = let D\' = parseDec (Psi, eD) let Psi\'\' = Decl (Psi, UDec D\') in Choose (Lam (UDec D\', transProgI (Psi\'\', eP, (F, Shift 1), W))) | transProgIN (Psi, New (nil, eP), F, W)  = transProgIN (Psi, eP, F, W) | transProgIN (Psi, New (eD :: eDs, eP), F, W)  = let D\' = parseDec (Psi, eD) let Psi\'\' = Decl (Psi, UDec D\') in New (Lam (UDec D\', transProgI (Psi\'\', New (eD :: eDs, eP), (F, Shift 1), W))) | transProgIN (Psi, P as AppTerm (EP, s), F, W)  = (* check that F == F\' *) let (P\', (F\', _)) = transProgS (Psi, P, W, nil) let () = () in P\'(*      | transProgIN ((Psi, env), D.Pair (EP1, EP2), T.And (F1, F2), W) =\n        let\n          val P1 = transProgIN ((Psi, env), EP1, F1, W)\n          val P2 = transProgIN ((Psi, env), EP2, F2, W)\n        in\n          T.PairPrg (P1, P2)\n        end\n      | transProgIN ((Psi, env), P as D.AppProg (EP1, EP2), F, W) =\n        let\n          val (P\', (F\', _)) = transProgS ((Psi, env), P, W)\n          val ()  = ()   (* check that F == F\' *)\n        in\n          P\'\n        end\n      | transProgIN ((Psi, env), P as D.AppTerm (EP, s), F, W) =\n        let\n          val (P\', (F\', _)) = transProgS ((Psi, env), P, W)\n          val ()  = ()   (* check that F == F\' *)\n        in\n          P\'\n        end\n      | transProgIN ((Psi, env), P as D.Inx (s, EP), T.Ex (I.Dec (_, V), F\'), W) =\n        let\n          val (U, V) = parseTerm ((Psi, env), s)\n          val P\' = transProgI ((Psi, env), EP, (F\', T.Dot (T.Exp U, T.id)), W)\n        in\n          T.PairExp (U, P\')\n        end\n      | transProgIN ((Psi, env), D.Const name, F, W) =\n        let\n          val lemma = T.lemmaName name\n          val F\' = T.lemmaFor lemma\n          val () = ()    (* check that F == F\' *)\n        in\n          T.Root (T.Const lemma, T.Nil)\n        end\n\n(*      | transProgIN (Psi, D.Lam (s, EP)) =\n        let\n          val dec = stringTodec s\n          val (I.Decl (Psi, (D, _, _)), P, F\') = transProgI (I.Decl (ePsi, dec), EP)\n        in\n          (Psi, T.Lam (T.UDec D, P), T.All (D, F\'))\n        end\n*)\n\n\n      | transProgIN ((Psi, env), D.New (s, EP), F, W) =\n          let\n            val G = Names.ctxName (T.coerceCtx Psi)\n            val _ = print (Print.ctxToString (I.Null, G) ^ "\\n")\n            val (U, V) = parseTerm ((Psi, env), s ^ " type")\n            val _ = print (Print.expToString (G, U) ^ "\\n")\n\n          fun extract (G, Us) = extractW (G, Whnf.whnf Us)\n          and extractW (G, (I.Pi ((D as I.Dec (_, _), _), V\'), s)) =\n                extract (I.Decl(G, I.decSub (D, s)), (V\', I.dot1 s))\n            | extractW (G, _) = G\n\n          val G\' = extract (I.Null, (U, I.id))\n          val Dlist = T.ctxToBDecs (T.coerceCtx Psi, G\', W)\n\n          fun project ((G, env), []) = (env, 1)   (* is this the right starting point --cs *)\n            | project ((G, env), x :: N) =\n              let\n                val (env\', k) = project ((G, env), N)\n                val U = I.Root (I.Proj (I.Bidx 1, k), I.Nil)\n                val V =  TypeCheck.infer\' (G, U)\n              in\n                ((U, V, x) :: env\', k+1)\n              end\n\n          fun extend ((Psi\', env\'), []) = (Psi\', env\')\n            | extend ((Psi\', env\'), (N, D) :: Dlist\') =\n              let\n                val (Psi\'\', env\'\') = extend ((Psi\', env\'),  Dlist\')\n                val Psi\'\'\' = I.Decl (Psi\'\', T.UDec D)\n                val I.BDec (_, (cid, s)) = D\n                val G\'\'\' = T.coerceCtx Psi\'\'\'\n                val env\'\'\' = map (fn (U, V, name) => (I.EClo (U, I.shift), I.EClo (V, I.shift), name)) env\'\'\n                val (env\'\'\'\', _) = project ((G\'\'\', env\'\'\'), N)\n              in\n                (Psi\'\'\',  env\'\'\'\')\n               end\n\n           val (Psi\', env\') = extend ((Psi, env), Dlist)\n           val _ = printCtx (Names.ctxName (T.coerceCtx Psi\'), env\')\n\n          fun universalClosure ([], F) = F\n            | universalClosure ((_, D) :: Ds, F)  = T.All (T.UDec D, universalClosure (Ds, F))\n\n          val (P\', (F, t)) = transProgS ((Psi, env), EP, W)\n\n          in\n            T.Unit\n          end\n\n*) transProgS (Psi, Unit, W, args)  = (Unit, (True, id)) | transProgS (Psi, AppTerm (EP, s), W, args)  = transProgS (Psi, EP, W, s :: args) | transProgS (Psi, Const name, W, args)  = (*         val lemma = T.lemmaName name\n           val F = T.lemmaFor lemma *) let (n, F) = lookup (Psi, 1, name) let (S, Fs\') = transProgS\' (Psi, (F, id), W, args) in (Redex (Var n, S), Fs\') | transProgS (Psi, Choose (eD, eP), W, args)  = let D\' = parseDec (Psi, eD) let (P, (F, t)) = transProgS (Decl (Psi, UDec D\'), eP, W, args) in (Choose (Lam (UDec D\', P)), (F, t)) | transProgS (Psi, New (nil, eP), W, args)  = transProgS (Psi, eP, W, args) | transProgS (Psi, New (eD :: eDs, eP), W, args)  = let D\' = parseDec (Psi, eD) let (P, (F, t)) = transProgS (Decl (Psi, UDec D\'), New (eDs, eP), W, args) let UDec D\'\' = externalizeMDec (ctxLength Psi, UDec D\') let (B, _) = deblockify (Decl (Null, D\'\')) let F\' = raiseFor (B, (F, coerceSub t)) in (New (Lam (UDec D\', P)), (F\', id))(* bug: forgot to raise F[t] to F\' --cs Tue Jul  1 10:49:52 2003 *)transProgS\' (Psi, (World (_, F), s), W, args)  = transProgS\' (Psi, (F, s), W, args) | transProgS\' (Psi, (All ((UDec (Dec (_, V)), Implicit), F\'), s), W, args)  = (*        val X = I.EVar (ref NONE, I.Null, I.EClo (V, T.coerceSub s), ref nil) *) let G = coerceCtx Psi let X = newEVar (G, EClo (V, coerceSub s)) let (S, Fs\') = transProgS\' (Psi, (F\', Dot (Exp X, s)), W, args) in (AppExp (normalize (X, id), S), Fs\') | transProgS\' (Psi, (All ((UDec (Dec (_, V)), Explicit), F\'), s), W, t :: args)  = (*        val (F\'\', s\'\', _) = checkForWorld (F\', T.Dot (T.Exp U, s), W) *) let U = parseTerm (Psi, (t, EClo (V, coerceSub s))) let (S, Fs\') = transProgS\' (Psi, (F\', Dot (Exp U, s)), W, args) in (AppExp (U, S), Fs\') | transProgS\' (Psi, (F, s), _, nil)  = (Nil, (F, s)) (*\n     | transProgS ((Psi, env), D.Pair (EP1, EP2), W) =\n        let\n          val (P1, (F1, t1)) = transProgS ((Psi, env), EP1, W)\n          val (P2, (F2, t2)) = transProgS ((Psi, env), EP2, W)\n        in\n          (T.PairPrg (P1, P2), (T.And (F1, F2), T.comp (t1, t2)))\n        end\n\n     | transProgS ((Psi, env), D.AppProg (EP1, EP2), W) =\n        let\n          val (P1, (T.And (F1, F2), t)) = transProgS ((Psi, env), EP1, W)\n          val P2 = transProgIN ((Psi, env), EP2, T.FClo (F1, t), W)\n          val (F\'\', t\'\', W) = checkForWorld (F2, t, W)\n        in\n          (T.Redex (P1, T.AppPrg (P2, T.Nil)), (F\'\', t\'\'))\n        end\n\n\n      | transProgS ((Psi, env), P as D.Inx (s, EP), W) =  raise Error "Cannot infer existential types"\n\n(*      | transProgS ((Psi, env), D.Lam (s, EP), W) =\n        let\n          val dec = stringTodec s\n          val (I.Decl (Psi\', (D, _, _)), P, F) = transProgI (I.Decl (Psi, dec), EP)\n          val (F\', t\', _) = checkForWorld (F, T.id, W)\n        in\n          (T.Lam (T.UDec D, P), (T.All (D, F\'), t\'))\n        end\n*)\n      | transProgS ((Psi, env), D.New (s, eP), W)  =\n        let\n          val _ = print "["\n          val G = Names.ctxName (T.coerceCtx Psi)\n          val _ = print (Print.ctxToString (I.Null, G) ^ "\\n")\n          val (U, V) = parseTerm ((Psi, env), s ^ " type")\n(*        val _ = print (Print.expToString (G, U) ^ "\\n") *)\n\n          fun extract (G, Us) = extractW (G, Whnf.whnf Us)\n          and extractW (G, (I.Pi ((D as I.Dec (_, _), _), V\'), s)) =\n                extract (I.Decl(G, I.decSub (D, s)), (V\', I.dot1 s))\n            | extractW (G, _) = G\n\n          val G\' = extract (I.Null, (U, I.id))\n          val Dlist = T.ctxToBDecs (T.coerceCtx Psi, G\', W)\n\n          fun project ((G, env), []) = (env, 1)   (* is this the right starting point --cs *)\n            | project ((G, env), x :: N) =\n              let\n                val (env\', k) = project ((G, env), N)\n                val U = I.Root (I.Proj (I.Bidx 1, k), I.Nil)\n                val V =  TypeCheck.infer\' (G, U)\n              in\n                ((U, V, x) :: env\', k+1)\n              end\n\n          fun extend ((Psi\', env\'), []) = (Psi\', env\')\n            | extend ((Psi\', env\'), (N, D) :: Dlist\') =\n              let\n                val (Psi\'\', env\'\') = extend ((Psi\', env\'),  Dlist\')\n                val Psi\'\'\' = I.Decl (Psi\'\', T.UDec D)\n                val I.BDec (_, (cid, s)) = D\n                val G\'\'\' = T.coerceCtx Psi\'\'\'\n                val env\'\'\' = map (fn (U, V, name) =>\n                    (I.EClo (U, I.shift), I.EClo (V, I.shift), name)) env\'\'\n                val (env\'\'\'\', _) = project ((G\'\'\', env\'\'\'), N)\n              in\n                (Psi\'\'\',  env\'\'\'\')\n               end\n\n          val (Psi\', env\') = extend ((Psi, env), Dlist)\n          val _ = printCtx (Names.ctxName (T.coerceCtx Psi\'), env\')\n\n          fun universalClosure ([], F) = F\n            | universalClosure ((_, D) :: Ds, F)  = T.All (T.UDec D, universalClosure (Ds, F))\n\n          val (P\', (F, t)) = transProgS ((Psi, env), eP, W)\n          val F\' = T.forSub (F, t)\n          val F\'\' = universalClosure (Dlist, F\')\n          val P\'\' = lamClosure (F\'\', P\')\n        in\n          (P\'\', (F\'\', T.id))\n        end\n*) (* transProgram Ds = P\n\n       Invariant:\n       If Ds is a list of declarations then P is\n       the translated program, that does not do anything\n    *) let rec transProgram Ds  = transDecs (Null, Ds, fun (Psi, W) -> (Unit), Worlds []) let transFor = fun F -> let F\' = transFor (Null, F) in F\' (*    val makePattern = makePattern *) (*    val transPro = fn P => let val (P\', _) = transProgS ((I.Null, []), P, T.Worlds []) in P\' end *) let transDecs = transProgram let internalizeSig = internalizeSig let externalizePrg = fun P -> externalizePrg (0, P) (*    val transDecs = fn Ds => transDecs ((I.Null, []), NONE, Ds, fn (Psi,  W) => T.Unit, T.Worlds [])\n*)  end(* functor Trans *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Translator from Delphin external syntax to Delphin internal syntax *) (* Author: Richard Fontana, Carsten Schuermann *) module type TRANS = sig module DextSyn : DEXTSYNexception Error of stringval internalizeSig : unit -> unitval transFor : (* IntSyn.dctx * *) Form -> Forval transDecs : Decs -> Prgval externalizePrg : Prg -> Prg(* val transPro : DextSyn.Prog -> Tomega.Prg *)  end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* The Parser *) (* Author: Richard Fontana *) module type PARSE = sig module DextSyn : DEXTSYNval fparse : string -> unitval gparse : string -> Astval sparse : unit -> Ast end(* signature PARSE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Delphin Front End Interface *) (* Author: Carsten Schuermann *) module DextSynDEXTSYN = DextSyn(struct module Stream' = Stream module ParseTerm' = ParseTerm module ExtSyn' = ParseTermExtSyn module Parsing' = Parsing module Lexer' = Lexer end)\nmodule DelphinLrValsDelphin_LRVALS = DelphinLrValsFun(struct module Token = LrParserToken module DextSyn' = DextSyn module Stream = Stream module Lexer' = Lexer module Parsing' = Parsing end)\nmodule InterfaceINTERFACE = Interface()\nmodule DelphinLexLEXERR = DelphinLexFun(struct module Tokens = DelphinLrValsTokens module Interface = Interface module Lexer = Lexer end)\nmodule DelphinParserPARSERR = Join(struct module ParserData = DelphinLrValsParserData module Lex = DelphinLex module LrParser = LrParser end)\nmodule ParsePARSE = Parse(struct module DextSyn = DextSyn module Interface = Interface module Parserr = DelphinParser module Tokens = DelphinLrValsTokens end)\nmodule TransTRANS = Trans(module DextSyn' = DextSyn)module Delphin = Delphin(struct module Twelf = Twelf module Parse = Parse module DextSyn = DextSyn module Trans = Trans module Parser = Parser end)\n(*\nstructure Tomega =\n  Tomega (structure IntSyn' = IntSyn\n\t  structure Whnf = Whnf\n\t  structure Conv = Conv);\n\nstructure Normalize =\n  Normalize (structure Tomega' = Tomega);\n*) (*structure Opsem =\n  Opsem (structure Tomega' = Tomega\n\t structure Unify = UnifyTrail\n\t structure Normalize = Normalize);\n*) ", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Interface for error reporting  syntax *) (* Author: Richard Fontana *) (* compare to Paths *) module type INTERFACE = sig type posval line : pos refval init_line : unit -> unitval next_line : unit -> unitval error : string * pos * pos -> unittype argval nothing : arg end(* signature INTERFACE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Interface for error reporting  syntax *) (* Author: Richard Fontana *) (* compare to Paths *) module Interface () : INTERFACE = struct type pos = int let line = ref 0 let rec init_line ()  = (line := 1) let rec next_line ()  = (line := ! line + 1) let rec error (errmsg, line : pos, _)  = output (stdOut, "Line " ^ (toString (line)) ^ ": " ^ errmsg ^ "\\n") type arg = unit let nothing = () end(* functor INTERFACE  *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: module StyleCheck = StyleCheck(struct module Whnf = Whnf module Index = Index module Origins = Origins end)

('Error parsing code:', '(* Style Checking *) (* Author: Carsten Schuermann *) module type STYLECHECK = sig exception Error of stringval check : unit -> unit(* raises Error (msg) *) val checkConDec : cid -> unit end\n(* signature STYLECHECK *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: module StyleCheck = StyleCheck(struct module Whnf = Whnf module Index = Index module Origins = Origins end)

('Error parsing code:', '(* Meta printer for proof states *) (* Author: Carsten Schuermann *) module type METAPRINT = sig module MetaSyn : METASYNval stateToString : State -> stringval sgnToString : Sgn -> stringval modeToString : Mode -> stringval conDecToString : ConDec -> string end\n(* signature METAPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Prover Interface *) (* Author: Carsten Schuermann *) module type MPI = sig module MetaSyn : METASYNexception Error of stringval init : (int * string list) -> unitval select : int -> unitval print : unit -> unitval next : unit -> unitval auto : unit -> unitval solve : unit -> unitval lemma : string -> unitval reset : unit -> unitval extract : unit -> Sgnval show : unit -> unitval undo : unit -> unit end\n(* signature MPI *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Splitting *) (* Author: Carsten Schuermann *) module Splitting (module Global : GLOBALmodule MetaSyn\' : METASYNmodule MetaAbstract : METAABSTRACTmodule MetaPrint : METAPRINTMetaPrintMetaSynMetaSyn\'MetaAbstractMetaSynMetaSyn\'module ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = MetaSyn\'.IntSyn !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = MetaSyn\'.IntSyn !*) module Index : INDEX(*! sharing Index.IntSyn = MetaSyn\'.IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = MetaSyn\'.IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = MetaSyn\'.IntSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = MetaSyn\'.IntSyn !*) ) : SPLITTING = struct module MetaSyn = MetaSyn\' exception Error of string (* Invariant:\n     Case analysis generates a list of successor states\n     (the cases) from a given state.\n\n     \'a flag marks cases where unification of the types\n     succeeded as "Active", and cases where there were\n     leftover constraints after unification as "Inactive".\n\n     NB: cases where unification fails are not considered\n\n     Consequence: Only those splitting operators can be\n     applied which do not generate inactive cases.\n  *)  type flag = Active of \'a | InActive type operator = (State * int) * State flag list module M = MetaSynmodule I = IntSyn(* constCases (G, (V, s), I, abstract, C) = C\'\n\n       Invariant:\n       If   G |- s : G\'  G\' |- V : type\n       and  I a list of of constant declarations\n       and  abstract an abstraction function\n       and  C a list of possible cases\n       then C\' is a list extending C, containing all possible\n         cases from I\n    *) let rec constCases (G, Vs, nil, abstract, ops)  = ops | constCases (G, Vs, Const c :: Sgn, abstract, ops)  = let (U, Vs\') = createAtomConst (G, Const c) in constCases (G, Vs, Sgn, abstract, trail (fun () -> try  with )) (* paramCases (G, (V, s), k, abstract, C) = C\'\n\n       Invariant:\n       If   G |- s : G\'  G\' |- V : type\n       and  k a variable\n       and  abstract an abstraction function\n       and  C a list of possible cases\n       then C\' is a list extending C, containing all possible\n         cases introduced by parameters <= k in G\n    *) let rec paramCases (G, Vs, 0, abstract, ops)  = ops | paramCases (G, Vs, k, abstract, ops)  = let (U, Vs\') = createAtomBVar (G, k) in paramCases (G, Vs, k - 1, abstract, trail (fun () -> try  with )) (* lowerSplitDest (G, (V, s\'), abstract) = C\'\n\n       Invariant:\n       If   G0, G |- s\' : G1  G1 |- V: type\n       and  G is the context of local parameters\n       and  abstract abstraction function\n       then C\' is a list of all cases unifying with V[s\']\n            (it contains constant and parameter cases)\n    *) let rec lowerSplitDest (G, (V as Root (Const c, _), s\'), abstract)  = constCases (G, (V, s\'), lookup c, abstract, paramCases (G, (V, s\'), ctxLength G, abstract, nil)) | lowerSplitDest (G, (Pi ((D, P), V), s\'), abstract)  = let D\' = decSub (D, s\') in lowerSplitDest (Decl (G, D\'), (V, dot1 s\'), fun (name, U) -> abstract (name, Lam (D\', U))) (* split ((G, M), (x:D, s), abstract) = C\'\n\n       Invariant :\n       If   |- G ctx\n       and  G |- M mtx\n       and  G |- s : G1   and  G1 |- D : L\n       and  abstract abstraction function\n       then C\' = (C1, ... Cn) are resulting cases from splitting D[s]\n    *) let rec split (Prefix (G, M, B), (D as Dec (_, V), s), abstract)  = lowerSplitDest (Null, (V, s), fun (name\', U\') -> abstract (name\', Prefix (G, M, B), Dot (Exp (U\'), s))) (* rename to add N prefix? *) (* occursIn (k, U) = B,\n\n       Invariant:\n       If    U in nf\n       then  B iff k occurs in U\n    *) let rec occursInExp (k, Uni _)  = false | occursInExp (k, Pi (DP, V))  = occursInDecP (k, DP) || occursInExp (k + 1, V) | occursInExp (k, Root (C, S))  = occursInCon (k, C) || occursInSpine (k, S) | occursInExp (k, Lam (D, V))  = occursInDec (k, D) || occursInExp (k + 1, V) | occursInExp (k, FgnExp csfe)  = fold csfe (fun (U, B) -> B || occursInExp (k, normalize (U, id))) false(* no case for Redex, EVar, EClo *) occursInCon (k, BVar (k\'))  = (k = k\') | occursInCon (k, Const _)  = false | occursInCon (k, Def _)  = false | occursInCon (k, Skonst _)  = false(* no case for FVar *) occursInSpine (_, Nil)  = false | occursInSpine (k, App (U, S))  = occursInExp (k, U) || occursInSpine (k, S)(* no case for SClo *) occursInDec (k, Dec (_, V))  = occursInExp (k, V)occursInDecP (k, (D, _))  = occursInDec (k, D) let rec isIndexInit k  = false let rec isIndexSucc (D, isIndex) k  = occursInDec (k, D) || isIndex (k + 1) let rec isIndexFail (D, isIndex) k  = isIndex (k + 1) (* checkExp (M, U) = B\n\n       Invariant:\n       If   G |- M\n       and  G |- U : V\n       and  U in nf\n       then B holds iff U does not contain any Bot variables\n    *) let rec checkVar (Decl (M, Top), 1)  = true | checkVar (Decl (M, Bot), 1)  = false | checkVar (Decl (M, _), k)  = checkVar (M, k - 1) let rec checkExp (M, Uni _)  = true | checkExp (M, Pi ((D, P), V))  = checkDec (M, D) && checkExp (Decl (M, Top), V) | checkExp (M, Lam (D, V))  = checkDec (M, D) && checkExp (Decl (M, Top), V) | checkExp (M, Root (BVar k, S))  = checkVar (M, k) && checkSpine (M, S) | checkExp (M, Root (_, S))  = checkSpine (M, S)checkSpine (M, Nil)  = true | checkSpine (M, App (U, S))  = checkExp (M, U) && checkSpine (M, S)checkDec (M, Dec (_, V))  = checkExp (M, V) (* copied from meta-abstract *) (* modeEq (marg, st) = B\'\n\n       Invariant:\n       If   (marg = + and st = top) or (marg = - and st = bot)\n       then B\' = true\n       else B\' = false\n    *) let rec modeEq (Marg (Plus, _), Top)  = true | modeEq (Marg (Minus, _), Bot)  = true | modeEq _  = false (*\n       The inherit functions below copy the splitting depth attribute\n       between successive states, using a simultaneous traversal\n       in mode dependency order.\n\n       Invariant:\n       (G,M,B) |- V type\n       G = G0, G1, G2\n       |G2| = k       (length of local context)\n       d = |G1, G2|   (last BVar seen)\n       let n < |G|\n       if   n>d then n is an index of a variable already seen in mdo\n       if   n=d then n is an index of a variable now seen for the first\n                     time\n       if   n<=k then n is a local parameter\n       it is impossible for     k < n < d\n    *) (* invariants on inheritXXX functions? -fp *) let rec inheritBelow (b\', k\', Lam (D\', U\'), Bdd\')  = inheritBelow (b\', k\' + 1, U\', inheritBelowDec (b\', k\', D\', Bdd\')) | inheritBelow (b\', k\', Pi ((D\', _), V\'), Bdd\')  = inheritBelow (b\', k\' + 1, V\', inheritBelowDec (b\', k\', D\', Bdd\')) | inheritBelow (b\', k\', Root (BVar (n\'), S\'), (B\', d, d\'))  = if n\' = k\' + d\' && n\' > k\'(* necessary for d\' = 0 *)  then inheritBelowSpine (b\', k\', S\', (Decl (B\', b\'), d, d\' - 1)) else inheritBelowSpine (b\', k\', S\', (B\', d, d\')) | inheritBelow (b\', k\', Root (C, S\'), Bdd\')  = inheritBelowSpine (b\', k\', S\', Bdd\')inheritBelowSpine (b\', k\', Nil, Bdd\')  = Bdd\' | inheritBelowSpine (b\', k\', App (U\', S\'), Bdd\')  = inheritBelowSpine (b\', k\', S\', inheritBelow (b\', k\', U\', Bdd\'))inheritBelowDec (b\', k\', Dec (x, V\'), Bdd\')  = inheritBelow (b\', k\', V\', Bdd\') (* skip *) let rec skip (k, Lam (D, U), Bdd\')  = skip (k + 1, U, skipDec (k, D, Bdd\')) | skip (k, Pi ((D, _), V), Bdd\')  = skip (k + 1, V, skipDec (k, D, Bdd\')) | skip (k, Root (BVar (n), S), (B\', d, d\'))  = if n = k + d && n > k(* necessary for d = 0 *)  then skipSpine (k, S, (B\', d - 1, d\')) else skipSpine (k, S, (B\', d, d\')) | skip (k, Root (C, S), Bdd\')  = skipSpine (k, S, Bdd\')skipSpine (k, Nil, Bdd\')  = Bdd\' | skipSpine (k, App (U, S), Bdd\')  = skipSpine (k, S, skip (k, U, Bdd\'))skipDec (k, Dec (x, V), Bdd\')  = skip (k, V, Bdd\') (* Uni impossible *) let rec inheritExp (B, k, Lam (D, U), k\', Lam (D\', U\'), Bdd\')  = inheritExp (B, k + 1, U, k\' + 1, U\', inheritDec (B, k, D, k\', D\', Bdd\')) | inheritExp (B, k, Pi ((D, _), V), k\', Pi ((D\', _), V\'), Bdd\')  = inheritExp (B, k + 1, V, k\' + 1, V\', inheritDec (B, k, D, k\', D\', Bdd\')) | inheritExp (B, k, V as Root (BVar (n), S), k\', V\', (B\', d, d\'))  = if n = k + d && n > k(* new original variable *)  then (* inheritBelow (I.ctxLookup (B, n-k) - 1, k\', V\', (B\', d-1, d\')) *) skipSpine (k, S, inheritNewRoot (B, ctxLookup (B, n - k), k, V, k\', V\', (B\', d, d\'))) else if n > k + d(* already seen original variable *) (* then (B\', d, d\') *) (* previous line avoids redundancy,\n                  but may violate invariant outside pattern fragment *)  then skipSpine (k, S, inheritBelow (ctxLookup (B, n - k) - 1, k\', V\', (B\', d, d\'))) else (* must correspond *) (* C\' = BVar (n) *) let Root (C\', S\') = V\' in inheritSpine (B, k, S, k\', S\', (B\', d, d\')) | inheritExp (B, k, Root (C, S), k\', Root (C\', S\'), Bdd\')  = (* C ~ C\' *)  inheritSpine (B, k, S, k\', S\', Bdd\')inheritNewRoot (B, b, k, Root (BVar (n), S), k\', V\' as Root (BVar (n\'), S\'), (B\', d, d\'))  = (* n = k+d *)  if n\' = k\' + d\' && n\' > k\'(* n\' also new --- same variable: do not decrease *)  then inheritBelow (b, k\', V\', (B\', d - 1, d\')) else inheritBelow (b - 1, k\', V\', (B\', d - 1, d\')) | inheritNewRoot (B, b, k, V, k\', V\', (B\', d, d\'))  = (* n\' not new --- decrease the splitting depth of all variables in V\' *)  inheritBelow (b - 1, k\', V\', (B\', d - 1, d\'))inheritSpine (B, k, Nil, k\', Nil, Bdd\')  = Bdd\' | inheritSpine (B, k, App (U, S), k\', App (U\', S\'), Bdd\')  = inheritSpine (B, k, S, k\', S\', inheritExp (B, k, U, k\', U\', Bdd\'))inheritDec (B, k, Dec (_, V), k\', Dec (_, V\'), Bdd\')  = inheritExp (B, k, V, k\', V\', Bdd\') let rec inheritDTop (B, k, Pi ((Dec (_, V1), No), V2), k\', Pi ((Dec (_, V1\'), No), V2\'), Bdd\')  = inheritG (B, k, V1, k\', V1\', inheritDTop (B, k + 1, V2, k\' + 1, V2\', Bdd\')) | inheritDTop (B, k, V as Root (Const (cid), S), k\', V\' as Root (Const (cid\'), S\'), Bdd\')  = (* cid = cid\' *)  let mS = valOf (modeLookup (cid)) in inheritSpineMode (Top, mS, B, k, S, k\', S\', Bdd\')inheritDBot (B, k, Pi ((Dec (_, V1), No), V2), k\', Pi ((Dec (_, V1\'), No), V2\'), Bdd\')  = inheritDBot (B, k + 1, V2, k\' + 1, V2\', Bdd\') | inheritDBot (B, k, Root (Const (cid), S), k\', Root (Const (cid\'), S\'), Bdd\')  = (* cid = cid\' *)  let mS = valOf (modeLookup (cid)) in inheritSpineMode (Bot, mS, B, k, S, k\', S\', Bdd\')inheritG (B, k, Root (Const (cid), S), k\', V\' as Root (Const (cid\'), S\'), Bdd\')  = let mS = valOf (modeLookup (cid)) in (* mode dependency in Goal: first M.Top, then M.Bot *) inheritSpineMode (Bot, mS, B, k, S, k\', S\', inheritSpineMode (Top, mS, B, k, S, k\', S\', Bdd\'))inheritSpineMode (mode, Mnil, B, k, Nil, k\', Nil, Bdd\')  = Bdd\' | inheritSpineMode (mode, Mapp (m, mS), B, k, App (U, S), k\', App (U\', S\'), Bdd\')  = if modeEq (m, mode) then inheritSpineMode (mode, mS, B, k, S, k\', S\', inheritExp (B, k, U, k\', U\', Bdd\')) else inheritSpineMode (mode, mS, B, k, S, k\', S\', Bdd\') let rec inheritSplitDepth (S as State (_, Prefix (G, M, B), V), S\' as State (name\', Prefix (G\', M\', B\'), V\'))  = (* S\' *)  (* current first occurrence depth in V *) (* current first occurrence depth in V\' *) (* mode dependency in Clause: first M.Top then M.Bot *) (* check proper traversal *) let d = ctxLength G let d\' = ctxLength G\' let V = normalize (V, id) let V\' = normalize (V\', id) let (B\'\', 0, 0) = inheritDBot (B, 0, V, 0, V\', inheritDTop (B, 0, V, 0, V\', (Null, d, d\'))) in State (name\', Prefix (G\', M\', B\'\'), V\') (* abstractInit (M.State (name, M.Prefix (G, M, B), V)) = F\'\n\n       State is the state before splitting, to inherit splitting depths.\n       Invariant:\n       If   G |- V : L\n       then forall |- G\' ctx\n            and    G\' |- M\' ctx\n            and    G\' |- s\' : G\n            and    names name\'\n            then   following holds: S\' = F\' (name\', G\', M\', s\')\n                                    S\' is a new state\n    *) let rec abstractInit (State (name, GM, V)) (name\', Prefix (G\', M\', B\'), s\')  = inheritSplitDepth (State (name, GM, V), abstract (State (name ^ name\', Prefix (G\', M\', B\'), EClo (V, s\')))) (* abstractInit (x:D, mode, F) = F\'\n\n       Invariant:\n       If   G |- D : L\n       and  forall |- G\' ctx\n            and    G\' |- M\' ctx\n            and    G\' |- s\' : G\n            and    names name\'\n            then   S\' = F (name\', G\', M\', s\')\n       then forall |- G\' ctx\n            and    G\' |- M\' ctx\n            and    G\' |- s\' : G\n            then   following holds: S\' = F (name\', (G\', D[s]) , (M\', mode) , 1 . s\' o ^)\n                                    is a new state\n    *) let rec abstractCont ((D, mode, b), abstract) (name\', Prefix (G\', M\', B\'), s\')  = abstract (name\', Prefix (Decl (G\', decSub (D, s\')), Decl (M\', mode), Decl (B\', b)), dot1 s\') let rec makeAddressInit S k  = (S, k) let rec makeAddressCont makeAddress k  = makeAddress (k + 1) (* expand\' (M.Prefix (G, M), isIndex, abstract, makeAddress) = (M.Prefix (G\', M\'), s\', ops\')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- M mtx\n       and  isIndex (k) = B function s.t. B holds iff k index\n       and  abstract, dynamic abstraction function\n       and  makeAddress, a function which calculates the index of the variable\n            to be split\n       then |- G\' ctx\n       and  G\' |- M\' mtx\n       and  G\' is a subcontext of G where all Top variables have been replaced\n            by EVars\'\n       and  G\' |- s\' : G\n       and  ops\' is a list of all possiblie splitting operators\n    *) let rec expand\' (Prefix (Null, Null, Null), isIndex, abstract, makeAddress)  = (Prefix (Null, Null, Null), id, nil) | expand\' (Prefix (Decl (G, D), Decl (M, mode as Top), Decl (B, b)), isIndex, abstract, makeAddress)  = let (Prefix (G\', M\', B\'), s\', ops) = expand\' (Prefix (G, M, B), isIndexSucc (D, isIndex), abstractCont ((D, mode, b), abstract), makeAddressCont makeAddress) let Dec (xOpt, V) = D let X = newEVar (G\', EClo (V, s\')) let ops\' = if b > 0 && (* check if splitting bound > 0 *)  && not (isIndex 1) && checkDec (M, D) then (makeAddress 1, split (Prefix (G\', M\', B\'), (D, s\'), abstract)) :: ops else ops in (Prefix (G\', M\', B\'), Dot (Exp (X), s\'), ops\') | expand\' (Prefix (Decl (G, D), Decl (M, mode as Bot), Decl (B, b)), isIndex, abstract, makeAddress)  = let (Prefix (G\', M\', B\'), s\', ops) = expand\' (Prefix (G, M, B), isIndexSucc (D, isIndex), (* -###- *) , abstractCont ((D, mode, b), abstract), makeAddressCont makeAddress) in (Prefix (Decl (G\', decSub (D, s\')), Decl (M\', Bot), Decl (B\', b)), (* b = 0 *) , dot1 s\', ops) (* expand ((G, M), V) = ops\'\n\n       Invariant:\n       If   |- G ctx\n       and  G |- M mtx\n       and  G |- V : L\n       then ops\' is a list of all possiblie splitting operators\n    *) let rec expand (S as State (name, Prefix (G, M, B), V))  = let (_, _, ops) = expand\' (Prefix (G, M, B), isIndexInit, abstractInit S, makeAddressInit S) in ops (* index (Op) = k\n\n       Invariant:\n       If   Op = (_, S) then k = |S|\n    *) let rec index (_, Sl)  = length Sl (* apply (Op) = Sl\'\n\n       Invariant:\n       If   Op = (_, Sl) then Sl\' = Sl\n    *) let rec apply (_, Sl)  = map (fun (Active S) -> S | InActive -> raise (Error "Not applicable: leftover constraints")) Sl (* menu (Op) = s\'\n\n       Invariant:\n       If   Op = ((G, D), Sl)\n       and  G |- D : L\n       then s\' = string describing the operator\n    *) let rec menu (Op as ((State (name, Prefix (G, M, B), V), i), Sl))  = let rec active (nil, n)  = n | active (InActive :: L, n)  = active (L, n) | active ((Active _) :: L, n)  = active (L, n + 1) let rec inactive (nil, n)  = n | inactive (InActive :: L, n)  = inactive (L, n + 1) | inactive ((Active _) :: L, n)  = inactive (L, n) let rec indexToString 0  = "zero cases" | indexToString 1  = "1 case" | indexToString n  = (toString n) ^ " cases" let rec flagToString (_, 0)  = "" | flagToString (n, m)  = " [active: " ^ (toString n) ^ " inactive: " ^ (toString m) ^ "]" in "Splitting : " ^ decToString (G, ctxDec (G, i)) ^ " (" ^ (indexToString (index Op)) ^ (flagToString (active (Sl, 0), inactive (Sl, 0))) ^ ")" let rec var ((_, i), _)  = i let expand = expand let apply = apply let var = var let index = index let menu = menu  (* local *)  end\n(* functor Splitting *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "module MetaSyn = MetaSyn(module Whnf = Whnf)\nmodule MetaAbstract = MetaAbstract(struct module Global = Global module MetaSyn' = MetaSyn module MetaGlobal = MetaGlobal module Abstract = Abstract module ModeTable = ModeTable module Whnf = Whnf module Print = Print module Constraints = Constraints module Unify = UnifyNoTrail module Names = Names module TypeCheck = TypeCheck module Subordinate = Subordinate end)\nmodule MetaPrint = MetaPrint(struct module Global = Global module MetaSyn' = MetaSyn module Formatter = Formatter module Print = Print module ClausePrint = ClausePrint end)\nmodule Init = Init(struct module MetaSyn' = MetaSyn module MetaAbstract = MetaAbstract end)\nmodule OLDSearch = OLDSearch(struct module MetaGlobal = MetaGlobal module Conv = Conv module MetaSyn' = MetaSyn module Compile = Compile module Whnf = Whnf module Unify = UnifyTrail module Index = IndexSkolem module CPrint = CPrint module Print = Print module Names = Names end)\nmodule Lemma = Lemma(struct module MetaSyn' = MetaSyn module MetaAbstract = MetaAbstract end)\nmodule Splitting = Splitting(struct module Global = Global module MetaSyn' = MetaSyn module MetaPrint = MetaPrint module MetaAbstract = MetaAbstract module Whnf = Whnf module ModeTable = ModeTable module Index = Index module Print = Print module Unify = UnifyTrail end)\nmodule Filling = Filling(struct module Global = Global module MetaSyn' = MetaSyn module MetaAbstract = MetaAbstract module Print = Print module Search = OLDSearch module Whnf = Whnf end)\nmodule Recursion = Recursion(struct module Global = Global module MetaSyn' = MetaSyn module MetaPrint = MetaPrint module Whnf = Whnf module Unify = UnifyTrail module Conv = Conv module Names = Names module Print = Print module Subordinate = Subordinate module Order = Order module ModeTable = ModeTable module MetaAbstract = MetaAbstract module Lemma = Lemma module Filling = Filling module Formatter = Formatter end)\nmodule Qed = Qed(struct module Global = Global module MetaSyn' = MetaSyn end)\nmodule StrategyFRS = StrategyFRS(struct module MetaGlobal = MetaGlobal module MetaSyn' = MetaSyn module MetaAbstract = MetaAbstract module Lemma = Lemma module Filling = Filling module Recursion = Recursion module Splitting = Splitting module Qed = Qed module MetaPrint = MetaPrint module Timers = Timers end)\nmodule StrategyRFS = StrategyRFS(struct module MetaGlobal = MetaGlobal module MetaSyn' = MetaSyn module MetaAbstract = MetaAbstract module Lemma = Lemma module Filling = Filling module Recursion = Recursion module Splitting = Splitting module Qed = Qed module MetaPrint = MetaPrint module Timers = Timers end)\nmodule Strategy = Strategy(struct module MetaGlobal = MetaGlobal module MetaSyn' = MetaSyn module StrategyFRS = StrategyFRS module StrategyRFS = StrategyRFS end)\nmodule Prover = Prover(struct module MetaGlobal = MetaGlobal module MetaSyn' = MetaSyn module MetaAbstract = MetaAbstract module MetaPrint = MetaPrint module Filling = Filling module Splitting = Splitting module Recursion = Recursion module Init = Init module Strategy = Strategy module Qed = Qed module Names = Names module Timers = Timers end)\nmodule Mpi = Mpi(struct module MetaGlobal = MetaGlobal module MetaSyn' = MetaSyn module MetaAbstract = MetaAbstract module Init = Init module Lemma = Lemma module Filling = Filling module Recursion = Recursion module Splitting = Splitting module Strategy = Strategy module Qed = Qed module MetaPrint = MetaPrint module Names = Names module Timers = Timers module Ring = Ring end)\nmodule Skolem = Skolem(struct module Global = Global module Whnf = Whnf module Abstract = Abstract module IndexSkolem = IndexSkolem module ModeTable = ModeTable module Print = Print module Timers = Timers module Compile = Compile module Names = Names end)\n", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta printer for proof states *) (* Author: Carsten Schuermann *) module MetaPrint (module Global : GLOBALmodule MetaSyn\' : METASYNmodule Formatter : FORMATTERmodule Print : PRINT(*! sharing Print.IntSyn = MetaSyn\'.IntSyn !*) PrintFormatterFormattermodule ClausePrint : CLAUSEPRINT(*! sharing ClausePrint.IntSyn = MetaSyn\'.IntSyn !*) ClausePrintFormatterFormatter) : METAPRINT = struct module MetaSyn = MetaSyn\' module M = MetaSynmodule I = IntSynmodule F = Formatterlet rec modeToString Top  = "+" | modeToString Bot  = "-" (* depthToString is used to format splitting depth *) let rec depthToString (b)  = if b <= 0 then "" else toString b let rec fmtPrefix (GM)  = let rec fmtPrefix\' (Prefix (Null, Null, Null), Fmt)  = Fmt | fmtPrefix\' (Prefix (Decl (Null, D), Decl (Null, mode), Decl (Null, b)), Fmt)  = [String (depthToString b); String (modeToString mode); formatDec (Null, D)] @ Fmt | fmtPrefix\' (Prefix (Decl (G, D), Decl (M, mode), Decl (B, b)), Fmt)  = fmtPrefix\' (Prefix (G, M, B), [String ","; Space; Break; String (depthToString b); String (modeToString mode); formatDec (G, D)] @ Fmt) in HVbox (fmtPrefix\' (GM, [])) let rec prefixToString GM  = makestring_fmt (fmtPrefix GM) let rec stateToString (State (name, GM as Prefix (G, M, B), V))  = name ^ ":\\n" ^ prefixToString GM ^ "\\n--------------\\n" ^ clauseToString (G, V) ^ "\\n\\n" let rec sgnToString (SgnEmpty)  = "" | sgnToString (ConDec (e, S))  = (if ! chatter >= 4(* use explicitly quantified form *)  then conDecToString e ^ "\\n" else if ! chatter >= 3(* use form without quantifiers, which is reparsable *)  then conDecToString e ^ "\\n" else "") ^ sgnToString S let modeToString = modeToString let sgnToString = sgnToString let stateToString = stateToString let conDecToString = conDecToString  (* local *)  end\n(* functor MetaPrint *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Skolem constant administration *) (* Author: Carsten Schuermann *) module Skolem (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module IndexSkolem : INDEX(*! sharing IndexSkolem.IntSyn = IntSyn\' !*) module ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Compile : COMPILE(*! sharing Compile.IntSyn = IntSyn\' !*) module Timers : TIMERSmodule Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) ) : SKOLEM = struct (*! structure IntSyn = IntSyn\' !*)  exception Error of string module I = IntSynmodule M = ModeSyn(*! structure CompSyn = Compile.CompSyn !*) (* installSkolem (name, k, (V, mS), L) =\n\n       Invariant:\n            name is the name of a theorem\n       and  imp is the number of implicit arguments\n       and  V is its term together with the mode assignment mS\n       and  L is the level of the declaration\n\n       Effects: New Skolem constants are generated, named, and indexed\n    *) let rec installSkolem (name, imp, (V, mS), L)  = (* spine n = S\'\n\n           Invariant:\n           S\' = n; n-1; ... 1; Nil\n        *) (* installSkolem\' ((V, mS), s, k) = ()\n\n           Invariant:\n                G |- V : type\n           and  G\' |- s : G\n           and  |G\'| = d\n           and  k is a continuation, mapping a type G\' |- V\' type\n                to . |- {{G\'}} V\'\n\n           Effects: New Skolem constants are generated, named, and indexed\n        *) let rec spine 0  = Nil | spine n  = App (Root (BVar n, Nil), spine (n - 1)) let rec installSkolem\' (d, (Pi ((D, DP), V), mS), s, k)  = (match mS with Mapp (Marg (Plus, _), mS\') -> installSkolem\' (d + 1, (V, mS\'), dot1 s, fun V -> k (piDepend ((normalizeDec (D, s), Meta), V)))(*                                  fn V => k (I.Pi ((Whnf.normalizeDec (D, s), DP), V))) *)  | Mapp (Marg (Minus, _), mS\') -> (*                  val CompSyn.SClause r = CompSyn.sProgLookup sk *) let Dec (_, V\') = D let V\'\' = k (normalize (V\', s)) let name\' = skonstName (name ^ "#") let SD = SkoDec (name\', NONE, imp, V\'\', L) let sk = sgnAdd SD let H = Skonst sk let _ = install Ordinary H let _ = installConstName sk let _ = (time compiling install) Ordinary sk let S = spine d let _ = if ! chatter >= 3 then print (conDecToString SD ^ "\\n") else () in installSkolem\' (d, (V, mS\'), Dot (Exp (Root (H, S)), s), k)) | installSkolem\' (_, (Uni _, Mnil), _, _)  = () in installSkolem\' (0, (V, mS), id, fun V -> V) (* install L = ()\n\n       Invariant:\n           L is a list of a\'s (mututal inductive theorems)\n           which have an associated mode declaration\n\n       Effect: Skolem constants for all theorems are generated, named, and indexed\n    *) let rec install nil  = () | install (a :: aL)  = let ConDec (name, _, imp, _, V, L) = sgnLookup a let SOME mS = modeLookup a let _ = installSkolem (name, imp, (V, mS), Type) in install aL let install = install  (* local *)  end(* functor Skolem *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Global parameters *) (* Author: Carsten Schuermann *) module type METAGLOBAL = sig type StrategyRFSFRSval strategy : Strategy refval maxFill : int refval maxSplit : int refval maxRecurse : int ref end\n(* signature METAGLOBAL *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Search (based on abstract machine ) *) (* Author: Carsten Schuermann *) module OLDSearch ((*! structure IntSyn\' : INTSYN !*) module MetaGlobal : METAGLOBALmodule MetaSyn\' : METASYN(*! sharing MetaSyn\'.IntSyn = IntSyn\' !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) (*\n                structure Assign : ASSIGN\n                sharing Assign.IntSyn = IntSyn\'\n                *) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module Compile : COMPILE(*! sharing Compile.IntSyn = IntSyn\' !*) (*! sharing Compile.CompSyn = CompSyn\' !*) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) ) : OLDSEARCH = struct (*! structure IntSyn = IntSyn\' !*)  module MetaSyn = MetaSyn\' (*! structure CompSyn = CompSyn\' !*)  exception Error of string module I = IntSynmodule M = MetaSynmodule C = CompSynlet rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a | cidFromHead (Skonst a)  = a (* only used for type families of compiled clauses *) let rec eqHead (Const a, Const a\')  = a = a\' | eqHead (Def a, Def a\')  = a = a\' | eqHead _  = false (* solve ((g,s), (G,dPool), sc, (acc, k)) => ()\n     Invariants:\n       G |- s : G\'\n       G\' |- g :: goal\n       G ~ dPool  (context G matches dPool)\n       acc is the accumulator of results\n       and k is the max search depth limit\n           (used in the existential case for iterative deepening,\n            used in the universal case for max search depth)\n       if  G |- M :: g[s] then G |- sc :: g[s] => Answer, Answer closed\n  *) let rec solve ((Atom p, s), dp, sc, acck)  = matchAtom ((p, s), dp, sc, acck) | solve ((Impl (r, A, H, g), s), DProg (G, dPool), sc, acck)  = let D\' = Dec (NONE, EClo (A, s)) in solve ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, H))), (fun (M, acck\') -> sc (Lam (D\', M), acck\')), acck) | solve ((All (D, g), s), DProg (G, dPool), sc, acck)  = let D\' = decSub (D, s) in solve ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Parameter)), (fun (M, acck\') -> sc (Lam (D\', M), acck\')), acck)(* rsolve ((p,s\'), (r,s), (G,dPool), sc, (acc, k)) = ()\n     Invariants:\n       G |- s : G\'\n       G\' |- r :: resgoal\n       G |- s\' : G\'\'\n       G\'\' |- p :: atom\n       G ~ dPool\n       acc is the accumulator of results\n       and k is the max search depth limit\n           (used in the existential case for iterative deepening,\n            used in the universal case for max search depth)\n       if G |- S :: r[s] then G |- sc : (r >> p[s\']) => Answer\n  *) rSolve (ps\', (Eq Q, s), DProg (G, dPool), sc, acck as (acc, k))  = if unifiable (G, ps\', (Q, s)) then sc (Nil, acck) else acc | rSolve (ps\', (And (r, A, g), s), dp as DProg (G, dPool), sc, acck)  = let X = newEVar (G, EClo (A, s)) in rSolve (ps\', (r, Dot (Exp (X), s)), dp, (fun (S, acck\') -> solve ((g, s), dp, (fun (M, acck\'\') -> (try  with )), acck\')), acck) | rSolve (ps\', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), sc, acck)  = let X = newEVar (G, EClo (A, s)) in rSolve (ps\', (r, Dot (Exp (X), s)), dp, (fun (S, acck\') -> sc (App (X, S), acck\')), acck)(*    | rSolve (ps\', (C.Axists (I.Dec (_, A), r), s), dp as C.DProg (G, dPool), sc, acck) =\n        let\n          val X = I.newEVar (G, I.EClo (A, s))\n        in\n          rSolve (ps\', (r, I.Dot (I.Exp (X), s)), dp,\n                  (fn (S, acck\') => sc (S, acck\')), acck)\n        end\n*) (* aSolve ... *) aSolve ((Trivial, s), dp, sc, acc)  = sc ()(* Fri Jan 15 16:04:39 1999 -fp,cs\n    | aSolve ((C.Unify(I.Eqn(e1, e2), ag), s), dp, sc, acc) =\n      ((Unify.unify ((e1, s), (e2, s));\n        aSolve ((ag, s), dp, sc, acc))\n       handle Unify.Unify _ => acc)\n     *) (* matchatom ((p, s), (G, dPool), sc, (acc, k)) => ()\n     G |- s : G\'\n     G\' |- p :: atom\n     G ~ dPool\n     acc is the accumulator of results\n     and k is the max search depth limit\n         (used in the existential case for iterative deepening,\n          used in the universal case for max search depth)\n     if G |- M :: p[s] then G |- sc :: p[s] => Answer\n  *) matchAtom (ps\' as (Root (Ha, _), _), dp as DProg (G, dPool), sc, (acc, k))  = let rec matchSig acc\'  = let rec matchSig\' (nil, acc\'\')  = acc\'\' | matchSig\' (Hc :: sgn\', acc\'\')  = let SClause (r) = sProgLookup (cidFromHead Hc) let acc\'\'\' = trail (fun () -> rSolve (ps\', (r, id), dp, (fun (S, acck\') -> sc (Root (Hc, S), acck\')), (acc\'\', k - 1))) in matchSig\' (sgn\', acc\'\'\') in matchSig\' (lookup (cidFromHead Ha), acc\') let rec matchDProg (Null, _, acc\')  = matchSig acc\' | matchDProg (Decl (dPool\', Dec (r, s, Ha\')), n, acc\')  = if eqHead (Ha, Ha\') then let acc\'\' = trail (fun () -> rSolve (ps\', (r, comp (s, Shift n)), dp, (fun (S, acck\') -> sc (Root (BVar n, S), acck\')), (acc\', k - 1))) in matchDProg (dPool\', n + 1, acc\'\') else matchDProg (dPool\', n + 1, acc\') | matchDProg (Decl (dPool\', Parameter), n, acc\')  = matchDProg (dPool\', n + 1, acc\') in if k < 0 then acc else matchDProg (dPool, 1, acc) (* occursInExp (r, (U, s)) = B,\n\n       Invariant:\n       If    G |- s : G1   G1 |- U : V\n       then  B holds iff r occurs in (the normal form of) U\n    *) let rec occursInExp (r, Vs)  = occursInExpW (r, whnf Vs)occursInExpW (r, (Uni _, _))  = false | occursInExpW (r, (Pi ((D, _), V), s))  = occursInDec (r, (D, s)) || occursInExp (r, (V, dot1 s)) | occursInExpW (r, (Root (_, S), s))  = occursInSpine (r, (S, s)) | occursInExpW (r, (Lam (D, V), s))  = occursInDec (r, (D, s)) || occursInExp (r, (V, dot1 s)) | occursInExpW (r, (EVar (r\', _, V\', _), s))  = (r = r\') || occursInExp (r, (V\', s)) | occursInExpW (r, (FgnExp csfe, s))  = fold csfe (fun (U, B) -> B || occursInExp (r, (U, s))) falseoccursInSpine (_, (Nil, _))  = false | occursInSpine (r, (SClo (S, s\'), s))  = occursInSpine (r, (S, comp (s\', s))) | occursInSpine (r, (App (U, S), s))  = occursInExp (r, (U, s)) || occursInSpine (r, (S, s))occursInDec (r, (Dec (_, V), s))  = occursInExp (r, (V, s)) (* nonIndex (r, GE) = B\n\n       Invariant:\n       B hold iff\n        r does not occur in any type of EVars in GE\n    *) let rec nonIndex (_, nil)  = true | nonIndex (r, EVar (_, _, V, _) :: GE)  = (not (occursInExp (r, (V, id)))) && nonIndex (r, GE) (* select (GE, (V, s), acc) = acc\'\n\n       Invariant:\n       If   GE is a list of Evars\n       and  G |- s : G\'   G\' |- V : L\n       then acc\' is a list of EVars (G\', X\') s.t.\n         (0) it extends acc\'\n         (1) (G\', X\') occurs in V[s]\n         (2) (G\', X\') is not an index Variable to any (G, X) in acc\'.\n    *) (* Efficiency: repeated whnf for every subterm in Vs!!! *) let rec selectEVar (nil, _, acc)  = acc | selectEVar ((X as EVar (r, _, _, _)) :: GE, Vs, acc)  = if occursInExp (r, Vs) && nonIndex (r, acc) then selectEVar (GE, Vs, X :: acc) else selectEVar (GE, Vs, acc) (* searchEx\' max (GE, sc) = acc\'\n\n       Invariant:\n       If   GE is a list of EVars to be instantiated\n       and  max is the maximal number of constructors\n       then if an instantiation of EVars in GE is found Success is raised\n            otherwise searchEx\' terminates with []\n    *) (* contexts of EVars are recompiled for each search depth *) let rec searchEx\' max (nil, sc)  = [sc ()] | searchEx\' max (EVar (r, G, V, _) :: GE, sc)  = solve ((compileGoal (G, V), id), compileCtx false G, (fun (U\', (acc\', _)) -> (instantiateEVar (r, U\', nil); searchEx\' max (GE, sc))), (nil, max)) (* deepen (f, P) = R\'\n\n       Invariant:\n       If   f function expecting parameters P\n         checking the variable MetaGlobal.maxLevel\n       then R\' is the result of applying f to P and\n         traversing all possible numbers up to MetaGlobal.maxLevel\n    *) let rec deepen f P  = let rec deepen\' (level, acc)  = if level > (! maxFill) then acc else (if ! chatter > 5 then print "#" else (); deepen\' (level + 1, f level P)) in deepen\' (1, nil) (* searchEx (G, GE, (V, s), sc) = acc\'\n       Invariant:\n       If   G |- s : G\'   G\' |- V : level\n       and  GE is a list of EVars contained in V[s]\n         where G |- X : VX\n       and  sc is a function to be executed after all non-index variables have\n         been instantiated\n       then acc\' is a list containing the one result from executing the success continuation\n         All EVar\'s got instantiated with the smallest possible terms.\n    *) let rec searchEx (G, GE, Vs, sc)  = (if ! chatter > 5 then print "[Search: " else (); deepen searchEx\' (selectEVar (GE, Vs, nil), fun Params -> (if ! chatter > 5 then print "OK]\\n" else (); sc Params)); if ! chatter > 5 then print "FAIL]\\n" else (); raise (Error "No object found")) (* searchAll\' (GE, acc, sc) = acc\'\n\n       Invariant:\n       If   GE is a list of EVars to be instantiated\n       and  acc is list of already collected results of the success continuation\n       then acc\' is an extension of acc\', containing the results of sc\n         after trying all combinations of instantiations of EVars in GE\n    *) (* Shared contexts of EVars in GE may recompiled many times *) let rec searchAll\' (nil, acc, sc)  = sc (acc) | searchAll\' (EVar (r, G, V, _) :: GE, acc, sc)  = solve ((compileGoal (G, V), id), compileCtx false G, (fun (U\', (acc\', _)) -> (instantiateEVar (r, U\', nil); searchAll\' (GE, acc\', sc))), (acc, ! maxFill)) (* searchAll (G, GE, (V, s), sc) = acc\'\n\n       Invariant:\n       If   G |- s : G\'   G\' |- V : level\n       and  GE is a list of EVars contained in V[s]\n         where G |- X : VX\n       and  sc is a function to be executed after all non-index variables have\n         been instantiated\n       then acc\' is a list of results from executing the success continuation\n    *) let rec searchAll (G, GE, Vs, sc)  = searchAll\' (selectEVar (GE, Vs, nil), nil, sc) let searchEx = searchEx let searchAll = searchAll  (* local ... *)  end\n(* functor Search *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
Code parsed successfully: (* Skolem administration *) (* Author: Carsten Schuermann *) module type SKOLEM = sig (*! structure IntSyn : INTSYN !*) val install : cid list -> unit end
(* signature SKOLEM *) 
('Error parsing code:', '(* Qed *) (* Author: Carsten Schuermann *) module type QED = sig module MetaSyn : METASYNexception Error of stringval subgoal : State -> bool end\n(* signature QED *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Basic search engine *) (* Author: Carsten Schuermann *) module type OLDSEARCH = sig module MetaSyn : METASYNexception Error of stringval searchEx : dctx * Exp list * (Exp * Sub) * (unit -> unit) -> State listval searchAll : dctx * Exp list * (Exp * Sub) * (State list -> State list) -> State list end\n(* signature SEARCH *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Lemma *) (* Author: Carsten Schuermann *) module type LEMMA = sig module MetaSyn : METASYNexception Error of stringval apply : State * cid -> State end\n(* signature LEMMA *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Abstraction *) (* Author: Carsten Schuermann *) module MetaAbstract (module Global : GLOBALmodule MetaSyn\' : METASYNmodule MetaGlobal : METAGLOBALmodule Abstract : ABSTRACT(*! sharing Abstract.IntSyn = MetaSyn\'.IntSyn !*) module ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = MetaSyn\'.IntSyn !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = MetaSyn\'.IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = MetaSyn\'.IntSyn !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = MetaSyn\'.IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = MetaSyn\'.IntSyn !*) module Names : NAMES(*! sharing Names.IntSyn = MetaSyn\'.IntSyn !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = MetaSyn\'.IntSyn !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = MetaSyn\'.IntSyn  !*) ) : METAABSTRACT = struct module MetaSyn = MetaSyn\' exception Error of string module I = IntSynmodule S = Streammodule M = MetaSynmodule C = Constraints(* Invariants? *) (* Definition: Mode dependency order\n\n       A pair ((G, M), V) is in mode dependency order iff\n           G |- V : type\n           G |- M modes\n       and G = G0+, G1-, G1+,  ... G0-\n       and V = {xn:Vn} ..{x1:V1}P0\n       where G0+ collects all +variables when traversing P0 in order\n       and Gi+ collects all +variables when traverseing Vi in order  (i > 0)\n       and Gi- collects all -variables when traversing Vi in order   (i > 0)\n       and G0- collects all -variables when traversing P0 in order.\n    *) type Var = EV of Exp option ref(* Var ::= EVar <r_, V, St>       *)  * Exp * Mode | BV (*       | BV                     *) (*--------------------------------------------------------------------*) (* First section: Collecting EVars and BVars in mode dependency order *) (*--------------------------------------------------------------------*) (* checkEmpty Cnstr = ()\n       raises Error exception if constraints Cnstr cannot be simplified\n       to the empty constraint\n    *) let rec checkEmpty (nil)  = () | checkEmpty (Cnstr)  = (match simplify Cnstr with nil -> () | _ -> raise (Error "Unresolved constraints")) (* Let G x A: defined as\n\n       .      x .            = .\n       (G, V) x (A, BVar)    = (G x A), V\n       (G, V) x (A, EVar V\') = (G, V x A), V\'\n\n       Then all A : Atx satisfy the following invariant: |- A Atx\n\n       ? If    A = A\', EV (r, V, m)\n       ? then  . |- V = {G x A\'}.V\' : type\n       ? where G x A\' |- V\' : type\n\n       We write A ||- U if all EVars and BVars of U are collected in A,\n       A ||- S if all EVars and BVars of S are collected in A,\n       and similiar notation for the other syntactic categories.\n    *) (* typecheck ((G, M), V) = ()\n\n       Invariant:\n       If G |- V : type\n       then typecheck returns ()\n       else TypeCheck.Error is raised\n    *) let rec typecheck (Prefix (G, M, B), V)  = typeCheck (G, (V, Uni Type)) (* modeEq (marg, st) = B\'\n\n       Invariant:\n       If   (marg = + and st = top) or (marg = - and st = bot)\n       then B\' = true\n       else B\' = false\n    *) let rec modeEq (Marg (Plus, _), Top)  = true | modeEq (Marg (Minus, _), Bot)  = true | modeEq _  = false (* atxLookup (atx, r)  = Eopt\'\n\n       Invariant:\n       If   r exists in atx as EV (V)\n       then Eopt\' = SOME EV and . |- V : type\n       else Eopt\' = NONE\n    *) let rec atxLookup (Null, _)  = NONE | atxLookup (Decl (M, BV), r)  = atxLookup (M, r) | atxLookup (Decl (M, E as EV (r\', _, _)), r)  = if (r = r\') then SOME E else atxLookup (M, r) (* raiseType (k, G, V) = {{G\'}} V\n\n       Invariant:\n       If G |- V : L\n          G = G0, G\'  (so k <= |G|)\n       then  G0 |- {{G\'}} V : L\n             |G\'| = k\n\n       All abstractions are potentially dependent.\n    *) let rec raiseType (0, G, V)  = V | raiseType (depth, Decl (G, D), V)  = raiseType (depth - 1, G, Pi ((D, Maybe), V)) (* weaken (depth,  G, a) = (w\')\n    *) let rec weaken (0, G, a)  = id | weaken (depth, Decl (G\', D as Dec (name, V)), a)  = let w\' = weaken (depth - 1, G\', a) in if belowEq (targetFam V, a) then dot1 w\' else comp (w\', shift) (* countPi V = n\'\n\n       If   G |- x : V\n       and  V = {G\'} V\'\n       then |G\'| = n\'\n    *) (* V in nf or enf? -fp *) let rec countPi V  = let rec countPi\' (Root _, n)  = n | countPi\' (Pi (_, V), n)  = countPi\' (V, n + 1) | countPi\' (EClo (V, _), n)  = countPi\' (V, n) in countPi\' (V, 0) (* collectExp (lG0, G, (U, s), mode, (A, depth)) = (A\', depth\')\n       collects EVar\'s and BVar\'s in mode dependency order!\n       depth is needed to decide if a BVar is encountered for the first time.\n\n       Invariant:\n       Let A : auxiliary context,\n           depth : length of the subcontext of G, which must still\n                   be traversed and collected\n\n       If   G  |- s : G\'  and   G\' |- U : V\n       and  G = G0, G0\', GO\'\', Gp\n       and  . |- A Atx\n       and  |G0,  G0\', G0\'\'| =  lG0\n       and       |G0\', G0\'\'| = depth\n       then           |G0\'\'| = depth\'\n       and  . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- U [s]\n    *) let rec collectExp (lG0, G, Us, mode, Adepth)  = collectExpW (lG0, G, whnf Us, mode, Adepth)collectExpW (lG0, G, (Uni _, s), mode, Adepth)  = (* impossible? *)  Adepth | collectExpW (lG0, G, (Pi ((D, _), V), s), mode, Adepth)  = collectExp (lG0, Decl (G, decSub (D, s)), (V, dot1 s), mode, collectDec (lG0, G, (D, s), mode, Adepth)) | collectExpW (lG0, G, (Lam (D, U), s), mode, Adepth)  = collectExp (lG0, Decl (G, decSub (D, s)), (U, dot1 s), mode, collectDec (lG0, G, (D, s), mode, Adepth)) | collectExpW (lG0, G, Us as (Root (BVar (k), S), s), mode, Adepth as (A, depth))  = (* s = id *)  let l = ctxLength G in if (k = l + depth - lG0) && depth > 0 then (* invariant: all variables (EV or BV) in V already seen! *) let Dec (_, V) = ctxDec (G, k) in collectSpine (lG0, G, (S, s), mode, (Decl (A, BV), depth - 1)) else collectSpine (lG0, G, (S, s), mode, Adepth) | collectExpW (lG0, G, (Root (C, S), s), mode, Adepth)  = collectSpine (lG0, G, (S, s), mode, Adepth) | collectExpW (lG0, G, (EVar (r, GX, V, cnstrs), s), mode, Adepth as (A, depth))  = (match atxLookup (A, r) with NONE -> (* lGp\' >= 0 *) (* lGp\'\' >= 0 *) (* invariant: all variables (EV) in Vraised already seen *) let _ = checkEmpty (! cnstrs) let lGp\' = ctxLength GX - lG0 + depth let w = weaken (lGp\', GX, targetFam V) let iw = invert w let GX\' = strengthen (iw, GX) let lGp\'\' = ctxLength GX\' - lG0 + depth let Vraised = raiseType (lGp\'\', GX\', EClo (V, iw)) let X\' as EVar (r\', _, _, _) = newEVar (GX\', EClo (V, iw)) let _ = instantiateEVar (r, EClo (X\', w), nil) in collectSub (lG0, G, lGp\'\', s, mode, (Decl (A, EV (r\', Vraised, mode)), depth)) | SOME (EV (_, V, _)) -> let lGp\' = countPi V in collectSub (lG0, G, lGp\', s, mode, Adepth)) | collectExpW (lGO, G, (FgnExp csfe, s), mode, Adepth)  = fold csfe (fun (U, Adepth\') -> collectExp (lGO, G, (U, s), mode, Adepth\')) Adepth(* hack - should discuss with cs    -rv *) (* collectSub (lG0, G, lG\'\', s, mode, (A, depth)) = (A\', depth\')\n       collects EVar\'s and BVar\'s in mode dependency order!\n       depth is needed to decide if a BVar is encountered for the first time.\n\n       Invariant:\n       Let A : auxiliary context,\n           depth : length of the subcontext of G, which must still\n                   be traversed and collected\n\n       If   G  |- s : G\'\n       and  G = G0, G0\', GO\'\', Gp\n       and  . |- A Atx\n       and  |G0,  G0\', G0\'\'| =  lG0\n       and       |G0\', G0\'\'| = depth\n       and  G\' = GO, G\'\'\n       and  |G\'\'| = lG\'\'\n       then           |G0\'\'| = depth\'\n       and  . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- s   (for the first |G\'| elements of s)\n    *) collectSub (_, _, 0, _, _, Adepth)  = Adepth | collectSub (lG0, G, lG\', Shift (k), mode, Adepth)  = collectSub (lG0, G, lG\', Dot (Idx (k + 1), Shift (k + 1)), mode, Adepth) | collectSub (lG0, G, lG\', Dot (Idx (k), s), mode, Adepth as (A, depth))  = (* typing invariant guarantees that (EV, BV) in k : V already\n             collected !! *)  collectSub (lG0, G, lG\' - 1, s, mode, Adepth) | collectSub (lG0, G, lG\', Dot (Exp (U), s), mode, Adepth)  = (* typing invariant guarantees that (EV, BV) in V already\n             collected !! *)  collectSub (lG0, G, lG\' - 1, s, mode, collectExp (lG0, G, (U, id), mode, Adepth))(* collectSpine (lG0, G, (S, s), mode, (A, depth)) = (A\', depth\')\n       collects EVar\'s and BVar\'s in mode dependency order!\n       depth is needed to decide if a BVar is encountered for the first time.\n\n       Invariant:\n       Let A : auxiliary context,\n           depth : length of the subcontext of G, which must still\n                   be traversed and collected\n\n       If   G  |- s : G\'  and   G\' |- S : V > V\'\n       and  G = G0, G0\', GO\'\', Gp\n       and  . |- A Atx\n       and  |G0,  G0\', G0\'\'| =  lG0\n       and       |G0\', G0\'\'| = depth\n       then           |G0\'\'| = depth\'\n       and  . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- S\n    *) collectSpine (lG0, G, (Nil, _), mode, Adepth)  = Adepth | collectSpine (lG0, G, (SClo (S, s\'), s), mode, Adepth)  = collectSpine (lG0, G, (S, comp (s\', s)), mode, Adepth) | collectSpine (lG0, G, (App (U, S), s), mode, Adepth)  = collectSpine (lG0, G, (S, s), mode, collectExp (lG0, G, (U, s), mode, Adepth))(* collectDec (lG0, G, (x:D, s), mode, (A, depth)) = (A\', depth\')\n       collects EVar\'s and BVar\'s in mode dependency order!\n       depth is needed to decide if a BVar is encountered for the first time.\n\n       Invariant:\n       Let A : auxiliary context,\n           depth : length of the subcontext of G, which must still\n                   be traversed and collected\n\n       If   G  |- s : G\'  and   G\' |- D : L\n       and  G = G0, G0\', GO\'\', Gp\n       and  . |- A Atx\n       and  |G0,  G0\', G0\'\'| =  lG0\n       and       |G0\', G0\'\'| = depth\n       then           |G0\'\'| = depth\'\n       and  . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- x:D[s]\n    *) collectDec (lG0, G, (Dec (x, V), s), mode, Adepth)  = collectExp (lG0, G, (V, s), mode, Adepth) (* collectModeW (lG0, G, modeIn, modeRec, (V, s) (A, depth)) = (A\', depth\')\n       collects EVar\'s and BVar\'s in mode dependency order!\n       depth is needed to decide if a BVar is encountered for the first time.\n\n       Invariant:\n       Let A : auxiliary context,\n           depth : length of the subcontext of G, which must still\n                   be traversed and collected\n\n       If   G  |- s : G\'  and   G\' |- V : L        V[s] in whnf\n       and  G = G0, G0\', GO\'\', Gp\n       and  . |- A Atx\n       and  |G0,  G0\', G0\'\'| =  lG0\n       and       |G0\', G0\'\'| = depth\n       then           |G0\'\'| = depth\'\n       and  . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- V\n       and  A\'\' consists of all EVars/BVars marked with modeIn in V and\n                recored as modeRec\n    *) let rec collectModeW (lG0, G, modeIn, modeRec, (Root (Const cid, S), s), Adepth)  = (* s = id *)  let rec collectModeW\' (((Nil, _), Mnil), Adepth)  = Adepth | collectModeW\' (((SClo (S, s\'), s), M), Adepth)  = collectModeW\' (((S, comp (s\', s)), M), Adepth) | collectModeW\' (((App (U, S), s), Mapp (m, mS)), Adepth)  = collectModeW\' (((S, s), mS), if modeEq (m, modeIn) then collectExp (lG0, G, (U, s), modeRec, Adepth) else Adepth) let mS = valOf (modeLookup (cid)) in collectModeW\' (((S, s), mS), Adepth) | collectModeW (lG0, G, modeIn, modeRec, (Pi ((D, P), V), s), Adepth)  = raise (Error ("Implementation restricted to the Horn fragment of the meta logic")) (* collectG (lG0, G, (V, s) (A, depth)) = (A\', depth\')\n       collects EVar\'s and BVar\'s in mode dependency order!\n       depth is needed to decide if a BVar is encountered for the first time.\n\n       Invariant:\n       Let A : auxiliary context,\n           depth : length of the subcontext of G, which must still\n                   be traversed and collected\n\n       If   G  |- s : G\'  and   G\' |- V : L\n       and  G = G0, G0\', GO\'\', Gp\n       and  . |- A Atx\n       and  |G0,  G0\', G0\'\'| =  lG0\n       and       |G0\', G0\'\'| = depth\n       then           |G0\'\'| = depth\'\n       and  . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- V\n       and  A\'\' consists of all Top EVars/BVars in the head of V\n                    followed by Bot/Top EVars/BVars of recursive calls\n                    (A\'\' is in mode dependecy order)\n    *) let rec collectG (lG0, G, Vs, Adepth)  = collectGW (lG0, G, whnf Vs, Adepth)collectGW (lG0, G, Vs, Adepth)  = collectModeW (lG0, G, Bot, Top, Vs, collectModeW (lG0, G, Top, Bot, Vs, Adepth)) (* collectDTop (lG0, G, (V, s) (A, depth)) = (A\', depth\')\n       collects EVar\'s and BVar\'s in mode dependency order!\n       depth is needed to decide if a BVar is encountered for the first time.\n\n       Invariant:\n       Let A : auxiliary context,\n           depth : length of the subcontext of G, which must still\n                   be traversed and collected\n\n       If   G  |- s : G\'  and   G\' |- V : L\n       and  G = G0, G0\', GO\'\', Gp\n       and  . |- A Atx\n       and  |G0,  G0\', G0\'\'| =  lG0\n       and       |G0\', G0\'\'| = depth\n       then           |G0\'\'| = depth\'\n       and  . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- V\n       and  A\'\' consists of all Top EVars/BVars in the head of V\n                    followed by Bot/Top EVars/BVars of recursive calls\n                    (A\'\' is in mode dependecy order)\n    *) let rec collectDTop (lG0, G, Vs, Adepth)  = collectDTopW (lG0, G, whnf Vs, Adepth)collectDTopW (lG0, G, (Pi ((D as Dec (x, V1), No), V2), s), Adepth)  = (* only arrows *)  collectG (lG0, G, (V1, s), collectDTop (lG0, Decl (G, decSub (D, s)), (V2, dot1 s), Adepth)) | collectDTopW (lG0, G, Vs as (Root _, s), Adepth)  = (* s = id *)  collectModeW (lG0, G, Top, Top, Vs, Adepth) (* collectDBot (lG0, G, (V, s), (A, depth)) = (A\', depth\')\n       collects EVar\'s and BVar\'s in mode dependency order!\n       depth is needed to decide if a BVar is encountered for the first time.\n\n       Invariant:\n       Let A : auxiliary context,\n           depth : length of the subcontext of G, which must still\n                   be traversed and collected\n\n       If   G  |- s : G\'  and   G\' |- V : L\n       and  G = G0, G0\', GO\'\', Gp\n       and  . |- A Atx\n       and  |G0,  G0\', G0\'\'| =  lG0\n       and       |G0\', G0\'\'| = depth\n       then           |G0\'\'| = depth\'\n       and  . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- V\n       and  A\'\' consists of all Top EVars/BVars in the head of V\n                    followed by Bot/Top EVars/BVars of recursive calls\n                    followed by Top EVars/BVars in the head of V\n                    (A\'\' is in mode dependecy order)\n    *) let rec collectDBot (lG0, G, Vs, Adepth)  = collectDBotW (lG0, G, whnf Vs, Adepth)collectDBotW (lG0, G, (Pi ((D, _), V), s), Adepth)  = collectDBot (lG0, Decl (G, decSub (D, s)), (V, dot1 s), Adepth) | collectDBotW (lG0, G, Vs as (Root _, s), Adepth)  = (* s = id *)  collectModeW (lG0, G, Bot, Bot, Vs, Adepth) (* collect ((G,_,_), V) = A\'\n       collects EVar\'s and BVar\'s in V mode dependency order.\n\n       Invariant:\n       If   G  |- s : G\'  and   G\' |- V : L\n       then . |- A\' Atx\n       and  A\' = A, A\'\'\n       and  A\'\' ||- V\n       and  A\'\' consists of all Top EVars/BVars in the head of V\n                    followed by Bot/Top EVars/BVars of recursive calls\n                    followed by Top EVars/BVars in the head of V\n                    (A\'\' is in mode dependecy order)\n    *) let rec collect (Prefix (G, M, B), V)  = let lG0 = ctxLength G let (A, k) = collectDBot (lG0, G, (V, id), (collectDTop (lG0, G, (V, id), (Null, lG0)))) in A (*------------------------------------------------------------*) (* Second section: Abstracting over EVars and BVars that have *) (* been collected in mode dependency order                    *) (*------------------------------------------------------------*) (* lookupEV (A, r) = (k\', V\')\n\n       Invariant:\n\n       If   A ||- V\n       and  G |- X : V\' occuring in V\n       then G x A |- k : V\'\n       and  . |- V\' : type\n    *) let rec lookupEV (A, r)  = (* lookupEV\' I.Null cannot occur by invariant *) let rec lookupEV\' (Decl (A, EV (r, V, _)), r\', k)  = if (r = r\') then (k, V) else lookupEV\' (A, r\', k + 1) | lookupEV\' (Decl (A, BV), r\', k)  = lookupEV\' (A, r\', k + 1) in lookupEV\' (A, r, 1) (* lookupBV (A, i) = k\'\n\n       Invariant:\n\n       If   A ||- V\n       and  G |- V type\n       and  G [x] A |- i : V\'\n       then ex a substititution  G x A |- s : G [x] A\n       and  G x A |- k\' : V\'\'\n       and  G x A |- V\' [s] = V\'\' : type\n    *) let rec lookupBV (A, i)  = (* lookupBV\' I.Null cannot occur by invariant *) let rec lookupBV\' (Decl (A, EV (r, V, _)), i, k)  = lookupBV\' (A, i, k + 1) | lookupBV\' (Decl (A, BV), 1, k)  = k | lookupBV\' (Decl (A, BV), i, k)  = lookupBV\' (A, i - 1, k + 1) in lookupBV\' (A, i, 1) (* abstractExpW (A, G, depth, (U, s)) = U\'\n\n       Invariant:\n       If    G0, G |- s : G1   G1 |- U : V    (U,s) in whnf\n       and   |G| = depth\n       and   A is auxiliary context in mode dependency order\n       and   A ||- U  and  A ||- V\n       then  G0 x A, G |- U\' : V\'\n       and   . ||- U\' and . ||- V\'\n       and   U\' is in nf\n    *) let rec abstractExpW (A, G, depth, (V as Uni (L), s))  = V | abstractExpW (A, G, depth, (Pi ((D, P), V), s))  = piDepend ((abstractDec (A, G, depth, (D, s)), P), abstractExp (A, Decl (G, decSub (D, s)), depth + 1, (V, dot1 s))) | abstractExpW (A, G, depth, (Lam (D, U), s))  = Lam (abstractDec (A, G, depth, (D, s)), abstractExp (A, Decl (G, decSub (D, s)), depth + 1, (U, dot1 s))) | abstractExpW (A, G, depth, (Root (C as BVar k, S), s))  = (* s = id *)  if k > depth then let k\' = lookupBV (A, k - depth) in Root (BVar (k\' + depth), abstractSpine (A, G, depth, (S, s))) else Root (C, abstractSpine (A, G, depth, (S, s))) | abstractExpW (A, G, depth, (Root (C, S), s))  = (* s = id *)  Root (C, abstractSpine (A, G, depth, (S, s))) | abstractExpW (A, G, depth, (EVar (r, _, V, _), s))  = (* IMPROVE: remove the raised variable, replace by V -cs ?-fp *) let (k, Vraised) = lookupEV (A, r) in Root (BVar (k + depth), abstractSub (A, G, depth, (Vraised, id), s, targetFam V, Nil)) | abstractExpW (A, G, depth, (FgnExp csfe, s))  = apply csfe (fun U -> abstractExp (A, G, depth, (U, s)))(* hack - should discuss with cs     -rv *) (* abstractExp, same as abstractExpW, but (V, s) need not be in whnf *) abstractExp (A, G, depth, Us)  = abstractExpW (A, G, depth, whnf Us)(* abstractSpine (A, G, depth, (S, s)) = U\'\n\n       Invariant:\n       If    G0, G |- s : G1   G1 |- S : V1 > V2\n       and   |G| = depth\n       and   A is auxiliary context in mode dependency order\n       and   A ||- U  and  H ||- V1\n       then  G0 x A, G |- S\' : V1\' > V2\'\n       and   . ||- S\' and . ||- V1\'\n    *) abstractSpine (A, G, depth, (Nil, _))  = Nil | abstractSpine (A, G, depth, (App (U, S), s))  = App (abstractExp (A, G, depth, (U, s)), abstractSpine (A, G, depth, (S, s))) | abstractSpine (A, G, depth, (SClo (S, s\'), s))  = abstractSpine (A, G, depth, (S, comp (s\', s)))(* abstractSub (A, G, depth, (XV, t), s, b, S) = S\'\n\n       Invariant:\n       If    G0, G |- s : G\'\n       and   |G| = depth\n       and   A is auxiliary context in mode dependency order\n       and   A ||- s\n       then  G0 x A, G |- S\' : {XV [t]}.W > W\n       and   . ||- S\'\n    *) (* optimize: whnf not necessary *) abstractSub (A, G, depth, XVt, s, b, S)  = abstractSubW (A, G, depth, whnf XVt, s, b, S)abstractSubW (A, G, depth, (Root _, _), s, b, S)  = S | abstractSubW (A, G, depth, XVt as (Pi _, _), Shift k, b, S)  = abstractSub (A, G, depth, XVt, Dot (Idx (k + 1), Shift (k + 1)), b, S) | abstractSubW (A, G, depth, XVt as (Pi (_, XV\'), t), Dot (Idx (k), s), b, S)  = let Dec (x, V) = ctxDec (G, k) in if k > depth then let k\' = lookupBV (A, k - depth) in abstractSub (A, G, depth, (XV\', dot1 t), s, b, App (Root (BVar (k\' + depth), Nil), S)) else abstractSub (A, G, depth, (XV\', dot1 t), s, b, App (Root (BVar (k), Nil), S)) | abstractSubW (A, G, depth, XVt as (Pi (_, XV\'), t), Dot (Exp (U), s), b, S)  = abstractSub (A, G, depth, (XV\', dot1 t), s, b, App (abstractExp (A, G, depth, (U, id)), S))(* abstractDec (A, G, depth, (x:V, s)) = x:V\'\n\n       Invariant:\n       If    G0, G |- s : G1   G1 |- V : L\n       and   |G| = G\n       and   |G| = depth\n       and   A is auxiliary context in mode dependency order\n       and   A ||- V\n       then  G0 x A, G |- V\' : L\n       and   . ||- V\'\n    *) abstractDec (A, G, depth, (Dec (xOpt, V), s))  = Dec (xOpt, abstractExp (A, G, depth, (V, s))) (* abstractCtx (A, (G, M)) = ((G\', M\') , G\'\')\n\n       Let E be a list of EVars possibly occuring in G\n\n       Invariant:\n       G\' = G x A\n       M\' = M x A    (similar to G x A, but just represents mode information)\n       G\'\' = G [x] A\n    *) let rec abstractCtx (Null, GM as Prefix (Null, Null, Null))  = (GM, Null) | abstractCtx (Decl (A, BV), Prefix (Decl (G, D), Decl (M, marg), Decl (B, b)))  = let (Prefix (G\', M\', B\'), lG\') = abstractCtx (A, Prefix (G, M, B)) let D\' = abstractDec (A, G, 0, (D, id)) let Dec (_, V) = D\' let _ = if (! doubleCheck) then typecheck (Prefix (G\', M\', B\'), V) else () in (Prefix (Decl (G\', decName (G\', D\')), Decl (M\', marg), Decl (B\', b)), Decl (lG\', D\')) | abstractCtx (Decl (A, EV (r, V, m)), GM)  = let (Prefix (G\', M\', B\'), lG\') = abstractCtx (A, GM) let V\'\' = abstractExp (A, lG\', 0, (V, id)) let _ = if (! doubleCheck) then typecheck (Prefix (G\', M\', B\'), V\'\') else () in (Prefix (Decl (G\', decName (G\', Dec (NONE, V\'\'))), Decl (M\', m), Decl (B\', match m with Top -> ! maxSplit | Bot -> 0)), lG\') (* abstract ((G, M), V) = ((G\', M\') , V\')\n\n       Invariant:\n       If    G |- V : type    (M modes associated with G)\n       then  G\' |- V\' : type  (M\' modes associated with G\')\n       and   . ||- V\'\n    *) let rec abstract (S as State (name, GM as Prefix (G, M, B), V))  = let _ = varReset Null let A = collect (GM, V) let (GM\', _) = abstractCtx (A, GM) let V\' = abstractExp (A, G, 0, (V, id)) let S = State (name, GM\', V\') let _ = if (! doubleCheck) then typecheck (GM\', V\') else () in S let abstract = abstract  (* local *)  end\n(* functor MetaAbstract *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Meta Abstraction *) (* Author: Carsten Schuermann *) module type METAABSTRACT = sig module MetaSyn : METASYNexception Error of stringval abstract : State -> State end\n(* signature METAABSTRACT *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Strategy *) (* Author: Carsten Schuermann *) module type STRATEGY = sig module MetaSyn : METASYNval run : State list -> State list * State list(* open cases -> remaining cases * solved cases *)  end\n(* signature STRATEGY *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Prover *) (* Author: Carsten Schuermann *) module type PROVER = sig (*! structure IntSyn : INTSYN !*) exception Error of stringval init : (int * cid list) -> unitval auto : unit -> unitval print : unit -> unitval install : (ConDec -> cid) -> unit end\n(* signature PROVER *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Lemma *) (* Author: Carsten Schuermann *) module Lemma (module MetaSyn' : METASYNmodule MetaAbstract : METAABSTRACTMetaAbstractMetaSynMetaSyn') : LEMMA = struct module MetaSyn = MetaSyn' exception Error of string module A = MetaAbstractmodule M = MetaSynmodule I = IntSyn(* createEVars (G, M, B) = ((G', M', B'), s')\n\n       Invariant:\n       If   |- G ctx\n       then |- G' ctx\n       and  . |- s' : G\n       M and B are mode and bound contexts matching G, and similarly for M' and B'.\n    *) let rec createEVars (Prefix (Null, Null, Null))  = (Prefix (Null, Null, Null), id) | createEVars (Prefix (Decl (G, D), Decl (M, Top), Decl (B, b)))  = let (Prefix (G', M', B'), s') = createEVars (Prefix (G, M, B)) in (Prefix (Decl (G', decSub (D, s')), Decl (M', Top), Decl (B', b)), dot1 s') | createEVars (Prefix (Decl (G, Dec (_, V)), Decl (M, Bot), Decl (B, _)))  = let (Prefix (G', M', B'), s') = createEVars (Prefix (G, M, B)) let X = newEVar (G', EClo (V, s')) in (Prefix (G', M', B'), Dot (Exp (X), s')) (* apply (((G, M), V), a) = ((G', M'), V')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- M mtx\n       and  a is a type constant of type Va: Sigma (a) = Va\n       then |- G' ctx\n       and  G' |- M' mtx\n       and  G' |- S' : Va > type\n       and  G' |- s' : G\n       and  G' |- V' = {a S'}. V[s' o ^]\n       and  ((G', M'), V') is a state\n    *) let rec apply (State (name, GM, V), a)  = (* Vs' = type *) let (GM' as Prefix (G', M', B'), s') = createEVars GM let (U', Vs') = createAtomConst (G', Const a) in abstract (State (name, GM', Pi ((Dec (NONE, U'), No), EClo (V, comp (s', shift))))) let apply = apply  (* local *)  end\n(* functor lemma *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Initialization *) (* Author: Carsten Schuermann *) module Init (module MetaSyn\' : METASYNmodule MetaAbstract : METAABSTRACTMetaAbstractMetaSynMetaSyn\') : INIT = struct module MetaSyn = MetaSyn\' exception Error of string module M = MetaSynmodule I = IntSyn(* init c = S\'\n\n       Invariant:\n       If   c is type constant identifier\n       then S\' is initial prover state.\n    *) let rec init\' cid  = let (V, _) = createAtomConst (Null, Const cid) in abstract (State ("/" ^ conDecName (sgnLookup cid) ^ "/", Prefix (Null, Null, Null), V)) (* init c1 .. cn = S1 .. Sn\n\n       Invariant:\n       If   c1 .. cn are mutually recursive\n       then S1 .. Sn is an initial prover state.\n    *) let rec init cidList  = map init\' cidList let init = init  (* local *)  end\n(* functor Init *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Recursion *) (* Author: Carsten Schuermann *) (* See [Rohwedder,Pfenning ESOP\'96] *) module Recursion (module Global : GLOBALmodule MetaSyn\' : METASYNmodule Whnf : WHNF(*! sharing Whnf.IntSyn = MetaSyn\'.IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = MetaSyn\'.IntSyn !*) module Conv : CONV(*! sharing Conv.IntSyn = MetaSyn\'.IntSyn !*) module Names : NAMES(*! sharing Names.IntSyn = MetaSyn\'.IntSyn !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = MetaSyn\'.IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = MetaSyn\'.IntSyn !*) module Order : ORDER(*! sharing Order.IntSyn = MetaSyn\'.IntSyn !*) module ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = MetaSyn\'.IntSyn !*) module Lemma : LEMMALemmaMetaSynMetaSyn\'module Filling : FILLINGFillingMetaSynMetaSyn\'module MetaPrint : METAPRINTMetaPrintMetaSynMetaSyn\'module MetaAbstract : METAABSTRACTMetaAbstractMetaSynMetaSyn\'module Formatter : FORMATTER(*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = MetaSyn\'.IntSyn !*) ) : RECURSION = struct module MetaSyn = MetaSyn\' exception Error of string type operator = State module M = MetaSynmodule I = IntSynmodule O = Ordermodule N = Namesmodule F = Formattertype Quantifier = Universal | Existential (*     | Ex                      *) (* If Q marks all parameters in a context G we write   G : Q               *) (* duplicate code? -fp *) let rec vectorToString (G, O)  = let rec fmtOrder (Arg (Us, Vs))  = [String (expToString (G, EClo Us)); String ":"; String (expToString (G, EClo Vs))] | fmtOrder (Lex L)  = [String "{"; HVbox (fmtOrders L); String "}"] | fmtOrder (Simul L)  = [String "["; HVbox (fmtOrders L); String "]"]fmtOrders nil  = nil | fmtOrders (O :: nil)  = fmtOrder O | fmtOrders (O :: L)  = fmtOrder O @ (String " " :: fmtOrders L) in makestring_fmt (HVbox (fmtOrder O)) (* vector (c, (S, s)) = P\'\n\n       Invariant:\n       If   . |- c : V   G |- s : G\'    G\' |- S : V > type\n       and  V = {x1:V1} ... {xn:Vn} type\n       and  G |- S[s] = U1 .. Un : V[s] > type\n       and  sel (c) = i1 .. im\n       then P\' = (U1\'[s1\']: V1\'[t1\'], .., U1\'[sm\']: V1\'[tm\'])\n       and  G |- sj\' : Gj\'    Gj\' |- Uj\' : V1j\'\n       and  G |- tj\' : Gj\'    Gj\' |- Vj\' : L\n       and  G |- Vj\' [tj\'] = V1j\' [sj\'] : L\n       and  G |- Uik = Uk\'[sk\']\n    *) let rec vector (c, (S, s))  = let Vid = (constType c, id) let rec select\' (n, (Ss\', Vs\'\'))  = select\'W (n, (Ss\', whnf Vs\'\'))select\'W (1, ((App (U\', S\'), s\'), (Pi ((Dec (_, V\'\'), _), _), s\'\')))  = ((U\', s\'), (V\'\', s\'\')) | select\'W (n, ((SClo (S\', s1\'), s2\'), Vs\'\'))  = select\'W (n, ((S\', comp (s1\', s2\')), Vs\'\')) | select\'W (n, ((App (U\', S\'), s\'), (Pi ((Dec (_, V1\'\'), _), V2\'\'), s\'\')))  = select\' (n - 1, ((S\', s\'), (V2\'\', Dot (Exp (EClo (U\', s\')), s\'\')))) let rec select (Arg n)  = Arg (select\' (n, ((S, s), Vid))) | select (Lex L)  = Lex (map select L) | select (Simul L)  = Simul (map select L) in select (selLookup c) (* set_parameter (G, X, k, sc, ops) = ops\'\n\n       Invariant:\n       appends a list of recursion operators to ops after\n       instantiating X with all possible local parameters (between 1 and k)\n    *) let rec set_parameter (G, X as EVar (r, _, V, _), k, sc, ops)  = let rec set_parameter\' (0, ops\')  = ops\' | set_parameter\' (k\', ops\')  = let D\' as Dec (_, V\') = ctxDec (G, k\') let ops\'\' = trail (fun () -> if unifiable (G, (V, id), (V\', id)) && unifiable (G, (X, id), (Root (BVar k\', Nil), id)) then sc ops\' else ops\') in set_parameter\' (k\' - 1, ops\'\') in set_parameter\' (k, ops) (* ltinit (G, k, ((U1, s1), (V2, s2)), ((U3, s3), (V4, s4)), sc, ops) = ops\'\n\n       Invariant:\n       If   G = G0, Gp    (G0, global context, Gp, parameter context)\n       and  |Gp| = k\n       and  G |- s1 : G1   G1 |- U1 : V1\n       and  G |- s2 : G2   G2 |- V2 : L\n            G |- s3 : G1   G1 |- U3 : V3\n       and  G |- s4 : G2   G2 |- V4 : L\n       and  G |- V1[s1] == V2 [s2]\n       and  G |- V3[s3] == V4 [s5]\n       and  ops is a set of all all possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators\n    *) let rec ltinit (G, k, (Us, Vs), UsVs\', sc, ops)  = ltinitW (G, k, whnfEta (Us, Vs), UsVs\', sc, ops)ltinitW (G, k, (Us, Vs as (Root _, _)), UsVs\', sc, ops)  = lt (G, k, (Us, Vs), UsVs\', sc, ops) | ltinitW (G, k, ((Lam (D1, U), s1), (Pi (D2, V), s2)), ((U\', s1\'), (V\', s2\')), sc, ops)  = ltinit (Decl (G, decSub (D1, s1), (* = I.decSub (D2, s2) *) ), k + 1, ((U, dot1 s1), (V, dot1 s2)), ((U\', comp (s1\', shift)), (V\', comp (s2\', shift))), sc, ops)(* lt (G, k, ((U, s1), (V, s2)), (U\', s\'), sc, ops) = ops\'\n\n       Invariant:\n       If   G = G0, Gp    (G0, global context, Gp, parameter context)\n       and  |Gp| = k\n       and  G |- s1 : G1   G1 |- U1 : V1   (U1 [s1] in  whnf)\n       and  G |- s2 : G2   G2 |- V2 : L    (V2 [s2] in  whnf)\n            G |- s3 : G1   G1 |- U3 : V3\n       and  G |- s4 : G2   G2 |- V4 : L\n       and  k is the length of the local context\n       and  G |- V1[s1] == V2 [s2]\n       and  G |- V3[s3] == V4 [s5]\n       and  ops is a set of already calculuate possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators\n    *) (* Vs is Root!!! *) (* (Us\',Vs\') may not be eta-expanded!!! *) lt (G, k, (Us, Vs), (Us\', Vs\'), sc, ops)  = ltW (G, k, (Us, Vs), whnfEta (Us\', Vs\'), sc, ops)ltW (G, k, (Us, Vs), ((Root (Const c, S\'), s\'), Vs\'), sc, ops)  = ltSpine (G, k, (Us, Vs), ((S\', s\'), (constType c, id)), sc, ops) | ltW (G, k, (Us, Vs), ((Root (BVar n, S\'), s\'), Vs\'), sc, ops)  = if n <= k then (* n must be a local variable *) let Dec (_, V\') = ctxDec (G, n) in ltSpine (G, k, (Us, Vs), ((S\', s\'), (V\', id)), sc, ops) else ops | ltW (G, _, _, ((EVar _, _), _), _, ops)  = ops | ltW (G, k, ((U, s1), (V, s2)), ((Lam (D as Dec (_, V1\'), U\'), s1\'), (Pi ((Dec (_, V2\'), _), V\'), s2\')), sc, ops)  = if equiv (targetFam V, targetFam V1\')(* == I.targetFam V2\' *)  then (* enforce that X gets only bound to parameters *) (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\', s1\')) let sc\' = fun ops\' -> set_parameter (G, X, k, sc, ops\') in lt (G, k, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc\', ops) else if below (targetFam V1\', targetFam V) then (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\', s1\')) in lt (G, k, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc, ops) else opsltSpine (G, k, (Us, Vs), (Ss\', Vs\'), sc, ops)  = ltSpineW (G, k, (Us, Vs), (Ss\', whnf Vs\'), sc, ops)ltSpineW (G, k, (Us, Vs), ((Nil, _), _), _, ops)  = ops | ltSpineW (G, k, (Us, Vs), ((SClo (S, s\'), s\'\'), Vs\'), sc, ops)  = ltSpineW (G, k, (Us, Vs), ((S, comp (s\', s\'\')), Vs\'), sc, ops) | ltSpineW (G, k, (Us, Vs), ((App (U\', S\'), s1\'), (Pi ((Dec (_, V1\'), _), V2\'), s2\')), sc, ops)  = let ops\' = le (G, k, (Us, Vs), ((U\', s1\'), (V1\', s2\')), sc, ops) in ltSpine (G, k, (Us, Vs), ((S\', s1\'), (V2\', Dot (Exp (EClo (U\', s1\')), s2\'))), sc, ops\')(* eq (G, ((U, s1), (V, s2)), (U\', s\'), sc, ops) = ops\'\n\n       Invariant:\n       If   G |- s1 : G1   G1 |- U1 : V1   (U1 [s1] in  whnf)\n       and  G |- s2 : G2   G2 |- V2 : L    (V2 [s2] in  whnf)\n            G |- s3 : G1   G1 |- U3 : V3\n       and  G |- s4 : G2   G2 |- V4 : L\n       and  G |- V1[s1] == V2 [s2]\n       and  G |- V3[s3] == V4 [s5]\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators resulting from U[s1] = U\'[s\']\n    *) eq (G, (Us, Vs), (Us\', Vs\'), sc, ops)  = (trail (fun () -> if unifiable (G, Vs, Vs\') && unifiable (G, Us, Us\') then sc ops else ops))(* le (G, k, ((U, s1), (V, s2)), (U\', s\'), sc, ops) = ops\'\n\n       Invariant:\n       If   G = G0, Gp    (G0, global context, Gp, parameter context)\n       and  |Gp| = k\n       and  G |- s1 : G1   G1 |- U1 : V1   (U1 [s1] in  whnf)\n       and  G |- s2 : G2   G2 |- V2 : L    (V2 [s2] in  whnf)\n            G |- s3 : G1   G1 |- U3 : V3\n       and  G |- s4 : G2   G2 |- V4 : L\n       and  k is the length of the local context\n       and  G |- V1[s1] == V2 [s2]\n       and  G |- V3[s3] == V4 [s5]\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators resulting from U[s1] <= U\'[s\']\n    *) le (G, k, (Us, Vs), (Us\', Vs\'), sc, ops)  = let ops\' = eq (G, (Us, Vs), (Us\', Vs\'), sc, ops) in leW (G, k, (Us, Vs), whnfEta (Us\', Vs\'), sc, ops\')leW (G, k, ((U, s1), (V, s2)), ((Lam (D as Dec (_, V1\'), U\'), s1\'), (Pi ((Dec (_, V2\'), _), V\'), s2\')), sc, ops)  = if equiv (targetFam V, targetFam V1\')(* == I.targetFam V2\' *)  then (* = I.newEVar (I.EClo (V2\', s2\')) *) (* enforces that X can only bound to parameter *) let X = newEVar (G, EClo (V1\', s1\')) let sc\' = fun ops\' -> set_parameter (G, X, k, sc, ops\') in le (G, k, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc\', ops) else if below (targetFam V1\', targetFam V) then (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\', s1\')) in le (G, k, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc, ops) else ops | leW (G, k, (Us, Vs), (Us\', Vs\'), sc, ops)  = lt (G, k, (Us, Vs), (Us\', Vs\'), sc, ops) (* ordlt (G, O1, O2, sc, ops) = ops\'\n\n       Invariant:\n       If   G |- O1 augmented subterms\n       and  G |- O2 augmented subterms\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators of all instantiations of EVars s.t. O1 is\n            lexicographically smaller than O2\n    *) let rec ordlt (G, Arg UsVs, Arg UsVs\', sc, ops)  = ltinit (G, 0, UsVs, UsVs\', sc, ops) | ordlt (G, Lex L, Lex L\', sc, ops)  = ordltLex (G, L, L\', sc, ops) | ordlt (G, Simul L, Simul L\', sc, ops)  = ordltSimul (G, L, L\', sc, ops)(* ordltLex (G, L1, L2, sc, ops) = ops\'\n\n       Invariant:\n       If   G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators of all instantiations of EVars s.t. L1 is\n            lexicographically less then L2\n    *) ordltLex (G, nil, nil, sc, ops)  = ops | ordltLex (G, O :: L, O\' :: L\', sc, ops)  = let ops\' = trail (fun () -> ordlt (G, O, O\', sc, ops)) in ordeq (G, O, O\', fun ops\'\' -> ordltLex (G, L, L\', sc, ops\'\'), ops\')(* ordltSimul (G, L1, L2, sc, ops) = ops\'\n\n       Invariant:\n       If   G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators of all instantiations of EVars s.t. L1 is\n            simultaneously smaller than L2\n    *) ordltSimul (G, nil, nil, sc, ops)  = ops | ordltSimul (G, O :: L, O\' :: L\', sc, ops)  = let ops\'\' = trail (fun () -> ordlt (G, O, O\', fun ops\' -> ordleSimul (G, L, L\', sc, ops\'), ops)) in ordeq (G, O, O\', fun ops\' -> ordltSimul (G, L, L\', sc, ops\'), ops\'\')(* ordleSimul (G, L1, L2, sc, ops) = ops\'\n\n       Invariant:\n       If   G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators of all instantiations of EVars s.t. L1 is\n            simultaneously smaller than or equal to L2\n    *) ordleSimul (G, nil, nil, sc, ops)  = sc ops | ordleSimul (G, O :: L, O\' :: L\', sc, ops)  = ordle (G, O, O\', fun ops\' -> ordleSimul (G, L, L\', sc, ops\'), ops)(* ordeq (G, O1, O2, sc, ops) = ops\'\n\n       Invariant:\n       If   G |- O1 augmented subterms\n       and  G |- O2 augmented subterms\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators of all instantiations of EVars s.t. O1 is\n            convertible to O2\n    *) ordeq (G, Arg (Us, Vs), Arg (Us\', Vs\'), sc, ops)  = if unifiable (G, Vs, Vs\') && unifiable (G, Us, Us\') then sc ops else ops | ordeq (G, Lex L, Lex L\', sc, ops)  = ordeqs (G, L, L\', sc, ops) | ordeq (G, Simul L, Simul L\', sc, ops)  = ordeqs (G, L, L\', sc, ops)(* ordlteqs (G, L1, L2, sc, ops) = ops\'\n\n       Invariant:\n       If   G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n            recursion operators of all instantiations of EVars s.t. L1 is\n            convertible to L2\n    *) ordeqs (G, nil, nil, sc, ops)  = sc ops | ordeqs (G, O :: L, O\' :: L\', sc, ops)  = ordeq (G, O, O\', fun ops\' -> ordeqs (G, L, L\', sc, ops\'), ops)(* ordeq (G, O1, O2, sc, ops) = ops\'\n\n       Invariant:\n       If   G |- O1 augmented subterms\n       and  G |- O2 augmented subterms\n       and  ops is a set of already calculuated possible states\n       and  sc is success continuation\n       then ops\' is an extension of ops, containing all\n1           recursion operators of all instantiations of EVars s.t. O1 is\n            convertible to O2 or smaller than O2\n    *) ordle (G, O, O\', sc, ops)  = let ops\' = trail (fun () -> ordeq (G, O, O\', sc, ops)) in ordlt (G, O, O\', sc, ops\') (* createEVars (G, M) = ((G\', M\'), s\')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- M mtx\n       then |- G\' ctx\n       and  G\' |- M\' mtx\n       and  G\' |- s\' : G\n    *) let rec createEVars (Prefix (Null, Null, Null))  = (Prefix (Null, Null, Null), id) | createEVars (Prefix (Decl (G, D), Decl (M, Top), Decl (B, b)))  = let (Prefix (G\', M\', B\'), s\') = createEVars (Prefix (G, M, B)) in (Prefix (Decl (G\', decSub (D, s\')), Decl (M\', Top), Decl (B\', b)), dot1 s\') | createEVars (Prefix (Decl (G, Dec (_, V)), Decl (M, Bot), Decl (B, _)))  = let (Prefix (G\', M\', B\'), s\') = createEVars (Prefix (G, M, B)) let X = newEVar (G\', EClo (V, s\')) in (Prefix (G\', M\', B\'), Dot (Exp (X), s\')) (* select (G, (V, s)) = (G\', (V1\', s1\'), (V2\', s2\'))\n\n     Invariant:\n     If   G |- s : G1   G1 |- V : type\n     and  G |- V [s] = {V1} ... {Vn} a S\n     then G\' = G, V1 .. Vn\n     and  G\' |- s1\' : G1\'   G1\' |- V1\' : type\n     and  G\' |- s2\' : G2\'   G2\' |- V2\' : type\n     and  G\' |- V1\' [s1\'] = V1 [^n]\n     and  G\' |- V2\' [s2\'] = a S\n    *) let rec select (G, Vs)  = selectW (G, (whnf Vs))selectW (G, (Pi ((D as Dec (_, V1), _), V2), s))  = let rec select\' (G, (Vs1, Vs2))  = selectW\' (G, (Vs1, whnf Vs2))selectW\' (G, (Vs1, Vs2 as (Root _, _)))  = (G, (Vs1, Vs2)) | selectW\' (G, ((V1, s1), (Pi ((D, P), V2\'), s2)))  = select\' (Decl (G, decSub (D, s2)), ((V1, comp (s1, shift)), (V2\', dot1 s2))) in select\' (Decl (G, decSub (D, s)), ((V1, comp (s, shift)), (V2, dot1 s))) (* lemma (S, t, ops) = (G\', P\', P\'\', abstract\', ops\')\n\n       Invariant:\n       If   S state  (S = ((G, M), V)\n                     |- G ctx\n                     G |- M mtx\n                     G |- V = {V1} ... {Vn} a S)\n       and  S\' state derived from S by an inductive call to t\n       and  ops a list of operators\n       then G is context, where all - variables are replaced by EVars in S\'\n       and  P\' is induction variable vector of EVars in the inductive call\n       and  P\'\' is induction variable vector of the theorem S.\n       and  G\' |- P\' : (V1\' .. Vn\')\n              (where  t : {W1} ..{Wm} b S, and Vi\' are among W1 .. Wm)\n       and  G\'\' |- P\'\' : (V1\'\' .. Vn\'\')\n              (where  a : {W1} ..{Wm} b S, and Vi\'\' are among W1 .. Wm)\n\n    *) let rec lemma (S, t, ops)  = let State (name, GM, V) = apply (S, t) let (Prefix (G\', M\', B\'), s\') = createEVars GM let (G\'\', ((Root (Const a1, S1), s1), (Root (Const a2, S2), s2))) = select (G\', (V, s\')) in (G\'\', vector (a1, (S1, s1)), vector (a2, (S2, s2)), fun ops\' -> ((abstract (State (name, Prefix (G\', M\', B\'), EClo (V, s\')))) :: ops\'), ops) (* expandLazy\' (S, L, ops) = ops\'\n\n       Invariant:\n       If   S state\n       and  L list of mutual recursive type families\n       and  ops a list of operators\n       then ops\' extends ops by all operators\n         representing inductive calls to theorems in L\n    *) let rec expandLazy\' (S, Empty, ops)  = ops | expandLazy\' (S, (LE (t, L)), ops)  = expandLazy\' (S, L, ordle (lemma (S, t, ops))) | expandLazy\' (S, (LT (t, L)), ops)  = expandLazy\' (S, L, ordlt (lemma (S, t, ops))) let rec recursionDepth V  = let rec recursionDepth\' (Root _, n)  = n | recursionDepth\' (Pi (_, V), n)  = recursionDepth\' (V, n + 1) in recursionDepth\' (V, 0) (* expandLazy S = ops\'\n\n       Invariant:\n       If   S State\n       then ops\' a list of operations which cause a recursive call\n         (only induction variables are instantiated)\n    *) let rec expandLazy (S as State (_, _, V))  = if recursionDepth V > (! maxRecurse) then nil else expandLazy\' (S, (mutLookup (targetFam V)), nil) (* inputConv ((V1, s1), (V2, s2)) = B\n\n       Invariant:\n       If  G |- s1 : G1   G1 |- V1 : L\n       and G |- s2 : G2   G2 |- V2 : L\n       and G |- V1[s1] = c1 ; S1\n       and G |- V2[s2] = c2 ; S2\n       then B\' holds iff c1 =  c2 and V1[s1] ==+ V2[s2]   (convertible on + arguments of c1)\n    *) let rec inputConv (Vs1, Vs2)  = inputConvW (whnf Vs1, whnf Vs2)inputConvW ((Root (Const c1, S1), s1), (Root (Const c2, S2), s2))  = (* s1 = s2 = id *)  if c1 = c2 then inputConvSpine (valOf (modeLookup c1), ((S1, s1), (constType c1, id)), ((S2, s2), (constType c2, id))) else falseinputConvSpine (Mnil, ((S1, _), _), ((S2, _), _))  = true | inputConvSpine (mS, ((SClo (S1, s1\'), s1), Vs1), (Ss2, Vs2))  = inputConvSpine (mS, ((S1, comp (s1\', s1)), Vs1), (Ss2, Vs2)) | inputConvSpine (mS, (Ss1, Vs1), ((SClo (S2, s2\'), s2), Vs2))  = inputConvSpine (mS, (Ss1, Vs1), ((S2, comp (s2\', s2)), Vs2)) | inputConvSpine (Mapp (Marg (Minus, _), mS), ((App (U1, S1), s1), (Pi ((Dec (_, V1), _), W1), t1)), ((App (U2, S2), s2), (Pi ((Dec (_, V2), _), W2), t2)))  = conv ((V1, t1), (V2, t2)) && inputConvSpine (mS, ((S1, s1), (W1, Dot (Exp (EClo (U1, s1)), t1))), ((S2, s2), (W2, Dot (Exp (EClo (U1, s1)), t2)))) | inputConvSpine (Mapp (Marg (Plus, _), mS), ((App (U1, S1), s1), (Pi ((Dec (_, V1), _), W1), t1)), ((App (U2, S2), s2), (Pi ((Dec (_, V2), _), W2), t2)))  = inputConvSpine (mS, ((S1, s1), (W1, Dot (Exp (EClo (U1, s1)), t1))), ((S2, s2), (W2, Dot (Exp (EClo (U2, s2)), t2)))) (* removeDuplicates ops = ops\'\n\n       Invariant:\n       If   ops is a list of recursion operators,\n       then ops\' is a sublist of ops, s.t.\n         forall S = ((G, M), V) in ops\'\n               |- G ctx\n               G |- M mtx\n               G |- V = {V0} .. {Vn} a ; S : type\n               and Vi = ci ; S\'\n               and forall 1 <= i <= n:\n                 either ci =/= c0 orelse\n                 G, V0 .. Vi |- V0 [^ i] =/=+ Vi (not convertible on + arguments on c0)\n    *) let rec removeDuplicates nil  = nil | removeDuplicates (S\' :: ops)  = let rec compExp (Vs1, Vs2)  = compExpW (whnf Vs1, whnf Vs2)compExpW (Vs1, (Root _, _))  = false | compExpW (Vs1 as (V1, s1), (Pi ((D2, _), V2), s2))  = compDec (Vs1, (D2, s2)) || compExp ((V1, comp (s1, shift)), (V2, dot1 s2))compDec (Vs1, (Dec (_, V2), s2))  = inputConv (Vs1, (V2, s2)) let rec check (State (name, GM, V))  = checkW (whnf (V, id))checkW (Pi ((D, _), V), s)  = checkDec ((D, comp (s, shift)), (V, dot1 s))checkDec ((Dec (_, V1), s1), Vs2)  = compExp ((V1, s1), Vs2) in if check S\' then removeDuplicates ops else S\' :: (removeDuplicates ops) (* fillOps ops = ops\'\n\n       Invariant:\n       If   ops is a list of lazy recursion operators\n       then ops\' is a list of recursion operators combined with a filling\n         operator to fill non-index variables.\n    *) let rec fillOps nil  = nil | fillOps (S\' :: ops)  = let rec fillOps\' nil  = nil | fillOps\' (O :: _)  = (apply O) let (fillop, _) = expand S\' in (fillOps\' fillop) @ (fillOps ops) (* expandEager S = ops\'\n\n       Invariant:\n       If   S State\n       then ops\' a list of operations which cause a recursive call\n         (all variables of recursive call are instantiated)\n    *) let rec expandEager S  = removeDuplicates (fillOps (expandLazy S)) let rec apply S  = S let rec menu (S as State (name, Prefix (G\', M\', B\'), Pi ((Dec (_, V), _), _)))  = "Recursion : " ^ (expToString (G\', V)) let rec handleExceptions f P  = try  with let expandLazy = handleExceptions expandLazy let expandEager = handleExceptions expandEager let apply = apply let menu = menu  (* local *)  end\n(* functor Recursion *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {})])
('Error parsing code:', '(* Strategy *) (* Author: Carsten Schuermann *) module StrategyFRS (module MetaGlobal : METAGLOBALmodule MetaSyn\' : METASYNmodule Filling : FILLINGFillingMetaSynMetaSyn\'module Splitting : SPLITTINGSplittingMetaSynMetaSyn\'module Recursion : RECURSIONRecursionMetaSynMetaSyn\'module Lemma : LEMMALemmaMetaSynMetaSyn\'module Qed : QEDQedMetaSynMetaSyn\'module MetaPrint : METAPRINTMetaPrintMetaSynMetaSyn\'module Timers : TIMERS) : STRATEGY = struct module MetaSyn = MetaSyn\' module M = MetaSynlet rec printInit ()  = if ! chatter > 3 then print "Strategy 1.0: FRS\\n" else () let rec printFinish (State (name, _, _))  = if ! chatter > 5 then print ("[Finished: " ^ name ^ "]\\n") else if ! chatter > 4 then print ("[" ^ name ^ "]\\n") else if ! chatter > 3 then print ("[" ^ name ^ "]") else () let rec printFilling ()  = if ! chatter > 5 then print ("[Filling ... ") else if ! chatter > 4 then print ("F") else () let rec printRecursion ()  = if ! chatter > 5 then print ("[Recursion ...") else if ! chatter > 4 then print ("R") else () let rec printSplitting ()  = if ! chatter > 5 then print ("[Splitting ...") else if ! chatter > 4 then print ("S") else () let rec printCloseBracket ()  = if ! chatter > 5 then print ("]\\n") else () let rec printQed ()  = if ! chatter > 3 then print ("[QED]\\n") else () (* findMin L = Sopt\n\n       Invariant:\n\n       If   L be a set of splitting operators\n       then Sopt = NONE if L = []\n       else Sopt = SOME S, s.t. index S is minimal among all elements in L\n    *) let rec findMin nil  = NONE | findMin (O :: L)  = let rec findMin\' (nil, k, result)  = result | findMin\' (O\' :: L\', k, result)  = let k\' = index O\' in if index O\' < k then findMin\' (L\', k\', SOME O\') else findMin\' (L\', k, result) in findMin\' (L, index O, SOME O) (* split   (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n       recurse (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n       fill    (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n\n       Invariant:\n       openStates\' extends openStates and\n         contains the states resulting from givenStates which cannot be\n         solved using Filling, Recursion, and Splitting\n       solvedStates\' extends solvedStates and\n         contains the states resulting from givenStates which can be\n         solved using Filling, Recursion, and Splitting\n    *) let rec split (S :: givenStates, os as (openStates, solvedStates))  = match findMin ((time splitting expand) S) with NONE -> fill (givenStates, (S :: openStates, solvedStates)) | SOME splitOp -> let _ = printSplitting () let SL = (time splitting apply) splitOp let _ = printCloseBracket () in (try  with )recurse (S :: givenStates, os as (openStates, solvedStates))  = match (time recursion expandEager) S with nil -> split (S :: givenStates, os) | (recursionOp :: _) -> let _ = printRecursion () let S\' = (time recursion apply) recursionOp let _ = printCloseBracket () in (try  with )fill (nil, os)  = os | fill (S :: givenStates, os as (openStates, solvedStates))  = let rec fillOp ()  = match (time filling expand) S with (_, fillingOp) -> (try  with ) in try  with (* run givenStates = (openStates\', solvedStates\')\n\n       Invariant:\n       openStates\' contains the states resulting from givenStates which cannot be\n         solved using Filling, Recursion, and Splitting\n       solvedStates\' contains the states resulting from givenStates which can be\n         solved using Filling, Recursion, and Splitting\n     *) let rec run givenStates  = let _ = printInit () let os = fill (givenStates, (nil, nil)) let _ = match os with (nil, _) -> printQed () | _ -> () in os let run = run  (* local *)  end\n(* functor StrategyFRS *) module StrategyRFS (module MetaGlobal : METAGLOBALmodule MetaSyn\' : METASYNmodule Filling : FILLINGFillingMetaSynMetaSyn\'module Splitting : SPLITTINGSplittingMetaSynMetaSyn\'module Recursion : RECURSIONRecursionMetaSynMetaSyn\'module Lemma : LEMMALemmaMetaSynMetaSyn\'module Qed : QEDQedMetaSynMetaSyn\'module MetaPrint : METAPRINTMetaPrintMetaSynMetaSyn\'module Timers : TIMERS) : STRATEGY = struct module MetaSyn = MetaSyn\' module M = MetaSynlet rec printInit ()  = if ! chatter > 3 then print "Strategy 1.0: RFS\\n" else () let rec printFinish (State (name, _, _))  = if ! chatter > 5 then print ("[Finished: " ^ name ^ "]\\n") else if ! chatter > 4 then print ("[" ^ name ^ "]\\n") else if ! chatter > 3 then print ("[" ^ name ^ "]") else () let rec printFilling ()  = if ! chatter > 5 then print ("[Filling ... ") else if ! chatter > 4 then print ("F") else () let rec printRecursion ()  = if ! chatter > 5 then print ("[Recursion ...") else if ! chatter > 4 then print ("R") else () let rec printSplitting ()  = if ! chatter > 5 then print ("[Splitting ...") else if ! chatter > 4 then print ("S") else () let rec printCloseBracket ()  = if ! chatter > 5 then print ("]\\n") else () let rec printQed ()  = if ! chatter > 3 then print ("[QED]\\n") else () (* findMin L = Sopt\n\n       Invariant:\n\n       If   L be a set of splitting operators\n       then Sopt = NONE if L = []\n       else Sopt = SOME S, s.t. index S is minimal among all elements in L\n    *) let rec findMin nil  = NONE | findMin (O :: L)  = let rec findMin\' (nil, k, result)  = result | findMin\' (O\' :: L\', k, result)  = let k\' = index O\' in if index O\' < k then findMin\' (L\', k\', SOME O\') else findMin\' (L\', k, result) in findMin\' (L, index O, SOME O) (* split   (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n       recurse (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n       fill    (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n\n       Invariant:\n       openStates\' extends openStates and\n         contains the states resulting from givenStates which cannot be\n         solved using Filling, Recursion, and Splitting\n       solvedStates\' extends solvedStates and\n         contains the states resulting from givenStates which can be\n         solved using Filling, Recursion, and Splitting\n    *) let rec split (S :: givenStates, os as (openStates, solvedStates))  = match findMin ((time splitting expand) S) with NONE -> recurse (givenStates, (S :: openStates, solvedStates)) | SOME splitOp -> let _ = printSplitting () let SL = (time splitting apply) splitOp let _ = printCloseBracket () in (try  with )fill (nil, os)  = os | fill (S :: givenStates, os as (openStates, solvedStates))  = match (time filling expand) S with (_, fillingOp) -> (try  with )recurse (nil, os)  = os | recurse (S :: givenStates, os as (openStates, solvedStates))  = match (time recursion expandEager) S with nil -> fill (S :: givenStates, os) | (recursionOp :: _) -> let _ = printRecursion () let S\' = (time recursion apply) recursionOp let _ = printCloseBracket () in (try  with ) (* run givenStates = (openStates\', solvedStates\')\n\n       Invariant:\n       openStates\' contains the states resulting from givenStates which cannot be\n         solved using Filling, Recursion, and Splitting\n       solvedStates\' contains the states resulting from givenStates which can be\n         solved using Filling, Recursion, and Splitting\n     *) let rec run givenStates  = let _ = printInit () let os = recurse (givenStates, (nil, nil)) let _ = match os with (nil, _) -> printQed () | _ -> () in os let run = run  (* local *)  end\n(* functor StrategyRFS *) module Strategy (module MetaGlobal : METAGLOBALmodule MetaSyn\' : METASYNmodule StrategyFRS : STRATEGYStrategyFRSMetaSynMetaSyn\'module StrategyRFS : STRATEGYStrategyRFSMetaSynMetaSyn\') : STRATEGY = struct module MetaSyn = MetaSyn\' let rec run SL  = match ! strategy with RFS -> run SL | FRS -> run SL end\n(* functor Strategy *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {})])
('Error parsing code:', '(* Meta Prover Interface *) (* Author: Carsten Schuermann *) module Mpi (module MetaGlobal : METAGLOBALmodule MetaSyn\' : METASYNmodule Init : INITInitMetaSynMetaSyn\'module Filling : FILLINGFillingMetaSynMetaSyn\'module Splitting : SPLITTINGSplittingMetaSynMetaSyn\'module Recursion : RECURSIONRecursionMetaSynMetaSyn\'module Lemma : LEMMALemmaMetaSynMetaSyn\'module Strategy : STRATEGYStrategyMetaSynMetaSyn\'module Qed : QEDQedMetaSynMetaSyn\'module MetaPrint : METAPRINTMetaPrintMetaSynMetaSyn\'module Names : NAMES(*! sharing Names.IntSyn = MetaSyn\'.IntSyn !*) module Timers : TIMERSmodule Ring : RING) : MPI = struct module MetaSyn = MetaSyn\' exception Error of string module M = MetaSynmodule I = IntSyntype MenuItem = Filling of operator | Recursion of operator | Splitting of operator let Open : State ring ref = ref (init []) let Solved : State ring ref = ref (init []) let History : State ring * State ring list ref = ref nil let Menu : MenuItem list option ref = ref NONE let rec initOpen ()  = Open := init [] let rec initSolved ()  = Solved := init [] let rec empty ()  = empty (! Open) let rec current ()  = current (! Open) let rec delete ()  = Open := delete (! Open) let rec insertOpen S  = Open := insert (! Open, S) let rec insertSolved S  = Solved := insert (! Solved, S) let rec insert S  = if subgoal S then (insertSolved S; print (stateToString S); print "\\n[Subgoal finished]\\n"; print "\\n") else insertOpen S let rec collectOpen ()  = foldr :: nil (! Open) let rec collectSolved ()  = foldr :: nil (! Solved) let rec nextOpen ()  = Open := next (! Open) let rec pushHistory ()  = History := (! Open, ! Solved) :: (! History) let rec popHistory ()  = match (! History) with nil -> raise (Error "History stack empty") | (Open\', Solved\') :: History\' -> (History := History\'; Open := Open\'; Solved := Solved\') let rec abort s  = (print ("* " ^ s); raise (Error s)) let rec reset ()  = (initOpen (); initSolved (); History := nil; Menu := NONE) let rec cLToString (nil)  = "" | cLToString (c :: nil)  = (conDecName (sgnLookup c)) | cLToString (c :: L)  = (conDecName (sgnLookup c)) ^ ", " ^ (cLToString L) let rec SplittingToMenu (nil, A)  = A | SplittingToMenu (O :: L, A)  = SplittingToMenu (L, Splitting O :: A) let rec FillingToMenu (nil, A)  = A | FillingToMenu (O :: L, A)  = FillingToMenu (L, Filling O :: A) let rec RecursionToMenu (nil, A)  = A | RecursionToMenu (O :: L, A)  = RecursionToMenu (L, Recursion O :: A) let rec menu ()  = if empty () then Menu := NONE else let S = current () let SplitO = expand S let RecO = expandEager S let (FillO, FillC) = expand S in Menu := SOME (FillingToMenu ([FillC], FillingToMenu (FillO, RecursionToMenu (RecO, SplittingToMenu (SplitO, nil))))) let rec format k  = if k < 10 then (toString k) ^ ".  " else (toString k) ^ ". " let rec menuToString ()  = let rec menuToString\' (k, nil)  = "" | menuToString\' (k, Splitting O :: M)  = (menuToString\' (k + 1, M)) ^ "\\n" ^ (format k) ^ (menu O) | menuToString\' (k, Filling O :: M)  = (menuToString\' (k + 1, M)) ^ "\\n" ^ (format k) ^ (menu O) | menuToString\' (k, Recursion O :: M)  = (menuToString\' (k + 1, M)) ^ "\\n" ^ (format k) ^ (menu O) in match ! Menu with NONE -> raise (Error "Menu is empty") | SOME M -> menuToString\' (1, M) let rec makeConDec (State (name, Prefix (G, M, B), V))  = let rec makeConDec\' (Null, V, k)  = ConDec (name, NONE, k, Normal, V, Type) | makeConDec\' (Decl (G, D), V, k)  = makeConDec\' (G, Pi ((D, Maybe), V), k + 1) in (makeConDec\' (G, V, 0)) let rec makeSignature (nil)  = SgnEmpty | makeSignature (S :: SL)  = ConDec (makeConDec S, makeSignature SL) let rec extract ()  = if empty () then makeSignature (collectSolved ()) else (print "[Error: Proof not completed yet]\\n"; SgnEmpty) let rec show ()  = print (sgnToString (extract ()) ^ "\\n") let rec printMenu ()  = if empty () then (show (); print "[QED]\\n") else let S = current () in (print "\\n"; print (stateToString S); print "\\nSelect from the following menu:\\n"; print (menuToString ()); print "\\n") let rec contains (nil, _)  = true | contains (x :: L, L\')  = (exists (fun x\' -> x = x\') L\') && contains (L, L\') let rec equiv (L1, L2)  = contains (L1, L2) && contains (L2, L1) let rec init\' (k, cL as (c :: _))  = (* if no termination ordering given! *) let _ = maxFill := k let _ = reset () let cL\' = try  with  in if equiv (cL, cL\') then map (fun S -> insert S) (init cL) else raise (Error ("Theorem by simultaneous induction not correctly stated:" ^ "\\n            expected: " ^ (cLToString cL\'))) let rec init (k, nL)  = let rec cids nil  = nil | cids (name :: nL)  = (match stringToQid name with NONE -> raise (Error ("Malformed qualified identifier " ^ name)) | SOME qid -> (match constLookup qid with NONE -> raise (Error ("Type family " ^ qidToString qid ^ " not defined")) | SOME cid -> cid :: (cids nL))) in (try  with ) let rec select k  = let rec select\' (k, nil)  = abort ("No such menu item") | select\' (1, Splitting O :: _)  = let S\' = (time splitting apply) O let _ = pushHistory () let _ = delete () let _ = map insert S\' in (menu (); printMenu ()) | select\' (1, Recursion O :: _)  = let S\' = (time recursion apply) O let _ = pushHistory () let _ = delete () let _ = insert S\' in (menu (); printMenu ()) | select\' (1, Filling O :: _)  = let _ = match (time filling apply) O with nil -> abort ("Filling unsuccessful: no object found") | (S :: _) -> (delete (); insert S; pushHistory ()) in (menu (); printMenu ()) | select\' (k, _ :: M)  = select\' (k - 1, M) in try  with let rec lemma name  = if empty () then raise (Error "Nothing to prove") else let S = current () let S\' = try  with  let _ = pushHistory () let _ = delete () let _ = insert S\' in (menu (); printMenu ()) let rec solve ()  = if empty () then raise (Error "Nothing to prove") else let S = current () let (Open\', Solved\') = try  with  let _ = pushHistory () let _ = delete () let _ = map insertOpen Open\' let _ = map insertSolved Solved\' in (menu (); printMenu ()) let rec auto ()  = let (Open\', Solved\') = try  with  let _ = pushHistory () let _ = initOpen () let _ = map insertOpen Open\' let _ = map insertSolved Solved\' in (menu (); printMenu ()) let rec next ()  = (nextOpen (); menu (); printMenu ()) let rec undo ()  = (popHistory (); menu (); printMenu ()) let init = init let select = select let print = printMenu let next = next let lemma = lemma let reset = reset let solve = solve let auto = auto let extract = extract let show = show let undo = undo  (* local *)  end\n(* functor MPI *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Filling *) (* Author: Carsten Schuermann *) module Filling (module MetaSyn\' : METASYNmodule MetaAbstract : METAABSTRACTMetaAbstractMetaSynMetaSyn\'module Search : OLDSEARCHSearchMetaSynMetaSyn\'module Whnf : WHNF(*! sharing Whnf.IntSyn = MetaSyn\'.IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = MetaSyn\'.IntSyn !*) ) : FILLING = struct module MetaSyn = MetaSyn\' exception Error of string exception TimeOut type operator = (State * int) * (unit -> State list) module M = MetaSynmodule I = IntSynexception Success of State let rec delay (search, Params) ()  = (try  with ) let rec makeAddressInit S k  = (S, k) let rec makeAddressCont makeAddress k  = makeAddress (k + 1) (* operators (G, GE, (V, s), abstract, makeAddress) = (OE\', OL\')\n\n       Invariant:\n       If   G |- s : G1   G1 |- V : type\n       and  abstract is an abstraction continuation\n       and  makeAddress is continuation which calculates the correct\n         debruijn index of the variable being filled\n       and V = {V1}...{Vn} V\'\n       then OE\' is an operator list, OL\' is a list with one operator\n         where the ith O\' in OE\' corresponds to a function which generates ALL possible\n                                      successor states instantiating - non-index variables\n                                      with terms (if possible) in Vi\n        and OL\' is a list containing one operator which instantiates all - non-index variables\n          in V\' with the smallest possible terms.\n    *) let rec operators (G, GE, Vs, abstractAll, abstractEx, makeAddress)  = operatorsW (G, GE, whnf Vs, abstractAll, abstractEx, makeAddress)operatorsW (G, GE, Vs as (Root (C, S), _), abstractAll, abstractEx, makeAddress)  = (nil, (makeAddress 0, delay (fun Params -> (try  with ), (G, GE, Vs, abstractEx)))) | operatorsW (G, GE, (Pi ((D as Dec (_, V1), P), V2), s), abstractAll, abstractEx, makeAddress)  = let (GO\', O) = operators (Decl (G, decSub (D, s)), GE, (V2, dot1 s), abstractAll, abstractEx, makeAddressCont makeAddress) in ((makeAddress 0, delay (searchAll, (G, GE, (V1, s), abstractAll))) :: GO\', O) (* createEVars (G, M) = ((G\', M\'), s\', GE\')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- M mtx\n       then |- G\' ctx\n       and  G\' |- M\' mtx\n       and  G\' |- s\' : G\n       and  GE a list of EVars\n\n    *) let rec createEVars (Prefix (Null, Null, Null))  = (Prefix (Null, Null, Null), id, nil) | createEVars (Prefix (Decl (G, D), Decl (M, Top), Decl (B, b)))  = let (Prefix (G\', M\', B\'), s\', GE\') = createEVars (Prefix (G, M, B)) in (Prefix (Decl (G\', decSub (D, s\')), Decl (M\', Top), Decl (B\', b)), dot1 s\', GE\') | createEVars (Prefix (Decl (G, Dec (_, V)), Decl (M, Bot), Decl (B, _)))  = let (Prefix (G\', M\', B\'), s\', GE\') = createEVars (Prefix (G, M, B)) let X = newEVar (G\', EClo (V, s\')) let X\' = lowerEVar X in (Prefix (G\', M\', B\'), Dot (Exp (X), s\'), X\' :: GE\') (* expand\' ((G, M), V) = (OE\', OL\')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- M mtx\n       and  G |- V type\n       and  V = {V1}...{Vn} V\'\n       then OE\' is an operator list, OL\' is a list with one operator\n         where the ith O\' in OE\' corresponds to a function which generates ALL possible\n                                      successor states instantiating - non-index variables\n                                      with terms (if possible) in Vi\n        and OL\' is a list containing one operator which instantiates all - non-index variables\n          in V\' with the smallest possible terms.\n    *) let rec expand (S as State (name, Prefix (G, M, B), V))  = let (Prefix (G\', M\', B\'), s\', GE\') = createEVars (Prefix (G, M, B)) let rec abstractAll acc  = (try  with ) let rec abstractEx ()  = try  with in operators (G\', GE\', (V, s\'), abstractAll, abstractEx, makeAddressInit S) (* apply (S, f) = S\'\n\n       Invariant:\n       S is state and f is a function constructing the successor state S\'\n    *) let rec apply (_, f)  = f () let rec menu ((State (name, Prefix (G, M, B), V), k), Sl)  = (* no cases for\n              toSTring (G, I.Root _, k) for k <> 0\n            *) let rec toString (G, Pi ((Dec (_, V), _), _), 0)  = expToString (G, V) | toString (G, V as Root _, 0)  = expToString (G, V) | toString (G, Pi ((D, _), V), k)  = toString (Decl (G, D), V, k - 1) in "Filling   : " ^ toString (G, V, k) let expand = expand let apply = apply let menu = menu  (* local *)  end\n(* functor Filling *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Global parameters *) (* Author: Carsten Schuermann *) module MetaGlobalMETAGLOBAL = struct type Strategy = RFS | FRS let strategy = ref FRS let maxFill = ref 6 let maxSplit = ref 2 let maxRecurse = ref 10 end\n(* structure MetaGlobal *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Prover *) (* Author: Carsten Schuermann *) module Prover (module MetaGlobal : METAGLOBALmodule MetaSyn\' : METASYNmodule Init : INITInitMetaSynMetaSyn\'module Strategy : STRATEGYStrategyMetaSynMetaSyn\'module Filling : FILLINGFillingMetaSynMetaSyn\'module Splitting : SPLITTINGSplittingMetaSynMetaSyn\'module Recursion : RECURSIONRecursionMetaSynMetaSyn\'module Qed : QEDQedMetaSynMetaSyn\'module MetaPrint : METAPRINTMetaPrintMetaSynMetaSyn\'module Names : NAMES(*! sharing Names.IntSyn = MetaSyn\'.IntSyn !*) module Timers : TIMERS) : PROVER = struct (*! structure IntSyn = MetaSyn\'.IntSyn !*)  exception Error of string module MetaSyn = MetaSyn\'module M = MetaSynmodule I = IntSyn(* List of open states *) let openStates : State list ref = ref nil (* List of solved states *) let solvedStates : State list ref = ref nil let rec error s  = raise (Error s) (* reset () = ()\n\n       Invariant:\n       Resets the internal state of open states/solved states\n    *) let rec reset ()  = (openStates := nil; solvedStates := nil) (* contains (L1, L2) = B\'\n\n       Invariant:\n       B\' holds iff L1 subset of L2 (modulo permutation)\n    *) let rec contains (nil, _)  = true | contains (x :: L, L\')  = (exists (fun x\' -> x = x\') L\') && contains (L, L\') (* equiv (L1, L2) = B\'\n\n       Invariant:\n       B\' holds iff L1 is equivalent to L2 (modulo permutation)\n    *) let rec equiv (L1, L2)  = contains (L1, L2) && contains (L2, L1) (* insertState S = ()\n\n       Invariant:\n       If S is successful prove state, S is stored in solvedStates\n       else S is stored in openStates\n    *) let rec insertState S  = if subgoal S then solvedStates := S :: (! solvedStates) else openStates := S :: (! openStates) (* cLtoString L = s\n\n       Invariant:\n       If   L is a list of cid,\n       then s is a string, listing their names\n    *) let rec cLToString (nil)  = "" | cLToString (c :: nil)  = (conDecName (sgnLookup c)) | cLToString (c :: L)  = (conDecName (sgnLookup c)) ^ ", " ^ (cLToString L) (* init (k, cL) = ()\n\n       Invariant:\n       If   k is the maximal search depth\n       and  cL is a complete and consistent list of cids\n       then init initializes the openStates/solvedStates\n       else an Error exception is raised\n    *) let rec init (k, cL as (c :: _))  = (* if no termination ordering given! *) let _ = maxFill := k let _ = reset () let cL\' = try  with  in if equiv (cL, cL\') then app (fun S -> insertState S) (init cL) else raise (Error ("Theorem by simultaneous induction not correctly stated:" ^ "\\n            expected: " ^ (cLToString cL\'))) (* auto () = ()\n\n       Invariant:\n       Solves as many States in openStates\n       as possible.\n    *) let rec auto ()  = let _ = print "M2.Prover.auto\\n" let (Open, solvedStates\') = try  with  let _ = openStates := Open let _ = solvedStates := (! solvedStates) @ solvedStates\' in if (length (! openStates)) > 0 then raise (Error ("A proof could not be found")) else () (* makeConDec (name, (G, M), V) = e\'\n\n       Invariant:\n       If   |- G ctx\n       and  G |- M mtx\n       and  G |- V : type\n       then e\' = (name, |G|, {G}.V, Type) is a signature conDec\n    *) let rec makeConDec (State (name, Prefix (G, M, B), V))  = let rec makeConDec\' (Null, V, k)  = ConDec (name, NONE, k, Normal, V, Type) | makeConDec\' (Decl (G, D), V, k)  = makeConDec\' (G, Pi ((D, Maybe), V), k + 1) in (makeConDec\' (G, V, 0)) (* makeSignature (SL) = IS\'\n\n       Invariant:\n       If   SL is a list of states,\n       then IS\' is the corresponding interface signaure\n    *) let rec makeSignature (nil)  = SgnEmpty | makeSignature (S :: SL)  = ConDec (makeConDec S, makeSignature SL) (* install () = ()\n\n       Invariant:\n       Installs solved states into the global signature.\n    *) let rec install (installConDec)  = let rec install\' SgnEmpty  = () | install\' (ConDec (e, S))  = (installConDec e; install\' S) let IS = if (length (! openStates)) > 0 then raise (Error ("Theorem not proven")) else makeSignature (! solvedStates) in (install\' IS; if ! chatter > 2 then (print "% ------------------\\n"; print (sgnToString (IS)); print "% ------------------\\n") else ()) (* print () = ()\n\n       Invariant:\n       Prints the list of open States and the list of closed states.\n    *) let rec printState ()  = let rec print\' nil  = () | print\' (S :: L)  = (print (stateToString S); print\' L) in (print "Open problems:\\n"; print "==============\\n\\n"; print\' (! openStates); print "Solved problems:\\n"; print "================\\n\\n"; print\' (! solvedStates)) let print = printState let init = init let auto = auto let install = install  (* local *)  end\n(* functor Prover *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Initialization *) (* Author: Carsten Schuermann *) module type INIT = sig module MetaSyn : METASYNexception Error of stringval init : cid list -> State list end\n(* signature INIT *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Splitting *) (* Author: Carsten Schuermann *) module type SPLITTING = sig module MetaSyn : METASYNexception Error of stringtype operatorval expand : State -> operator listval apply : operator -> State listval var : operator -> intval menu : operator -> stringval index : operator -> int end\n(* signature SPLITTING *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Recursion *) (* Author: Carsten Schuermann *) module type RECURSION = sig module MetaSyn : METASYNexception Error of stringtype operatorval expandLazy : State -> operator listval expandEager : State -> operator listval apply : operator -> Stateval menu : operator -> string end\n(* signature RECURSION *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta syntax *) (* Author: Carsten Schuermann *) module type METASYN = sig (*! structure IntSyn : INTSYN !*) type ModeBotTop(*     | Top                  *) type PrefixPrefixdctx(* G   declarations           *)  * Mode Ctx(* Mtx modes                  *)  * int Ctx(* Btx splitting depths       *) type StateStatestring(*             [name]         *)  * Prefix(*             G; Mtx; Btx    *)  * Exp(*             |- V           *) type SgnSgnEmptyConDecConDec * Sgn(*      | c:V, IS             *) val createAtomConst : dctx * Head -> (Exp * eclo)val createAtomBVar : dctx * int -> (Exp * eclo) end\n(* signature METASYN *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Filling *) (* Author: Carsten Schuermann *) module type FILLING = sig module MetaSyn : METASYNexception Error of stringexception TimeOuttype operatorval expand : State -> operator list * operator(*\n    gets a list of operators, which fill in several non index variables\n    on one level simultaneously\n  *) val apply : operator -> State list(*\n    in the case of an induction hypothesis, an operator can transform a\n    state into several states. In the case of just filling in the existential\n    parameters, there will by only one resulting state (we only need ONE\n    witness instantiation of the variables \n  *) val menu : operator -> string end', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* QED *) (* Author: Carsten Schuermann *) module Qed (module Global : GLOBALmodule MetaSyn' : METASYN) : QED = struct module MetaSyn = MetaSyn' exception Error of string module M = MetaSynmodule I = IntSynlet rec subgoal (State (name, Prefix (G, M, B), V))  = let rec check Null  = true | check (Decl (M, Top))  = check M | check (Decl (M, Bot))  = false in check M let subgoal = subgoal  (* local *)  end\n(* functor Qed *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Meta syntax *) (* Author: Carsten Schuermann *) module MetaSyn ((*! structure IntSyn' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn' !*) ) : METASYN = struct (*! structure IntSyn = IntSyn' !*)  exception Error of string type Var = int type Mode = Bot | Top (*     | Top                  *)  type Prefix = Prefix of dctx(* G   declarations           *)  * Mode Ctx(* Mtx modes                  *)  * int Ctx (* Btx splitting depths       *)  type State = State of string(*             [name]         *)  * Prefix(*             G; Mtx; Btx    *)  * Exp (*             |- V           *)  type Sgn = SgnEmpty | ConDec of ConDec * Sgn (*      | c:V, IS             *)  module I = IntSyn(* createEVarSpineW (G, (V, s)) = ((V', s') , S')\n\n       Invariant:\n       If   G |- s : G1   and  G1 |- V = Pi {V1 .. Vn}. W : L\n       and  G1, V1 .. Vn |- W atomic\n       then G |- s' : G2  and  G2 |- V' : L\n       and  S = X1; ...; Xn; Nil\n       and  G |- W [1.2...n. s o ^n] = V' [s']\n       and  G |- S : V [s] >  V' [s']\n    *) let rec createEVarSpine (G, Vs)  = createEVarSpineW (G, whnf Vs)createEVarSpineW (G, Vs as (Uni Type, s))  = (Nil, Vs) | createEVarSpineW (G, Vs as (Root _, s))  = (Nil, Vs) | createEVarSpineW (G, (Pi ((D as Dec (_, V1), _), V2), s))  = let X = newEVar (G, EClo (V1, s)) let (S, Vs) = createEVarSpine (G, (V2, Dot (Exp (X), s))) in (App (X, S), Vs) (* createAtomConst (G, c) = (U', (V', s'))\n\n       Invariant:\n       If   S |- c : Pi {V1 .. Vn}. V\n       then . |- U' = c @ (Xn; .. Xn; Nil)\n       and  . |- U' : V' [s']\n    *) let rec createAtomConst (G, H)  = let cid = (match H with (Const cid) -> cid | (Skonst cid) -> cid) let V = constType cid let (S, Vs) = createEVarSpine (G, (V, id)) in (Root (H, S), Vs) (* createAtomBVar (G, k) = (U', (V', s'))\n\n       Invariant:\n       If   G |- k : Pi {V1 .. Vn}. V\n       then . |- U' = k @ (Xn; .. Xn; Nil)\n       and  . |- U' : V' [s']\n    *) let rec createAtomBVar (G, k)  = let Dec (_, V) = ctxDec (G, k) let (S, Vs) = createEVarSpine (G, (V, id)) in (Root (BVar (k), S), Vs) let createAtomConst = createAtomConst let createAtomBVar = createAtomBVar  end(* functor MetaSyn *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Tabled Syntax *) (* Author: Brigitte Pientka *) module TabledSyn ((*! structure IntSyn' : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn' !*) module Table : TABLE where keyintmodule Index : INDEX(*! sharing Index.IntSyn = IntSyn' !*) ) : TABLEDSYN = struct (*! structure IntSyn = IntSyn' !*)  exception Error of string type Tabled = yes | no (*  datatype ModeSpine = Mnil | Mapp of Marg * ModeSpine\n  and  Marg = Marg of Mode * string option\n  *)  module I = IntSynlet tabledSignature : bool Table = new (0) (* reset () = ()\n\n       Effect: Resets tabled array\n    *) let rec reset ()  = clear tabledSignature (* installTabled (a, tabled) = ()\n\n       Effect: the tabled is stored with the type family a\n    *) let rec installTabled a  = insert tabledSignature (a, false) (* installTabled (a, tabled) = ()\n\n       Effect: the tabled is stored with the type family a\n    *) let rec installKeepTable a  = ((* Table.delete tabledSignature a; *) insertShadow tabledSignature (a, true); ()) (* tablingLookup a = bool\n\n       Looks up whether the predicat a is tabled\n\n    *) let rec tabledLookup a  = (match (lookup tabledSignature a) with NONE -> false | SOME _ -> true) (* keepTable a = bool\n\n       if we should keep the table for this predicate a\n        then returns true\n          otherwise false\n    *) let rec keepTable a  = (match (lookup tabledSignature a) with NONE -> false | SOME true -> true | SOME false -> false) let reset = reset let installTabled = installTabled let installKeepTable = installKeepTable let tabledLookup = tabledLookup let keepTable = keepTable  end\n(* functor TabledSyn *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Tabled Syntax *) (* Author: Brigitte Pientka *) module type TABLEDSYN = sig (*! structure IntSyn : INTSYN !*) exception Error of stringval reset : unit -> unitval installTabled : cid -> unitval installKeepTable : cid -> unitval tabledLookup : cid -> boolval keepTable : cid -> bool end\n(* signature TABLEDSYN *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: module TabledSyn = TabledSyn(struct module Names = Names module Table = IntRedBlackTree module Index = Index end)

('Error parsing code:', '(* Substitution Trees *) (* Author: Brigitte Pientka *) module type SUBTREE = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN     !*) (*! structure RBSet : RBSET  !*) type nvar = int(* index for normal variables *) type bvar = int(* index for bound variables *) type bdepth = int(* depth of locally bound variables *) (* normal (linear) substitutions *) (*  type normalSubsts = (IntSyn.Dec IntSyn.Ctx * IntSyn.Exp) RBSet.ordSet *) type typeLabelTypeLabelBodytype normalSubsts = typeLabel * Exp ordSettype querySubsts = Dec Ctx * (typeLabel * Exp) ordSettype CGoalCGoalsAuxGoal * cid * Conjunction * int(* assignable (linear) subsitutions *) type AssSubAssignDec Ctx * Exptype assSubsts = AssSub ordSet(* key = int = bvar *) type CnstrEqnDec Ctx * Exp * Exptype TreeLeafnormalSubsts * Dec Ctx * CGoalNodenormalSubsts * Tree ordSet(*  type candidate = assSubsts * normalSubsts * cnstrSubsts * Cnstr * IntSyn.Dec IntSyn.Ctx * CGoal *) val indexArray : (int ref) * (Tree ref) arrayval sProgReset : unit -> unitval sProgInstall : (cid * CompHead * Conjunction) -> unitval matchSig : cid * Dec Ctx * eclo * ((Conjunction * Sub) * cid -> unit) -> unit(*  val goalToString : string -> IntSyn.Dec IntSyn.Ctx * CompSyn.Goal * IntSyn.Sub -> string *)  end\n(* signature SUBTREE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Printer for Compiled Syntax *) (* Author: Iliano Cervesato *) module type CPRINT = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN !*) val goalToString : string -> dctx * Goal -> stringval clauseToString : string -> dctx * ResGoal -> stringval sProgToString : unit -> stringval dProgToString : DProg -> stringval subgoalsToString : string -> dctx * Conjunction -> string end\n(* signature CPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Now in compsyn.fun *) (*
structure CompSyn =
  CompSyn (structure Global = Global
           (*! structure IntSyn' = IntSyn !*)
	   structure Names = Names
           structure Table = IntRedBlackTree);
*) module CPrint = CPrint(struct module Print = Print module Formatter = Formatter module Names = Names end)
module SubTree = SubTree(struct module IntSyn' = IntSyn module Whnf = Whnf module Unify = UnifyTrail module CompSyn' = CompSyn module Print = Print module CPrint = CPrint module Names = Names module Formatter = Formatter module CSManager = CSManager module Table = IntRedBlackTree module RBSet = RBSet end)module Compile = Compile(struct module Whnf = Whnf module TypeCheck = TypeCheck module SubTree = SubTree module CPrint = CPrint module Print = Print module Names = Names end)
module Assign = Assign(struct module Whnf = Whnf module Unify = UnifyTrail module Print = Print end)

('Error parsing code:', '(* Compiled Syntax *) (* Author: Iliano Cervesato *) (* Modified: Jeff Polakow *) (* Modified: Frank Pfenning *) (* Modified: Brigitte Pientka *) module CompSyn (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Table : TABLE where keyint) : COMPSYN = struct (*! structure IntSyn = IntSyn\' !*)  type Opt = No | LinearHeads | Indexing let optimize = ref LinearHeads type Goal = Atom of Exp | Impl of ResGoal * Exp(*     | (r,A,a) => g         *)  * Head * Goal | All of Dec * Goal and ResGoal = Eq of Exp | Assign of Exp * AuxGoal | And of ResGoal(*     | r & (A,g)            *)  * Exp * Goal | In of ResGoal(*     | r && (A,g)           *)  * Exp * Goal | Exists of Dec * ResGoal | Axists of Dec * ResGoal and AuxGoal = Trivial | UnifyEq of dctx * Exp(* call unify *)  * Exp * AuxGoal (* Static programs -- compiled version for substitution trees *)  type Conjunction = True | Conjunct of Goal * Exp * Conjunction type CompHead = Head of (Exp * Dec Ctx * AuxGoal * cid) (* proof skeletons instead of proof term *)  type Flatterm = Pc of cid | Dc of cid | Csolver of Exp type pskeleton = Flatterm list (* Representation invariants for compiled syntax:\n     Judgments:\n       G |- g goal   g is a valid goal in G\n       G |- r resgoal  g is a valid residual goal in G\n\n       G |- A ~> g   A compiles to goal g\n       G |- A ~> r   A compiles to residual goal r\n       G |- A ~> <head , subgoals>\n\n     G |- p  goal\n     if  G |- p : type, p = H @ S       (* mod whnf *)\n\n     G |- (r, A, a) => g  goal\n     if G |- A : type\n        G |- r  resgoal\n        G |- A ~> r\n        a  target head of A (for indexing purposes)\n\n     G |- all x:A. g  goal\n     if G |- A : type\n        G, x:A |- g  goal\n\n     For dynamic clauses:\n\n     G |- q  resgoal\n     if G |- q : type, q = H @ S        (* mod whnf *)\n\n     G |- r & (A,g)  resgoal\n     if G |- A : type\n        G |- g  goal\n        G |- A ~> g\n        G, _:A |- r  resgoal\n\n     G |- exists x:A. r  resgoal\n     if  G |- A : type\n         G, x:A |- r  resgoal\n\n     G |- exists\' x:A. r  resgoal     but exists\' doesn\'t effect the proof-term\n     if  G |- A : type\n         G, x:A |- r  resgoal\n\n     For static clauses:\n     G |- true subgoals\n\n     if G |- sg && g subgoals\n     if G |- g goal\n        G |- sg subgoals\n\n  *)  (* Static programs --- compiled version of the signature (no indexing) *)  type ConDec = SClause of ResGoal | Void (* Other declarations are ignored          *)  (* Static programs --- compiled version of the signature (indexed by first argument) *)  type ConDecDirect = HeadGoals of CompHead * Conjunction | Null (* Other declarations are ignored          *)  (* Compiled Declarations *)  (* added Thu Jun 13 13:41:32 EDT 2002 -cs *)  type ComDec = Parameter | Dec of ResGoal * Sub * Head | BDec of ResGoal * Sub * Head list | PDec (* The dynamic clause pool --- compiled version of the context *)  (* Dynamic programs: context with synchronous clause pool *)  type DProg = DProg of dctx * ComDec Ctx let maxCid = maxCid (* program array indexed by clause names (no direct head access) *) let sProgArray = array (maxCid + 1, Void) : ConDec array let detTable : bool Table = new (32) (* Invariants *) (* 0 <= cid < I.sgnSize () *) (* program array indexed by clause names (no direct head access) *) let rec sProgInstall (cid, conDec)  = update (sProgArray, cid, conDec) let rec sProgLookup (cid)  = sub (sProgArray, cid) let rec sProgReset ()  = modify (fun _ -> Void) sProgArray let detTableInsert = insert detTable let rec detTableCheck (cid)  = (match (lookup detTable cid) with SOME (deterministic) -> deterministic | NONE -> false) let rec detTableReset ()  = clear detTable  (* goalSub (g, s) = g\'\n\n     Invariants:\n     If   G  |- s : G\'    G\' |- g : A\n     then g\' = g[s]\n     and  G  |- g\' : A\n  *)  let rec goalSub (Atom (p), s)  = Atom (EClo (p, s)) | goalSub (Impl (d, A, Ha, g), s)  = Impl (resGoalSub (d, s), EClo (A, s), Ha, goalSub (g, dot1 s)) | goalSub (All (D, g), s)  = All (decSub (D, s), goalSub (g, dot1 s))(* resGoalSub (r, s) = r\'\n\n     Invariants:\n     If   G  |- s : G\'    G\' |- r : A\n     then r\' = r[s]\n     and  G  |- r\' : A [s]\n  *) resGoalSub (Eq (q), s)  = Eq (EClo (q, s)) | resGoalSub (And (r, A, g), s)  = And (resGoalSub (r, dot1 s), EClo (A, s), goalSub (g, s)) | resGoalSub (In (r, A, g), s)  = In (resGoalSub (r, dot1 s), EClo (A, s), goalSub (g, s)) | resGoalSub (Exists (D, r), s)  = Exists (decSub (D, s), resGoalSub (r, dot1 s)) let rec pskeletonToString []  = " " | pskeletonToString ((Pc i) :: O)  = qidToString (constQid i) ^ " " ^ (pskeletonToString O) | pskeletonToString ((Dc i) :: O)  = ("(Dc " ^ (toString i) ^ ") ") ^ (pskeletonToString O) | pskeletonToString (Csolver U :: O)  = ("(cs _ ) " ^ (pskeletonToString O)) end\n(* functor CompSyn *) module CompSyn = CompSyn(struct module Global = Global module Names = Names module Table = IntRedBlackTree end)\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Compiler *) (* Author: Iliano Cervesato *) (* Modified: Jeff Polakow *) (* Modified: Carsten Schuermann *) (* Modified: Frank Pfenning *) module type COMPILE = sig (*! structure IntSyn: INTSYN !*) (*! structure CompSyn: COMPSYN !*) exception Error of stringOptOptval optimize : Opt refval install : ConDecForm -> cid -> unitval sProgReset : unit -> unitval compileCtx : bool -> (Dec Ctx) -> DProgval compileGoal : (Dec Ctx * Exp) -> Goal(* for the meta theorem prover  --cs *) val compilePsi : bool -> (Dec Ctx) -> DProg end\n(* signature COMPILE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Now in compsyn.fun *) (*
structure CompSyn =
  CompSyn (structure Global = Global
           (*! structure IntSyn' = IntSyn !*)
	   structure Names = Names
           structure Table = IntRedBlackTree);
*) module CPrint = CPrint(struct module Print = Print module Formatter = Formatter module Names = Names end)
module SubTree = SubTree(struct module IntSyn' = IntSyn module Whnf = Whnf module Unify = UnifyTrail module CompSyn' = CompSyn module Print = Print module CPrint = CPrint module Names = Names module Formatter = Formatter module CSManager = CSManager module Table = IntRedBlackTree module RBSet = RBSet end)module Compile = Compile(struct module Whnf = Whnf module TypeCheck = TypeCheck module SubTree = SubTree module CPrint = CPrint module Print = Print module Names = Names end)
module Assign = Assign(struct module Whnf = Whnf module Unify = UnifyTrail module Print = Print end)

('Error parsing code:', '(* Printer for Compiled Syntax *) (* Author: Iliano Cervesato *) module CPrint ((*! structure IntSyn\' : INTSYN !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Formatter : FORMATTERPrintFormatterFormattermodule Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) ) : CPRINT = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure CompSyn = CompSyn\' !*)  open CompSyn let rec compose (Null, G)  = G | compose (Decl (G, D), G\')  = Decl (compose (G, G\'), D) (* goalToString (G, g) where G |- g  goal *) let rec goalToString t (G, Atom (p))  = t ^ "SOLVE   " ^ expToString (G, p) ^ "\\n" | goalToString t (G, Impl (p, A, _, g))  = t ^ "ASSUME  " ^ expToString (G, A) ^ "\\n" ^ (clauseToString (t ^ "\\t") (G, p)) ^ goalToString t (Decl (G, Dec (NONE, A)), g) ^ "\\n" | goalToString t (G, All (D, g))  = let D\' = decLUName (G, D) in t ^ "ALL     " ^ makestring_fmt (formatDec (G, D\')) ^ "\\n" ^ goalToString t (Decl (G, D\'), g) ^ "\\n"(* auxToString (G, r) where G |- r auxgoal *) auxToString t (G, Trivial)  = "" | auxToString t (G, UnifyEq (G\', p1, N, ga))  = t ^ "UNIFYEqn  " ^ expToString (compose (G\', G), p1) ^ " = " ^ expToString (compose (G\', G), N) ^ "\\n" ^ auxToString t (G, ga)(* clauseToString (G, r) where G |- r  resgoal *) clauseToString t (G, Eq (p))  = t ^ "UNIFY   " ^ expToString (G, p) ^ "\\n" | clauseToString t (G, Assign (p, ga))  = (t ^ "ASSIGN  " ^ (try  with ) ^ "\\n" ^ (auxToString t (G, ga))) | clauseToString t (G, And (r, A, g))  = clauseToString t (Decl (G, Dec (NONE, A)), r) ^ goalToString t (G, g) | clauseToString t (G, In (r, A, g))  = let D = decEName (G, Dec (NONE, A)) in clauseToString t (Decl (G, D), r) ^ t ^ "META    " ^ decToString (G, D) ^ "\\n" ^ goalToString t (G, g) | clauseToString t (G, Exists (D, r))  = let D\' = decEName (G, D) in t ^ "EXISTS  " ^ (try  with ) ^ "\\n" ^ clauseToString t (Decl (G, D\'), r) | clauseToString t (G, Axists (D as ADec (SOME (n), d), r))  = let D\' = decEName (G, D) in t ^ "EXISTS\'  " ^ (try  with ) ^ "\\n" ^ clauseToString t (Decl (G, D\'), r) let rec subgoalsToString t (G, True)  = t ^ "True " | subgoalsToString t (G, Conjunct (Goal, A, Sg))  = t ^ goalToString t (Decl (G, Dec (NONE, A)), Goal) ^ " and " ^ subgoalsToString t (G, Sg) (* conDecToString (c, clause) printed representation of static clause *) let rec conDecToString (c, SClause (r))  = let _ = varReset Null let name = conDecName (sgnLookup c) let l = size name in name ^ (if l > 6 then ":\\n" else ":") ^ (clauseToString "\\t" (Null, r) ^ "\\n") | conDecToString (c, Void)  = conDecToString (sgnLookup c) ^ "\\n\\n" (* sProgToString () = printed representation of static program *) let rec sProgToString ()  = let (size, _) = sgnSize () let rec ts (cid)  = if cid < size then conDecToString (cid, sProgLookup cid) ^ ts (cid + 1) else "" in ts 0 (* dProgToString (G, dProg) = printed representation of dynamic program *) let rec dProgToString (DProg (Null, Null))  = "" | dProgToString (DProg (Decl (G, Dec (SOME x, _)), Decl (dPool, Dec (r, _, _))))  = dProgToString (DProg (G, dPool)) ^ "\\nClause    " ^ x ^ ":\\n" ^ clauseToString "\\t" (G, r) | dProgToString (DProg (Decl (G, Dec (SOME x, A)), Decl (dPool, Parameter)))  = dProgToString (DProg (G, dPool)) ^ "\\nParameter " ^ x ^ ":\\t" ^ expToString (G, A) (* case for CompSyn.BDec is still missing *)  (* local open ... *)  end\n(* functor CPrint *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Assignment *) (* Author: Brigitte Pientka *) module Assign ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) ) : ASSIGN = struct (*! structure IntSyn = IntSyn\' !*)  exception Assignment of string open IntSyn (*\n     templates\n           p ::= Root(n, NIL) | Root(c, SP) | EVar (X, V) | AVar A |\n                 Lam (D, p)\n                   where X is uninstantiated and occurs uniquely\n                   any multiple occurrence of X has been renamed to A.\n\n                 any eta-expanded EVar remains an EVar\n                 but it may be lowered during whnf (or in the special case here\n                 expansion)\n\n          SP ::= p ; SP | NIL\n\n   *) (* assignExpW (G, (U1, s1), (U2, s2)) = ()\n\n     invariant:\n     G |- s1 : G1    G1 |- U1 : V1   (U1, s1) in whnf\n     G |- s2 : G2    G2 |- U2 : V2   (U2, s2) is template\n  *) let rec assignExpW (G, (Uni L1, _), (Uni L2, _), cnstr)  = (* L1 = L2 by invariant *)  cnstr | assignExpW (G, Us1 as (Root (H1, S1), s1), Us2 as (Root (H2, S2), s2), cnstr)  = (match (H1, H2) with (Const (c1), Const (c2)) -> if (c1 = c2) then assignSpine (G, (S1, s1), (S2, s2), cnstr) else raise (Assignment "Constant clash") | (BVar (k1), BVar (k2)) -> if (k1 = k2) then assignSpine (G, (S1, s1), (S2, s2), cnstr) else raise (Assignment "Bound variable clash") | (Skonst (c1), Skonst (c2)) -> if (c1 = c2) then assignSpine (G, (S1, s1), (S2, s2), cnstr) else raise (Assignment "Skolem constant clash") | (Def (d1), Def (d2)) -> (* cannot occur by invariant; all definitions in clause heads have been\n               replaced by AVars Tue Jun 18 19:47:39 2002 -bp *) if (d1 = d2) then (* because of strict *) assignSpine (G, (S1, s1), (S2, s2), cnstr) else assignExp (G, expandDef (Us1), expandDef (Us2), cnstr) | (Def d1, _) -> assignExp (G, expandDef Us1, Us2, cnstr) | (_, Def (d2)) -> (* cannot occur by invariant; all definitions in clause heads have been\n               replaced by AVars Tue Jun 18 19:47:44 2002 -bp *) assignExp (G, Us1, expandDef Us2, cnstr) | (FgnConst (cs1, ConDec (n1, _, _, _, _, _)), FgnConst (cs2, ConDec (n2, _, _, _, _, _))) -> (* we require unique string representation of external constants *) if (cs1 = cs2) && (n1 = n2) then cnstr else raise (Assignment "Foreign Constant clash") | (FgnConst (cs1, ConDef (n1, _, _, W1, _, _, _)), FgnConst (cs2, ConDef (n2, _, _, V, W2, _, _))) -> (if (cs1 = cs2) && (n1 = n2) then cnstr else assignExp (G, (W1, s1), (W2, s2), cnstr)) | (FgnConst (_, ConDef (_, _, _, W1, _, _, _)), _) -> assignExp (G, (W1, s1), Us2, cnstr) | (_, FgnConst (_, ConDef (_, _, _, W2, _, _, _))) -> assignExp (G, Us1, (W2, s2), cnstr) | _ -> (raise (Assignment ("Head mismatch ")))) | assignExpW (G, (Lam (D1, U1), s1), (Lam (D2, U2), s2), cnstr)  = (* D1[s1] = D2[s2]  by invariant *)  assignExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (U2, dot1 s2), cnstr) | assignExpW (G, (U1, s1), (Lam (D2, U2), s2), cnstr)  = (* Cannot occur if expressions are eta expanded *)  assignExp (Decl (G, decSub (D2, s2)), (Redex (EClo (U1, shift), App (Root (BVar (1), Nil), Nil)), dot1 s1), (U2, dot1 s2), cnstr) | assignExpW (G, (Pi ((D1 as Dec (_, V1), _), U1), s1), (Pi ((D2 as Dec (_, V2), _), U2), s2), cnstr)  = let cnstr\' = assignExp (G, (V1, s1), (V2, s2), cnstr) in assignExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (U2, dot1 s2), cnstr\') | assignExpW (G, Us1 as (U, s1), Us2 as (EVar (r2, _, _, _), s2), cnstr)  = (* s2 = id *)  (* don\'t trail, because EVar has been created since most recent choice point *)  (* Tue Apr  2 10:23:19 2002 -bp -fp *)  (r2 := SOME (EClo (Us1)); cnstr) | assignExpW (G, Us1 as (U, s1), Us2 as (AVar (r2), s2), cnstr)  = (* s2 = id *)  (* don\'t trail, because AVars never survive local scope *)  (r2 := SOME (EClo Us1); cnstr) | assignExpW (G, (Lam (D1, U1), s1), (U2, s2), cnstr)  = (* ETA: can\'t occur if eta expanded *)  assignExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (Redex (EClo (U2, shift), App (Root (BVar (1), Nil), Nil)), dot1 s2), cnstr) | assignExpW (G, Us1, Us2 as (EClo (U, s\'), s), cnstr)  = assignExp (G, Us1, (U, comp (s\', s)), cnstr) | assignExpW (G, Us1 as (EVar (r, _, V, Cnstr), s), Us2, cnstr)  = (Eqn (G, EClo (Us1), EClo (Us2)) :: cnstr) | assignExpW (G, Us1 as (EClo (U, s\'), s), Us2, cnstr)  = assignExp (G, (U, comp (s\', s)), Us2, cnstr) | assignExpW (G, Us1 as (FgnExp (_, fe), _), Us2, cnstr)  = (* by invariant Us2 cannot contain any FgnExp *)  (Eqn (G, EClo (Us1), EClo (Us2)) :: cnstr) | assignExpW (G, Us1, Us2 as (FgnExp (_, fe), _), cnstr)  = (Eqn (G, EClo (Us1), EClo (Us2)) :: cnstr)assignSpine (G, (Nil, _), (Nil, _), cnstr)  = cnstr | assignSpine (G, (SClo (S1, s1\'), s1), Ss, cnstr)  = assignSpine (G, (S1, comp (s1\', s1)), Ss, cnstr) | assignSpine (G, Ss, (SClo (S2, s2\'), s2), cnstr)  = assignSpine (G, Ss, (S2, comp (s2\', s2)), cnstr) | assignSpine (G, (App (U1, S1), s1), (App (U2, S2), s2), cnstr)  = let cnstr\' = assignExp (G, (U1, s1), (U2, s2), cnstr) in assignSpine (G, (S1, s1), (S2, s2), cnstr\')assignExp (G, Us1, Us2 as (U2, s2), cnstr)  = assignExpW (G, whnf Us1, whnf Us2, cnstr) let rec solveCnstr nil  = true | solveCnstr (Eqn (G, U1, U2) :: Cnstr)  = (unifiable (G, (U1, id), (U2, id)) && solveCnstr Cnstr) let rec printSub (Shift n)  = print ("Shift " ^ toString n ^ "\\n") | printSub (Dot (Idx n, s))  = (print ("Idx " ^ toString n ^ " . "); printSub s) | printSub (Dot (Exp (EVar (_, _, _, _)), s))  = (print ("Exp (EVar _ ). "); printSub s) | printSub (Dot (Exp (AVar (_)), s))  = (print ("Exp (AVar _ ). "); printSub s) | printSub (Dot (Exp (EClo (AVar (_), _)), s))  = (print ("Exp (AVar _ ). "); printSub s) | printSub (Dot (Exp (EClo (_, _)), s))  = (print ("Exp (EClo _ ). "); printSub s) | printSub (Dot (Exp (_), s))  = (print ("Exp (_ ). "); printSub s) | printSub (Dot (Undef, s))  = (print ("Undef . "); printSub s) let rec unifyW (G, (Xs1 as AVar (r as ref NONE), s), Us2)  = (* s = id *)  r := SOME (EClo (Us2)) | unifyW (G, Xs1, Us2)  = (* Xs1 should not contain any uninstantiated AVar anymore *)  unifyW (G, Xs1, Us2) let rec unify (G, Xs1, Us2)  = unifyW (G, whnf Xs1, whnf Us2) let rec matchW (G, (Xs1 as AVar (r as ref NONE), s), Us2)  = (* s = id *)  r := SOME (EClo (Us2)) | matchW (G, Xs1, Us2)  = (* Xs1 should not contain any uninstantiated AVar anymore *)  matchW (G, Xs1, Us2) let rec match (G, Xs1, Us2)  = matchW (G, whnf Xs1, whnf Us2) let solveCnstr = solveCnstr let rec unifiable (G, Us1, Us2)  = try  with let rec instance (G, Us1, Us2)  = try  with (*\n    fun assign(G, Us1, Us2) = assignExp(G, Us1, Us2, [])\n    *) let rec assignable (G, Us1, Uts2)  = (try  with ) let rec firstConstArg (A as Root (h as Const c, S), s)  = (* #implicit arguments to predicate *) (* other cases cannot occur during compilation *) let i = conDecImp (sgnLookup (c)) let rec constExp (U, s)  = constExpW (whnf (U, s))constExpW (Lam (D, U), s)  = constExp (U, s) | constExpW (Root (H as Const cid, S), s)  = SOME (cid) | constExpW (_, _)  = NONE let rec ithElem (k, (App (U, S), s))  = if (k = i) then constExp (U, s) else ithElem (k + 1, (S, s)) | ithElem (k, (Nil, s))  = NONE in ithElem (0, (S, s))  end\n(* functor Assign *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Substitution Tree indexing *) (* Author: Brigitte Pientka *) module SubTree ((*! structure IntSyn\' : INTSYN !*) (*!structure CompSyn\' : COMPSYN !*) (*!  sharing CompSyn\'.IntSyn = IntSyn\' !*) module Whnf : WHNF(*!  sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*!  sharing Unify.IntSyn = IntSyn\'!*) module Print : PRINT(*!  sharing Print.IntSyn = IntSyn\' !*) (* CPrint currently unused *) module CPrint : CPRINT(*!  sharing CPrint.IntSyn = IntSyn\' !*) (*!  sharing CPrint.CompSyn = CompSyn\' !*) (* unused *) module Formatter : FORMATTER(*!  sharing Print.Formatter = Formatter !*) (* unused *) module Names : NAMES(*!  sharing Names.IntSyn = IntSyn\' !*) module CSManager : CS_MANAGER(*!  sharing CSManager.IntSyn = IntSyn\'!*) (*! structure RBSet : RBSET !*) ) : SUBTREE = struct (*!  structure IntSyn = IntSyn\' !*)  (*!  structure CompSyn = CompSyn\' !*)  (*!  structure RBSet = RBSet !*)  type nvar = int (* index for normal variables *)  type bvar = int (* index for bound variables *)  type bdepth = int (* depth of locally bound variables *)  (* A substitution tree is defined as follows:\n     Node := Leaf (ns, G, sgoal) | Node(ns, Set of Nodes)\n     normal linear modal substitutions ns := . | R/n, ns\n\n   For each node we have the following invariant:\n        S |- ns : S\'    i.e. ns substitutes for internal variables\n        G\'|- as : G     i.e. as substitutes for assignable variables\n        G |- qs : G     i.e. qs substitutes for modal variables\n                             occuring in the query term\n\n  NOTE: Since lambda-abstraction carries a type-label, we must generalize\n   the type-label, and hence perform indexing on type-labels. -- On\n   the other hand during unification or assignment an instantiation of\n   the existential variables occurring in the type-label is not\n   necessary. They must have been instantiated already. However, we\n   must still instantiate internal nvars.\n\n  Example: given the following two terms:\n   hilnd ((A imp (B imp C)) imp ((A imp B) imp (A imp C))) (s) (impi [u:nd (A imp B imp C)]\n                     impi [v:nd (A imp B)]\n                     impi [w:nd A] impe (impe u w) (impe v w)).\n\n   hilnd (A imp (B imp A)) (s) (impi [u:nd A]\n                     impi [v:nd B]\n                     impi [w:nd A] impe (impe u w) (impe v w)).\n\n\n  if we generalize (A imp B imp C) then we must obtain\n\n  hilnd (n1 imp (n2 imp n3)) (s) (impi [u:nd n4]\n             impi [v:nd n5]\n             impi [w:nd A] impe (impe u w) (impe v w)).\n\n  otherwise we could obtain a term which is not well-typed.\n\n  *)  (* typeLabel distinguish between declarations (=type labels)\n   which are subject to indexing, but only the internal nvars will\n   be instantiated during asssignment and Body which are subject to\n   indexing and existential variables and nvars will be instantiated\n   during assignment\n *)  type typeLabel = TypeLabel | Body type normalSubsts = typeLabel * Exp ordSet (* key = int = bvar *)  type AssSub = Assign of (Dec Ctx * Exp) type assSubsts = AssSub ordSet (* key = int = bvar *)  type querySubsts = Dec Ctx * (typeLabel * Exp) ordSet type Cnstr = Eqn of Dec Ctx * Exp * Exp type cnstrSubsts = Exp ordSet (* key = int = bvar *)  type CGoal = CGoals of AuxGoal * cid * Conjunction * int (* cid of clause *)  type genType = Top | Regular type Tree = Leaf of normalSubsts * Dec Ctx * CGoal | Node of normalSubsts * Tree ordSet type candidate = (assSubsts * normalSubsts * cnstrSubsts * Cnstr * Dec Ctx * CGoal) (* Initialization of substitutions *)  let nid : unit -> normalSubsts = new let assignSubId : unit -> assSubsts = new let cnstrSubId : unit -> cnstrSubsts = new let querySubId : unit -> querySubsts = new (* Identity substitution *)  let rec isId s  = isEmpty s (* Initialize substitution tree *)  let rec makeTree ()  = ref (Node (nid (), new ())) (* Test if node has any children *)  let rec noChildren C  = isEmpty C (* Index array\n\n   Invariant:\n   For all type families  a  indexArray = [a1,...,an]\n   where a1,...,an is a substitution tree consisting of all constants\n   for target family ai\n\n   *)  let indexArray = tabulate (maxCid, (fun i -> (ref 0, makeTree ()))) module I = IntSynmodule C = CompSynmodule S = RBSetexception Error of string exception Assignment of string exception Generalization of string (* Auxiliary functions *) let rec cidFromHead (Const c)  = c | cidFromHead (Def c)  = c let rec dotn (0, s)  = s | dotn (i, s)  = dotn (i - 1, dot1 s) let rec compose\' (Null, G)  = G | compose\' (Decl (G, D), G\')  = Decl (compose\' (G, G\'), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Lam (D, V)) let rec printSub (Shift n)  = print ("Shift " ^ toString n ^ "\\n") | printSub (Dot (Idx n, s))  = (print ("Idx " ^ toString n ^ " . "); printSub s) | printSub (Dot (Exp (EVar (_, _, _, _)), s))  = (print ("Exp (EVar _ ). "); printSub s) | printSub (Dot (Exp (AVar (_)), s))  = (print ("Exp (AVar _ ). "); printSub s) | printSub (Dot (Exp (EClo (AVar (_), _)), s))  = (print ("Exp (AVar _ ). "); printSub s) | printSub (Dot (Exp (EClo (_, _)), s))  = (print ("Exp (EClo _ ). "); printSub s) | printSub (Dot (Exp (_), s))  = (print ("Exp (_ ). "); printSub s) | printSub (Dot (Undef, s))  = (print ("Undef . "); printSub s) (*\n     Linear normal higher-order patterns\n           p ::= n | Root(c, S) | Root(b, S) | Lam (D, p)\n\n                 where n is a linear bound "normalized" variable\n\n          SP ::= p ; S | NIL\n\n     Context\n        G : context for bound variables (bvars)\n            (type information is stored in the context)\n        G ::= . | G, x : A\n\n        S : context for linear normalized bound variables (nvars)\n            (no type information is stored in the context)\n            (these are the types of the variables definitions)\n        S ::= . | S, n\n\n     Templates: G ; S |- p\n     Substitutions: G ; S |- nsub : S\'\n\n    Let s is a substitution for normalized bound variables (nvars)\n    and nsub1 o nsub2 o .... o nsubn = s, s.t.\n     G, S_2|- nsub1 : S_1\n     G, S_3|- nsub2 : S_2\n      ....\n     G |- nsubn : S_n\n      . ; G |- s : G, S_1\n\n    A term U can be decomposed into a term p together with a sequenence of\n    substitutions s1, s2, ..., sn such that s1 o s2 o .... o sn = s\n    and the following holds:\n\n    If    G |- U\n\n    then\n\n       G, S |- p\n\n        G |- s : G, S\n\n        G |- p[s]     and p[s] = U\n\n   In addition:\n   all expressions in the index are linear, i.e.\n   an expression is first linearized before it is inserted into the index\n   (this makes retrieving all axpressions from the index which unify with\n    a given expression simpler, because we can omit the occurs check)\n\n   *) (* ---------------------------------------------------------------*) (* nctr = |D| =  #normal variables *) let nctr = ref 1 let rec newNVar ()  = (nctr := ! nctr + 1; NVar (! nctr)) let rec eqHeads (Const k, Const k\')  = (k = k\') | eqHeads (BVar k, BVar k\')  = (k = k\') | eqHeads (Def k, Def k\')  = (k = k\') | eqHeads (_, _)  = false (* most specific linear common generalization *) (* compatible (T, U) = (C, rho_u\', rho_t\') opt\n    if\n       U, T are both in normal form\n       U and T share at least the top function symbol\n   then\n     C[rho_u\'] = U and C[rho_t\'] = T\n   *) let rec compatible (label, T, U, rho_t, rho_u)  = let rec genExp (label, b, T as NVar n, U as Root (H, S))  = (insert rho_u (n, (label, U)); T) | genExp (label, b, T as Root (H1, S1), U as Root (H2, S2))  = if eqHeads (H1, H2) then Root (H1, genSpine (label, b, S1, S2)) else (match b with Regular -> (insert rho_t (! nctr + 1, (label, T)); insert rho_u (! nctr + 1, (label, U)); newNVar ()) | _ -> raise (Generalization "Should never happen!")) | genExp (label, b, Lam (D1 as Dec (N, A1), T1), Lam (D2 as Dec (_, A2), U2))  = (* NOTE: by invariant A1 =/= A2 *)  Lam (Dec (N, genExp (TypeLabel, Regular, A1, A2)), genExp (label, b, T1, U2)) | genExp (label, b, Pi (DD1 as (D1, No), E1), Pi (DD2 as (D2, No), E2))  = Pi ((genDec (TypeLabel, Regular, D1, D2), No), genExp (label, b, E1, E2)) | genExp (label, b, Pi (DD1 as (D1, Maybe), E1), Pi (DD2 as (D2, Maybe), E2))  = Pi ((genDec (TypeLabel, Regular, D1, D2), Maybe), genExp (label, b, E1, E2)) | genExp (label, b, Pi (DD1 as (D1, Meta), E1), Pi (DD2 as (D2, Meta), E2))  = Pi ((genDec (TypeLabel, Regular, D1, D2), Meta), genExp (label, b, E1, E2)) | genExp (label, b, T, U)  = raise (Generalization "Cases where U= EVar or EClo should never happen!")genSpine (label, b, Nil, Nil)  = Nil | genSpine (label, b, App (T, S1), App (U, S2))  = App (genExp (label, b, T, U), genSpine (label, b, S1, S2))genDec (label, b, Dec (N, E1), Dec (N\', E2))  = Dec (N, genExp (label, b, E1, E2)) let rec genTop (label, T as Root (H1, S1), U as Root (H2, S2))  = if eqHeads (H1, H2) then Root (H1, genSpine (label, Regular, S1, S2)) else raise (Generalization "Top-level function symbol not shared") | genTop (label, Lam (D1 as Dec (N, A1), T1), Lam (D2 as Dec (_, A2), U2))  = (* by invariant A1 =/= A2 *)  Lam (Dec (N, genExp (label, Regular, A1, A2)), genTop (label, T1, U2)) | genTop (_, _, _)  = raise (Generalization "Top-level function symbol not shared") in try  with (* compatibleSub(nsub_t, nsub_e) = (sg, rho_t, rho_e) opt\n\n   if dom(nsub_t) <= dom(nsub_e)\n      codom(nsub_t) : linear hop in normal form (may contain normal vars)\n      codom(nsub_e) : linear hop in normal form (does not contain normal vars)\n   then\n     nsub_t = [rho_t]sg\n     nsub_e = [rho_e]sg\n\n    G_e, Glocal_e |- nsub_e : Sigma\n    G_t, Glocal_t |- nsub_t : Sigma\'\n    Sigma\' <= Sigma\n\n    Glocal_e ~ Glocal_t  (have approximately the same type)\n\n   *) let rec compatibleSub (nsub_t, nsub_e)  = (* by invariant rho_t = empty, since nsub_t <= nsub_e *) let (sg, rho_t, rho_e) = (nid (), nid (), nid ()) let _ = forall nsub_e (fun (nv, (l\', E)) -> (match (lookup nsub_t nv) with SOME (l, T) -> (* by invariant d = d\'\n                                     therefore T and E have the same approximate type A *) (if l = l\' then (match compatible (l, T, E, rho_t, rho_e) with NONE -> (insert rho_t (nv, (l, T)); insert rho_e (nv, (l, E))) | SOME (T\') -> insert sg (nv, (l, T\'))) else raise (Generalization "Labels don\'t agree\\n")) | NONE -> insert rho_e (nv, (l\', E)))) in if isId (sg) then NONE else SOME (sg, rho_t, rho_e) (* mkNode (N, sg, r1, (G, RC), r2) = N\'    *) let rec mkNode (Node (_, Children), sg, rho1, GR as (G, RC), rho2)  = let c = new () in insertList c [(1, Node (rho1, Children)); (2, Leaf (rho2, G, RC))]; Node (sg, c) | mkNode (Leaf (_, G1, RC1), sg, rho1, GR as (G2, RC2), rho2)  = let c = new () in insertList c [(1, Leaf (rho1, G1, RC1)); (2, Leaf (rho2, G2, RC2))]; Node (sg, c) (* Insertion *) (* compareChild (children, (n, child), n, n\', (G, R)) = ()\n\n   *) let rec compareChild (children, (n, child), nsub_t, nsub_e, GR as (G_clause2, Res_clause2))  = (match compatibleSub (nsub_t, nsub_e) with NONE -> (insert children (n + 1, Leaf (nsub_e, G_clause2, Res_clause2))) | SOME (sg, rho1, rho2) -> (if isId rho1 then if isId rho2 then (* sg = nsub_t = nsub_e *) (insertShadow children (n, mkNode (child, sg, rho1, GR, rho2))) else (* sg = nsub_t and nsub_e = sg o rho2 *) (insertShadow children (n, insert (child, rho2, GR))) else (insertShadow children (n, mkNode (child, sg, rho1, GR, rho2)))))(* insert (N, nsub_e, (G, R2)) = N\'\n\n     if s is the substitution in node N\n        G |- nsub_e : S and\n    G, S\' |- s : S\n    then\n     N\' contains a path n_1 .... n_n s.t.\n     [n_n] ...[n_1] s = nsub_e\n  *) insert (N as Leaf (nsub_t, G_clause1, R1), nsub_e, GR as (G_clause2, R2))  = (match compatibleSub (nsub_t, nsub_e) with NONE -> raise (Error "Leaf is not compatible substitution r") | SOME (sg, rho1, rho2) -> mkNode (N, sg, rho1, GR, rho2)) | insert (N as Node (_, children), nsub_e, GR as (G_clause2, RC))  = if noChildren children then (* initial *) (insert children (1, (Leaf (nsub_e, G_clause2, RC))); N) else (match (last children) with (n, child as Node (nsub_t, children\')) -> (compareChild (children, (n, child), nsub_t, nsub_e, GR); N) | (n, child as Leaf (nsub_t, G1, RC1)) -> (compareChild (children, (n, child), nsub_t, nsub_e, GR); N)) (* retrieval (U,s)\n     retrieves all clauses which unify with (U,s)\n\n     backtracking implemented via SML failure continuation\n\n   *) let rec normalizeNExp (NVar n, csub)  = let A = newAVar () in insert csub (n, A); A | normalizeNExp (Root (H, S), nsub)  = Root (H, normalizeNSpine (S, nsub)) | normalizeNExp (Lam (D, U), nsub)  = Lam (normalizeNDec (D, nsub), normalizeNExp (U, nsub)) | normalizeNExp (Pi ((D, P), U), nsub)  = (* cannot happen -bp *)  Pi ((normalizeNDec (D, nsub), P), normalizeNExp (U, nsub))normalizeNSpine (Nil, _)  = Nil | normalizeNSpine (App (U, S), nsub)  = App (normalizeNExp (U, nsub), normalizeNSpine (S, nsub))normalizeNDec (Dec (N, E), nsub)  = Dec (N, normalizeNExp (E, nsub)) (* assign (G, Us1, U2, nsub_goal, asub, csub, cnstr) = cnstr\n   if G = local assumptions, G\' context of query\n      G1 |- U1 : V1\n     G\', G  |- s1 : G1\n     G\', G  |- U1[s1]     and s1 is an explicit substitution\n\n      G2 |- U2 : V2\n  G\', G  |- asub\' : G2 and asub is a assignable substitution\n\n      U2 is eta-expanded\n   then\n   G2, N |- cnstr\n      G2 |- csub : N\n      G2 |- cnstr[csub]\n\n      G  |- nsub_goal : N\n     *) let rec assign (nvaronly, Glocal_u1, Us1, U2, nsub_goal, asub, csub, cnstr)  = let depth = ctxLength Glocal_u1 let rec assignHead (nvaronly, depth, Glocal_u1, Us1 as (Root (H1, S1), s1), U2 as Root (H2, S2), cnstr)  = (match (H1, H2) with (Const (c1), Const (c2)) -> if (c1 = c2) then assignSpine (nvaronly, depth, Glocal_u1, (S1, s1), S2, cnstr) else raise (Assignment "Constant clash") | (Skonst (c1), Skonst (c2)) -> if (c1 = c2) then assignSpine (nvaronly, depth, Glocal_u1, (S1, s1), S2, cnstr) else raise (Assignment "Skolem constant clash") | (Def d1, _) -> assignExp (nvaronly, depth, Glocal_u1, expandDef Us1, U2, cnstr) | (FgnConst (cs1, ConDec (n1, _, _, _, _, _)), FgnConst (cs2, ConDec (n2, _, _, _, _, _))) -> (* we require unique string representation of external constants *) if (cs1 = cs2) && (n1 = n2) then cnstr else raise (Assignment "Foreign Constant clash") | (FgnConst (cs1, ConDef (n1, _, _, W1, _, _, _)), FgnConst (cs2, ConDef (n2, _, _, V, W2, _, _))) -> (if (cs1 = cs2) && (n1 = n2) then cnstr else assignExp (nvaronly, depth, Glocal_u1, (W1, s1), W2, cnstr)) | (FgnConst (_, ConDef (_, _, _, W1, _, _, _)), _) -> assignExp (nvaronly, depth, Glocal_u1, (W1, s1), U2, cnstr) | (_, FgnConst (_, ConDef (_, _, _, W2, _, _, _))) -> assignExp (nvaronly, depth, Glocal_u1, Us1, W2, cnstr) | (_, _) -> (raise (Assignment ("Head mismatch "))))assignExpW (nvaronly, depth, Glocal_u1, (Uni L1, s1), Uni L2, cnstr)  = cnstr | assignExpW (nvaronly, depth, Glocal_u1, Us1, NVar n, cnstr)  = (insert nsub_goal (n, (Glocal_u1, (nvaronly, EClo (Us1)))); cnstr) | assignExpW (Body, depth, Glocal_u1, Us1 as (Root (H1, S1), s1), U2 as Root (H2, S2), cnstr)  = (match H2 with BVar (k2) -> if (k2 > depth) then (* BVar(k2) stands for an existential variable *) (* S2 is an etaSpine by invariant *) (insert asub ((k2 - ctxLength (Glocal_u1)), Assign (Glocal_u1, EClo (Us1))); cnstr) else (match H1 with BVar (k1) -> if (k1 = k2) then assignSpine (Body, depth, Glocal_u1, (S1, s1), S2, cnstr) else raise (Assignment "Bound variable clash") | _ -> raise (Assignment "Head mismatch")) | _ -> assignHead (Body, depth, Glocal_u1, Us1, U2, cnstr)) | assignExpW (TypeLabel, depth, Glocal_u1, Us1 as (Root (H1, S1), s1), U2 as Root (H2, S2), cnstr)  = (match H2 with BVar (k2) -> if (k2 > depth) then (* BVar(k2) stands for an existential variable *) (* then by invariant, it must have been already instantiated *) cnstr else (match H1 with BVar (k1) -> if (k1 = k2) then assignSpine (TypeLabel, depth, Glocal_u1, (S1, s1), S2, cnstr) else raise (Assignment "Bound variable clash") | _ -> raise (Assignment "Head mismatch")) | _ -> assignHead (TypeLabel, depth, Glocal_u1, Us1, U2, cnstr)) | assignExpW (nvaronly, depth, Glocal_u1, Us1, U2 as Root (BVar k2, S), cnstr)  = if (k2 > depth) then (* BVar(k2) stands for an existential variable *) (* I.Root (BVar k2, S) will be fully applied (invariant from compilation) *) (* Glocal_u1 |- Us1 *) (match nvaronly with TypeLabel -> cnstr | Body -> (insert asub ((k2 - depth), Assign (Glocal_u1, EClo (Us1))); cnstr)) else (match nvaronly with TypeLabel -> cnstr | Body -> (match Us1 with (EVar (r, _, V, Cnstr), s) -> let U2\' = normalizeNExp (U2, csub) in (Eqn (Glocal_u1, EClo (Us1), U2\') :: cnstr) | (EClo (U, s\'), s) -> assignExp (Body, depth, Glocal_u1, (U, comp (s\', s)), U2, cnstr) | (FgnExp (_, ops), _) -> let U2\' = normalizeNExp (U2, csub) in (Eqn (Glocal_u1, EClo (Us1), U2\') :: cnstr))) | assignExpW (nvaronly, depth, Glocal_u1, (Lam (D1 as Dec (_, A1), U1), s1), Lam (D2 as Dec (_, A2), U2), cnstr)  = (* D1[s1] = D2[s2]  by invariant *)  (* nsub_goal may be destructively updated,\n               asub does not change (i.e. existential variables are not instantiated,\n               by invariant they must have been already instantiated\n             *) let cnstr\' = assignExp (TypeLabel, depth, Glocal_u1, (A1, s1), A2, cnstr) in assignExp (nvaronly, depth + 1, Decl (Glocal_u1, decSub (D1, s1)), (U1, dot1 s1), U2, cnstr\') | assignExpW (nvaronly, depth, Glocal_u1, (Pi ((D1 as Dec (_, A1), _), U1), s1), Pi ((D2 as Dec (_, A2), _), U2), cnstr)  = (* D1[s1] = D2[s2]  by invariant *)  (* nsub_goal may be destructively updated,\n               asub does not change (i.e. existential variables are not instantiated,\n               by invariant they must have been already instantiated\n            *) let cnstr\' = assignExp (TypeLabel, depth, Glocal_u1, (A1, s1), A2, cnstr) in assignExp (nvaronly, depth + 1, Decl (Glocal_u1, decSub (D1, s1)), (U1, dot1 s1), U2, cnstr\') | assignExpW (nvaronly, depth, Glocal_u1, Us1 as (EVar (r, _, V, Cnstr), s), U2, cnstr)  = (* generate cnstr substitution for all nvars occurring in U2 *)  let U2\' = normalizeNExp (U2, csub) in (Eqn (Glocal_u1, EClo (Us1), U2\') :: cnstr) | assignExpW (nvaronly, depth, Glocal_u1, Us1 as (EClo (U, s\'), s), U2, cnstr)  = assignExp (nvaronly, depth, Glocal_u1, (U, comp (s\', s)), U2, cnstr) | assignExpW (nvaronly, depth, Glocal_u1, Us1 as (FgnExp (_, ops), _), U2, cnstr)  = (* by invariant Us2 cannot contain any FgnExp *)  let U2\' = normalizeNExp (U2, csub) in (Eqn (Glocal_u1, EClo (Us1), U2\') :: cnstr) | assignExpW (nvaronly, depth, Glocal_u1, Us1, U2 as FgnExp (_, ops), cnstr)  = (Eqn (Glocal_u1, EClo (Us1), U2) :: cnstr)(*      | assignExpW (nvaronly, depth, Glocal_u1, (U1, s1), I.Lam (D2, U2), cnstr) =\n          (* Cannot occur if expressions are eta expanded *)\n          raise Assignment "Cannot occur if expressions in clause heads are eta-expanded"*) (*      | assignExpW (nvaronly, depth, Glocal_u1, (I.Lam (D1, U1), s1), U2, cnstr) =\n      (* ETA: can\'t occur if eta expanded *)\n            raise Assignment "Cannot occur if expressions in query are eta-expanded"\n*) (* same reasoning holds as above *) assignSpine (nvaronly, depth, Glocal_u1, (Nil, _), Nil, cnstr)  = cnstr | assignSpine (nvaronly, depth, Glocal_u1, (SClo (S1, s1\'), s1), S, cnstr)  = assignSpine (nvaronly, depth, Glocal_u1, (S1, comp (s1\', s1)), S, cnstr) | assignSpine (nvaronly, depth, Glocal_u1, (App (U1, S1), s1), App (U2, S2), cnstr)  = (* nsub_goal, asub may be destructively updated *) let cnstr\' = assignExp (nvaronly, depth, Glocal_u1, (U1, s1), U2, cnstr) in assignSpine (nvaronly, depth, Glocal_u1, (S1, s1), S2, cnstr\')assignExp (nvaronly, depth, Glocal_u1, Us1, U2, cnstr)  = assignExpW (nvaronly, depth, Glocal_u1, whnf Us1, U2, cnstr) in assignExp (nvaronly, depth, Glocal_u1, Us1, U2, cnstr) (* assignable (g, nsub, nsub_goal, asub, csub, cnstr) = (nsub_goal\', csub, cnstr\') option\n\n    nsub, nsub_goal, nsub_goal\' are  well-formed normal substitutions\n    asub is a well-formed assignable substitution\n    csub is maps normal variables to avars\n\n        G  |- nsub_goal\n        G\' |- nsub : N\n        G  |- asub : G\'\n\n    G\'     |- csub : N\'\n    G\', N\' |- cnstr\n    G\'     |- cnstr[csub]\n\n   *) let rec assignableLazy (nsub, nsub_query, assignSub, (nsub_left, cnstrSub), cnstr)  = let nsub_query\' = querySubId () let cref = ref cnstr let rec assign\' (nsub_query, nsub)  = let (nsub_query_left, nsub_left1) = differenceModulo nsub_query nsub (fun (Glocal_u, (l, U)) -> fun (l\', T) -> cref := assign (l, (* = l\' *) , Glocal_u, (U, id), T, nsub_query\', assignSub, cnstrSub, ! cref)) let nsub_left\' = update nsub_left1 (fun (l, U) -> (l, normalizeNExp (U, cnstrSub))) in (SOME (union nsub_query_left nsub_query\', (union nsub_left nsub_left\', cnstrSub), ! cref)) in try  with let rec assignableEager (nsub, nsub_query, assignSub, cnstrSub, cnstr)  = let nsub_query\' = querySubId () let cref = ref cnstr let rec assign\' (nsub_query, nsub)  = (* normalize nsub_left (or require that it is normalized\n             collect all left-over nsubs and later combine it with cnstrsub\n           *) let (nsub_query_left, nsub_left) = differenceModulo nsub_query nsub (fun (Glocal_u, (l, U)) -> fun (l\', T) -> cref := assign (l\', (* = l *) , Glocal_u, (U, id), T, nsub_query\', assignSub, cnstrSub, ! cref)) let _ = forall nsub_left (fun (nv, (nvaronly, U)) -> match (lookup cnstrSub nv) with NONE -> raise (Error "Left-over nsubstitution") | SOME (AVar A) -> A := SOME (normalizeNExp (U, cnstrSub))) in (* cnstr[rsub] *) (* nsub_goal1 = rgoal u nsub_goal\'  remaining substitutions to be checked *) (SOME (union nsub_query_left nsub_query\', cnstrSub, ! cref)) in try  with (* Unification *) let rec unifyW (G, (X as AVar (r as ref NONE), Shift 0), Us2)  = (r := SOME (EClo (Us2))) | unifyW (G, (X as AVar (r as ref NONE), s), Us2 as (U, s2))  = (print "unifyW -- not s = Id\\n"; print ("Us2 = " ^ expToString (G, EClo (Us2)) ^ "\\n"); r := SOME (EClo (Us2))) | unifyW (G, Xs1, Us2)  = (* Xs1 should not contain any uninstantiated AVar anymore *)  unifyW (G, Xs1, Us2) let rec unify (G, Xs1, Us2)  = unifyW (G, whnf Xs1, whnf Us2) let rec unifiable (G, Us1, Us2)  = try  with (* Convert context G into explicit substitution *) (* ctxToEVarSub (i, G, G\', asub, s) = s\' *) let rec ctxToExplicitSub (i, Gquery, Null, asub)  = id | ctxToExplicitSub (i, Gquery, Decl (Gclause, Dec (_, A)), asub)  = let s = ctxToExplicitSub (i + 1, Gquery, Gclause, asub) let (U\' as EVar (X\', _, _, _)) = newEVar (Gquery, EClo (A, s)) in match lookup asub i with NONE -> () | SOME (Assign (Glocal_u, U)) -> X\' := SOME (raiseType (Glocal_u, U)); Dot (Exp (U\'), s) | ctxToExplicitSub (i, Gquery, Decl (Gclause, ADec (_, d)), asub)  = let (U\' as (AVar X\')) = newAVar () in (match lookup asub i with NONE -> () | SOME (Assign (Glocal_u, U)) -> X\' := SOME (U)); Dot (Exp (EClo (U\', Shift (~ d))), ctxToExplicitSub (i + 1, Gquery, Gclause, asub))(* d = I.ctxLength Glocal_u *) let rec solveAuxG (Trivial, s, Gquery)  = true | solveAuxG (UnifyEq (Glocal, e1, N, eqns), s, Gquery)  = let G = compose\' (Glocal, Gquery) let s\' = shift (Glocal, s) in if unifiable (G, (N, s\'), (e1, s\')) then solveAuxG (eqns, s, Gquery) else false let rec solveCnstr (Gquery, Gclause, nil, s)  = true | solveCnstr (Gquery, Gclause, Eqn (Glocal, U1, U2) :: Cnstr, s)  = (unifiable (compose\' (Gquery, Glocal), (U1, id), (U2, shift (Glocal, s))) && solveCnstr (Gquery, Gclause, Cnstr, s)) let rec solveResiduals (Gquery, Gclause, CGoals (AuxG, cid, ConjGoals, i), asub, cnstr\', sc)  = let s = ctxToExplicitSub (1, Gquery, Gclause, asub) let success = solveAuxG (AuxG, s, Gquery) && solveCnstr (Gquery, Gclause, cnstr\', s) in if success then (sc ((ConjGoals, s), cid, (* B *) )) else () let rec ithChild (CGoals (_, _, _, i), n)  = (i = n) let rec retrieveChild (num, Child, nsub_query, assignSub, cnstr, Gquery, sc)  = let rec retrieve (Leaf (nsub, Gclause, Residuals), nsub_query, assignSub, cnstrSub, cnstr)  = (match assignableEager (nsub, nsub_query, assignSub, cnstrSub, cnstr)(* destructively updates assignSub, might initiate backtracking  *)  with NONE -> () | SOME (nsub_query\', cnstrSub\', cnstr\') -> (if (isId nsub_query\')(* cnstrSub\' = empty? by invariant *)  then (* LCO optimization *) if ithChild (Residuals, ! num) then solveResiduals (Gquery, Gclause, Residuals, assignSub, cnstr\', sc) else trail (fun () -> solveResiduals (Gquery, Gclause, Residuals, assignSub, cnstr\', sc)) else raise (Error "Left-over normal substitutions!"))) | retrieve (Node (nsub, Children), nsub_query, assignSub, cnstrSub, cnstr)  = (match assignableEager (nsub, nsub_query, assignSub, cnstrSub, cnstr)(* destructively updates nsub_query, assignSub,  might fail and initiate backtracking *) (* we must undo any changes to assignSub and whatever else is destructively updated,\n             cnstrSub?, cnstr? or keep them separate from different branches!*)  with NONE -> () | SOME (nsub_query\', cnstrSub\', cnstr\') -> (forall Children (fun (n, Child) -> retrieve (Child, nsub_query\', copy assignSub, copy cnstrSub\', cnstr\')))) in retrieve (Child, nsub_query, assignSub, cnstrSubId (), cnstr) let rec retrieval (n, STree as Node (s, Children), G, r, sc)  = (* s = id *)  let (nsub_query, assignSub) = (querySubId (), assignSubId ()) in insert nsub_query (1, (Null, (Body, r))); forall Children (fun (_, C) -> retrieveChild (n, C, nsub_query, assignSub, nil, G, sc)) (*----------------------------------------------------------------------------*) (* Retrieval via set of candidates *) let rec retrieveAll (num, Child, nsub_query, assignSub, cnstr, candSet)  = let i = ref 0 let rec retrieve (Leaf (nsub, Gclause, Residuals), nsub_query, assignSub, (nsub_left, cnstrSub), cnstr)  = (match assignableLazy (nsub, nsub_query, assignSub, (nsub_left, cnstrSub), cnstr)(* destructively updates assignSub, might initiate backtracking  *)  with NONE -> () | SOME (nsub_query\', (nsub_left\', cnstrSub\'), cnstr\') -> (if (isId nsub_query\') then (* LCO optimization *) (i := ! i + 1; insert candSet (! i, (assignSub, nsub_left\', cnstrSub\', cnstr\', Gclause, Residuals)); ()) else raise (Error "Left-over normal substitutions!"))) | retrieve (Node (nsub, Children), nsub_query, assignSub, (nsub_left, cnstrSub), cnstr)  = (match assignableLazy (nsub, nsub_query, assignSub, (nsub_left, cnstrSub), cnstr)(* destructively updates nsub_query, assignSub,  might fail and initiate backtracking *) (* we must undo any changes to assignSub and whatever else is destructively updated,\n             cnstrSub?, cnstr? or keep them separate from different branches!*)  with NONE -> () | SOME (nsub_query\', (nsub_left\', cnstrSub\'), cnstr\') -> (forall Children (fun (n, Child) -> retrieve (Child, nsub_query\', copy assignSub, (copy nsub_left\', copy cnstrSub\'), cnstr\')))) in retrieve (Child, nsub_query, assignSub, (nid (), cnstrSubId ()), cnstr) let rec retrieveCandidates (n, STree as Node (s, Children), Gquery, r, sc)  = (* s = id *)  let (nsub_query, assignSub) = (querySubId (), assignSubId ()) let candSet = new () let rec solveCandidate (i, candSet)  = match (lookup candSet i) with NONE -> ((* print "No candidate left anymore\\n" ;*) ()) | SOME (assignSub, nsub_left, cnstrSub, cnstr, Gclause, Residuals, (* CGoals(AuxG, cid, ConjGoals, i) *) ) -> (trail (fun () -> (forall nsub_left (fun (nv, (l, U)) -> match (lookup cnstrSub nv) with NONE -> raise (Error "Left-over nsubstitution") | SOME (AVar A) -> A := SOME (U)); solveResiduals (Gquery, Gclause, Residuals, assignSub, cnstr, sc))); solveCandidate (i + 1, candSet, (* sc = (fn S => (O::S)) *) )) in insert nsub_query (1, (Null, (Body, r))); forall Children (fun (_, C) -> retrieveAll (n, C, nsub_query, assignSub, nil, candSet)); (* execute one by one all candidates : here ! *) solveCandidate (1, candSet) let rec matchSig (a, G, ps as (Root (Ha, S), s), sc)  = let (n, Tree) = sub (indexArray, a) in (* retrieval (n, !Tree, G, I.EClo(ps), sc)   *) retrieveCandidates (n, ! Tree, G, EClo (ps), sc) let rec matchSigIt (a, G, ps as (Root (Ha, S), s), sc)  = let (n, Tree) = sub (indexArray, a) in retrieval (n, ! Tree, G, EClo (ps), sc) let rec sProgReset ()  = (nctr := 1; modify (fun (n, Tree) -> (n := 0; Tree := ! (makeTree ()); (n, Tree))) indexArray) let rec sProgInstall (a, Head (E, G, Eqs, cid), R)  = let (n, Tree) = sub (indexArray, a) let nsub_goal = new () in insert nsub_goal (1, (Body, E)); Tree := insert (! Tree, nsub_goal, (G, CGoals (Eqs, cid, R, ! n + 1))); n := ! n + 1 let sProgReset = sProgReset let sProgInstall = sProgInstall let matchSig = matchSigIt  (* local *)  end\n(* functor SubTree *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Compiled Syntax *) (* Author: Iliano Cervesato *) (* Modified: Jeff Polakow *) module type COMPSYN = sig (*! structure IntSyn : INTSYN !*) type OptNoLinearHeadsIndexingval optimize : Opt reftype GoalAtomExpImplResGoal * Exp(*     | (r,A,a) => g         *)  * Head * GoalAllDec * Goal and ResGoalEqExpAssignExp * AuxGoalAndResGoal(*     | r & (A,g)            *)  * Exp * GoalInResGoal(*     | r virt& (A,g)        *)  * Exp * GoalExistsDec * ResGoalAxistsDec * ResGoal and AuxGoalTrivialUnifyEqdctx * Exp(* call unify *)  * Exp * AuxGoal(* Static programs -- compiled version for substitution trees *) type ConjunctionTrueConjunctGoal * Exp * Conjunctiontype CompHeadHead(Exp * Dec Ctx * AuxGoal * cid)(* pskeleton instead of proof term *) type FlattermPcintDcintCsolverExptype pskeleton = Flatterm list(* The dynamic clause pool --- compiled version of the context *) (* type dpool = (ResGoal * IntSyn.Sub * IntSyn.cid) option IntSyn.Ctx *) (* Compiled Declarations *) (* added Thu Jun 13 13:41:32 EDT 2002 -cs *) type ComDecParameterDecResGoal * Sub * HeadBDecResGoal * Sub * Head listPDec(* Dynamic programs: context with synchronous clause pool *) type DProgDProg(dctx * ComDec Ctx)(* Programs --- compiled version of the signature (no direct head access) *) type ConDecSClauseResGoalVoid(* Other declarations are ignored  *) (* Install Programs (without indexing) *) val sProgInstall : cid * ConDec -> unitval sProgLookup : cid -> ConDecval sProgReset : unit -> unit(* Deterministic flag *) val detTableInsert : cid * bool -> unitval detTableCheck : cid -> boolval detTableReset : unit -> unit(* Explicit Substitutions *) val goalSub : Goal * Sub -> Goalval resGoalSub : ResGoal * Sub -> ResGoalval pskeletonToString : pskeleton -> string end\n(* signature COMPSYN *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Assignment *) (* Author: Larry Greenfield *) (* Modified: Brigitte Pientka *) module type ASSIGN = sig (*! structure IntSyn : INTSYN !*) (* assignable (Us,ps) assigns the term U[s] to the \n     linear higher-order pattern p[s]; if successfull it\n     returns a list of residual equations that have been postponed *) (* EVars and AVars in ps are instantiated as an effect *) val assignable : dctx * eclo * eclo -> Cnstr list option(* solveCnstr solves dynamically residuated equations *) val solveCnstr : Cnstr list -> bool(* unifiable solves statically residuated equations *) val unifiable : dctx * eclo * eclo -> bool(* instance solves statically residuated equations *) val instance : dctx * eclo * eclo -> boolval firstConstArg : Exp * Sub -> cid option end\n(* signature ASSIGN *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module type MSG = sig val message : string -> unitval setMessageFunc : (string -> unit) -> unit endmodule MsgMSG = struct let default = print let messageFunc = ref (default) let rec setMessageFunc f  = (messageFunc := f) let rec message s  = ((! messageFunc) s) end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Timers *) (* Author: Frank Pfenning *) module Timers = Timers(module Timing' = Timing)\n(*\n(* alternative not using actual timers *)\nstructure Timers =\n  Timers (structure Timing' = Counting);\n*) ", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* time-limit.sml\n *\n * COPYRIGHT (c) 1993 by AT&T Bell Laboratories.  See COPYRIGHT file for details.\n * Modified: Brigitte Pientka\n *) module TimeLimitsig exception TimeOutval timeLimit : time option -> (\'a -> \'b) -> \'a -> \'b end = struct exception TimeOut let rec timeLimit NONE f x  = f x | timeLimit (SOME t) f x  = let _ = print ("TIME LIMIT : " ^ toString t ^ "sec \\n") let setitimer = setIntTimer let rec timerOn ()  = ignore (setitimer (SOME t)) let rec timerOff ()  = ignore (setitimer NONE) let escapeCont = callcc (fun k -> (callcc (fun k\' -> (throw k k\')); timerOff (); raise (TimeOut))) let rec handler _  = escapeCont in setHandler (sigALRM, HANDLER handler); timerOn (); (try  with ) before timerOff () end\n(* TimeLimit *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Timers *) (* Author: Frank Pfenning *) module Timers = Timers(module Timing' = Timing)\n(*\n(* alternative not using actual timers *)\nstructure Timers =\n  Timers (structure Timing' = Counting);\n*) ", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Timers collecting statistics about Twelf *) (* Author: Frank Pfenning *) module type TIMERS = sig module Timing : TIMING(* Programming interface *) val parsing : center(* lexing and parsing *) val recon : center(* term reconstruction *) val abstract : center(* abstraction after reconstruction *) val checking : center(* redundant type-checking *) val modes : center(* mode checking *) val subordinate : center(* construction subordination relation *) val printing : center(* printing *) val compiling : center(* compilation *) val solving : center(* solving queries *) val coverage : center(* coverage checking *) val worlds : center(* world checking *) val ptrecon : center(* solving queries using ptskeleon *) val filling : center(* filling in m2 *) val filltabled : center(* filling in m2 *) val recursion : center(* recursion in m2 *) val splitting : center(* splitting in m2 *) val inference : center(* inference in m2 *) val terminate : center(* checking termination *) val delphin : center(* Operational Semantics of Delphin *) (* Warning: time for printing of the answer substitution to a
     query is counted twice here.
  *) val total : sum(* total time *) (* time center f x = y
     if f x = y and time of computing f x is added to center.
     If f x raises an exception, it is re-raised.
  *) val time : center -> ('a -> 'b) -> ('a -> 'b)(* External interface *) val reset : unit -> unit(* reset above centers *) val check : unit -> unit(* check timer values *) val show : unit -> unit(* check, then reset *)  end
(* signature TIMERS *) 
('Error parsing code:', '(* Timing utilities based on SML\'97 Standard Library *) (* Author: Frank Pfenning *) (*\n   For documentation on timers and time, see also the\n   SML\'97 Standard Library structures Time and Timer\n\n   In saved heaps in SML of NJ, a global timer must\n   be initialized, otherwise exception Time.Time is raised\n   somewhere.\n*) module type TIMING = sig val init : unit -> unittype centerval newCenter : string -> centerval reset : center -> unitval time : center -> (\'a -> \'b) -> (\'a -> \'b)type sumval sumCenter : string * center list -> sumval toString : center -> stringval sumToString : sum -> string end\n(* signature TIMING *) module TimingTIMING = struct (* user and system time add up to total CPU time used *)  (* gc time is a portion of the total CPU time devoted to garbage collection *)  type cpuTime = {usr: time; sys: time; gc: time} type realTime = time let rec init ()  = () type result = Value of \'a | Exception of exn type center = string * cpuTime * realTime ref type sum = string * center list let zero = {usr = zeroTime; sys = zeroTime; gc = zeroTime} let rec minus ({usr = t1; sys = t2; gc = t3}, {usr = s1; sys = s2; gc = s3})  = {usr = - (t1, s1); sys = - (t2, s2); gc = - (t3, s3)} let rec plus ({usr = t1; sys = t2; gc = t3}, {usr = s1; sys = s2; gc = s3})  = {usr = + (t1, s1); sys = + (t2, s2); gc = + (t3, s3)} let rec sum ({usr = t1; sys = t2; gc = t3})  = + (t1, t2) (* We use only one global timer each for CPU time and real time *) (* val CPUTimer = Timer.startCPUTimer () *) (* val realTimer = Timer.startRealTimer () *) (* newCenter (name) = new center, initialized to 0 *) let rec newCenter (name)  = (name, ref (zero, zeroTime)) (* reset (center) = (), reset center to 0 as effect *) let rec reset (_, counters)  = (counters := (zero, zeroTime)) (* time center f x = y\n       runs f on x and adds its time to center.\n       If f x raises an exception, this is properly re-raised\n\n       Warning: if the execution of f uses its own centers,\n       the time for those will be counted twice!\n    *) let rec checkCPUAndGCTimer timer  = let {usr = usr; sys = sys} = checkCPUTimer timer let gc = checkGCTime timer in {usr = usr; sys = sys; gc = gc} let rec time (_, counters) (f : \'a -> \'b) (x : \'a)  = let realTimer = startRealTimer () let CPUTimer = startCPUTimer () let result = try  with  let evalCPUTime = checkCPUAndGCTimer (CPUTimer) let evalRealTime = checkRealTimer (realTimer) let (CPUTime, realTime) = ! counters let _ = counters := (plus (CPUTime, evalCPUTime), + (realTime, evalRealTime)) in match result with Value (v) -> v | Exception (e) -> raise (e) (* sumCenter (name, centers) = sc\n       where sc is a new sum which contains the sum of the timings of centers.\n\n       Warning: the centers should not overlap!\n    *) let rec sumCenter (name, l)  = (name, l) let rec stdTime (n, time)  = padLeft \' \' n (toString time) let rec timesToString (name, (CPUTime as {usr = t1; sys = t2; gc = t3}, realTime))  = name ^ ": " ^ "Real = " ^ stdTime (7, realTime) ^ ", " ^ "Run = " ^ stdTime (7, sum CPUTime) ^ " " ^ "(" ^ stdTime (7, t1) ^ " usr, " (* ^ stdTime (5, t2) ^ " sys, " ^ *)  (* elide sys time *)  ^ stdTime (6, t3) ^ " gc)" ^ "\\n" let rec toString (name, ref (CPUTime, realTime))  = timesToString (name, (CPUTime, realTime)) let rec sumToString (name, centers)  = let rec sumup (nil, (CPUTime, realTime))  = timesToString (name, (CPUTime, realTime)) | sumup ((_, ref (C, R)) :: centers, (CPUTime, realTime))  = sumup (centers, (plus (CPUTime, C), + (realTime, R))) in sumup (centers, (zero, zeroTime))  (* local ... *)  end\n(* structure Timing *) (* This version only counts, but does not time *) (* Unused in the default linking, but could be *) (* passed as a paramter to Timers *) module CountingTIMING = struct type result = Value of \'a | Exception of exn type center = string * int ref type sum = string * center list let rec init ()  = () let rec newCenter (name)  = (name, ref 0) let rec reset (_, counters)  = (counters := 0) let rec time (_, counters) (f : \'a -> \'b) (x : \'a)  = let _ = counters := ! counters + 1 in f x let rec sumCenter (name, l)  = (name, l) let rec toString\' (name, n)  = name ^ ": " ^ toString n ^ "\\n" let rec toString (name, ref n)  = toString\' (name, n) let rec sumToString (name, centers)  = let rec sumup (nil, total)  = toString\' (name, total) | sumup ((_, ref n) :: centers, total)  = sumup (centers, total + n) in sumup (centers, 0) end\n(* structure Counting *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Names of Constants and Variables *) (* Author: Carsten Schuermann *) module FunNames (module Global : GLOBAL(*! structure FunSyn\' : FUNSYN !*) module HashTable : TABLE where keystring) : FUNNAMES = struct (*! structure FunSyn = FunSyn\' !*)  exception Error of string (****************************************)  (* Constants Names and Name Preferences *)  (****************************************)  (*\n     Names (strings) are associated with constants (cids) in two ways:\n     (1) There is an array nameArray mapping constants to print names (string),\n     (2) there is a hashtable sgnHashTable mapping identifiers (strings) to constants.\n\n     The mapping from constants to their print names must be maintained\n     separately from the global signature, since constants which have\n     been shadowed must be marked as such when printing.  Otherwise,\n     type checking can generate very strange error messages such as\n     "Constant clash: c <> c".\n\n     In the same table we also record the fixity property of constants,\n     since it is more a syntactic then semantic property which would\n     pollute the lambda-calculus core.\n\n     The mapping from identifers (strings) to constants is used during\n     parsing.\n\n     There are global invariants which state the mappings must be\n     consistent with each other.\n  *)  (* nameInfo carries the print name and fixity for a constant *)  type nameInfo = NameInfo of string let maxCid = maxCid (* nameArray maps constants to print names and fixity *) let nameArray = array (maxCid + 1, NameInfo "") : nameInfo array (* sgnHashTable maps identifiers (strings) to constants (cids) *) let sgnHashTable : cid Table = new (4096) let hashInsert = insertShadow sgnHashTable (* returns optional shadowed entry *) let hashLookup = lookup sgnHashTable (* returns optional cid *) let rec hashClear ()  = clear sgnHashTable (* reset () = ()\n       Effect: clear name tables related to constants\n\n       nameArray does not need to be reset, since it is reset individually\n       for every constant as it is declared\n    *) let rec reset ()  = (hashClear ()) (* override (cid, nameInfo) = ()\n       Effect: mark cid as shadowed --- it will henceforth print as %name%\n    *) let rec override (cid, NameInfo (name))  = (* should shadowed identifiers keep their fixity? *)  update (nameArray, cid, NameInfo ("%" ^ name ^ "%")) let rec shadow NONE  = () | shadow (SOME (_, cid))  = override (cid, sub (nameArray, cid)) (* installName (name, cid) = ()\n       Effect: update mappings from constants to print names and identifiers\n               to constants, taking into account shadowing\n    *) let rec installName (name, lemma)  = (* returns optional shadowed entry *) let shadowed = hashInsert (name, lemma) in (update (nameArray, lemma, NameInfo (name)); shadow shadowed) (* nameLookup (name) = SOME(cid),  if cid has name and is not shadowed,\n                         = NONE,   if there is no such constant\n    *) let rec nameLookup name  = hashLookup name (* constName (cid) = name,\n       where `name\' is the print name of cid\n    *) let rec constName (cid)  = (match sub (nameArray, cid) with (NameInfo (name)) -> name)  (* local ... *)  end\n(* functor Names *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Search (based on abstract machine ) : Version 1.3 *) (* Author: Carsten Schuermann *) module UniqueSearch (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) (*! structure FunSyn\' : FUNSYN !*) (*! sharing FunSyn\'.IntSyn = IntSyn\' !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.IntSyn = IntSyn\' !*) (*! sharing StateSyn\'.FunSyn = FunSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module MTPGlobal : MTPGLOBAL(*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Assign : ASSIGN(*! sharing Assign.IntSyn = IntSyn\'                         !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module Compile : COMPILE(*! sharing Compile.IntSyn = IntSyn\' !*) (*! sharing Compile.CompSyn = CompSyn\' !*) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) ) : UNIQUESEARCH = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure FunSyn = FunSyn\' !*)  module StateSyn = StateSyn\' (*! structure CompSyn = CompSyn\' !*)  exception Error of string type acctype = Exp module I = IntSynmodule C = CompSyn(* isInstantiated (V) = SOME(cid) or NONE\n       where cid is the type family of the atomic target type of V,\n       NONE if V is a kind or object or have variable type.\n    *) let rec isInstantiated (Root (Const (cid), _))  = true | isInstantiated (Pi (_, V))  = isInstantiated V | isInstantiated (Root (Def (cid), _))  = true | isInstantiated (Redex (V, S))  = isInstantiated V | isInstantiated (Lam (_, V))  = isInstantiated V | isInstantiated (EVar (ref (SOME (V)), _, _, _))  = isInstantiated V | isInstantiated (EClo (V, s))  = isInstantiated V | isInstantiated _  = false let rec compose\' (Null, G)  = G | compose\' (Decl (G, D), G\')  = Decl (compose\' (G, G\'), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) (* exists P K = B\n       where B iff K = K1, Y, K2  s.t. P Y  holds\n    *) let rec exists P K  = let rec exists\' (Null)  = false | exists\' (Decl (K\', Y))  = P (Y) || exists\' (K\') in exists\' K (* occursInExp (r, (U, s)) = B,\n\n       Invariant:\n       If    G |- s : G1   G1 |- U : V\n       then  B holds iff r occurs in (the normal form of) U\n    *) let rec occursInExp (r, Vs)  = occursInExpW (r, whnf Vs)occursInExpW (r, (Uni _, _))  = false | occursInExpW (r, (Pi ((D, _), V), s))  = occursInDec (r, (D, s)) || occursInExp (r, (V, dot1 s)) | occursInExpW (r, (Root (_, S), s))  = occursInSpine (r, (S, s)) | occursInExpW (r, (Lam (D, V), s))  = occursInDec (r, (D, s)) || occursInExp (r, (V, dot1 s)) | occursInExpW (r, (EVar (r\', _, V\', _), s))  = (r = r\') || occursInExp (r, (V\', s)) | occursInExpW (r, (FgnExp csfe, s))  = fold csfe (fun (U, B) -> B || occursInExp (r, (U, s))) false(* hack - should consult cs  -rv *) occursInSpine (_, (Nil, _))  = false | occursInSpine (r, (SClo (S, s\'), s))  = occursInSpine (r, (S, comp (s\', s))) | occursInSpine (r, (App (U, S), s))  = occursInExp (r, (U, s)) || occursInSpine (r, (S, s))occursInDec (r, (Dec (_, V), s))  = occursInExp (r, (V, s)) (* nonIndex (r, GE) = B\n\n       Invariant:\n       B hold iff\n        r does not occur in any type of EVars in GE\n    *) let rec nonIndex (_, nil)  = true | nonIndex (r, EVar (_, _, V, _) :: GE)  = (not (occursInExp (r, (V, id)))) && nonIndex (r, GE) (* select (GE, (V, s), acc) = acc\'\n\n       Invariant:\n    *) (* Efficiency: repeated whnf for every subterm in Vs!!! *) let rec selectEVar (nil)  = nil | selectEVar ((X as EVar (r, _, _, ref nil)) :: GE)  = let Xs = selectEVar (GE) in if nonIndex (r, Xs) then Xs @ [X] else Xs | selectEVar ((X as EVar (r, _, _, cnstrs)) :: GE)  = (* Constraint case *)  let Xs = selectEVar (GE) in if nonIndex (r, Xs) then X :: Xs else Xs (* pruneCtx (G, n) = G\'\n\n       Invariant:\n       If   |- G ctx\n       and  G = G0, G1\n       and  |G1| = n\n       then |- G\' = G0 ctx\n    *) let rec pruneCtx (G, 0)  = G | pruneCtx (Decl (G, _), n)  = pruneCtx (G, n - 1) let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a | cidFromHead (Skonst a)  = a (* only used for type families of compiled clauses *) let rec eqHead (Const a, Const a\')  = a = a\' | eqHead (Def a, Def a\')  = a = a\' | eqHead _  = false (* solve ((g,s), (G,dPool), sc, (acc, k)) => ()\n     Invariants:\n       G |- s : G\'\n       G\' |- g :: goal\n       G ~ dPool  (context G matches dPool)\n       acc is the accumulator of results\n       and k is the max search depth limit\n           (used in the existential case for iterative deepening,\n            used in the universal case for max search depth)\n       if  G |- M :: g[s] then G |- sc :: g[s] => Answer, Answer closed\n  *) let rec solve (max, depth, (Atom p, s), dp, sc, acc)  = matchAtom (max, depth, (p, s), dp, sc, acc) | solve (max, depth, (Impl (r, A, H, g), s), DProg (G, dPool), sc, acc)  = let D\' = Dec (NONE, EClo (A, s)) in solve (max, depth + 1, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, H))), (fun (M, acc\') -> sc (Lam (D\', M), acc\')), acc) | solve (max, depth, (All (D, g), s), DProg (G, dPool), sc, acc)  = let D\' = decSub (D, s) in solve (max, depth + 1, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Parameter)), (fun (M, acc\') -> sc (Lam (D\', M), acc\')), acc)(* rsolve (max, depth, (p,s\'), (r,s), (G,dPool), sc, (acc, k)) = ()\n     Invariants:\n       G |- s : G\'\n       G\' |- r :: resgoal\n       G |- s\' : G\'\'\n       G\'\' |- p :: atom\n       G ~ dPool\n       acc is the accumulator of results\n       and k is the max search depth limit\n           (used in the existential case for iterative deepening,\n            used in the universal case for max search depth)\n       if G |- S :: r[s] then G |- sc : (r >> p[s\']) => Answer\n  *) rSolve (max, depth, ps\', (Eq Q, s), DProg (G, dPool), sc, acc)  = if unifiable (G, ps\', (Q, s)) then sc (Nil, acc) else acc | rSolve (max, depth, ps\', (Assign (Q, eqns), s), dp as DProg (G, dPool), sc, acc)  = (match assignable (G, ps\', (Q, s)) with SOME (cnstr) -> aSolve ((eqns, s), dp, cnstr, (fun () -> sc (Nil, acc)), acc) | NONE -> acc) | rSolve (max, depth, ps\', (And (r, A, g), s), dp as DProg (G, dPool), sc, acc)  = (* is this EVar redundant? -fp *) let X = newEVar (G, EClo (A, s)) in rSolve (max, depth, ps\', (r, Dot (Exp (X), s)), dp, (fun (S, acc\') -> solve (max, depth, (g, s), dp, (fun (M, acc\'\') -> sc (App (M, S), acc\'\')), acc\')), acc) | rSolve (max, depth, ps\', (In (r, A, g), s), dp as DProg (G, dPool), sc, acc)  = (* G |- g goal *) (* G |- A : type *) (* G, A |- r resgoal *) (* G0, Gl  |- s : G *) (* G0, Gl  |- w : G0 *) (* G0 |- iw : G0, Gl *) (* G0 |- w : G *) (* G0 |- X : A[s\'] *) (* G0, Gl |- X\' : A[s\'][w] = A[s] *) let G0 = pruneCtx (G, depth) let dPool0 = pruneCtx (dPool, depth) let w = Shift (depth) let iw = invert w let s\' = comp (s, iw) let X = newEVar (G0, EClo (A, s\')) let X\' = EClo (X, w) in rSolve (max, depth, ps\', (r, Dot (Exp (X\'), s)), dp, (fun (S, acc\') -> if isInstantiated X then sc (App (X\', S), acc\') else solve (max, 0, (g, s\'), DProg (G0, dPool0), (fun (M, acc\'\') -> (try  with )), acc\')), acc) | rSolve (max, depth, ps\', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), sc, acc)  = let X = newEVar (G, EClo (A, s)) in rSolve (max, depth, ps\', (r, Dot (Exp (X), s)), dp, (fun (S, acc\') -> sc (App (X, S), acc\')), acc) | rSolve (max, depth, ps\', (Axists (ADec (SOME (X), d), r), s), dp as DProg (G, dPool), sc, acc)  = let X\' = newAVar () in rSolve (max, depth, ps\', (r, Dot (Exp (EClo (X\', Shift (~ d))), s)), dp, sc, acc)(* we don\'t increase the proof term here! *)(* aSolve ((ag, s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       if G |- ag[s] auxgoal\n       then sc () is evaluated with return value res\n       else res = Fail\n     Effects: instantiation of EVars in ag[s], dp and sc () *) aSolve ((Trivial, s), dp, cnstr, sc, acc)  = (if solveCnstr cnstr then sc () else acc) | aSolve ((UnifyEq (G\', e1, N, eqns), s), dp as DProg (G, dPool), cnstr, sc, acc)  = let G\'\' = compose\' (G\', G) let s\' = shift (G\', s) in if unifiable (G\'\', (N, s\'), (e1, s\')) then aSolve ((eqns, s), dp, cnstr, sc, acc) else acc(* matchatom ((p, s), (G, dPool), sc, (acc, k)) => ()\n     G |- s : G\'\n     G\' |- p :: atom\n     G ~ dPool\n     acc is the accumulator of results\n     and k is the max search depth limit\n         (used in the existential case for iterative deepening,\n          used in the universal case for max search depth)\n     if G |- M :: p[s] then G |- sc :: p[s] => Answer\n  *) matchAtom (0, _, _, _, _, acc)  = acc | matchAtom (max, depth, ps\' as (Root (Ha, _), _), dp as DProg (G, dPool), sc, acc)  = let rec matchSig\' (nil, acc\')  = acc\' | matchSig\' (Hc :: sgn\', acc\')  = let SClause (r) = sProgLookup (cidFromHead Hc) let acc\'\'\' = trail (fun () -> rSolve (max - 1, depth, ps\', (r, id), dp, (fun (S, acc\'\') -> sc (Root (Hc, S), acc\'\')), acc\')) in matchSig\' (sgn\', acc\'\'\') let rec matchDProg (Null, _, acc\')  = matchSig\' (lookup (cidFromHead Ha), acc\') | matchDProg (Decl (dPool\', Dec (r, s, Ha\')), n, acc\')  = if eqHead (Ha, Ha\') then let acc\'\'\' = trail (fun () -> rSolve (max - 1, depth, ps\', (r, comp (s, Shift n)), dp, (fun (S, acc\'\') -> sc (Root (BVar n, S), acc\'\')), acc\')) in matchDProg (dPool\', n + 1, acc\'\'\') else matchDProg (dPool\', n + 1, acc\') | matchDProg (Decl (dPool\', Parameter), n, acc\')  = matchDProg (dPool\', n + 1, acc\') in matchDProg (dPool, 1, acc)(* searchEx\' max (GE, sc) = acc\'\n\n       Invariant:\n       If   GE is a list of EVars to be instantiated\n       and  max is the maximal number of constructors\n       then if an instantiation of EVars in GE is found Success is raised\n            otherwise searchEx\' terminates with []\n    *) (* contexts of EVars are recompiled for each search depth *) searchEx\' max (nil, sc, acc)  = sc acc | searchEx\' max ((X as EVar (r, G, V, _)) :: GE, sc, acc)  = solve (max, 0, (compileGoal (G, V), id), compileCtx false G, (fun (U\', acc\') -> try  with ), acc) (* searchEx (G, GE, (V, s), sc) = acc\'\n       Invariant:\n       If   G |- s : G\'   G\' |- V : level\n       and  GE is a list of EVars contained in V[s]\n         where G |- X : VX\n       and  sc is a function to be executed after all non-index variables have\n         been instantiated\n       then acc\' is a list containing the one result from executing the success continuation\n         All EVar\'s got instantiated with the smallest possible terms.\n    *) let rec searchEx (it, depth) (GE, sc, acc)  = (if ! chatter > 5 then print "[Search: " else (); searchEx\' depth (selectEVar (GE), fun acc\' -> (if ! chatter > 5 then print "OK]\\n" else (); let GE\' = foldr (fun (X as EVar (_, G, _, _), L) -> collectEVars (G, (X, id), L)) nil GE let gE\' = length GE\' in if gE\' > 0 then if it > 0 then searchEx (it - 1, depth) (GE\', sc, acc\') else raise (Error "not found") else sc acc\'(* warning: iterative deepening depth is not propably updated.\n                                             possible that it runs into an endless loop ? *) ), acc)) (* search (GE, sc) = ()\n\n       Invariant:\n       GE is a list of uninstantiated EVars\n       and sc is a success continuation : int -> unit\n\n       Side effect:\n       success continuation will raise exception\n    *) (* Shared contexts of EVars in GE may recompiled many times *) let rec search (maxFill, GE, sc)  = searchEx (1, maxFill) (GE, sc, nil) let searchEx = search  (* local ... *)  end\n(* functor Search *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Global parameters *) (* Author: Carsten Schuermann *) module type MTPGLOBAL = sig type ProverTypeNewOldval prover : ProverType refval maxFill : int refval maxSplit : int refval maxRecurse : int ref end\n(* signature MTPGLOBAL *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Type checking for functional proof term calculus *) (* Author: Carsten Schuermann *) module type FUNTYPECHECK = sig (*! structure FunSyn : FUNSYN !*) module StateSyn : STATESYNexception Error of stringval isFor : dctx * For -> unitval check : Pro * For -> unitval checkSub : lfctx * Sub * lfctx -> unitval isState : State -> unit end(* Signature FUNTYPECHECK *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Inference: Version 1.3 *) (* Author: Carsten Schuermann *) module type INFERENCE = sig (*! structure FunSyn : FUNSYN !*) module StateSyn : STATESYNexception Error of stringtype operatorval expand : State -> operatorval apply : operator -> Stateval menu : operator -> string end\n(* signature Inference *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Printing of functional proof terms *) (* Author: Carsten Schuermann *) module FunPrint ((*! structure FunSyn\' : FUNSYN !*) module Formatter : FORMATTERmodule Names : NAMES(*! sharing Names.IntSyn = FunSyn\'.IntSyn !*) module Print : PRINTPrintFormatterFormatter(*! sharing Print.IntSyn = FunSyn\'.IntSyn !*) ) : FUNPRINT = struct (*! structure FunSyn = FunSyn\' !*)  module Formatter = Formatter module F = FunSynmodule I = IntSynmodule Fmt = Formattermodule P = Print(* Invariant:\n\n       The proof term must satisfy the following conditions:\n       * proof term must have the structure\n           Rec.     Lam ... Lam Case\n                And Lam ... Lam Case\n                ...\n                And Lam ... Lam Case\n         and the body of every case must be of the form\n           (Let Decs in Case ...\n           or\n           Inx ... Inx Unit) *\n         where Decs are always of the form\n           New ... New App .. App Split .. Split Empty\n     *) (* formatCtxBlock (G, (G1, s1)) = (G\', s\', fmts\')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- G1 ctx\n       and  G2 |- s1 : G\n       then G\' = G2, G1 [s1]\n       and  G\' |- s\' : G, G1\n       and  fmts is a format list of G1[s1]\n    *) let rec formatCtxBlock (G, (Null, s))  = (G, s, nil) | formatCtxBlock (G, (Decl (Null, D), s))  = let D\' = decSub (D, s) let fmt = formatDec (G, D\') in (Decl (G, D\'), dot1 s, [fmt]) | formatCtxBlock (G, (Decl (G\', D), s))  = let (G\'\', s\'\', fmts) = formatCtxBlock (G, (G\', s)) let D\'\' = decSub (D, s\'\') let fmt = formatDec (G\'\', D\'\') in (Decl (G\'\', D\'\'), dot1 s\'\', fmts @ [String ","; Break; fmt]) (* formatFor\' (G, (F, s)) = fmts\'\n\n       Invariant:\n       If   |- G ctx\n       and  G |- s : Psi\'\n       and  Psi\' |- F formula\n       then fmts\' is a list of formats for F\n    *) let rec formatFor\' (G, (All (LD, F), s))  = (match LD with Prim D -> let D\' = decName (G, D) in [String "{{"; formatDec (G, decSub (D\', s)); String "}}"; Break] @ formatFor\' (Decl (G, D\'), (F, dot1 s)) | Block (CtxBlock (l, G\')) -> let (G\'\', s\'\', fmts) = formatCtxBlock (G, (G\', s)) in [String "{"; Hbox fmts; String "}"; Break] @ formatFor\' (G\'\', (F, s\'\'))) | formatFor\' (G, (Ex (D, F), s))  = let D\' = decName (G, D) in [String "[["; formatDec (G, decSub (D\', s)); String "]]"; Break] @ formatFor\' (Decl (G, D\'), (F, dot1 s)) | formatFor\' (G, (True, s))  = [String "True"] (* formatFor (Psi, F) names = fmt\'\n       formatForBare (Psi, F) = fmt\'\n\n       Invariant:\n       If   |- Psi ctx\n       and  Psi |- F = F1 ^ .. ^ Fn formula\n       and  names is a list of n names,\n       then fmt\' is the pretty printed format\n    *) let rec formatFor (Psi, F) names  = (* formatFor1 (index, G, (F, s)) = fmts\'\n\n           Invariant:\n           If   |- G ctx\n           and  G |- s : Psi\n           and  Psi |- F1 ^ .. ^ F(index-1) ^ F formula\n           then fmts\' is a list of pretty printed formats for F\n        *) let rec nameLookup index  = nth (names, index) let rec formatFor1 (index, G, (And (F1, F2), s))  = formatFor1 (index, G, (F1, s)) @ [Break] @ formatFor1 (index + 1, G, (F2, s)) | formatFor1 (index, G, (F, s))  = [String (nameLookup index); Space; String "::"; Space; HVbox (formatFor\' (G, (F, s)))] let rec formatFor0 Args  = Vbox0 0 1 (formatFor1 Args) in (varReset Null; formatFor0 (0, makectx Psi, (F, id))) let rec formatForBare (G, F)  = HVbox (formatFor\' (G, (F, id))) (* formatPro (Psi, P) names = fmt\'\n\n       Invariant:\n       If   |- Psi ctx\n       and  Psi; . |- P = rec x. (P1, P2, .. Pn) in F\n       and  names is a list of n names,\n       then fmt\' is the pretty printed format of P\n    *) let rec formatPro Args names  = (* blockName (G1, G2) = G2\'\n\n           Invariant:\n           If   G1 |- G2 ctx\n           then G2\' = G2 modulo new non-conficting variable names.\n        *) (* ctxBlockName (G1, CB) = CB\'\n\n           Invariant:\n           If   G1 |- CB ctxblock\n           then CB\' = CB modulo new non-conficting variable names.\n        *) (* decName (G, LD) = LD\'\n\n           Invariant:\n           If   G1 |- LD lfdec\n           then LD\' = LD modulo new non-conficting variable names.\n        *) (* numberOfSplits Ds = n\'\n\n           Invariant:\n           If   Psi, Delta |- Ds :: Psi\', Delta\'\n           then n\'= |Psi\'| - |Psi|\n        *) (* psiName (Psi1, s, Psi2, l) = Psi1\'\n\n           Invariant:\n           If   |- Psi1 ctx\n           and  |- Psi1\' ctx\n           and  |- Psi2 ctx\n           and  Psi2 = Psi2\', Psi2\'\'\n           and  Psi1 |- s : Psi2\n           and  |Psi2\'\'| = l\n           then Psi1\' = Psi1 modulo variable naming\n           and  for all x in Psi2 s.t. s(x) = x in Psi1\'\n        *) (* merge (G1, G2) = G\'\n\n           Invariant:\n           G\' = G1, G2\n        *) (* formatCtx (Psi, G) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi |- G ctx\n           then fmt\' is a pretty print format of G\n        *) (* formatTuple (Psi, P) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- P = Inx (M1, Inx ... (Mn, Unit))\n           then fmt\' is a pretty print format of (M1, .., Mn)\n        *) (* formatSplitArgs (Psi, L) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  L = (M1, .., Mn)\n           and  Psi |- Mk:Ak for all 1<=k<=n\n           then fmt\' is a pretty print format of (M1, .., Mn)\n        *) (* frontToExp (Ft) = U\'\n\n           Invariant:\n           G |- Ft = U\' : V   for a G, V\n        *) (* formatDecs1 (Psi, Ds, s, L) = L\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- Ds : Psi\'; Delta\'\n           and  Psi\' = x1:A1 .. xn:An\n           and  Psi\'\' |- s : Psi\n           and  for i<=n\n                L = (M1 .. Mi)\n                s.t   Psi\'\' |- Mi : Ai\n           then L\' extends L\n           s.t. L = (M1 .. Mn)\n                for all i <=n\n                Psi\'\' |- Mi : Ai\n                (and Mi is a splitting of a the result of an inductive call)\n        *) (* formatDecs0 (Psi, Ds) = (Ds\', S\')\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi ; Delta |- Ds : Psi\', Delta\'\n           and  Ds = App M1 ... App Mn Ds\'   (where Ds\' starts with Split)\n           then S\' = (M1, M2 .. Mn)\n           and  Psi1, Delta1 |- Ds\' : Psi1\', Delta1\'\n                (for some Psi1, Delta1, Psi1\', Delta1\')\n        *) (* formatDecs (index, Psi, Ds, (Psi1, s1)) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- Ds : Psi\'; Delta\'\n           and  Psi1 |- s1 : Psi, Psi\'\n           then fmt\' is a pretty print format of Ds\n        *) (* formatLet (Psi, P, fmts) = fmts\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- P = Let . Case P\' :: F\n           and  fmts is a list of pretty print formats of P\n           then fmts\' extends fmts\n           and  fmts also includes a pretty print format for P\'\n        *) (* argsToSpine (Psi1, s, S) = S\'\n\n           Invariant:\n           If   Psi1 |- s = M1 . M2 .. Mn. ^|Psi1|: Psi2\n           and  Psi1 |- S : V1 > {Psi2} V2\n           then Psi1 |- S\' : V1 > V2\n           and S\' = S, M1 .. Mn\n           where\n           then Fmts is a list of arguments\n        *) (* formatHead (index, Psi1, s, Psi2) = fmt\'\n\n           Invariant:\n           If    Psi1 |- s : Psi2\n           then  fmt is a format of the entire head\n           where index represents the function name\n           and   s the spine.\n        *) (* formatPro2 (index, Psi, L) = fmts\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi |- L a list of cases\n           then fmts\' list of pretty print formats of L\n        *) (* formatPro1 (index, Psi, P) = fmts\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; . |- P :: F\n           and  P is either a Lam .. | Case ... | Pair ...\n           then fmts\' is alist of pretty print formats of P\n        *) (* formatPro0 (Psi, P) = fmt\'\n           If   |- Psi ctx\n           and  Psi; . |- P :: F\n           then fmt\' is a pretty print format of P\n        *) let rec nameLookup index  = nth (names, index) let rec blockName (G1, G2)  = let rec blockName\' (G1, Null)  = (G1, Null) | blockName\' (G1, Decl (G2, D))  = let (G1\', G2\') = blockName\' (G1, G2) let D\' = decName (G1, D) in (Decl (G1\', D\'), Decl (G2\', D\')) let (G1\', G2\') = blockName\' (G1, G2) in G2\' let rec ctxBlockName (G1, CtxBlock (name, G2))  = CtxBlock (name, blockName (G1, G2)) let rec decName (G, Prim D)  = Prim (decName (G, D)) | decName (G, Block CB)  = Block (ctxBlockName (G, CB)) let rec numberOfSplits Ds  = let rec numberOfSplits\' (Empty, n)  = n | numberOfSplits\' (New (_, Ds), n)  = numberOfSplits\' (Ds, n) | numberOfSplits\' (App (_, Ds), n)  = numberOfSplits\' (Ds, n) | numberOfSplits\' (Lemma (_, Ds), n)  = numberOfSplits\' (Ds, n) | numberOfSplits\' (Split (_, Ds), n)  = numberOfSplits\' (Ds, n + 1) | numberOfSplits\' (Left (_, Ds), n)  = numberOfSplits\' (Ds, n) | numberOfSplits\' (Right (_, Ds), n)  = numberOfSplits\' (Ds, n) in numberOfSplits\' (Ds, 0) let rec psiName (Psi1, s, Psi2, l)  = let rec nameDec (D as Dec (SOME _, _), name)  = D | nameDec (Dec (NONE, V), name)  = Dec (SOME name, V) let rec namePsi (Decl (Psi, Prim D), 1, name)  = Decl (Psi, Prim (nameDec (D, name))) | namePsi (Decl (Psi, LD as Prim D), n, name)  = Decl (namePsi (Psi, n - 1, name), LD) | namePsi (Decl (Psi, Block (CtxBlock (label, G))), n, name)  = let (Psi\', G\') = nameG (Psi, G, n, name, fun n\' -> namePsi (Psi, n\', name)) in Decl (Psi\', Block (CtxBlock (label, G\')))nameG (Psi, Null, n, name, k)  = (k n, Null) | nameG (Psi, Decl (G, D), 1, name, k)  = (Psi, Decl (G, nameDec (D, name))) | nameG (Psi, Decl (G, D), n, name, k)  = let (Psi\', G\') = nameG (Psi, G, n - 1, name, k) in (Psi\', Decl (G\', D)) let rec ignore (s, 0)  = s | ignore (Dot (_, s), k)  = ignore (s, k - 1) | ignore (Shift n, k)  = ignore (Dot (Idx (n + 1), Shift (n + 1)), k - 1) let rec copyNames (Shift n, G as Decl _) Psi1  = copyNames (Dot (Idx (n + 1), Shift (n + 1)), G) Psi1 | copyNames (Dot (Exp _, s), Decl (G, _)) Psi1  = copyNames (s, G) Psi1 | copyNames (Dot (Idx k, s), Decl (G, Dec (NONE, _))) Psi1  = copyNames (s, G) Psi1 | copyNames (Dot (Idx k, s), Decl (G, Dec (SOME name, _))) Psi1  = let Psi1\' = namePsi (Psi1, k, name) in copyNames (s, G) Psi1\' | copyNames (Shift _, Null) Psi1  = Psi1 let rec psiName\' (Null)  = Null | psiName\' (Decl (Psi, D))  = let Psi\' = psiName\' Psi in Decl (Psi\', decName (makectx Psi\', D)) in psiName\' (copyNames (ignore (s, l), makectx Psi2) Psi1) let rec merge (G1, Null)  = G1 | merge (G1, Decl (G2, D))  = Decl (merge (G1, G2), D) let rec formatCtx (Psi, G)  = let G0 = makectx Psi let rec formatCtx\' (Null)  = nil | formatCtx\' (Decl (Null, Dec (SOME name, V)))  = [String name; String ":"; formatExp (G0, V)] | formatCtx\' (Decl (G, Dec (SOME name, V)))  = (formatCtx\' G) @ [String ","; Break; String name; String ":"; formatExp (merge (G0, G), V)] in Hbox (String "|" :: (formatCtx\' G @ [String "|"])) let rec formatTuple (Psi, P)  = let rec formatTuple\' (Unit)  = nil | formatTuple\' (Inx (M, Unit))  = [formatExp (makectx Psi, M)] | formatTuple\' (Inx (M, P\'))  = (formatExp (makectx Psi, M) :: String "," :: Break :: formatTuple\' P\') in match P with (Inx (_, Unit)) -> Hbox (formatTuple\' P) | _ -> HVbox0 1 1 1 (String "(" :: (formatTuple\' P @ [String ")"])) let rec formatSplitArgs (Psi, L)  = let rec formatSplitArgs\' (nil)  = nil | formatSplitArgs\' (M :: nil)  = [formatExp (makectx Psi, M)] | formatSplitArgs\' (M :: L)  = (formatExp (makectx Psi, M) :: String "," :: Break :: formatSplitArgs\' L) in if length L = 1 then Hbox (formatSplitArgs\' L) else HVbox0 1 1 1 (String "(" :: (formatSplitArgs\' L @ [String ")"])) let rec frontToExp (Idx k)  = Root (BVar k, Nil) | frontToExp (Exp (U))  = U let rec formatDecs1 (Psi, Split (xx, Ds), Dot (Ft, s1), L)  = formatDecs1 (Psi, Ds, s1, frontToExp (Ft) :: L) | formatDecs1 (Psi, Empty, s1, L)  = L | formatDecs1 (Psi, Ds, Shift n, L)  = formatDecs1 (Psi, Ds, Dot (Idx (n + 1), Shift (n + 1)), L) let rec formatDecs0 (Psi, App ((xx, M), Ds))  = let (Ds\', S) = formatDecs0 (Psi, Ds) in (Ds\', App (M, S)) | formatDecs0 (Psi, Ds)  = (Ds, Nil) let rec formatDecs (index, Psi, Ds as App ((xx, _), P), (Psi1, s1))  = let (Ds\', S) = formatDecs0 (Psi, Ds) let L\' = formatDecs1 (Psi, Ds\', s1, nil) let name = nameLookup index in Hbox [formatSplitArgs (Psi1, L\'); Space; String "="; Break; HVbox (String name :: Break :: formatSpine (makectx Psi, S))] | formatDecs (index, Psi, New (B as CtxBlock (_, G), Ds), (Psi1, s1))  = let B\' = ctxBlockName (makectx Psi, B) let fmt = formatDecs (index, Decl (Psi, Block B\'), Ds, (Psi1, s1)) in Vbox [formatCtx (Psi, G); Break; fmt] | formatDecs (index, Psi, Lemma (lemma, Ds), (Psi1, s1))  = let (Ds\', S) = formatDecs0 (Psi, Ds) let L\' = formatDecs1 (Psi, Ds\', s1, nil) let (LemmaDec (names, _, _)) = lemmaLookup lemma in Hbox [formatSplitArgs (Psi1, L\'); Space; String "="; Break; HVbox (String (nth (names, index)) :: Break :: formatSpine (makectx Psi, S))] | formatDecs (index, Psi, Left (_, Ds), (Psi1, s1))  = let fmt = formatDecs (index, Psi, Ds, (Psi1, s1)) in fmt | formatDecs (index, Psi, Right (_, Ds), (Psi1, s1))  = let fmt = formatDecs (index + 1, Psi, Ds, (Psi1, s1)) in fmt let rec formatLet (Psi, Let (Ds, Case (Opts ((Psi1, s1, P1 as Let _) :: nil))), fmts)  = let Psi1\' = psiName (Psi1, s1, Psi, numberOfSplits Ds) let fmt = formatDecs (0, Psi, Ds, (Psi1\', s1)) in formatLet (Psi1\', P1, fmts @ [fmt; Break]) | formatLet (Psi, Let (Ds, Case (Opts ((Psi1, s1, P1) :: nil))), fmts)  = let Psi1\' = psiName (Psi1, s1, Psi, numberOfSplits Ds) let fmt = formatDecs (0, Psi, Ds, (Psi1\', s1)) in Vbox0 0 1 ([String "let"; Break; Spaces 2; Vbox0 0 1 (fmts @ [fmt]); Break; String "in"; Break; Spaces 2; formatPro3 (Psi1\', P1); Break; String "end"])(* formatPro3 (Psi, P) = fmt\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- P :: F\n           and  P = let .. in .. end | <..,..> | <>\n           then fmt is a pretty print of P\n        *) formatPro3 (Psi, P as Unit)  = formatTuple (Psi, P) | formatPro3 (Psi, P as Inx _)  = formatTuple (Psi, P) | formatPro3 (Psi, P as Let _)  = formatLet (Psi, P, nil) let rec argsToSpine (s, Null, S)  = S | argsToSpine (Shift (n), Psi, S)  = argsToSpine (Dot (Idx (n + 1), Shift (n + 1)), Psi, S) | argsToSpine (Dot (Ft, s), Decl (Psi, D), S)  = argsToSpine (s, Psi, App (frontToExp Ft, S)) let rec formatHead (index, Psi\', s, Psi)  = Hbox [Space; HVbox (String (nameLookup index) :: Break :: formatSpine (makectx Psi\', argsToSpine (s, Psi, Nil)))] let rec formatPro2 (index, Psi, nil)  = nil | formatPro2 (index, Psi, (Psi\', s, P) :: nil)  = let Psi\'\' = psiName (Psi\', s, Psi, 0) let fhead = if index = 0 then "fun" else "and" in [HVbox0 1 5 1 [String fhead; formatHead (index, Psi\'\', s, Psi); Space; String "="; Break; formatPro3 (Psi\'\', P)]; Break] | formatPro2 (index, Psi, (Psi\', s, P) :: O)  = let Psi\'\' = psiName (Psi\', s, Psi, 0) in formatPro2 (index, Psi, O) @ [HVbox0 1 5 1 [String "  |"; formatHead (index, Psi\'\', s, Psi); Space; String "="; Break; formatPro3 (Psi\'\', P)]; Break] let rec formatPro1 (index, Psi, Lam (D, P))  = formatPro1 (index, Decl (Psi, decName (makectx Psi, D)), P) | formatPro1 (index, Psi, Case (Opts Os))  = formatPro2 (index, Psi, Os) | formatPro1 (index, Psi, Pair (P1, P2))  = formatPro1 (index, Psi, P1) @ formatPro1 (index + 1, Psi, P2) let rec formatPro0 (Psi, Rec (DD, P))  = Vbox0 0 1 (formatPro1 (0, Psi, P)) in (varReset Null; formatPro0 Args) let rec formatLemmaDec (LemmaDec (names, P, F))  = Vbox0 0 1 [formatFor (Null, F) names; Break; formatPro (Null, P) names] let rec forToString Args names  = makestring_fmt (formatFor Args names) let rec proToString Args names  = makestring_fmt (formatPro Args names) let rec lemmaDecToString Args  = makestring_fmt (formatLemmaDec Args) let formatFor = formatFor let formatForBare = formatForBare let formatPro = formatPro let formatLemmaDec = formatLemmaDec let forToString = forToString let proToString = proToString let lemmaDecToString = lemmaDecToString  end\n(* signature FUNPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Type checking for functional proof term calculus *) (* Author: Carsten Schuermann *) module FunTypeCheck ((*! structure FunSyn\' : FUNSYN !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.FunSyn = FunSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = FunSyn\'.IntSyn !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = FunSyn\'.IntSyn !*) module Conv : CONV(*! sharing Conv.IntSyn = FunSyn\'.IntSyn !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = FunSyn\'.IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = FunSyn\'.IntSyn !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = FunSyn\'.IntSyn !*) module Weaken : WEAKEN(*! sharing Weaken.IntSyn = FunSyn\'.IntSyn   !*) module FunPrint : FUNPRINT(*! sharing FunPrint.FunSyn = FunSyn\' !*) ) : FUNTYPECHECK = struct (*! structure FunSyn = FunSyn\' !*)  module StateSyn = StateSyn\' exception Error of string module I = IntSynmodule F = FunSynmodule S = StateSyn(* conv ((G, s), (G\', s\')) = B\n\n       Invariant:\n       B iff G [s]  == G\' [s\']\n       Might migrate in to conv module  --cs\n    *) let rec conv (Gs, Gs\')  = exception Conv let rec conv ((Null, s), (Null, s\'))  = (s, s\') | conv ((Decl (G, Dec (_, V)), s), (Decl (G\', Dec (_, V\')), s\'))  = let (s1, s1\') = conv ((G, s), (G\', s\')) let ps as (s2, s2\') = (dot1 s1, dot1 s1\') in if conv ((V, s1), (V\', s1\')) then ps else raise (Conv) | conv _  = raise (Conv) in try  with (* extend (G, L) = G\'\n\n       Invariant:\n       If   G : \'a ctx\n       and  L : \'a list\n       then G\' = G, L : \'a ctx\n    *) let rec extend (G, nil)  = G | extend (G, D :: L)  = extend (Decl (G, D), L) (* validBlock (Psi, k, (l : G)) = ()\n\n       Invariant:\n       If   |- Psi ctx\n       and  |- k is a debruijn index (for LF context)\n       and  |- l label\n       and  |- G LFctx\n       then validBlock terminates with ()\n       iff  Psi = Psi1, l\': (x1:A1 .. xn:An), Psi2\n       and  l = l\'\n       and  Psi(k) = x1\n       and  G == x1:A1 .. xn:An\n    *) let rec validBlock (Psi, k, (l, G))  = let rec skipBlock (Null, k)  = k | skipBlock (Decl (G\', _), k)  = skipBlock (G\', k - 1) let rec validBlock\' (Decl (Psi, Block (CtxBlock (l\', G\'))), 0)  = if (l\' = l) && conv ((G, id), (G\', id)) then () else raise (Error "Typecheck Error: Not a valid block") | validBlock\' (Decl (Psi, Prim _), 0)  = raise (Error "Typecheck Error: Not a valid block") | validBlock\' (Null, k)  = raise (Error "Typecheck Error: Not a valid block") | validBlock\' (Decl (Psi, Block (CtxBlock (l\', G\'))), k)  = validBlock\' (Psi, skipBlock (G\', k)) | validBlock\' (Decl (Psi, Prim (D)), k)  = validBlock\' (Psi, k - 1) in validBlock\' (Psi, k) (* raiseSub (l:G, Psi\') = s\'\n\n       Invariant:\n       If   |- Psi ctx\n       and  Psi |- l:G ctx\n       and  Psi, l:G |- Psi\' ctx\n       then Psi, {G} Psi\', l:G|- s\' : Psi, l:G, Psi\'\n    *) let rec raiseSub (G, Psi\')  = let n = ctxLength G let m = ctxLength Psi\' let rec args (0, a, S)  = S | args (n\', a, S)  = let Dec (_, V) = ctxDec (G, n\') in if belowEq (targetFam V, a) then args (n\' - 1, a, App (Root (BVar n\', Nil), S)) else args (n\' - 1, a, S) let rec term m\'  = let Dec (_, V) = ctxDec (Psi\', m\') in Exp (Root (BVar (n + m\'), args (n, targetFam (V), Nil))) let rec raiseSub\'\' (0, s)  = s | raiseSub\'\' (m\', s)  = raiseSub\'\' (m\' - 1, Dot (term m\', s)) let rec raiseSub\' (0, s)  = raiseSub\'\' (m, s) | raiseSub\' (n\', s)  = raiseSub\' (n\' - 1, Dot (Idx n\', s)) in raiseSub\' (n, Shift (n + m)) (* raiseType (l:G, L) = L\'\n\n       Invariant:\n       L contains no parameter block declarations\n       Each x:A in L is mapped xto  x:{G}A in L\'\n       L\' preserves the order of L\n    *) let rec raiseType (CtxBlock (l, G), Psi\')  = (* no case of F.Block by invariant *) let rec raiseType\'\' (Null, Vn, a)  = Vn | raiseType\'\' (Decl (G\', D as Dec (_, V\')), Vn, a)  = if belowEq (targetFam V\', a) then raiseType\'\' (G\', piDepend ((D, Maybe), Vn), a) else raiseType\'\' (G\', strengthenExp (Vn, shift), a) let rec raiseType\' (Psi1, nil)  = nil | raiseType\' (Psi1, Prim (D as Dec (x, V)) :: Psi1\')  = let s = raiseSub (G, Psi1) let Vn = normalize (V, s) let a = targetFam Vn let D\' = Dec (x, raiseType\'\' (G, Vn, a)) in Prim (D\') :: (raiseType\' (Decl (Psi1, D), Psi1\')) in raiseType\' (Null, Psi\') (* raiseM (B, L) = L\'\n\n       Invariant\n       Each xx in F in L is mapped to xx in PI B. F in L\'\n       L\' preserves the order of L\n    *) let rec raiseM (B, nil)  = nil | raiseM (B, MDec (xx, F) :: L)  = MDec (xx, All (Block B, F)) :: raiseM (B, L) (* psub (k, Phi, s) = s\'\n\n       Invariant:\n       If   |- Phi ctx\n       and  |- Psi ctx\n       and  Psi = Psi1, l\': (x1:A1 .. xn:An), Psi2\n       and  Psi (k) = x1\n       and  | Phi | = n\n       and  s = k-i ... k. id   for i <=n\n       then s\' = k-n . ... k . id\n    *) let rec psub (k, Null, s)  = s | psub (k, Decl (G, _), s)  = psub (k - 1, G, Dot (Idx k, s)) let rec deltaSub (Null, s)  = Null | deltaSub (Decl (Delta, DD), s)  = Decl (deltaSub (Delta, s), mdecSub (DD, s)) let rec shift Delta  = deltaSub (Delta, shift) let rec shifts (Null, Delta)  = Delta | shifts (Decl (G, _), Delta)  = shifts (G, shift Delta) let rec shiftBlock (CtxBlock (_, G), Delta)  = shifts (G, Delta) let rec shiftSub (Null, s)  = s | shiftSub (Decl (G, _), s)  = shiftSub (G, comp (shift, s)) let rec shiftSubBlock (CtxBlock (_, G), s)  = shiftSub (G, s) (* check (Psi, Delta, P, (F, s)) = ()\n\n       Invariant:\n       If   Psi\'\' |- F formula\n       and  Psi |- s : Psi\'\'\n       and  Psi |- Delta mctx\n        returns () if there exists a F\',\n              s.t. Psi, Delta |- P  : F\'\n              and  Psi |- F\' = F[s] formula\n       otherwise Error is raised\n    *) let rec check (Psi, Delta, Unit, (True, _))  = () | check (Psi, Delta, Rec (DD, P), F)  = (check (Psi, Decl (Delta, DD), P, F)) | check (Psi, Delta, Lam (LD as Prim (Dec (_, V)), P), (All (Prim (Dec (_, V\')), F\'), s\'))  = if (conv ((V, id), (V\', s\'))) then check (Decl (Psi, LD), shift Delta, P, (F\', dot1 s\')) else raise (Error "Typecheck Error: Primitive Abstraction") | check (Psi, Delta, Lam (LD as Block (B as CtxBlock (l, G)), P), (All (Block (CtxBlock (l\', G\')), F\'), s\'))  = (if (l = l\' && conv ((G, id), (G\', s\'))) then check (Decl (Psi, LD), shiftBlock (B, Delta), P, (F\', dot1n (G, s\'))) else raise (Error "Typecheck Error: Block Abstraction")) | check (Psi, Delta, Inx (M, P), (Ex (Dec (_, V\'), F\'), s\'))  = (typeCheck (makectx Psi, (M, (EClo (V\', s\')))); check (Psi, Delta, P, (F\', Dot (Exp (M), s\')))) | check (Psi, Delta, Case (Opts O), (F\', s\'))  = checkOpts (Psi, Delta, O, (F\', s\')) | check (Psi, Delta, Pair (P1, P2), (And (F1\', F2\'), s\'))  = (check (Psi, Delta, P1, (F1\', s\')); check (Psi, Delta, P2, (F2\', s\'))) | check (Psi, Delta, Let (Ds, P), (F\', s\'))  = let (Psi\', Delta\', s\'\') = assume (Psi, Delta, Ds) in check (extend (Psi, Psi\'), extend (Delta, Delta\'), P, (F\', comp (s\', s\'\'))) | check _  = raise (Error "Typecheck Error: Term not well-typed")infer (Delta, kk)  = (ctxLookup (Delta, kk), id)(* assume (Psi, Delta, Ds) = (Psi\', Delta\', s\')\n\n       Invariant:\n       If   |- Psi context\n       and  Psi |- Delta assumptions\n       and  Psi, Delta |- Decs declarations\n       then |- Psi, Psi\' context\n       and  Psi, Psi\' |- Delta, Delta\' assumptions\n       and  Psi, Psi\' |- s\' = ^|Psi\'| : Psi\n    *) assume (Psi, Delta, Empty)  = (nil, nil, id) | assume (Psi, Delta, Split (kk, Ds))  = (match infer (Delta, kk) with (MDec (name, Ex (D, F)), s) -> let LD = Prim (decSub (D, s)) let DD = MDec (name, forSub (F, dot1 s)) let (Psi\', Delta\', s\') = assume (Decl (Psi, LD), Decl (shift Delta, DD), Ds) in (LD :: Psi\', mdecSub (DD, s\') :: Delta\', comp (shift, s\')) | _ -> raise (Error "Typecheck Error: Declaration")) | assume (Psi, Delta, New (B, Ds))  = (* check B valid context block       <-------------- omission *) let _ = typeCheck (makectx (Decl (Psi, Block B)), (Uni Type, Uni Kind)) let (Psi\', Delta\', s\') = assume (Decl (Psi, Block B), shiftBlock (B, Delta), Ds) in (raiseType (B, Psi\'), raiseM (B, Delta\'), s\') | assume (Psi, Delta, App ((kk, U), Ds))  = (match infer (Delta, kk) with (MDec (name, All (Prim (Dec (_, V)), F)), s) -> let _ = try  with  let DD = MDec (name, forSub (F, Dot (Exp (U), s))) let (Psi\', Delta\', s\') = assume (Psi, Decl (Delta, DD), Ds) in (Psi\', mdecSub (DD, s\') :: Delta\', s\') | (MDec (name, F), s) -> raise (Error ("Typecheck Error: Declaration App" ^ (forToString (Null, F) ["x"])))) | assume (Psi, Delta, PApp ((kk, k), Ds))  = (match infer (Delta, kk) with (MDec (name, All (Block (CtxBlock (l, G)), F)), s) -> let _ = validBlock (Psi, k, (l, G)) let DD = MDec (name, forSub (F, psub (k, G, s))) let (Psi\', Delta\', s\') = assume (Psi, Decl (Delta, DD), Ds) in (Psi\', mdecSub (DD, s\') :: Delta\', s\') | _ -> raise (Error "Typecheck Error: Declaration PApp")) | assume (Psi, Delta, Left (kk, Ds))  = (match infer (Delta, kk) with (MDec (name, And (F1, F2)), s) -> let DD = MDec (name, forSub (F1, s)) let (Psi\', Delta\', s\') = assume (Psi, Decl (Delta, DD), Ds) in (Psi\', mdecSub (DD, s\') :: Delta\', s\') | _ -> raise (Error "Typecheck Error: Declaration Left")) | assume (Psi, Delta, Right (kk, Ds))  = (match infer (Delta, kk) with (MDec (name, And (F1, F2)), s) -> let DD = MDec (name, forSub (F2, s)) let (Psi\', Delta\', s\') = assume (Psi, Decl (Delta, DD), Ds) in (Psi\', mdecSub (DD, s\') :: Delta\', s\') | _ -> raise (Error "Typecheck Error: Declaration Left")) | assume (Psi, Delta, Lemma (cc, Ds))  = let LemmaDec (names, _, F) = lemmaLookup cc let name = foldr ^ "" names let DD = MDec (SOME name, F) let (Psi\', Delta\', s\') = assume (Psi, Decl (Delta, DD), Ds) in (Psi\', mdecSub (DD, s\') :: Delta\', s\')(* checkSub (Psi1, s, Psi2) = ()\n\n       Invariant:\n       The function terminates\n       iff  Psi1 |- s : Psi2\n    *) checkSub (Null, Shift 0, Null)  = () | checkSub (Decl (Psi, Prim D), Shift k, Null)  = if k > 0 then checkSub (Psi, Shift (k - 1), Null) else raise (Error "Substitution not well-typed") | checkSub (Decl (Psi, Block (CtxBlock (_, G))), Shift k, Null)  = let g = ctxLength G in if k >= g then checkSub (Psi, Shift (k - g), Null) else raise (Error "Substitution not well-typed") | checkSub (Psi\', Shift k, Psi)  = checkSub (Psi\', Dot (Idx (k + 1), Shift (k + 1)), Psi) | checkSub (Psi\', Dot (Idx k, s\'), Decl (Psi, Prim (Dec (_, V2))))  = let G\' = makectx Psi\' let Dec (_, V1) = ctxDec (G\', k) in if conv ((V1, id), (V2, s\')) then checkSub (Psi\', s\', Psi) else raise (Error ("Substitution not well-typed \\n  found: " ^ expToString (G\', V1) ^ "\\n  expected: " ^ expToString (G\', EClo (V2, s\')))) | checkSub (Psi\', Dot (Exp (U), s\'), Decl (Psi, Prim (Dec (_, V2))))  = let G\' = makectx Psi\' let _ = typeCheck (G\', (U, EClo (V2, s\'))) in checkSub (Psi\', s\', Psi) | checkSub (Psi\', s as Dot (Idx k, _), Decl (Psi, Block (CtxBlock (l1, G))))  = (* check that l1 = l2     <----------------------- omission *) (* checkSub\' ((G\', w), s, G, m) = ()\n          *) let (Block (CtxBlock (l2, G\')), w) = lfctxLFDec (Psi\', k) let rec checkSub\' ((Null, w1), s1, Null, _)  = s1 | checkSub\' ((Decl (G\', Dec (_, V\')), w1), Dot (Idx k\', s1), Decl (G, Dec (_, V)), m)  = if k\' = m then if conv ((V\', w1), (V, s1)) then checkSub\' ((G\', comp (w1, shift)), s1, G, m + 1) else raise (Error "ContextBlock assignment not well-typed") else raise (Error "ContextBlock assignment out of order") in checkSub (Psi\', checkSub\' ((G\', w), s, G, k), Psi)(* checkOpts (Psi, Delta, (O, s) *) checkOpts (Psi, Delta, nil, _)  = () | checkOpts (Psi, Delta, (Psi\', t, P) :: O, (F\', s\'))  = (checkSub (Psi\', t, Psi); check (Psi\', deltaSub (Delta, t), P, (F\', comp (s\', t))); (* [Psi\' strict in  t] <------------------------- omission*) checkOpts (Psi, Delta, O, (F\', s\'))) let rec checkRec (P, T)  = check (Null, Null, P, (T, id)) let rec isFor (G, All (Prim D, F))  = (try  with ) | isFor (G, All (Block (CtxBlock (_, G1)), F))  = isForBlock (G, ctxToList G1, F) | isFor (G, Ex (D, F))  = (try  with ) | isFor (G, True)  = () | isFor (G, And (F1, F2))  = (isFor (G, F1); isFor (G, F2))isForBlock (G, nil, F)  = isFor (G, F) | isForBlock (G, D :: G1, F)  = isForBlock (Decl (G, D), G1, F) let rec checkTags\' (V, Ex _)  = () | checkTags\' (Pi (_, V), All (_, F))  = checkTags\' (V, F) | checkTags\' _  = raise (Domain) let rec checkTags (Null, Null)  = () | checkTags (Decl (G, Dec (_, V)), Decl (B, T))  = (checkTags (G, B); match T with Lemma (_) -> () | _ -> ()) (* isState (S) = ()\n\n       Invariant:\n\n       Side effect:\n       If it doesn\'t hold that |- S state, then exception Error is raised\n\n       Remark: Function is only partially implemented\n    *) let rec isState (State (n, (G, B), (IH, OH), d, O, H, F))  = (typeCheckCtx G; checkTags (G, B); if (not (closedCtx G)) then raise (Error "State context not closed!") else (); map (fun (n\', F\') -> (isFor (G, F\')(* ;          TextIO.print ("Checked: " ^ (FunPrint.Formatter.makestring_fmt (FunPrint.formatForBare (G, F\'))) ^ "\\n") *) )) H; (* n\' is not checked for consistency   --cs *) isFor (G, F)) let isFor = isFor let check = checkRec let checkSub = checkSub let isState = isState  end(* Signature FUNTYPECHECK *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Weakening substitutions *) (* Author: Carsten Schuermann *) module Weaken ((*! structure IntSyn' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn' !*) ) : WEAKEN = struct (*! structure IntSyn = IntSyn' !*)  module I = IntSyn(* strengthenExp (U, s) = U'\n\n       Invariant:\n       If   G |- s : G'\n       and  G |- U : V\n       then G' |- U' = U[s^-1] : V [s^-1]\n    *) let rec strengthenExp (U, s)  = normalize (cloInv (U, s), id) (* strengthenDec (x:V, s) = x:V'\n\n       Invariant:\n       If   G |- s : G'\n       and  G |- V : L\n       then G' |- V' = V[s^-1] : L\n    *) let rec strengthenDec (Dec (name, V), s)  = Dec (name, strengthenExp (V, s)) (* strengthenCtx (G, s) = (G', s')\n\n       If   G0 |- G ctx\n       and  G0 |- s G1\n       then G1 |- G' = G[s^-1] ctx\n       and  G0 |- s' : G1, G'\n    *) let rec strengthenCtx (Null, s)  = (Null, s) | strengthenCtx (Decl (G, D), s)  = let (G', s') = strengthenCtx (G, s) in (Decl (G', strengthenDec (D, s')), dot1 s') let rec strengthenSub (s, t)  = compInv (s, t) let rec strengthenSpine (Nil, t)  = Nil | strengthenSpine (App (U, S), t)  = App (strengthenExp (U, t), strengthenSpine (S, t)) let strengthenExp = strengthenExp let strengthenSpine = strengthenSpine let strengthenDec = strengthenDec let strengthenCtx = strengthenCtx let strengthenSub = strengthenSub  end(* functor Weaken *) ", 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Weakening substitutions for meta substitutions *) (* Author: Carsten Schuermann *) module FunWeaken ((*! structure FunSyn' : FUNSYN !*) module Weaken : WEAKEN(*! sharing Weaken.IntSyn = FunSyn'.IntSyn !*) ) : FUNWEAKEN = struct (*! structure FunSyn = FunSyn' !*)  module F = FunSynmodule I = IntSyn(* strengthenPsi (Psi, s) = (Psi', s')\n\n       If   Psi0 |- Psi ctx\n       and  Psi0 |- s Psi1\n       then Psi1 |- Psi' = Psi[s^-1] ctx\n       and  Psi0 |- s' : Psi1, Psi'\n    *) let rec strengthenPsi (Null, s)  = (Null, s) | strengthenPsi (Decl (Psi, Prim D), s)  = let (Psi', s') = strengthenPsi (Psi, s) in (Decl (Psi', Prim (strengthenDec (D, s'))), dot1 s') | strengthenPsi (Decl (Psi, Block (CtxBlock (l, G))), s)  = let (Psi', s') = strengthenPsi (Psi, s) let (G'', s'') = strengthenCtx (G, s') in (Decl (Psi', Block (CtxBlock (l, G''))), s'') (* strengthenPsi' (Psi, s) = (Psi', s')\n\n       If   Psi0 |- Psi ctx\n       and  Psi0 |- s : Psi1\n       then Psi1 |- Psi' = Psi[s^-1] ctx\n       and  Psi0 |- s' : Psi1, Psi'  weakening substitution\n    *) let rec strengthenPsi' (nil, s)  = (nil, s) | strengthenPsi' (Prim D :: Psi, s)  = let D' = strengthenDec (D, s) let s' = dot1 s let (Psi'', s'') = strengthenPsi' (Psi, s') in (Prim D' :: Psi'', s'') | strengthenPsi' (Block (CtxBlock (l, G)) :: Psi, s)  = let (G', s') = strengthenCtx (G, s) let (Psi'', s'') = strengthenPsi' (Psi, s') in (Block (CtxBlock (l, G')) :: Psi'', s'') let strengthenPsi = strengthenPsi let strengthenPsi' = strengthenPsi'  end(* functor FunWeaken *) ", 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Meta Prover Interface *) (* Author: Carsten Schuermann *) module type MTPI = sig (*! structure FunSyn : FUNSYN !*) module StateSyn : STATESYNexception Error of stringval init : int * string list -> unitval select : int -> unitval print : unit -> unitval next : unit -> unitval auto : unit -> unitval solve : unit -> unitval check : unit -> unitval reset : unit -> unit(*  val extract: unit -> MetaSyn.Sgn *) (*  val show   : unit -> unit *) val undo : unit -> unit end\n(* signature MTPI *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Splitting : Version 1.3 *) (* Author: Carsten Schuermann *) module MTPSplitting (module MTPGlobal : MTPGLOBALmodule Global : GLOBAL(*! structure IntSyn : INTSYN !*) (*! structure FunSyn : FUNSYN !*) (*! sharing FunSyn.IntSyn = IntSyn !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.FunSyn = FunSyn !*) (*! sharing StateSyn\'.IntSyn = IntSyn !*) module Heuristic : HEURISTICmodule MTPAbstract : MTPABSTRACT(*! sharing MTPAbstract.IntSyn = IntSyn !*) MTPAbstractStateSynStateSyn\'module MTPrint : MTPRINTMTPrintStateSynStateSyn\'module Names : NAMES(* too be removed  -cs *) (*! sharing Names.IntSyn = IntSyn !*) (* too be removed  -cs *) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn !*) module FunTypeCheck : FUNTYPECHECK(*! sharing FunTypeCheck.FunSyn = FunSyn !*) FunTypeCheckStateSynStateSyn\'module Index : INDEX(*! sharing Index.IntSyn = IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn  !*) ) : MTPSPLITTING = struct module StateSyn = StateSyn\' exception Error of string (* Invariant:\n     Case analysis generates a list of successor states\n     (the cases) from a given state.\n\n     \'a flag marks cases where unification of the types\n     succeeded as "Active", and cases where there were\n     leftover constraints after unification as "Inactive".\n\n     NB: cases where unification fails are not considered\n\n     Consequence: Only those splitting operators can be\n     applied which do not generate inactive cases (this\n     can be checked for a given operator by applicable)\n  *)  type flag = Active of \'a | InActive type Operator = Operator of (State * int) * State flag list * index type operator = Operator module I = IntSynmodule F = FunSynmodule S = StateSynmodule H = Heuristiclet rec makeOperator ((S, k), L, Splits n, g, I, m, true)  = (* recursive case *)  Operator ((S, k), L, {sd = n; ind = I; c = length L; m = m; r = 1; p = g + 1}) | makeOperator ((S, k), L, Splits n, g, I, m, false)  = (* non-recursive case *)  Operator ((S, k), L, {sd = n; ind = I; c = length L; m = m; r = 0; p = g + 1}) (* aux (G, B) = L\'\n\n       Invariant:\n       If   . |- G ctx\n       and  G |- B tags\n       then . |- L\' = GxB lfctx\n    *) let rec aux (Null, Null)  = Null | aux (Decl (G, D), Decl (B, Lemma _))  = Decl (aux (G, B), Prim D) | aux (G as Decl (_, D), B as Decl (_, Parameter (SOME l)))  = let LabelDec (name, _, G2) = labelLookup l let (Psi\', G\') = aux\' (G, B, length G2) in Decl (Psi\', Block (CtxBlock (SOME l, G\')))aux\' (G, B, 0)  = (aux (G, B), Null) | aux\' (Decl (G, D), Decl (B, Parameter (SOME _)), n)  = let (Psi\', G\') = aux\' (G, B, n - 1) in (Psi\', Decl (G\', D)) (* conv ((G, s), (G\', s\')) = B\n\n       Invariant:\n       B iff G [s]  == G\' [s\']\n       Might migrate in to conv module  --cs\n    *) let rec conv (Gs, Gs\')  = exception Conv let rec conv ((Null, s), (Null, s\'))  = (s, s\') | conv ((Decl (G, Dec (_, V)), s), (Decl (G\', Dec (_, V\')), s\'))  = let (s1, s1\') = conv ((G, s), (G\', s\')) let ps as (s2, s2\') = (dot1 s1, dot1 s1\') in if conv ((V, s1), (V\', s1\')) then ps else raise (Conv) | conv _  = raise (Conv) in try  with (* createEVarSpineW (G, (V, s)) = ((V\', s\') , S\')\n\n       Invariant:\n       If   G |- s : G1   and  G1 |- V = Pi {V1 .. Vn}. W : L\n       and  G1, V1 .. Vn |- W atomic\n       then G |- s\' : G2  and  G2 |- V\' : L\n       and  S = X1; ...; Xn; Nil\n       and  G |- W [1.2...n. s o ^n] = V\' [s\']\n       and  G |- S : V [s] >  V\' [s\']\n    *) let rec createEVarSpine (G, Vs)  = createEVarSpineW (G, whnf Vs)createEVarSpineW (G, Vs as (Uni Type, s))  = (Nil, Vs) | createEVarSpineW (G, Vs as (Root _, s))  = (Nil, Vs) | createEVarSpineW (G, (Pi ((D as Dec (_, V1), _), V2), s))  = let X = newEVar (G, EClo (V1, s)) let (S, Vs) = createEVarSpine (G, (V2, Dot (Exp (X), s))) in (App (X, S), Vs) (* createAtomConst (G, c) = (U\', (V\', s\'))\n\n       Invariant:\n       If   S |- c : Pi {V1 .. Vn}. V\n       then . |- U\' = c @ (Xn; .. Xn; Nil)\n       and  . |- U\' : V\' [s\']\n    *) let rec createAtomConst (G, H)  = let cid = (match H with (Const cid) -> cid | (Skonst cid) -> cid) let V = constType cid let (S, Vs) = createEVarSpine (G, (V, id)) in (Root (H, S), Vs) (* createAtomBVar (G, k) = (U\', (V\', s\'))\n\n       Invariant:\n       If   G |- k : Pi {V1 .. Vn}. V\n       then . |- U\' = k @ (Xn; .. Xn; Nil)\n       and  . |- U\' : V\' [s\']\n    *) let rec createAtomBVar (G, k)  = let Dec (_, V) = ctxDec (G, k) let (S, Vs) = createEVarSpine (G, (V, id)) in (Root (BVar (k), S), Vs) (* someEVars (G, G1, s) = s\'\n\n       Invariant:\n       If   |- G ctx\n       and  G |- s : G\'\n       then G |- s\' : G\', G1\n\n       Remark: This is someEVars from recursion.fun with a generalized ih --cs\n    *) let rec someEVars (G, nil, s)  = s | someEVars (G, Dec (_, V) :: L, s)  = someEVars (G, L, Dot (Exp (newEVar (G, EClo (V, s))), s)) let rec maxNumberParams a  = let rec maxNumberParams\' (n)  = if n < 0 then 0 else let LabelDec (name, G1, G2) = labelLookup n let m\' = foldr (fun (Dec (_, V), m) -> if targetFam V = a then m + 1 else m) 0 G2 in maxNumberParams\' (n - 1) + m\' in maxNumberParams\' (labelSize () - 1) let rec maxNumberLocalParams (Pi ((Dec (_, V1), _), V2), a)  = let m = maxNumberLocalParams (V2, a) in if targetFam V1 = a then m + 1 else m | maxNumberLocalParams (Root _, a)  = 0 let rec maxNumberConstCases a  = length (lookup a) let rec maxNumberCases (V, a)  = maxNumberParams a + maxNumberLocalParams (V, a) + maxNumberConstCases a (* ctxSub (G, s) = G\'\n\n       Invariant:\n       If   G2 |- s : G1\n       and  G1 |- G ctx\n       then G2 |- G\' = G[s] ctx\n    *) let rec ctxSub (nil, s)  = nil | ctxSub (D :: G, s)  = decSub (D, s) :: ctxSub (G, dot1 s) let rec createTags (0, l)  = Null | createTags (n, l)  = Decl (createTags (n - 1, l), Parameter (SOME l)) let rec createLemmaTags (Null)  = Null | createLemmaTags (Decl (G, D))  = Decl (createLemmaTags G, Lemma (Splits (! maxSplit))) (* constCases (G, (V, s), I, abstract, ops) = ops\'\n\n       Invariant:\n       If   G |- s : G\'  G\' |- V : type\n       and  I a list of of constant declarations\n       and  abstract an abstraction function\n       and  ops a list of possible splitting operators\n       then ops\' is a list extending ops, containing all possible\n         operators from I\n    *) let rec constCases (G, Vs, nil, abstract, ops)  = ops | constCases (G, Vs, Const c :: Sgn, abstract, ops)  = let (U, Vs\') = createAtomConst (G, Const c) in constCases (G, Vs, Sgn, abstract, trail (fun () -> try  with )) (* paramCases (G, (V, s), k, abstract, ops) = ops\'\n\n       Invariant:\n       If   G |- s : G\'  G\' |- V : type\n       and  k a variable\n       and  abstract an abstraction function\n       and  ops a list of possible splitting operators\n       then ops\' is a list extending ops, containing all possible\n         operators introduced by parameters <= k in G\n    *) let rec paramCases (G, Vs, 0, abstract, ops)  = ops | paramCases (G, Vs, k, abstract, ops)  = let (U, Vs\') = createAtomBVar (G, k) in paramCases (G, Vs, k - 1, abstract, trail (fun () -> try  with )) let rec constAndParamCases ops0 (c, G, k, (V, s\'), abstract)  = constCases (G, (V, s\'), lookup c, abstract, paramCases (G, (V, s\'), k, abstract, ops0)) let rec metaCases (d, ops0) (c, G, k, Vs, abstract)  = let g = ctxLength G let rec select (0, ops)  = ops | select (d\', ops)  = let n = g - d\' + 1 let Dec (_, V) = ctxDec (G, n) let ops\' = if targetFam V = c then let (U, Vs\') = createAtomBVar (G, n) in trail (fun () -> try  with ) else ops in select (d\' - 1, ops\') in select (d, ops0) (* lowerSplitDest (G, k, (V, s\'), abstract) = ops\'\n\n       Invariant:\n       If  G0, G |- s\' : G1  G1 |- V: type\n       and  k = |local parameters in G|\n       and  G is the context of local parameters\n       and  abstract abstraction function\n       then ops\' is a list of all operators unifying with V[s\']\n            (it contains constant and parameter cases)\n    *) let rec lowerSplitDest (G, k, (V as Root (Const c, _), s\'), abstract, cases)  = cases (c, G, ctxLength G, (V, s\'), abstract) | lowerSplitDest (G, k, (Pi ((D, P), V), s\'), abstract, cases)  = let D\' = decSub (D, s\') in lowerSplitDest (Decl (G, D\'), k + 1, (V, dot1 s\'), fun U -> abstract (Lam (D\', U)), cases) let rec abstractErrorLeft ((G, B), s)  = (raise (Error "Cannot split left of parameters")) let rec abstractErrorRight ((G, B), s)  = (raise (Error "Cannot split right of parameters")) (* split (x:D, sc, B, abstract) = cases\'\n\n       Invariant :\n       If   |- G ctx\n       and  G |- B tags\n       and  G |- D : L\n       then sc is a function, which maps\n                Gp, Bp          (. |- Gp ctx   Gp |- Bp tags)\n            to (G\', B\'), s\', (G, B), p\'\n                              (. |- G\' = Gp, G\'\' ctx\n                               G\'\' contains only parameter declarations from G\n                               G\' |- B\' tags\n                               G\' |- s\' : G\n                               and p\' holds iff (G\', B\') contains a parameter\n                             block independent of Gp, Bp)\n        and  abstract is an abstraction function which maps\n               (Gn, Bn), sn  (|- Gn ctx,  Gn |- Bn tags,  Gn |- sn : G)\n            to S\'            (|- S\' state)\n\n       then cases\' = (S1, ... Sn) are cases of the split\n    *) let rec split ((D as Dec (_, V), T), sc, abstract)  = let rec split\' (n, cases)  = if n < 0 then (* |- G\' = parameter blocks of G  ctx*) (* G\' |- B\' tags *) (* G\' |- s\' : G *) let ((G\', B\'), s\', (G0, B0), _) = sc (Null, Null) let rec abstract\' U\'  = (* G\' |- U\' : V[s\'] *) (* G\' |- U\'.s\' : G, V[s\'] *) let ((G\'\', B\'\'), s\'\') = abstractSub\' ((G\', B\'), Dot (Exp U\', s\'), Decl (B0, T)) let _ = if ! doubleCheck then let Psi\'\' = aux (G\'\', B\'\') let _ = typeCheckCtx (makectx Psi\'\') let Psi = aux (Decl (G0, D), Decl (B0, T)) let _ = typeCheckCtx (makectx Psi) in checkSub (Psi\'\', s\'\', Psi) else () in abstract ((G\'\', B\'\'), s\'\') in lowerSplitDest (G\', 0, (V, s\'), abstract\', constAndParamCases cases) else (* . |- t : G1 *) (* . |- G2 [t] ctx *) (* G2 [t] |- B2 tags *) (* . |- G\' ctx *) (* G\' |- B\' tags *) (* G\' |- s : G = G0 *) (* G0 |- B0 tags *) (* abstract\' U = S\'\n\n                   Invariant:\n                   If   G\' |- U\' : V[s\']\n                   then |- S\' state *) let LabelDec (name, G1, G2) = labelLookup n let t = someEVars (Null, G1, id) let B1 = createLemmaTags (listToCtx G1) let G2t = ctxSub (G2, t) let length = length G2 let B2 = createTags (length, n) let ((G\', B\'), s\', (G0, B0), p) = sc (ctxName (listToCtx G2t), B2) let rec abstract\' U\'  = (* G\' |- U\' : V[s\'] *)  if p then (raise (Error "Cannot split right of parameters")) else (* G\' |- U.s\' : G, V *) (* . |- t : G1 *) (* . |- G\'\' ctx *) (* G\'\' |- B\'\' tags *) (* G\'\' = G1\'\', G2\', G2\'\' *) (* where G1\'\' |- G2\' ctx, G2\' is the abstracted parameter block *) let ((G\'\', B\'\'), s\'\') = abstractSub (t, B1, (G\', B\'), Dot (Exp U\', s\'), Decl (B0, T)) let _ = if ! doubleCheck then let Psi\'\' = aux (G\'\', B\'\') let _ = typeCheckCtx (makectx Psi\'\') let Psi = aux (Decl (G0, D), Decl (B0, T)) let _ = typeCheckCtx (makectx Psi) in checkSub (Psi\'\', s\'\', Psi) else () in abstract ((G\'\', B\'\'), s\'\') let cases\' = lowerSplitDest (G\', 0, (V, s\'), abstract\', metaCases (length, cases)) in split\' (n - 1, cases\') in split\' (labelSize () - 1, nil) (* occursInExp (k, U) = B,\n\n       Invariant:\n       If    U in nf\n       then  B iff k occurs in U\n    *) let rec occursInExp (k, Uni _)  = false | occursInExp (k, Pi (DP, V))  = occursInDecP (k, DP) || occursInExp (k + 1, V) | occursInExp (k, Root (C, S))  = occursInCon (k, C) || occursInSpine (k, S) | occursInExp (k, Lam (D, V))  = occursInDec (k, D) || occursInExp (k + 1, V) | occursInExp (k, FgnExp csfe)  = fold csfe (fun (U, B) -> B || occursInExp (k, normalize (U, id))) false(* no case for Redex, EVar, EClo *) occursInCon (k, BVar (k\'))  = (k = k\') | occursInCon (k, Const _)  = false | occursInCon (k, Def _)  = false | occursInCon (k, Skonst _)  = false(* no case for FVar *) occursInSpine (_, Nil)  = false | occursInSpine (k, App (U, S))  = occursInExp (k, U) || occursInSpine (k, S)(* no case for SClo *) occursInDec (k, Dec (_, V))  = occursInExp (k, V)occursInDecP (k, (D, _))  = occursInDec (k, D) let rec isIndexInit k  = false let rec isIndexSucc (D, isIndex) k  = occursInDec (k, D) || isIndex (k + 1) let rec isIndexFail (D, isIndex) k  = isIndex (k + 1) (* abstractInit S ((G\', B\'), s\') = S\'\n\n       Invariant:\n       If   |- S = (n, (G, B), (IH, OH), d, O, H, F) state\n       and  |- G\' ctx\n       and  G\' |- B\' tags\n       and  G\' |- s\' : G\n       then |- S\' = (n, (G\', B\'), (IH, OH), d, O[s\'], H[s\'], F[s\']) state\n    *) let rec abstractInit (S as State (n, (G, B), (IH, OH), d, O, H, F)) ((G\', B\'), s\')  = (if ! doubleCheck then typeCheckCtx G\' else (); if ! doubleCheck then isFor (G\', forSub (F, s\')) else (); State (n, (G\', B\'), (IH, OH), d, orderSub (O, s\'), map (fun (i, F\') -> (i, forSub (F\', s\'))) H, forSub (F, s\'))) (* abstractCont ((x:V, T), abstract) = abstract\'\n\n       Invariant:\n       If   |- G ctx\n       and  G |- V : type\n       and  G |- B tags\n       and  abstract is an abstraction function which maps\n                    (Gn, Bn), sn  (|- Gn ctx,  Gn |- Bn tags,  Gn |- sn : G, D)\n                 to S\'            (|- S\' state)\n       then abstract\' is an abstraction function which maps\n                    (Gn\', Bn\'), sn\'  (|- Gn\' ctx,  Gn\' |- Bn\' tags,  Gn\' |- sn\' : G)\n                 to S\'               (|- S\' state)\n    *) let rec abstractCont ((D, T), abstract) ((G, B), s)  = abstract ((Decl (G, normalizeDec (D, s)), Decl (B, normalizeTag (T, s))), dot1 s) let rec makeAddressInit S k  = (S, k) let rec makeAddressCont makeAddress k  = makeAddress (k + 1) let rec occursInOrder (n, Arg (Us, Vt), k, sc)  = let U\' = normalize Us in if occursInExp (k, U\') then SOME (n) else sc (n + 1) | occursInOrder (n, Lex Os, k, sc)  = occursInOrders (n, Os, k, sc) | occursInOrder (n, Simul Os, k, sc)  = occursInOrders (n, Os, k, sc)(* no other case should be possible by invariant *) occursInOrders (n, nil, k, sc)  = sc n | occursInOrders (n, O :: Os, k, sc)  = occursInOrder (n, O, k, fun n\' -> occursInOrders (n\', Os, k, sc)) let rec inductionInit O k  = occursInOrder (0, O, k, fun n -> NONE) let rec inductionCont induction k  = induction (k + 1) (* expand\' ((G, B), isIndex, abstract, makeAddress) = (sc\', ops\')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- B tags\n       and  isIndex (k) = B function s.t. B holds iff k index\n       and  abstract is an abstraction function which maps\n               (Gn, Bn), sn  (|- Gn ctx,  Gn |- Bn tags,  Gn |- sn : G)\n            to S\'            (|- S\' state)\n       and  makeAddress, a function which calculates the index of the variable\n            to be split\n       then sc\' is a function, which maps\n               Gp, Bp         (. |- Gp ctx   Gp |- Bp tags)\n            to (G\', B\'), s\', (G, B), p\'\n                              (. |- G\' = Gp, G\'\' ctx\n                               G\'\' contains only parameter declarations from G\n                               G\' |- B\' tags\n                               G\' |- s\' : G\n                               and p\' holds iff (G\', B\') contains a parameter\n                             block independent of Gp, Bp)\n       and  ops\' is a list of splitting operators\n\n       Optimization possible :\n         instead of reconstructin (G, B) as the result of sc, just take (G, B)\n    *) let rec expand\' (GB as (Null, Null), isIndex, abstract, makeAddress, induction)  = (fun (Gp, Bp) -> ((Gp, Bp), Shift (ctxLength Gp), GB, false), nil) | expand\' (GB as (Decl (G, D), Decl (B, T as (Lemma (K as Splits _)))), isIndex, abstract, makeAddress, induction)  = let (sc, ops) = expand\' ((G, B), isIndexSucc (D, isIndex), abstractCont ((D, T), abstract), makeAddressCont makeAddress, inductionCont induction) let Dec (xOpt, V) = D let rec sc\' (Gp, Bp)  = (* G\' |- X : V[s\'] *) let ((G\', B\'), s\', (G0, B0), p\') = sc (Gp, Bp) let X = newEVar (G\', EClo (V, s\')) in ((G\', B\'), Dot (Exp (X), s\'), (Decl (G0, D), Decl (B0, T)), p\')(* G\' |- X.s\' : G, D *) let ops\' = if not (isIndex 1) && (splitDepth K) > 0 then let a = targetFam V in makeOperator (makeAddress 1, split ((D, T), sc, abstract), K, ctxLength G, induction 1, maxNumberCases (V, a), below (a, a)) :: ops else ops in (sc\', ops\') | expand\' ((Decl (G, D), Decl (B, T as (Lemma (RL)))), isIndex, abstract, makeAddress, induction)  = let (sc, ops) = expand\' ((G, B), isIndexSucc (D, isIndex), abstractCont ((D, T), abstract), makeAddressCont makeAddress, inductionCont induction) let Dec (xOpt, V) = D let rec sc\' (Gp, Bp)  = let ((G\', B\'), s\', (G0, B0), p\') = sc (Gp, Bp) let X = newEVar (G\', EClo (V, s\')) in ((G\', B\'), Dot (Exp (X), s\'), (Decl (G0, D), Decl (B0, T)), p\') in (sc\', ops) | expand\' ((Decl (G, D), Decl (B, T as (Lemma (RLdone)))), isIndex, abstract, makeAddress, induction)  = let (sc, ops) = expand\' ((G, B), isIndexSucc (D, isIndex), abstractCont ((D, T), abstract), makeAddressCont makeAddress, inductionCont induction) let Dec (xOpt, V) = D let rec sc\' (Gp, Bp)  = let ((G\', B\'), s\', (G0, B0), p\') = sc (Gp, Bp) let X = newEVar (G\', EClo (V, s\')) in ((G\', B\'), Dot (Exp (X), s\'), (Decl (G0, D), Decl (B0, T)), p\') in (sc\', ops) | expand\' ((Decl (G, D), Decl (B, T as Parameter (SOME _))), isIndex, abstract, makeAddress, induction)  = let (sc, ops) = expand\' ((G, B), isIndexSucc (D, isIndex), abstractErrorLeft, makeAddressCont makeAddress, inductionCont induction) let Dec (xOpt, V) = D let rec sc\' (Gp, Bp)  = let ((G\', B\'), s\', (G0, B0), _) = sc (Gp, Bp) in ((Decl (G\', decName (G\', decSub (D, s\'))), Decl (B\', T)), dot1 s\', (Decl (G0, D), Decl (B0, T)), true) in (sc\', ops) (* no case of (I.Decl (G, D), I.Decl (G, S.Parameter NONE)) *) (* expand (S) = ops\'\n\n       Invariant:\n       If   |- S state\n       then ops\' is a list of all possiblie splitting operators\n    *) let rec expand (S0 as State (n, (G0, B0), _, _, O, _, _))  = let _ = if ! doubleCheck then isState S0 else () let (_, ops) = expand\' ((G0, B0), isIndexInit, abstractInit S0, makeAddressInit S0, inductionInit O) in ops (* index (Op) = k\n\n       Invariant:\n       If   Op = (_, Sl)\n       then k = |Sl|\n    *) let rec index (Operator ((S, index), Sl, {c = k; _}))  = k let rec compare (Operator (_, _, I1), Operator (_, _, I2))  = compare (I1, I2) (* isInActive (F) = B\n\n       Invariant:\n       B holds iff F is inactive\n    *) let rec isInActive (Active _)  = false | isInActive (InActive)  = true (* applicable (Op) = B\'\n\n       Invariant:\n       If   Op = (_, Sl)\n       then B\' holds iff Sl does not contain inactive states\n    *) let rec applicable (Operator (_, Sl, I))  = not (exists isInActive Sl) (* apply (Op) = Sl\'\n\n       Invariant:\n       If   Op = (_, Sl)\n       then Sl\' = Sl\n\n       Side effect: If Sl contains inactive states, an exception is raised\n    *) let rec apply (Operator (_, Sl, I))  = map (fun (Active S) -> (if (! doubleCheck) then isState S else (); S) | InActive -> raise (Error "Not applicable: leftover constraints")) Sl (* menu (Op) = s\'\n\n       Invariant:\n       If   Op = ((S, i), Sl)  and  S is named\n       then s\' is a string describing the operation in plain text\n\n       (menu should hence be only called on operators which have\n        been calculated from a named state)\n    *) let rec menu (Op as Operator ((State (n, (G, B), (IH, OH), d, O, H, F), i), Sl, I))  = let rec active (nil, n)  = n | active (InActive :: L, n)  = active (L, n) | active ((Active _) :: L, n)  = active (L, n + 1) let rec inactive (nil, n)  = n | inactive (InActive :: L, n)  = inactive (L, n + 1) | inactive ((Active _) :: L, n)  = inactive (L, n) let rec casesToString 0  = "zero cases" | casesToString 1  = "1 case" | casesToString n  = (toString n) ^ " cases" let rec flagToString (_, 0)  = "" | flagToString (n, m)  = " [active: " ^ (toString n) ^ " inactive: " ^ (toString m) ^ "]" in "Splitting : " ^ decToString (G, ctxDec (G, i)) ^ " " ^ (indexToString I) ^ (flagToString (active (Sl, 0), inactive (Sl, 0))) ^ "" let expand = expand let menu = menu let applicable = applicable let apply = apply let index = index let compare = compare  (* local *)  end\n(* functor Splitting *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Internal syntax for functional proof term calculus *) (* Author: Carsten Schuermann *) module FunSyn ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn\' !*) ) : FUNSYN = struct (*! structure IntSyn = IntSyn\' !*)  exception Error of string type label = int type name = string type lemma = int type dlist = Dec list type LabelDec = LabelDec of name * dlist * dlist (* BB ::= l: SOME Theta. Phi  *)  type CtxBlock = CtxBlock of label option * dctx (* B ::= l : Phi              *)  type LFDec = Prim of Dec | Block of CtxBlock (*      | B                   *)  type lfctx = LFDec Ctx (* Psi ::= . | Psi, LD        *)  type For = All of LFDec * For | Ex of Dec * For | True | And of For * For (*     | F1 ^ F2              *)  type Pro = Lam of LFDec * Pro | Inx of Exp * Pro | Unit | Rec of MDec * Pro | Let of Decs * Pro | Case of Opts | Pair of Pro * Pro and Opts = Opts of lfctx * Sub * Pro list and MDec = MDec of name option * For and Decs = Empty | Split of int * Decs | New of CtxBlock * Decs | App of (int * Exp) * Decs | PApp of (int * int) * Decs | Lemma of lemma * Decs | Left of int * Decs | Right of int * Decs (*      | xx = pi2 yy, Ds     *)  type LemmaDec = LemmaDec of name list * Pro * For (* L ::= c:F = P              *)  type mctx = MDec Ctx (* Delta ::= . | Delta, xx : F*)  module I = IntSynlet maxLabel = maxCid let maxLemma = maxCid let labelArray = array (maxLabel + 1, LabelDec ("", nil, nil)) : LabelDec array let nextLabel = ref 0 let lemmaArray = array (maxLemma + 1, LemmaDec (nil, Unit, True)) : LemmaDec array let nextLemma = ref 0 let rec labelLookup label  = sub (labelArray, label) let rec labelAdd (labelDec)  = let label = ! nextLabel in if label > maxLabel then raise (Error ("Global signature size " ^ toString (maxLabel + 1) ^ " exceeded")) else (update (labelArray, label, labelDec); nextLabel := label + 1; label) let rec labelSize ()  = (! nextLabel) let rec labelReset ()  = (nextLabel := 0) let rec lemmaLookup lemma  = sub (lemmaArray, lemma) let rec lemmaAdd (lemmaDec)  = let lemma = ! nextLemma in if lemma > maxLemma then raise (Error ("Global signature size " ^ toString (maxLemma + 1) ^ " exceeded")) else (update (lemmaArray, lemma, lemmaDec); nextLemma := lemma + 1; lemma) let rec lemmaSize ()  = (! nextLemma) (* hack!!! improve !!!! *) let rec listToCtx (Gin)  = let rec listToCtx\' (G, nil)  = G | listToCtx\' (G, D :: Ds)  = listToCtx\' (Decl (G, D), Ds) in listToCtx\' (Null, Gin) let rec ctxToList (Gin)  = let rec ctxToList\' (Null, G)  = G | ctxToList\' (Decl (G, D), G\')  = ctxToList\' (G, D :: G\') in ctxToList\' (Gin, nil) (* union (G, G\') = G\'\'\n\n       Invariant:\n       G\'\' = G, G\'\n    *) let rec union (G, Null)  = G | union (G, Decl (G\', D))  = Decl (union (G, G\'), D) (* makectx Psi = G\n\n       Invariant:\n       G is Psi, where the Prim/Block information is discarded.\n    *) let rec makectx (Null)  = Null | makectx (Decl (G, Prim D))  = Decl (makectx G, D) | makectx (Decl (G, Block (CtxBlock (l, G\'))))  = union (makectx G, G\') let rec lfctxLength (Null)  = 0 | lfctxLength (Decl (Psi, Prim _))  = (lfctxLength Psi) + 1 | lfctxLength (Decl (Psi, Block (CtxBlock (_, G))))  = (lfctxLength Psi) + (ctxLength G) (* lfctxDec (Psi, k) = (LD\', w\')\n       Invariant:\n       If      |Psi| >= k, where |Psi| is size of Psi,\n       and     Psi = Psi1, LD, Psi2\n       then    Psi |- k = LD or Psi |- k in LD  (if LD is a contextblock\n       then    LD\' = LD\n       and     Psi |- w\' : Psi1, LD\\1   (w\' is a weakening substitution)\n       and     LD\\1 is LD if LD is prim, and LD\\1 = x:A if LD = G, x:A\n   *) let rec lfctxLFDec (Psi, k)  = (* lfctxDec\' (Null, k\')  should not occur by invariant *) let rec lfctxLFDec\' (Decl (Psi\', LD as Prim (Dec (x, V\'))), 1)  = (LD, Shift k) | lfctxLFDec\' (Decl (Psi\', Prim _), k\')  = lfctxLFDec\' (Psi\', k\' - 1) | lfctxLFDec\' (Decl (Psi\', LD as Block (CtxBlock (_, G))), k\')  = let l = ctxLength G in if k\' <= l then (LD, Shift (k - k\' + 1)) else lfctxLFDec\' (Psi\', k\' - l) in lfctxLFDec\' (Psi, k) (* dot1n (G, s) = s\'\n\n       Invariant:\n       If   G1 |- s : G2\n       then G1, G |- s\' : G2, G\n       where s\' = 1.(1.  ...     s) o ^ ) o ^\n                        |G|-times\n    *) let rec dot1n (Null, s)  = s | dot1n (Decl (G, _), s)  = dot1 (dot1n (G, s)) (* conv ((F1, s1), (F2, s2)) = B\n\n       Invariant:\n       If   G |- s1 : G1\n       and  G1 |- F1 : formula\n       and  G |- s2 : G2\n       and  G2 |- F2 : formula\n       and  (F1, F2 do not contain abstraction over contextblocks )\n       then B holds iff G |- F1[s1] = F2[s2] formula\n    *) let rec convFor ((True, _), (True, _))  = true | convFor ((All (Prim D1, F1), s1), (All (Prim D2, F2), s2))  = convDec ((D1, s1), (D2, s2)) && convFor ((F1, dot1 s1), (F2, dot1 s2)) | convFor ((All (Block (CtxBlock ((* SOME l1 *) , _, G1)), F1), s1), (All (Block (CtxBlock ((* SOME l2 *) , _, G2)), F2), s2))  = (* l1 = l2 andalso *)  convForBlock ((ctxToList G1, F1, s1), (ctxToList G1, F2, s2)) | convFor ((Ex (D1, F1), s1), (Ex (D2, F2), s2))  = convDec ((D1, s1), (D2, s2)) && convFor ((F1, dot1 s1), (F2, dot1 s2)) | convFor ((And (F1, F1\'), s1), (And (F2, F2\'), s2))  = convFor ((F1, s1), (F2, s2)) && convFor ((F1\', s1), (F2\', s2)) | convFor _  = falseconvForBlock ((nil, F1, s1), (nil, F2, s2))  = convFor ((F1, s1), (F2, s2)) | convForBlock ((D1 :: G1, F1, s1), (D2 :: G2, F2, s2))  = convDec ((D1, s1), (D2, s2)) && convForBlock ((G1, F1, dot1 s1), (G2, F2, dot1 s2)) | convForBlock _  = false let rec ctxSub (Null, s)  = (Null, s) | ctxSub (Decl (G, D), s)  = let (G\', s\') = ctxSub (G, s) in (Decl (G\', decSub (D, s\')), dot1 s) let rec forSub (All (Prim D, F), s)  = All (Prim (decSub (D, s)), forSub (F, dot1 s)) | forSub (All (Block (CtxBlock (name, G)), F), s)  = let (G\', s\') = ctxSub (G, s) in All (Block (CtxBlock (name, G\')), forSub (F, s\')) | forSub (Ex (D, F), s)  = Ex (decSub (D, s), forSub (F, dot1 s)) | forSub (True, s)  = True | forSub (And (F1, F2), s)  = And (forSub (F1, s), forSub (F2, s)) let rec mdecSub (MDec (name, F), s)  = MDec (name, forSub (F, s)) let rec normalizeFor (All (Prim D, F), s)  = All (Prim (normalizeDec (D, s)), normalizeFor (F, dot1 s)) | normalizeFor (Ex (D, F), s)  = Ex (normalizeDec (D, s), normalizeFor (F, dot1 s)) | normalizeFor (And (F1, F2), s)  = And (normalizeFor (F1, s), normalizeFor (F2, s)) | normalizeFor (True, _)  = True let labelLookup = labelLookup let labelAdd = labelAdd let labelSize = labelSize let labelReset = labelReset let lemmaLookup = lemmaLookup let lemmaAdd = lemmaAdd let lemmaSize = lemmaSize let mdecSub = mdecSub let makectx = makectx let lfctxLength = lfctxLength let lfctxLFDec = lfctxLFDec let dot1n = dot1n let convFor = convFor let forSub = forSub let normalizeFor = normalizeFor let ctxToList = ctxToList let listToCtx = listToCtx  end\n(* functor FunSyn *) module FunSyn = FunSyn(struct module Whnf = Whnf module Conv = Conv end)\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Names of Constants and Variables *) (* Author: Carsten Schuermann *) module type FUNNAMES = sig (*! structure FunSyn : FUNSYN !*) exception Error of string(* Constant names and fixities *) val reset : unit -> unitval installName : string * lemma -> unitval nameLookup : string -> lemma optionval constName : lemma -> string(* will mark if shadowed *)  end\n(* signature NAMES *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module MTPGlobal = MTPGlobal(module MetaGlobal = MetaGlobal)(* Now in funsyn.fun *) (*\nstructure FunSyn = \n  FunSyn ((*! structure IntSyn' = IntSyn !*)\n\t  structure Whnf = Whnf\n\t  structure Conv = Conv);\n*) module StateSyn = StateSyn(struct module Whnf = Whnf module Conv = Conv end)module FunNames = FunNames(struct module Global = Global module HashTable = StringHashTable end)\nmodule FunPrint = FunPrint(struct module Formatter = Formatter module Print = Print module Names = Names end)\n(* moves eventually into the Twelf core *) module Weaken = Weaken(module Whnf = Whnf)module FunWeaken = FunWeaken(module Weaken = Weaken)module FunTypeCheck = FunTypeCheck(struct module StateSyn' = StateSyn module Abstract = Abstract module TypeCheck = TypeCheck module Conv = Conv module Weaken = Weaken module Subordinate = Subordinate module Whnf = Whnf module Print = Print module FunPrint = FunPrint end)\nmodule RelFun = RelFun(struct module Global = Global module ModeTable = ModeTable module Names = Names module TypeCheck = TypeCheck module Trail = Trail module Unify = UnifyTrail module Whnf = Whnf module Print = Print module Weaken = Weaken module FunWeaken = FunWeaken module FunNames = FunNames end)\n(* Functor instantiation for the Prover *) module MTPData = MTPData(module MTPGlobal = MTPGlobal)module MTPAbstract = MTPAbstract(struct module StateSyn' = StateSyn module Whnf = Whnf module Constraints = Constraints module Unify = UnifyTrail module Subordinate = Subordinate module TypeCheck = TypeCheck module FunTypeCheck = FunTypeCheck module Abstract = Abstract end)\nmodule MTPInit = MTPInit(struct module MTPGlobal = MTPGlobal module Names = Names module StateSyn' = StateSyn module MTPData = MTPData module Formatter = Formatter module Whnf = Whnf module Print = Print module FunPrint = FunPrint end)module MTPrint = MTPrint(struct module Global = Global module Names = Names module StateSyn' = StateSyn module Formatter' = Formatter module Print = Print module FunPrint = FunPrint end)module MTPSearch = MTPSearch(struct module Global = Global module MTPGlobal = MTPGlobal module Abstract = Abstract module Conv = Conv module StateSyn' = StateSyn module Compile = Compile module Whnf = Whnf module Unify = UnifyTrail module Index = IndexSkolem module Assign = Assign module CPrint = CPrint module Print = Print module Names = Names end)\nmodule MTPFilling = MTPFilling(struct module MTPGlobal = MTPGlobal module StateSyn' = StateSyn module MTPData = MTPData module Whnf = Whnf module Abstract = Abstract module TypeCheck = TypeCheck module Search = MTPSearch module Whnf = Whnf end)module MTPSplitting = MTPSplitting(struct module MTPGlobal = MTPGlobal module Global = Global module StateSyn' = StateSyn module Heuristic = Heuristic module MTPrint = MTPrint module MTPAbstract = MTPAbstract module Names = Names module Conv = Conv module Whnf = Whnf module TypeCheck = TypeCheck module Subordinate = Subordinate module FunTypeCheck = FunTypeCheck module Index = Index module Print = Print module Unify = UnifyTrail end)\nmodule UniqueSearch = UniqueSearch(struct module Global = Global module StateSyn' = StateSyn module Abstract = Abstract module MTPGlobal = MTPGlobal module Whnf = Whnf module Unify = UnifyTrail module Assign = Assign module Index = Index module Compile = Compile module CPrint = CPrint module Print = Print module Names = Names end)\nmodule Inference = Inference(struct module MTPGlobal = MTPGlobal module StateSyn' = StateSyn module Abstract = Abstract module TypeCheck = TypeCheck module FunTypeCheck = FunTypeCheck module UniqueSearch = UniqueSearch module Whnf = Whnf module Print = Print end)module MTPRecursion = MTPRecursion(struct module MTPGlobal = MTPGlobal module Global = Global module StateSyn' = StateSyn module FunTypeCheck = FunTypeCheck module MTPSearch = MTPSearch module Abstract = Abstract module MTPAbstract = MTPAbstract module Whnf = Whnf module Unify = UnifyTrail module Conv = Conv module Names = Names module Subordinate = Subordinate module MTPrint = MTPrint module Print = Print module TypeCheck = TypeCheck module FunPrint = FunPrint module Formatter = Formatter end)\nmodule MTPStrategy = MTPStrategy(struct module MTPGlobal = MTPGlobal module StateSyn' = StateSyn module MTPrint = MTPrint module MTPData = MTPData module MTPFilling = MTPFilling module MTPSplitting = MTPSplitting module MTPRecursion = MTPRecursion module Inference = Inference module Timers = Timers end)module MTProver = MTProver(struct module MTPGlobal = MTPGlobal module StateSyn = StateSyn module Order = Order module MTPrint = MTPrint module MTPInit = MTPInit module MTPStrategy = MTPStrategy module RelFun = RelFun end)module CombiProver = CombiProver(struct module MTPGlobal = MTPGlobal module ProverNew = MTProver module ProverOld = Prover end)module MTPi = MTPi(struct module MTPGlobal = MTPGlobal module StateSyn' = StateSyn module FunTypeCheck = FunTypeCheck module RelFun = RelFun module Formatter = Formatter module Print = Print module MTPrint = MTPrint module MTPInit = MTPInit module MTPFilling = MTPFilling module MTPData = MTPData module MTPSplitting = MTPSplitting module MTPRecursion = MTPRecursion module Inference = Inference module MTPStrategy = MTPStrategy module Names = Names module Order = Order module Timers = Timers module Ring = Ring end)", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Printer Version 1.3 *) (* Author: Carsten Schuermann *) module type MTPRINT = sig module Formatter : FORMATTERmodule StateSyn : STATESYNexception Error of stringval nameState : State -> Stateval formatState : State -> formatval stateToString : State -> string end\n(* signature MTPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Search (based on abstract machine ) : Version 1.3 *) (* Author: Carsten Schuermann *) module MTPSearch (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module MTPGlobal : MTPGLOBALmodule StateSyn\' : STATESYN(*! sharing StateSyn\'.FunSyn.IntSyn = IntSyn\' !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\'              !*) module Assign : ASSIGN(*! sharing Assign.IntSyn = IntSyn\'   !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module Compile : COMPILE(*! sharing Compile.IntSyn = IntSyn\' !*) (*! sharing Compile.CompSyn = CompSyn\' !*) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) ) : MTPSEARCH = struct (*! structure IntSyn = IntSyn\' !*)  module StateSyn = StateSyn\' (*! structure CompSyn = CompSyn\' !*)  exception Error of string module I = IntSynmodule C = CompSyn(* isInstantiated (V) = SOME(cid) or NONE\n       where cid is the type family of the atomic target type of V,\n       NONE if V is a kind or object or have variable type.\n    *) let rec isInstantiated (Root (Const (cid), _))  = true | isInstantiated (Pi (_, V))  = isInstantiated V | isInstantiated (Root (Def (cid), _))  = true | isInstantiated (Redex (V, S))  = isInstantiated V | isInstantiated (Lam (_, V))  = isInstantiated V | isInstantiated (EVar (ref (SOME (V)), _, _, _))  = isInstantiated V | isInstantiated (EClo (V, s))  = isInstantiated V | isInstantiated _  = false let rec compose\' (Null, G)  = G | compose\' (Decl (G, D), G\')  = Decl (compose\' (G, G\'), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) (* raiseType (G, V) = {{G}} V\n\n       Invariant:\n       If G |- V : L\n       then  . |- {{G}} V : L\n\n       All abstractions are potentially dependent.\n    *) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Pi ((D, Maybe), V)) (* exists P K = B\n       where B iff K = K1, Y, K2  s.t. P Y  holds\n    *) let rec exists P K  = let rec exists\' (Null)  = false | exists\' (Decl (K\', Y))  = P (Y) || exists\' (K\') in exists\' K (* occursInExp (r, (U, s)) = B,\n\n       Invariant:\n       If    G |- s : G1   G1 |- U : V\n       then  B holds iff r occurs in (the normal form of) U\n    *) let rec occursInExp (r, Vs)  = occursInExpW (r, whnf Vs)occursInExpW (r, (Uni _, _))  = false | occursInExpW (r, (Pi ((D, _), V), s))  = occursInDec (r, (D, s)) || occursInExp (r, (V, dot1 s)) | occursInExpW (r, (Root (_, S), s))  = occursInSpine (r, (S, s)) | occursInExpW (r, (Lam (D, V), s))  = occursInDec (r, (D, s)) || occursInExp (r, (V, dot1 s)) | occursInExpW (r, (EVar (r\', _, V\', _), s))  = (r = r\') || occursInExp (r, (V\', s)) | occursInExpW (r, (FgnExp csfe, s))  = fold csfe (fun (U, B) -> B || occursInExp (r, (U, s))) false(* hack - should consult cs  -rv *) occursInSpine (_, (Nil, _))  = false | occursInSpine (r, (SClo (S, s\'), s))  = occursInSpine (r, (S, comp (s\', s))) | occursInSpine (r, (App (U, S), s))  = occursInExp (r, (U, s)) || occursInSpine (r, (S, s))occursInDec (r, (Dec (_, V), s))  = occursInExp (r, (V, s)) (* nonIndex (r, GE) = B\n\n       Invariant:\n       B hold iff\n        r does not occur in any type of EVars in GE\n    *) let rec nonIndex (_, nil)  = true | nonIndex (r, EVar (_, _, V, _) :: GE)  = (not (occursInExp (r, (V, id)))) && nonIndex (r, GE) (* select (GE, (V, s), acc) = acc\'\n\n       Invariant:\n    *) (* Efficiency: repeated whnf for every subterm in Vs!!! *) let rec selectEVar (nil)  = nil | selectEVar ((X as EVar (r, _, _, ref nil)) :: GE)  = let Xs = selectEVar (GE) in if nonIndex (r, Xs) then Xs @ [X] else Xs | selectEVar ((X as EVar (r, _, _, cnstrs)) :: GE)  = (* Constraint case *)  let Xs = selectEVar (GE) in if nonIndex (r, Xs) then X :: Xs else Xs (* pruneCtx (G, n) = G\'\n\n       Invariant:\n       If   |- G ctx\n       and  G = G0, G1\n       and  |G1| = n\n       then |- G\' = G0 ctx\n    *) let rec pruneCtx (G, 0)  = G | pruneCtx (Decl (G, _), n)  = pruneCtx (G, n - 1) let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a | cidFromHead (Skonst a)  = a (* only used for type families of compiled clauses *) let rec eqHead (Const a, Const a\')  = a = a\' | eqHead (Def a, Def a\')  = a = a\' | eqHead _  = false (* solve ((g,s), (G,dPool), sc, (acc, k)) => ()\n     Invariants:\n       G |- s : G\'\n       G\' |- g :: goal\n       G ~ dPool  (context G matches dPool)\n       acc is the accumulator of results\n       and k is the max search depth limit\n           (used in the existential case for iterative deepening,\n            used in the universal case for max search depth)\n       if  G |- M :: g[s] then G |- sc :: g[s] => Answer, Answer closed\n  *) let rec solve (max, depth, (Atom p, s), dp as DProg (G, dPool), sc)  = matchAtom (max, depth, (p, s), dp, sc) | solve (max, depth, (Impl (r, A, Ha, g), s), DProg (G, dPool), sc)  = let D\' = Dec (NONE, EClo (A, s)) in solve (max, depth + 1, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (fun M -> sc (Lam (D\', M)))) | solve (max, depth, (All (D, g), s), DProg (G, dPool), sc)  = let D\' = decSub (D, s) in solve (max, depth + 1, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Parameter)), (fun M -> sc (Lam (D\', M))))(* rsolve (max, depth, (p,s\'), (r,s), (G,dPool), sc, (acc, k)) = ()\n     Invariants:\n       G |- s : G\'\n       G\' |- r :: resgoal\n       G |- s\' : G\'\'\n       G\'\' |- p :: atom\n       G ~ dPool\n       acc is the accumulator of results\n       and k is the max search depth limit\n           (used in the existential case for iterative deepening,\n            used in the universal case for max search depth)\n       if G |- S :: r[s] then G |- sc : (r >> p[s\']) => Answer\n  *) rSolve (max, depth, ps\', (Eq Q, s), DProg (G, dPool), sc)  = if unifiable (G, ps\', (Q, s)) then sc Nil else () | rSolve (max, depth, ps\', (Assign (Q, eqns), s), dp as DProg (G, dPool), sc)  = (match assignable (G, ps\', (Q, s)) with SOME (cnstr) -> aSolve ((eqns, s), dp, cnstr, (fun () -> sc Nil)) | NONE -> ()) | rSolve (max, depth, ps\', (And (r, A, g), s), dp as DProg (G, dPool), sc)  = (* is this EVar redundant? -fp *) let X = newEVar (G, EClo (A, s)) in rSolve (max, depth, ps\', (r, Dot (Exp (X), s)), dp, (fun S -> solve (max, depth, (g, s), dp, (fun M -> sc (App (M, S)))))) | rSolve (max, depth, ps\', (In (r, A, g), s), dp as DProg (G, dPool), sc)  = (* G |- g goal *) (* G |- A : type *) (* G, A |- r resgoal *) (* G0, Gl  |- s : G *) (* G0, Gl  |- w : G0 *) (* G0 |- iw : G0, Gl *) (* G0 |- w : G *) (* G0 |- X : A[s\'] *) (* G0, Gl |- X\' : A[s\'][w] = A[s] *) let G0 = pruneCtx (G, depth) let dPool0 = pruneCtx (dPool, depth) let w = Shift (depth) let iw = invert w let s\' = comp (s, iw) let X = newEVar (G0, EClo (A, s\')) let X\' = EClo (X, w) in rSolve (max, depth, ps\', (r, Dot (Exp (X\'), s)), dp, (fun S -> if isInstantiated X then sc (App (X\', S)) else solve (max, 0, (g, s\'), DProg (G0, dPool0), (fun M -> (try  with ))))) | rSolve (max, depth, ps\', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), sc)  = let X = newEVar (G, EClo (A, s)) in rSolve (max, depth, ps\', (r, Dot (Exp (X), s)), dp, (fun S -> sc (App (X, S)))) | rSolve (max, depth, ps\', (Axists (ADec (SOME (X), d), r), s), dp as DProg (G, dPool), sc)  = let X\' = newAVar () in rSolve (max, depth, ps\', (r, Dot (Exp (EClo (X\', Shift (~ d))), s)), dp, sc)(* we don\'t increase the proof term here! *)(* aSolve ((ag, s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       if G |- ag[s] auxgoal\n       then sc () is evaluated with return value res\n       else res = Fail\n     Effects: instantiation of EVars in ag[s], dp and sc () *) aSolve ((Trivial, s), dp, cnstr, sc)  = (if solveCnstr cnstr then sc () else ()) | aSolve ((UnifyEq (G\', e1, N, eqns), s), dp as DProg (G, dPool), cnstr, sc)  = let (G\'\') = compose\' (G\', G) let s\' = shift (G\', s) in if unifiable (G\'\', (N, s\'), (e1, s\')) then aSolve ((eqns, s), dp, cnstr, sc) else ()(* matchatom ((p, s), (G, dPool), sc, (acc, k)) => ()\n     G |- s : G\'\n     G\' |- p :: atom\n     G ~ dPool\n     acc is the accumulator of results\n     and k is the max search depth limit\n         (used in the existential case for iterative deepening,\n          used in the universal case for max search depth)\n     if G |- M :: p[s] then G |- sc :: p[s] => Answer\n  *) matchAtom (0, _, _, _, _)  = () | matchAtom (max, depth, ps\' as (Root (Ha, _), _), dp as DProg (G, dPool), sc)  = let rec matchSig\' nil  = () | matchSig\' (Hc :: sgn\')  = let SClause (r) = sProgLookup (cidFromHead Hc) let _ = trail (fun () -> rSolve (max - 1, depth, ps\', (r, id), dp, (fun S -> sc (Root (Hc, S))))) in matchSig\' sgn\' let rec matchDProg (Null, _)  = matchSig\' (lookup (cidFromHead Ha)) | matchDProg (Decl (dPool\', Dec (r, s, Ha\')), n)  = if eqHead (Ha, Ha\') then let _ = trail (fun () -> rSolve (max - 1, depth, ps\', (r, comp (s, Shift n)), dp, (fun S -> sc (Root (BVar n, S))))) in matchDProg (dPool\', n + 1) else matchDProg (dPool\', n + 1) | matchDProg (Decl (dPool\', Parameter), n)  = matchDProg (dPool\', n + 1) in matchDProg (dPool, 1)(* searchEx\' max (GE, sc) = acc\'\n\n       Invariant:\n       If   GE is a list of EVars to be instantiated\n       and  max is the maximal number of constructors\n       then if an instantiation of EVars in GE is found Success is raised\n            otherwise searchEx\' terminates with []\n    *) (* contexts of EVars are recompiled for each search depth *) searchEx\' max (nil, sc)  = sc max | searchEx\' max ((X as EVar (r, G, V, _)) :: GE, sc)  = solve (max, 0, (compileGoal (G, V), id), compileCtx false G, (fun U\' -> try  with )) (* deepen (f, P) = R\'\n\n       Invariant:\n       If   f function expecting parameters P\n         checking the variable MTPGlobal.maxLevel\n       then R\' is the result of applying f to P and\n         traversing all possible numbers up to MTPGlobal.maxLevel\n    *) let rec deepen depth f P  = let rec deepen\' level  = if level > depth then () else (if ! chatter > 5 then print "#" else (); (f level P; deepen\' (level + 1))) in deepen\' 1 (* searchEx (G, GE, (V, s), sc) = acc\'\n       Invariant:\n       If   G |- s : G\'   G\' |- V : level\n       and  GE is a list of EVars contained in V[s]\n         where G |- X : VX\n       and  sc is a function to be executed after all non-index variables have\n         been instantiated\n       then acc\' is a list containing the one result from executing the success continuation\n         All EVar\'s got instantiated with the smallest possible terms.\n    *) let rec searchEx (it, depth) (GE, sc)  = (if ! chatter > 5 then print "[Search: " else (); deepen depth searchEx\' (selectEVar (GE), fun max -> (if ! chatter > 5 then print "OK]\\n" else (); let GE\' = foldr (fun (X as EVar (_, G, _, _), L) -> collectEVars (G, (X, id), L)) nil GE let gE\' = length GE\' in if gE\' > 0 then if it > 0 then searchEx (it - 1, 1) (GE\', sc) else () else sc max(* warning: iterative deepening depth is not propably updated.\n                                             possible that it runs into an endless loop ? *) )); if ! chatter > 5 then print "FAIL]\\n" else (); ()) (* search (GE, sc) = ()\n\n       Invariant:\n       GE is a list of uninstantiated EVars\n       and sc is a success continuation : int -> unit\n\n       Side effect:\n       success continuation will raise exception\n    *) (* Shared contexts of EVars in GE may recompiled many times *) let rec search (maxFill, GE, sc)  = searchEx (1, maxFill) (GE, sc) let searchEx = search  (* local ... *)  end\n(* functor Search *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Meta Theorem Prover abstraction : Version 1.3 *) (* Author: Frank Pfenning, Carsten Schuermann *) module MTPAbstract ((*! structure IntSyn\' : INTSYN !*) (*! structure FunSyn\' : FUNSYN !*) (*! sharing FunSyn\'.IntSyn = IntSyn\' !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.FunSyn = FunSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) module FunTypeCheck : FUNTYPECHECK(*! sharing FunTypeCheck.FunSyn = FunSyn\' !*) FunTypeCheckStateSynStateSyn\'module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) ) : MTPABSTRACT = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure FunSyn = FunSyn\' !*)  module StateSyn = StateSyn\' exception Error of string type ApproxFor = Head of dctx * (For * Sub) * int | Block of (dctx * Sub * int * Dec list) * ApproxFor (*      | (t, G2), AF *)  module I = IntSynmodule F = FunSynmodule S = StateSynmodule C = Constraints(* Intermediate Data Structure *) type EBVar = EV of Exp option ref * Exp * Tag * int | BV of Dec * Tag (*\n       We write {{K}} for the context of K, where EVars and BVars have\n       been translated to declarations and their occurrences to BVars.\n       We write {{U}}_K, {{S}}_K for the corresponding translation of an\n       expression or spine.\n\n       Just like contexts G, any K is implicitly assumed to be\n       well-formed and in dependency order.\n\n       We write  K ||- U  if all EVars and BVars in U are collected in K.\n       In particular, . ||- U means U contains no EVars or BVars.  Similarly,\n       for spines K ||- S and other syntactic categories.\n\n       Collection and abstraction raise Error if there are unresolved\n       constraints after simplification.\n    *) (* checkEmpty Cnstr = ()\n       raises Error exception if constraints Cnstr cannot be simplified\n       to the empty constraint\n    *) let rec checkEmpty (nil)  = () | checkEmpty (cnstrL)  = (match simplify cnstrL with nil -> () | _ -> raise (Error "Typing ambiguous -- unresolved constraints")) (* eqEVar X Y = B\n       where B iff X and Y represent same variable\n    *) let rec eqEVar (EVar (r1, _, _, _)) (EV (r2, _, _, _))  = (r1 = r2) | eqEVar _ _  = false (* exists P K = B\n       where B iff K = K1, Y, K2  s.t. P Y  holds\n    *) let rec exists P K  = let rec exists\' (Null)  = false | exists\' (Decl (K\', Y))  = P (Y) || exists\' (K\') in exists\' K let rec or (Maybe, _)  = Maybe | or (_, Maybe)  = Maybe | or (Meta, _)  = Meta | or (_, Meta)  = Meta | or (No, No)  = No (* occursInExp (k, U) = DP,\n\n       Invariant:\n       If    U in nf\n       then  DP = No      iff k does not occur in U\n             DP = Maybe   iff k occurs in U some place not as an argument to a Skonst\n             DP = Meta    iff k occurs in U and only as arguments to Skonsts\n    *) let rec occursInExp (k, Uni _)  = No | occursInExp (k, Pi (DP, V))  = or (occursInDecP (k, DP), occursInExp (k + 1, V)) | occursInExp (k, Root (H, S))  = occursInHead (k, H, occursInSpine (k, S)) | occursInExp (k, Lam (D, V))  = or (occursInDec (k, D), occursInExp (k + 1, V))(* no case for Redex, EVar, EClo *) occursInHead (k, BVar (k\'), DP)  = if (k = k\') then Maybe else DP | occursInHead (k, Const _, DP)  = DP | occursInHead (k, Def _, DP)  = DP | occursInHead (k, Skonst _, No)  = No | occursInHead (k, Skonst _, Meta)  = Meta | occursInHead (k, Skonst _, Maybe)  = Meta(* no case for FVar *) occursInSpine (_, Nil)  = No | occursInSpine (k, App (U, S))  = or (occursInExp (k, U), occursInSpine (k, S))(* no case for SClo *) occursInDec (k, Dec (_, V))  = occursInExp (k, V)occursInDecP (k, (D, _))  = occursInDec (k, D) (* piDepend ((D,P), V) = Pi ((D,P\'), V)\n       where P\' = Maybe if D occurs in V, P\' = No otherwise\n    *) (* optimize to have fewer traversals? -cs *) (* pre-Twelf 1.2 code walk Fri May  8 11:17:10 1998 *) let rec piDepend (DPV as ((D, No), V))  = Pi DPV | piDepend (DPV as ((D, Meta), V))  = Pi DPV | piDepend ((D, Maybe), V)  = Pi ((D, occursInExp (1, V)), V) (* weaken (depth,  G, a) = (w\')\n    *) let rec weaken (Null, a)  = id | weaken (Decl (G\', D as Dec (name, V)), a)  = let w\' = weaken (G\', a) in if belowEq (targetFam V, a) then dot1 w\' else comp (w\', shift) (* raiseType (G, V) = {{G}} V\n\n       Invariant:\n       If G |- V : L\n       then  . |- {{G}} V : L\n\n       All abstractions are potentially dependent.\n    *) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Pi ((D, Maybe), V)) let rec restore (0, Gp)  = (Gp, Null) | restore (n, Decl (G, D))  = let (Gp\', GX\') = restore (n - 1, G) in (Gp\', Decl (GX\', D)) let rec concat (Gp, Null)  = Gp | concat (Gp, Decl (G, D))  = Decl (concat (Gp, G), D) (* collectExpW (T, d, G, (U, s), K) = K\'\n\n       Invariant:\n       If    G |- s : G1     G1 |- U : V      (U,s) in whnf\n       No circularities in U\n             (enforced by extended occurs-check for BVars in Unify)\n       and   K\' = K, K\'\'\n             where K\'\' contains all EVars and BVars in (U,s)\n    *) (* Possible optimization: Calculate also the normal form of the term *) let rec collectExpW (T, d, G, (Uni L, s), K)  = K | collectExpW (T, d, G, (Pi ((D, _), V), s), K)  = collectExp (T, d, Decl (G, decSub (D, s)), (V, dot1 s), collectDec (T, d, G, (D, s), K)) | collectExpW (T, d, G, (Root (_, S), s), K)  = collectSpine (decrease T, d, G, (S, s), K) | collectExpW (T, d, G, (Lam (D, U), s), K)  = collectExp (T, d, Decl (G, decSub (D, s)), (U, dot1 s), collectDec (T, d, G, (D, s), K)) | collectExpW (T, d, G, (X as EVar (r, GdX, V, cnstrs), s), K)  = if exists (eqEVar X) K then collectSub (T, d, G, s, K) else (* optimization possible for d = 0 *) let (Gp, GX) = restore (ctxLength GdX - d, GdX) let _ = checkEmpty (! cnstrs) let w = weaken (GX, targetFam V) let iw = invert w let GX\' = strengthen (iw, GX) let X\' as EVar (r\', _, _, _) = newEVar (concat (Gp, GX\'), EClo (V, iw)) let _ = instantiateEVar (r, EClo (X\', w), nil) let V\' = raiseType (GX\', EClo (V, iw)) in collectSub (T, d, G, comp (w, s), Decl (collectExp (T, d, Gp, (V\', id), K), EV (r\', V\', T, d))) | collectExpW (T, d, G, (FgnExp csfe, s), K)  = fold csfe (fun (U, K\') -> collectExp (T, d, G, (U, s), K\')) K(* hack - should consult cs    -rv *) (* No other cases can occur due to whnf invariant *) (* collectExp (T, d, G, (U, s), K) = K\'\n\n       same as collectExpW  but  (U,s) need not to be in whnf\n    *) collectExp (T, d, G, Us, K)  = collectExpW (T, d, G, whnf Us, K)(* collectSpine (T, d, G, (S, s), K) = K\'\n\n       Invariant:\n       If    G |- s : G1     G1 |- S : V > P\n       then  K\' = K, K\'\'\n       where K\'\' contains all EVars and BVars in (S, s)\n     *) collectSpine (T, d, G, (Nil, _), K)  = K | collectSpine (T, d, G, (SClo (S, s\'), s), K)  = collectSpine (T, d, G, (S, comp (s\', s)), K) | collectSpine (T, d, G, (App (U, S), s), K)  = collectSpine (T, d, G, (S, s), collectExp (T, d, G, (U, s), K))(* collectDec (T, d, G, (x:V, s), K) = K\'\n\n       Invariant:\n       If    G |- s : G1     G1 |- V : L\n       then  K\' = K, K\'\'\n       where K\'\' contains all EVars and BVars in (V, s)\n    *) collectDec (T, d, G, (Dec (_, V), s), K)  = collectExp (T, d, G, (V, s), K)(* collectSub (T, d, G, s, K) = K\'\n\n       Invariant:\n       If    G |- s : G1\n       then  K\' = K, K\'\'\n       where K\'\' contains all EVars and BVars in s\n    *) collectSub (T, d, G, Shift _, K)  = K | collectSub (T, d, G, Dot (Idx _, s), K)  = collectSub (T, d, G, s, K) | collectSub (T, d, G, Dot (Exp (U), s), K)  = collectSub (T, d, G, s, collectExp (T, d, G, (U, id), K)) (* abstractEVar (K, depth, X) = C\'\n\n       Invariant:\n       If   G |- X : V\n       and  |G| = depth\n       and  X occurs in K  at kth position (starting at 1)\n       then C\' = BVar (depth + k)\n       and  {{K}}, G |- C\' : V\n    *) let rec abstractEVar (Decl (K\', EV (r\', _, _, d)), depth, X as EVar (r, _, _, _))  = if r = r\' then (BVar (depth + 1), d) else abstractEVar (K\', depth + 1, X) | abstractEVar (Decl (K\', BV _), depth, X)  = abstractEVar (K\', depth + 1, X) (* lookupBV (A, i) = k\'\n\n       Invariant:\n\n       If   A ||- V\n       and  G |- V type\n       and  G [x] A |- i : V\'\n       then ex a substititution  G x A |- s : G [x] A\n       and  G x A |- k\' : V\'\'\n       and  G x A |- V\' [s] = V\'\' : type\n    *) let rec lookupBV (K, i)  = (* lookupBV\' I.Null cannot occur by invariant *) let rec lookupBV\' (Decl (K, EV (r, V, _, _)), i, k)  = lookupBV\' (K, i, k + 1) | lookupBV\' (Decl (K, BV _), 1, k)  = k | lookupBV\' (Decl (K, BV _), i, k)  = lookupBV\' (K, i - 1, k + 1) in lookupBV\' (K, i, 1) (* abstractExpW (K, depth, (U, s)) = U\'\n       U\' = {{U[s]}}_K\n\n       Invariant:\n       If    G |- s : G1     G1 |- U : V    (U,s) is in whnf\n       and   K is internal context in dependency order\n       and   |G| = depth\n       and   K ||- U and K ||- V\n       then  {{K}}, G |- U\' : V\'\n       and   . ||- U\' and . ||- V\'\n       and   U\' is in nf\n    *) let rec abstractExpW (K, depth, (U as Uni (L), s))  = U | abstractExpW (K, depth, (Pi ((D, P), V), s))  = piDepend ((abstractDec (K, depth, (D, s)), P), abstractExp (K, depth + 1, (V, dot1 s))) | abstractExpW (K, depth, (Root (H as BVar k, S), s))  = (* s = id *)  if k > depth then let k\' = lookupBV (K, k - depth) in Root (BVar (k\' + depth), abstractSpine (K, depth, (S, s))) else Root (H, abstractSpine (K, depth, (S, s))) | abstractExpW (K, depth, (Root (H, S), s))  = Root (H, abstractSpine (K, depth, (S, s))) | abstractExpW (K, depth, (Lam (D, U), s))  = Lam (abstractDec (K, depth, (D, s)), abstractExp (K, depth + 1, (U, dot1 s))) | abstractExpW (K, depth, (X as EVar (_, G, _, _), s))  = let (H, d) = abstractEVar (K, depth, X) in Root (H, abstractSub (ctxLength G - d, K, depth, s, Nil)) | abstractExpW (K, depth, (FgnExp csfe, s))  = apply csfe (fun U -> abstractExp (K, depth, (U, s)))(* hack - should consult cs   -rv *) (* abstractExp (K, depth, (U, s)) = U\'\n\n       same as abstractExpW, but (U,s) need not to be in whnf\n    *) abstractExp (K, depth, Us)  = abstractExpW (K, depth, whnf Us)(* abstractSub (K, depth, s, S) = S\'      (implicit raising)\n       S\' = {{s}}_K @@ S\n\n       Invariant:\n       If   G |- s : G1\n       and  |G| = depth\n       and  K ||- s\n       then {{K}}, G |- S\' : {G1}.W > W   (for some W)\n       and  . ||- S\'\n    *) abstractSub (n, K, depth, Shift (k), S)  = if n > 0 then abstractSub (n, K, depth, Dot (Idx (k + 1), Shift (k + 1)), S) else (* n = 0 *) S | abstractSub (n, K, depth, Dot (Idx (k), s), S)  = let H = if k > depth then let k\' = lookupBV (K, k - depth) in BVar (k\' + depth) else BVar (k) in abstractSub (n - 1, K, depth, s, App (Root (H, Nil), S)) | abstractSub (n, K, depth, Dot (Exp (U), s), S)  = abstractSub (n - 1, K, depth, s, App (abstractExp (K, depth, (U, id)), S))(* abstractSpine (K, depth, (S, s)) = S\'\n       where S\' = {{S[s]}}_K\n\n       Invariant:\n       If   G |- s : G1     G1 |- S : V > P\n       and  K ||- S\n       and  |G| = depth\n\n       then {{K}}, G |- S\' : V\' > P\'\n       and  . ||- S\'\n    *) abstractSpine (K, depth, (Nil, _))  = Nil | abstractSpine (K, depth, (SClo (S, s\'), s))  = abstractSpine (K, depth, (S, comp (s\', s))) | abstractSpine (K, depth, (App (U, S), s))  = App (abstractExp (K, depth, (U, s)), abstractSpine (K, depth, (S, s)))(* abstractDec (K, depth, (x:V, s)) = x:V\'\n       where V = {{V[s]}}_K\n\n       Invariant:\n       If   G |- s : G1     G1 |- V : L\n       and  K ||- V\n       and  |G| = depth\n\n       then {{K}}, G |- V\' : L\n       and  . ||- V\'\n    *) abstractDec (K, depth, (Dec (x, V), s))  = Dec (x, abstractExp (K, depth, (V, s))) (* getlevel (V) = L if G |- V : L\n\n       Invariant: G |- V : L\' for some L\'\n    *) let rec getLevel (Uni _)  = Kind | getLevel (Pi (_, U))  = getLevel U | getLevel (Root _)  = Type | getLevel (Redex (U, _))  = getLevel U | getLevel (Lam (_, U))  = getLevel U | getLevel (EClo (U, _))  = getLevel U (* checkType (V) = () if G |- V : type\n\n       Invariant: G |- V : L\' for some L\'\n    *) let rec checkType V  = (match getLevel V with Type -> () | _ -> raise (Error "Typing ambiguous -- free type variable")) (* abstractCtx (K, V) = V\'\n       where V\' = {{K}} V\n\n       Invariant:\n       If   {{K}} |- V : L\n       and  . ||- V\n\n       then V\' = {{K}} V\n       and  . |- V\' : L\n       and  . ||- V\'\n    *) let rec abstractCtx (Null)  = (Null, Null) | abstractCtx (Decl (K\', EV (_, V\', T as Lemma (b), _)))  = let V\'\' = abstractExp (K\', 0, (V\', id)) let _ = checkType V\'\' let (G\', B\') = abstractCtx K\' let D\' = Dec (NONE, V\'\') in (Decl (G\', D\'), Decl (B\', T)) | abstractCtx (Decl (K\', EV (_, V\', T as None, _)))  = let V\'\' = abstractExp (K\', 0, (V\', id)) let _ = checkType V\'\' let (G\', B\') = abstractCtx K\' let D\' = Dec (NONE, V\'\') in (Decl (G\', D\'), Decl (B\', None)) | abstractCtx (Decl (K\', BV (D, T)))  = let D\' = abstractDec (K\', 0, (D, id)) let (G\', B\') = abstractCtx K\' in (Decl (G\', D\'), Decl (B\', T)) (* abstractGlobalSub (K, s, B) = s\'\n\n       Invariant:\n       If   K > G   aux context\n       and  G |- s : G\'\n       then K |- s\' : G\'\n    *) let rec abstractGlobalSub (K, Shift _, Null)  = Shift (ctxLength K) | abstractGlobalSub (K, Shift n, B as Decl _)  = abstractGlobalSub (K, Dot (Idx (n + 1), Shift (n + 1)), B) | abstractGlobalSub (K, Dot (Idx k, s\'), Decl (B, T as Parameter _))  = Dot (Idx (lookupBV (K, k)), abstractGlobalSub (K, s\', B)) | abstractGlobalSub (K, Dot (Exp U, s\'), Decl (B, T as Lemma _))  = Dot (Exp (abstractExp (K, 0, (U, id))), abstractGlobalSub (K, s\', B)) (* collectGlobalSub (G0, s, B, collect) = collect\'\n\n       Invariant:\n       If   |- G0 ctx\n       and  |- G ctx\n       and  G |- B tags\n       and  G0 |- s : G\n       and  collect is a function which maps\n               (d, K)  (d expresses the number of parameters in K, |- K aux ctx)\n            to K\'      (|- K\' aux ctx, which collects all EVars in K)\n    *) let rec collectGlobalSub (G0, Shift _, Null, collect)  = collect | collectGlobalSub (G0, s, B as Decl (_, Parameter (SOME l)), collect)  = let LabelDec (name, _, G2) = labelLookup l in skip (G0, length G2, s, B, collect) | collectGlobalSub (G0, Dot (Exp (U), s), Decl (B, T), collect)  = collectGlobalSub (G0, s, B, fun (d, K) -> collect (d, collectExp (T, d, G0, (U, id), K)))(* no cases for (G0, s, B as I.Decl (_, S.Parameter NONE), collect) *) skip (G0, 0, s, B, collect)  = collectGlobalSub (G0, s, B, collect) | skip (Decl (G0, D), n, s, Decl (B, T as Parameter _), collect)  = skip (G0, n - 1, invDot1 s, B, fun (d, K) -> collect (d + 1, Decl (K, BV (D, T)))) (* abstractNew ((G0, B0), s, B) = ((G\', B\'), s\')\n\n       Invariant:\n       If   . |- G0 ctx\n       and  G0 |- B0 tags\n       and  G0 |- s : G\n       and  G |- B tags\n       then . |- G\' = G1, Gp, G2\n       and  G\' |- B\' tags\n       and  G\' |- s\' : G\n    *) let rec abstractNew ((G0, B0), s, B)  = let cf = collectGlobalSub (G0, s, B, fun (_, K\') -> K\') let K = cf (0, Null) in (abstractCtx K, abstractGlobalSub (K, s, B)) (* abstractSub (t, B1, (G0, B0), s, B) = ((G\', B\'), s\')\n\n       Invariant:\n       If   . |- t : G1\n       and  G1 |- B1 tags\n\n       and  G0 |- B0 tags\n       and  G0 |- s : G\n       and  G |- B tags\n       then . |- G\' = G1, G0, G2\n       and  B\' |- G\' tags\n       and  G\' |- s\' : G\n    *) let rec abstractSubAll (t, B1, (G0, B0), s, B)  = (* skip\'\' (K, (G, B)) = K\'\n\n             Invariant:\n             If   G = x1:V1 .. xn:Vn\n             and  G |- B = <param> ... <param> tags\n             then  K\' = K, BV (x1) .. BV (xn)\n          *) let rec skip\'\' (K, (Null, Null))  = K | skip\'\' (K, (Decl (G0, D), Decl (B0, T)))  = Decl (skip\'\' (K, (G0, B0)), BV (D, T)) let collect2 = collectGlobalSub (G0, s, B, fun (_, K\') -> K\') let collect0 = collectGlobalSub (Null, t, B1, fun (_, K\') -> K\') let K0 = collect0 (0, Null) let K1 = skip\'\' (K0, (G0, B0)) let d = ctxLength G0 let K = collect2 (d, K1) in (abstractCtx K, abstractGlobalSub (K, s, B)) (* abstractFor (K, depth, (F, s)) = F\'\n       F\' = {{F[s]}}_K\n\n       Invariant:\n       If    G |- s : G1     G1 |- U : V    (U,s) is in whnf\n       and   K is internal context in dependency order\n       and   |G| = depth\n       and   K ||- U and K ||- V\n       then  {{K}}, G |- U\' : V\'\n       and   . ||- U\' and . ||- V\'\n       and   U\' is in nf\n    *) let rec abstractFor (K, depth, (All (Prim D, F), s))  = All (Prim (abstractDec (K, depth, (D, s))), abstractFor (K, depth + 1, (F, dot1 s))) | abstractFor (K, depth, (Ex (D, F), s))  = Ex (abstractDec (K, depth, (D, s)), abstractFor (K, depth + 1, (F, dot1 s))) | abstractFor (K, depth, (True, s))  = True | abstractFor (K, depth, (And (F1, F2), s))  = And (abstractFor (K, depth, (F1, s)), abstractFor (K, depth, (F2, s))) (* abstract (Gx, F) = F\'\n\n       Invariant:\n       If   G, Gx |- F formula\n       then G |- F\' = {{Gx}} F formula\n    *) let rec allClo (Null, F)  = F | allClo (Decl (Gx, D), F)  = allClo (Gx, All (Prim D, F)) let rec convert (Null)  = Null | convert (Decl (G, D))  = Decl (convert G, BV (D, Parameter NONE)) let rec createEmptyB 0  = Null | createEmptyB (n)  = Decl (createEmptyB (n - 1), None) let rec lower (_, 0)  = Null | lower (Decl (G, D), n)  = Decl (lower (G, n - 1), D) let rec split (G, 0)  = (G, Null) | split (Decl (G, D), n)  = let (G1, G2) = split (G, n - 1) in (G1, Decl (G2, D)) (* shift G = s\'\n\n       Invariant:\n       Forall contexts G0:\n       If   |- G0, G ctx\n       then G0, V, G |- s\' : G0, G\n    *) let rec shift (Null)  = shift | shift (Decl (G, _))  = dot1 (shift G) (* ctxSub (G, s) = G\'\n\n       Invariant:\n       If   G2 |- s : G1\n       and  G1 |- G ctx\n       then G2 |- G\' = G[s] ctx\n    *) let rec ctxSub (nil, s)  = nil | ctxSub (D :: G, s)  = decSub (D, s) :: ctxSub (G, dot1 s) (* weaken2 (G, a, i, S) = w\'\n\n       Invariant:\n       G |- w\' : Gw\n       Gw < G\n       G |- S : {Gw} V > V\n    *) let rec weaken2 (Null, a, i)  = (id, fun S -> S) | weaken2 (Decl (G\', D as Dec (name, V)), a, i)  = let (w\', S\') = weaken2 (G\', a, i + 1) in if belowEq (targetFam V, a) then (dot1 w\', fun S -> App (Root (BVar i, Nil), S)) else (comp (w\', shift), S\') (* raiseType (G, V) = {{G}} V\n\n       Invariant:\n       If G |- V : L\n       then  . |- {{G}} V : L\n\n       All abstractions are potentially dependent.\n    *) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, piDepend ((normalizeDec (D, id), Maybe), V)) (* raiseFor (G, F, w, sc) = F\'\n\n       Invariant:\n       If   G0 |- G ctx\n       and  G0, G, GF |- F for\n       and  G0, {G} GF [...] |- w : G0\n       and  sc maps  (G0, GA |- w : G0, |GA|)  to   (G0, GA, G[..] |- s : G0, G, GF)\n       then G0, {G} GF |- F\' for\n    *) let rec raiseFor (k, Gorig, F as True, w, sc)  = F | raiseFor (k, Gorig, Ex (Dec (name, V), F), w, sc)  = (* G0, {G}GF[..], G |- s : G0, G, GF *) (* G0, {G}GF[..], G |- V\' : type *) (* G0, {G}GF[..], G |- nw : G0, {G}GF[..], Gw\n                                         Gw < G *) (* G0, {G}GF[..], Gw |- iw : G0, {G}GF[..], G *) (* Generalize the invariant for Whnf.strengthen --cs *) (* G0, {G}GF[..], Gw |- V\'\' = V\'[iw] : type*) (* G0, {G}GF[..] |- V\'\'\' = {Gw} V\'\' : type*) (* G0, {G}GF[..], G[..] |- S\'\'\' : {Gw} V\'\'[..] > V\'\'[..] *) (* G0, {G}GF[..], G |- s : G0, G, GF *) let G = listToCtx (ctxSub (ctxToList Gorig, w)) let g = ctxLength G let s = sc (w, k) let V\' = EClo (V, s) let (nw, S) = weaken2 (G, targetFam V, 1) let iw = invert nw let Gw = strengthen (iw, G) let V\'\' = normalize (V\', iw) let V\'\'\' = normalize (raiseType (Gw, V\'\'), id) let S\'\'\' = S Nil let sc\' = fun (w\', k\') -> (* G0, GA |- w\' : G0 *) (* G0, GA, G[..] |- s\' : G0, G, GF *) let s\' = sc (w\', k\') in Dot (Exp (Root (BVar (g + k\' - k), S\'\'\')), s\')(* G0, GA, G[..] |- (g+k\'-k). S\', s\' : G0, G, GF, V *)  let F\' = raiseFor (k + 1, Gorig, F, comp (w, shift), sc\') in Ex (Dec (name, V\'\'\'), F\') | raiseFor (k, Gorig, All (Prim (Dec (name, V)), F), w, sc)  = (*                val G = F.listToCtx (ctxSub (F.ctxToList Gorig, w))\n                  val g = I.ctxLength G\n                  val s = sc (w, k)\n                                        (* G0, {G}GF[..], G |- s : G0, G, GF *)\n                  val V\' = Whnf.normalize (raiseType (G, Whnf.normalize (V, s)), I.id)\n                                        (* G0, {G}GF[..] |- V\' = {G}(V[s]) : type *)\n                  val S\' = spine g\n                                        (* G0, {G}GF[..] |- S\' > {G}(V[s]) > V[s] *)\n                  val sc\' = fn (w\', k\') =>\n                              let\n                                        (* G0, GA |- w\' : G0 *)\n                                val s\' = sc (w\', k\')\n                                        (* G0, GA, G[..] |- s\' : G0, G, GF *)\n                              in\n                                I.Dot (I.Exp (I.Root (I.BVar (g + k\'-k), S\')), s\')\n                                        (* G0, GA, G[..] |- g+k\'-k. S\', s\' : G0, G, GF, V *)\n                              end\n                  val F\' = raiseFor (k+1, Gorig, F, I.comp (w, I.shift), sc\')\n                in\n                  F.All (F.Prim (I.Dec (name, V\')), F\')\n*) (* G0, {G}GF[..], G |- s : G0, G, GF *) (* G0, {G}GF[..], G |- V\' : type *) (* G0, {G}GF[..], G |- nw : G0, {G}GF[..], Gw\n                                         Gw < G *) (* G0, {G}GF[..], Gw |- iw : G0, {G}GF[..], G *) (* Generalize the invariant for Whnf.strengthen --cs *) (* G0, {G}GF[..], Gw |- V\'\' = V\'[iw] : type*) (* G0, {G}GF[..] |- V\'\'\' = {Gw} V\'\' : type*) (* G0, {G}GF[..], G[..] |- S\'\'\' : {Gw} V\'\'[..] > V\'\'[..] *) (* G0, {G}GF[..], G |- s : G0, G, GF *) let G = listToCtx (ctxSub (ctxToList Gorig, w)) let g = ctxLength G let s = sc (w, k) let V\' = EClo (V, s) let (nw, S) = weaken2 (G, targetFam V, 1) let iw = invert nw let Gw = strengthen (iw, G) let V\'\' = normalize (V\', iw) let V\'\'\' = normalize (raiseType (Gw, V\'\'), id) let S\'\'\' = S Nil let sc\' = fun (w\', k\') -> (* G0, GA |- w\' : G0 *) (* G0, GA, G[..] |- s\' : G0, G, GF *) let s\' = sc (w\', k\') in Dot (Exp (Root (BVar (g + k\' - k), S\'\'\')), s\')(* G0, GA, G[..] |- (g+k\'-k). S\', s\' : G0, G, GF, V *)  let F\' = raiseFor (k + 1, Gorig, F, comp (w, shift), sc\') in All (Prim (Dec (name, V\'\'\')), F\') (* the other case of F.All (F.Block _, _) is not yet covered *) let rec extend (K, nil)  = K | extend (K, D :: L)  = extend (Decl (K, BV (D, None)), L) (* makeFor (G, w, AF) = F\'\n\n       Invariant :\n       If   |- G ctx\n       and  G |- w : G\'\n       and  G\' |- AF approx for\n       then G\'; . |- F\' = {EVARS} AF  for\n    *) let rec makeFor (K, w, Head (G, (F, s), d))  = (*        val _ = if !Global.doubleCheck then checkTags (GK, BK) else () *) let cf = collectGlobalSub (G, s, createEmptyB d, fun (_, K\') -> K\') let k = ctxLength K let K\' = cf (ctxLength G, K) let k\' = ctxLength K\' let (GK, BK) = abstractCtx K\' let _ = if ! doubleCheck then typeCheckCtx (GK) else () let w\' = comp (w, Shift (k\' - k)) let FK = abstractFor (K\', 0, (F, s)) let _ = if ! doubleCheck then isFor (GK, FK) else () let (GK1, GK2) = split (GK, k\' - k) in (GK1, allClo (GK2, FK)) | makeFor (K, w, Block ((G, t, d, G2), AF))  = (* BUG *) let k = ctxLength K let collect = collectGlobalSub (G, t, createEmptyB d, fun (_, K\') -> K\') let K\' = collect (ctxLength G, K) let k\' = ctxLength K\' let K\'\' = extend (K\', G2) let w\' = dot1n (listToCtx G2, comp (w, Shift (k\' - k))) let (GK, F\') = makeFor (K\'\', w\', AF) let _ = if ! doubleCheck then isFor (GK, F\') else () let (GK1, GK2) = split (GK, length G2) let F\'\' = raiseFor (0, GK2, F\', id, fun (w, _) -> dot1n (GK2, w)) let _ = if ! doubleCheck then isFor (GK1, F\'\') else () let (GK11, GK12) = split (GK1, k\' - k) let F\'\'\' = allClo (GK12, F\'\') let _ = if ! doubleCheck then isFor (GK11, F\'\'\') else () in (GK11, F\'\'\') let rec abstractApproxFor (AF as Head (G, _, _))  = let (_, F) = makeFor (convert G, id, AF) in F | abstractApproxFor (AF as Block ((G, _, _, _), _))  = let (_, F) = makeFor (convert G, id, AF) in F let weaken = weaken let raiseType = raiseType let abstractSub = abstractSubAll let abstractSub\' = abstractNew let abstractApproxFor = abstractApproxFor  end\n(* functor MTPAbstract *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Inference:  Version 1.3*) (* Author: Carsten Schuermann *) module Inference (module MTPGlobal : MTPGLOBAL(*! structure IntSyn : INTSYN !*) (*! structure FunSyn\' : FUNSYN !*) (*! sharing FunSyn\'.IntSyn = IntSyn !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.FunSyn = FunSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn !*) module FunTypeCheck : FUNTYPECHECK(*! sharing FunTypeCheck.FunSyn = FunSyn\' !*) FunTypeCheckStateSynStateSyn\'module UniqueSearch : UNIQUESEARCH(*! sharing UniqueSearch.IntSyn = IntSyn !*) (*! sharing UniqueSearch.FunSyn = FunSyn\' !*) UniqueSearchStateSynStateSyn\'module Print : PRINT(*! sharing Print.IntSyn = IntSyn !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) ) : INFERENCE = struct (*! structure FunSyn = FunSyn\' !*)  module StateSyn = StateSyn\' exception Error of string type operator = (unit -> State) module S = StateSynmodule F = FunSynmodule I = IntSynexception Success (* createEVars (G, (F, V, s)) = (Xs\', (F\', V\', s\'))\n\n       Invariant:\n       If   |- G ctx\n       and  G0 |- F = {{x1:A1}} .. {{xn::An}} F1 formula\n       and  G0 |- V = { x1:A1}  .. {xn:An} V1 : type\n       and  G |- s : G0\n       then Xs\' = (X1\', .., Xn\') a list of EVars\n       and  G |- Xi\' : A1 [X1\'/x1..X(i-1)\'/x(i-1)]          for all i <= n\n       and  G |- s: G\'\n       and  G0 |- F\' = F1 for\n       and  G0 |- V\' = V1 : type\n    *) let rec createEVars (G, (Pi ((Dec (_, V), Meta), V\'), s))  = let X = newEVar (G, EClo (V, s)) let X\' = lowerEVar X let (Xs, FVs\') = createEVars (G, (V\', Dot (Exp X, s))) in (X\' :: Xs, FVs\') | createEVars (G, FVs as (_, s))  = (nil, FVs) (* forward (G, B, (V, F)) = (V\', F\')  (or none)\n\n       Invariant:\n       If   |- G ctx\n       and  G |- B tags\n       and  G |- V type\n       and  G; . |- F : formula\n       then G |- V\' type\n       and  G; . |- F\' : formula\n\n    *) let rec forward (G, B, V as Pi ((_, Meta), _))  = let _ = if ! doubleCheck then typeCheck (G, (V, Uni Type)) else () let (Xs, (V\', s\')) = createEVars (G, (V, id)) in try  with | forward (G, B, V)  = NONE (* expand\' ((G, B), n) = ((Gnew, Bnew), sc)\n\n       Invariant:\n       If   |- G0 ctx    G0 |- B0 tags\n       and  |- G ctx     G |- B tags\n       and  G prefix of G0 , and B prefix of B0\n       and  n + |G| = |G0|\n       then sc is a continutation which maps\n            |- G\' ctx\n            and G\' |- B\' tags\n            and G\', B\' |- w\' : G0, B0\n            to  |- G\'\' ctx\n            and G\'\' |- B\'\' tags\n            and G\'\', B\'\' extends G, B\n       and |- Gnew = G ctx\n       and Gnew |- Bnew tags\n       where Bnew stems from B where all used lemmas (S.RL) are now tagged with (S.RLdone)\n    *) let rec expand\' ((G0, B0), (Null, Null), n)  = ((Null, Null), fun ((G\', B\'), w\') -> ((G\', B\'), w\')) | expand\' ((G0, B0), (Decl (G, D as Dec (_, V)), Decl (B, T as Lemma (RL))), n)  = let ((G0\', B0\'), sc\') = expand\' ((G0, B0), (G, B), n + 1) let s = Shift (n + 1) let Vs = normalize (V, s) in match (forward (G0, B0, (Vs))) with NONE -> ((Decl (G0\', D), Decl (B0\', T)), sc\') | SOME (V\') -> ((Decl (G0\', D), Decl (B0\', Lemma (RLdone))), fun ((G\', B\'), w\') -> (* G\' |- V\'\' : type *) let V\'\' = normalize (V\', w\') in sc\' ((Decl (G\', Dec (NONE, V\'\')), Decl (B\', Lemma (Splits (! maxSplit)))), comp (w\', shift))) | expand\' (GB0, (Decl (G, D), Decl (B, T)), n)  = let ((G0\', B0\'), sc\') = expand\' (GB0, (G, B), n + 1) in ((Decl (G0\', D), Decl (B0\', T)), sc\') (* expand\' S = op\'\n\n       Invariant:\n       If   |- S state\n       then op\' is an operator which performs the filling operation\n    *) let rec expand (S as State (n, (G, B), (IH, OH), d, O, H, F))  = let _ = if (! doubleCheck) then typeCheckCtx (G) else () let ((Gnew, Bnew), sc) = expand\' ((G, B), (G, B), 0) let _ = if (! doubleCheck) then typeCheckCtx (Gnew) else () let ((G\', B\'), w\') = sc ((Gnew, Bnew), id) let _ = typeCheckCtx G\' let S\' = State (n, (G\', B\'), (IH, OH), d, orderSub (O, w\'), map (fun (i, F\') -> (i, forSub (F\', w\'))) H, forSub (F, w\')) let _ = if ! doubleCheck then isState S\' else () in fun () -> S\' (* apply op = B\'\n\n       Invariant:\n       If op is a filling operator\n       then B\' holds iff the filling operation was successful\n    *) let rec apply f  = f () (* menu op = s\'\n\n       Invariant:\n       If op is a filling operator\n       then s\' is a string describing the operation in plain text\n    *) let rec menu _  = "Inference" let expand = expand let apply = apply let menu = menu  (* local *)  end\n(* functor Filling *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Weakening substitutions *) (* Author: Carsten Schuermann *) module type WEAKEN = sig (*! structure IntSyn : INTSYN !*) val strengthenExp : (Exp * Sub) -> Expval strengthenSpine : (Spine * Sub) -> Spineval strengthenCtx : (dctx * Sub) -> (dctx * Sub)val strengthenDec : (Dec * Sub) -> Decval strengthenSub : (Sub * Sub) -> Sub end(* signature PRUNE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Global parameters *) (* Author: Carsten Schuermann *) module MTPGlobal (module MetaGlobal : METAGLOBAL) : MTPGLOBAL = struct type ProverType = New | Old let prover = ref New let maxFill = maxFill let maxSplit = maxSplit let maxRecurse = maxRecurse end\n(* structure MTPGlobal *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Operational semantics *) (* Author: Carsten Schuermann *) module type Interpreter = sig (*! structure FunSyn : FUNSYN !*) val run : Pro -> Pro end(* Signature Interpreter *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Basic search engine: Version 1.3*) (* Author: Carsten Schuermann *) module type MTPSEARCH = sig module StateSyn : STATESYNexception Error of stringval searchEx : int * Exp list(*      * (IntSyn.Exp * IntSyn.Sub) *)  * (int -> unit) -> unit end\n(* signature SEARCH *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Printer Version 1.3 *) (* Author: Carsten Schuermann *) module MTPrint (module Global : GLOBAL(*! structure IntSyn : INTSYN !*) (*! structure FunSyn : FUNSYN !*) (*! sharing FunSyn.IntSyn = IntSyn !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.FunSyn = FunSyn !*) (*! sharing StateSyn\'.IntSyn = IntSyn !*) module Formatter\' : FORMATTERmodule Print : PRINTPrintFormatterFormatter\'(*! sharing Print.IntSyn = IntSyn !*) module FunPrint : FUNPRINT(*! sharing FunPrint.FunSyn = FunSyn !*) FunPrintFormatterFormatter\') : MTPRINT = struct module Formatter = Formatter\' module StateSyn = StateSyn\' exception Error of string module I = IntSynmodule N = Namesmodule S = StateSynmodule Fmt = Formatter(* nameState S = S\'\n\n       Invariant:\n       If   |- S state     and S unnamed\n       then |- S\' State    and S\' named\n       and  |- S = S\' state\n    *) let rec nameState (State (n, (G, B), (IH, OH), d, O, H, F))  = let _ = varReset Null let G\' = ctxName G in State (n, (G\', B), (IH, OH), d, O, H, F) let rec formatOrder (G, Arg (Us, Vs))  = [formatExp (G, EClo Us); String ":"; formatExp (G, EClo Vs)] | formatOrder (G, Lex Os)  = [String "{"; HVbox0 1 0 1 (formatOrders (G, Os)); String "}"] | formatOrder (G, Simul Os)  = [String "["; HVbox0 1 0 1 (formatOrders (G, Os)); String "]"]formatOrders (G, nil)  = nil | formatOrders (G, O :: nil)  = formatOrder (G, O) | formatOrders (G, O :: Os)  = formatOrder (G, O) @ [String ","; Break] @ formatOrders (G, Os) (* format T = fmt\'\n\n       Invariant:\n       If   T is a tag\n       then fmt\' is a a format descibing the tag T\n    *) let rec formatTag (G, Parameter l)  = [String "<p>"] | formatTag (G, Lemma (Splits k))  = [String "<i"; String (toString k); String ">"] | formatTag (G, Lemma (RL))  = [String "<i >"] | formatTag (G, Lemma (RLdone))  = [String "<i*>"] (*      | formatTag (G, S.Assumption k) = [Fmt.String "<a",\n                                         Fmt.String (Int.toString k),\n                                         Fmt.String ">"] *) (* formatCtx (G, B) = fmt\'\n\n       Invariant:\n       If   |- G ctx       and G is already named\n       and  |- B : G tags\n       then fmt\' is a format describing the context (G, B)\n    *) let rec formatCtx (Null, B)  = [] | formatCtx (Decl (Null, D), Decl (Null, T))  = if ! chatter >= 4 then [HVbox (formatTag (Null, T) @ [Break; formatDec (Null, D)])] else [formatDec (Null, D)] | formatCtx (Decl (G, D), Decl (B, T))  = if ! chatter >= 4 then formatCtx (G, B) @ [String ","; Break; Break] @ [HVbox (formatTag (G, T) @ [Break; formatDec (G, D)])] else formatCtx (G, B) @ [String ","; Break] @ [Break; formatDec (G, D)] (* formatState S = fmt\'\n\n       Invariant:\n       If   |- S state      and  S named\n       then fmt\' is a format describing the state S\n    *) let rec formatState (State (n, (G, B), (IH, OH), d, O, H, F))  = Vbox0 0 1 [HVbox0 1 0 1 (formatOrder (G, O)); Break; String "========================"; Break; HVbox0 1 0 1 (formatCtx (G, B)); Break; String "------------------------"; Break; formatForBare (G, F)] (* formatState S = S\'\n\n       Invariant:\n       If   |- S state      and  S named\n       then S\' is a string descring state S in plain text\n    *) let rec stateToString S  = (makestring_fmt (formatState S)) let nameState = nameState let formatState = formatState let stateToString = stateToString  (* local *)  end(* functor MTPrint *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* MTPStrategy : Version 1.3 *) (* Author: Carsten Schuermann *) module type MTPSTRATEGY = sig module StateSyn : STATESYNval run : State list -> State list * State list(* open cases -> remaining cases * solved cases *)  end\n(* signature MTPSTRATEGY *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Prover Version 1.3 *) (* Author: Carsten Schuermann *) module type MTPROVER = sig (*! structure FunSyn : FUNSYN !*) module StateSyn : STATESYNexception Error of stringval init : For * Order -> unit end\n(* signature MTPROVER *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* State definition for Proof Search *) (* Author: Carsten Schuermann *) module type STATESYN = sig (*! structure IntSyn : INTSYN !*) (*! structure FunSyn : FUNSYN !*) type OrderArg(Exp * Sub) * (Exp * Sub)LexOrder listSimulOrder listAllDec * OrderAndOrder * Order(*     | O1 ^ O2              *) type InfoSplitsintRLRLdonetype TagParameterlabel optionLemmaInfoNonetype StateStateint(* Part of theorem                   *)  * (dctx(* Context of Hypothesis, in general not named *)  * Tag Ctx)(* Status information *)  * (For * Order)(* Induction hypothesis, order       *)  * int(* length of meta context            *)  * Order(* Current order *)  * int * For list(* History of residual lemmas *)  * For(* Formula *) val orderSub : Order * Sub -> Orderval decrease : Tag -> Tagval splitDepth : Info -> intval normalizeOrder : Order -> Orderval convOrder : Order * Order -> boolval normalizeTag : Tag * Sub -> Tag end\n(* signature STATESYN *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Meta Theorem Prover abstraction : Version 1.3 *) (* Author: Frank Pfenning, Carsten Schuermann *) module type MTPABSTRACT = sig (*! structure IntSyn : INTSYN !*) (*! structure FunSyn : FUNSYN !*) module StateSyn : STATESYNexception Error of stringtype ApproxForHeaddctx * (For * Sub) * intBlock(dctx * Sub * int * Dec list) * ApproxFor(*  | (t, G2), AF *) val weaken : dctx * cid -> Subval raiseType : dctx * Exp -> Expval abstractSub : Sub * Tag Ctx * (dctx * Tag Ctx) * Sub * Tag Ctx -> ((dctx * Tag Ctx) * Sub)val abstractSub' : (dctx * Tag Ctx) * Sub * Tag Ctx -> ((dctx * Tag Ctx) * Sub)val abstractApproxFor : ApproxFor -> For end\n(* signature MTPABSTRACT *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Converter from relational representation to a functional\n   representation of proof terms *) (* Author: Carsten Schuermann *) module type RELFUN = sig (*! structure FunSyn : FUNSYN !*) exception Error of stringval convertFor : cid list -> Forval convertPro : cid list -> Pro end(* Signature RELFUN *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Printing of functional proof terms *) (* Author: Carsten Schuermann *) module type FUNPRINT = sig (*! structure FunSyn : FUNSYN !*) module Formatter : FORMATTERval formatForBare : dctx * For -> formatval formatFor : lfctx * For -> string list -> formatval formatPro : lfctx * Pro -> string list -> formatval formatLemmaDec : LemmaDec -> formatval forToString : lfctx * For -> string list -> stringval proToString : lfctx * Pro -> string list -> stringval lemmaDecToString : LemmaDec -> string end\n(* signature PRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Basic search engine: Version 1.3*) (* Author: Carsten Schuermann *) module type UNIQUESEARCH = sig (*! structure IntSyn : INTSYN !*) (*! structure FunSyn : FUNSYN !*) module StateSyn : STATESYNexception Error of stringtype acctype = Expval searchEx : int * Exp list * (acctype list -> acctype list) -> acctype list end\n(* signature SEARCH *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Initialization *) (* Author: Carsten Schuermann *) module MTPInit (module MTPGlobal : MTPGLOBALmodule MTPData : MTPDATA(*! structure IntSyn : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn !*) (*! structure FunSyn' : FUNSYN !*) (*! sharing FunSyn'.IntSyn = IntSyn !*) module StateSyn' : STATESYN(*! sharing StateSyn'.FunSyn = FunSyn' !*) module Formatter : FORMATTERmodule Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Print : PRINTPrintFormatterFormatter(*! sharing Print.IntSyn = IntSyn !*) module FunPrint : FUNPRINT(*! sharing FunPrint.FunSyn = FunSyn' !*) FunPrintFormatterFormatter) : MTPINIT = struct (*! structure FunSyn = FunSyn' !*)  module StateSyn = StateSyn' exception Error of string module I = IntSynmodule F = FunSynmodule S = StateSynmodule Fmt = Formatter(* init (F, OF) = Ss'\n\n       Invariant:\n       If   . |- F formula    and   F in nf\n       and  . |- OF order\n       then Ss' is a list of initial states for the theorem prover\n    *) let rec init (F, OF)  = (* added in case there are no existentials -fp *) let rec init' ((G, B), All (_, O), All (Prim D, F'), Ss)  = let D' = decName (G, D) in init' ((Decl (G, D'), Decl (B, Lemma (Splits (! maxSplit)))), O, F', Ss) | init' (GB, And (O1, O2), And (F1, F2), Ss)  = init' (GB, O1, F1, init' (GB, O2, F2, Ss)) | init' (GB, O, F' as Ex _, Ss)  = State (length Ss + 1, GB, (F, OF), 1, O, nil, F') :: Ss | init' (GB, O, F' as True, Ss)  = State (length Ss + 1, GB, (F, OF), 1, O, nil, F') :: Ss in (varReset Null; maxFill := 0; init' ((Null, Null), OF, F, nil)) let init = init  (* local *)  end\n(* functor Init *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Meta Recursion Version 1.3 *) (* Author: Carsten Schuermann *) (* See [Rohwedder,Pfenning ESOP\'96] *) module MTPRecursion (module MTPGlobal : MTPGLOBALmodule Global : GLOBAL(*! structure IntSyn : INTSYN !*) (*! structure FunSyn : FUNSYN !*) (*! sharing FunSyn.IntSyn = IntSyn !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.IntSyn = IntSyn !*) (*! sharing StateSyn\'.FunSyn = FunSyn !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn !*) module MTPAbstract : MTPABSTRACT(*! sharing MTPAbstract.IntSyn = IntSyn !*) (*! sharing MTPAbstract.FunSyn = FunSyn !*) MTPAbstractStateSynStateSyn\'module FunTypeCheck : FUNTYPECHECK(*! sharing FunTypeCheck.FunSyn = FunSyn !*) FunTypeCheckStateSynStateSyn\'module MTPrint : MTPRINTMTPrintStateSynStateSyn\'module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn !*) module Formatter : FORMATTERmodule FunPrint : FUNPRINT(*! sharing FunPrint.FunSyn = FunSyn !*) FunPrintFormatterFormatter(*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) ) : MTPRECURSION = struct module StateSyn = StateSyn\' exception Error of string type operator = State module I = IntSynmodule F = FunSynmodule S = StateSynmodule N = Namesmodule Fmt = Formattermodule A = MTPAbstracttype Dec = Lemma of int * For (* Residual Lemma *) let rec closedCtx (Null)  = () | closedCtx (Decl (G, D))  = if closedDec (G, (D, id)) then raise (Domain) else closedCtx G (*  spine n = S\'\n\n        Invariant:\n        S\' = n;..;1;Nil\n     *) let rec spine 0  = Nil | spine n  = App (Root (BVar n, Nil), spine (n - 1)) (* someEVars (G, G1, s) = s\'\n\n       Invariant:\n       If  |- G ctx\n       and  G |- s : G\n       then G |- s\' : G, G1\n    *) let rec someEVars (G, nil, s)  = s | someEVars (G, Dec (_, V) :: L, s)  = someEVars (G, L, Dot (Exp (newEVar (G, EClo (V, s))), s)) (* ctxSub (G, s) = G\'\n\n       Invariant:\n       If   G2 |- s : G1\n       and  G1 |- G ctx\n       then G2 |- G\' = G[s] ctx\n\n       NOTE, should go into a different module. Code duplication!\n    *) let rec ctxSub (nil, s)  = nil | ctxSub (D :: G, s)  = decSub (D, s) :: ctxSub (G, dot1 s) (* appendCtx ((G1, B1), T, G2) = (G\', B\')\n\n       Invariant:\n       If   |- G1 ctx\n       and  G1 |- B1 tags\n       and  T tag\n       and  G1 |- G2 ctx\n       then |- G\' = G1, G2 ctx\n       and  G\' |- B\' tags\n    *) let rec appendCtx (GB1, T, nil)  = GB1 | appendCtx ((G1, B1), T, D :: G2)  = appendCtx ((Decl (G1, D), Decl (B1, T)), T, G2) (* createCtx ((G, B), ll, s) = ((G\', B\'), s\', af\')\n\n     Invariant:\n     If   |- G ctx\n     and  G |- B tags\n     and  . |- label list\n     and  |- G1 ctx\n     and  G |- s : G1\n\n     then |- G\' : ctx\n     and  G\' |- B\' tags\n     and  G\' = G, G\'\'\n     and  G\' |- s\' : G1\n     and  af : forall . |- AF aux formulas. Ex . |- AF\' = {{G\'\'}} AF  auxFor\n     *) let rec createCtx ((G, B), nil, s)  = ((G, B), s, fun AF -> AF) | createCtx ((G, B), n :: ll, s)  = (* G |- s\' : G1 *) (* G |- G2\' ctx *) (* . |- G\' = G, G2\' ctx *) (* G\' |- s\'\' : G0 *) let LabelDec (l, G1, G2) = labelLookup n let t = someEVars (G, G1, id) let G2\' = ctxSub (G2, t) let (G\', B\') = appendCtx ((G, B), Parameter (SOME n), G2\') let s\' = comp (s, Shift (length G2\')) let (GB\'\', s\'\', af\'\') = createCtx ((G\', B\'), ll, s\') in (GB\'\', s\'\', fun AF -> Block ((G, t, length G1, G2\'), af\'\' AF)) (* createEVars\' (G, G0) = s\'\n\n       Invariant :\n       If   |- G ctx\n       and  |- G0 ctx\n       then G |- s\' : G0\n       and  s\' = X1 .. Xn where n = |G0|\n    *) let rec createEVars (G, Null)  = Shift (ctxLength G) | createEVars (G, Decl (G0, Dec (_, V)))  = let s = createEVars (G, G0) in Dot (Exp (newEVar (G, EClo (V, s))), s) (* checkCtx (G, G2, (V, s)) = B\'\n\n       Invariant:\n       If   |- G = G0, G1 ctx\n       and  G |- G2 ctx\n       and  G |- s : G0\n       and  G0 |- V : L\n       then B\' holds iff\n            G1 = V1 .. Vn and G, G1, V1 .. Vi-1 |- Vi unifies with V [s o ^i] : L\n    *) let rec checkCtx (G, nil, (V2, s))  = false | checkCtx (G, (D as Dec (_, V1)) :: G2, (V2, s))  = (trail (fun () -> unifiable (G, (V1, id), (V2, s))) || checkCtx (Decl (G, D), G2, (V2, comp (s, shift)))) (* checkLabels ((G\', B\'), V, ll, l) = lopt\'\n\n       Invariant:\n       If   |- G\' ctx\n       and  G\' |- B\' ctx\n       and  G\' |- s : G0\n       and  G0 |- V : type\n       and  . |- ll label list\n       and  . |- l label number\n       then lopt\' = NONE if no context block is applicable\n       or   lopt\' = SOME l\' if context block l\' is applicable\n\n       NOTE: For this implementation we only pick the first applicable contextblock.\n       It is not yet clear what should happen if there are inductive calls where more\n       then one contextblocks are introduced --cs\n    *) let rec checkLabels ((G\', B\'), (V, s), ll, (* as nil *) , l)  = if l < 0 then NONE else (* G\' |- t : G1 *) (* G |- G2\' ctx *) let LabelDec (name, G1, G2) = labelLookup l let s = someEVars (G\', G1, id) let G2\' = ctxSub (G2, s) let t = someEVars (G\', G1, id) let G2\' = ctxSub (G2, t) in if not (exists (fun l\' -> l = l\') ll) && checkCtx (G\', G2\', (V, s)) then SOME l else checkLabels ((G\', B\'), (V, s), ll, l - 1) (*      | checkLabels _ = NONE  (* more than one context block is introduced *) *) (* appendRL (Ds1, Ds2) = Ds\'\n\n       Invariant:\n       Ds1, Ds2 are a list of residual lemmas\n       Ds\' = Ds1 @ Ds2, where all duplicates are removed\n    *) let rec appendRL (nil, Ds)  = Ds | appendRL ((L as Lemma (n, F)) :: Ds1, Ds2)  = let Ds\' = appendRL (Ds1, Ds2) in if exists (fun (Lemma (n\', F\')) -> (n = n\') && convFor ((F, id), (F\', id))) Ds\' then Ds\' else L :: Ds\' (* recursion ((nih, Gall, Fex, Oex), (ncurrent, (G0, B0), ll, Ocurrent, H, F)) = Ds\n\n       Invariant:\n\n       If\n\n       nih  is the id or the induction hypothesis\n       |- Gall ctx\n       Gall |- Fex : for        (Fex doesn\'t contain any universal quantifiers)\n       Gall |- Oex : order\n\n       and\n       ncurrent is the id of the current proof goal\n       |- G0 ctx\n       G0 |- B0 tags\n       . |- ll label list\n       G0 |- Ocurrent order\n       G0 |- H history\n       G0 |- F formula\n\n       then\n       G0 |- Ds decs\n    *) let rec recursion ((nih, Gall, Fex, Oex), (ncurrent, (G0, B0), ll, Ocurrent, H, F))  = (* G\' |- s\' : G0 *) (* G\' |- t\' : Gall *) let ((G\', B\'), s\', af) = createCtx ((G0, B0), ll, id) let t\' = createEVars (G\', Gall) let AF = af (Head (G\', (Fex, t\'), ctxLength Gall)) let Oex\' = orderSub (Oex, t\') let Ocurrent\' = orderSub (Ocurrent, s\') let rec sc Ds  = let Fnew = abstractApproxFor AF in if exists (fun (nhist, Fhist) -> nih = nhist && convFor ((Fnew, id), (Fhist, id))) H then Ds else Lemma (nih, Fnew) :: Ds let rec ac ((G\', B\'), Vs, Ds)  = (match checkLabels ((G\', B\'), Vs, ll, labelSize () - 1) with NONE -> Ds | SOME l\' -> let Ds\' = recursion ((nih, Gall, Fex, Oex), (ncurrent, (G0, B0), l\' :: ll, Ocurrent, H, F)) in appendRL (Ds\', Ds)) in if ncurrent < nih then ordle ((G\', B\'), Oex\', Ocurrent\', sc, ac, nil) else ordlt ((G\', B\'), Oex\', Ocurrent\', sc, ac, nil)(* set_parameter (GB, X, k, sc, ac, S) = S\'\n\n       Invariant:\n       appends a list of recursion operators to S after\n       instantiating X with all possible local parameters (between 1 and k)\n    *) set_parameter (GB as (G1, B1), X as EVar (r, _, V, _), k, sc, ac, Ds)  = (* set_parameter\' ((G, B), k, Ds) = Ds\'\n\n           Invariant:\n           If    G1, D < G\n        *) let rec set_parameter\' ((Null, Null), _, Ds)  = Ds | set_parameter\' ((Decl (G, D), Decl (B, Parameter _)), k, Ds)  = let D\' as Dec (_, V\') = decSub (D, Shift (k)) let Ds\' = trail (fun () -> if unifiable (G1, (V, id), (V\', id)) && unifiable (G1, (X, id), (Root (BVar k, Nil), id)) then sc Ds else Ds) in set_parameter\' ((G, B), k + 1, Ds\') | set_parameter\' ((Decl (G, D), Decl (B, _)), k, Ds)  = set_parameter\' ((G, B), k + 1, Ds) in set_parameter\' (GB, 1, Ds)(* ltinit (GB, k, ((U1, s1), (V2, s2)), ((U3, s3), (V4, s4)), sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G = G0, Gp    (G0, global context, Gp, parameter context)\n       and  |Gp| = k\n       and  G |- s1 : G1   G1 |- U1 : V1\n       and  G |- s2 : G2   G2 |- V2 : L\n                G |- s3 : G1   G1 |- U3 : V3\n       and  G |- s4 : G2   G2 |- V4 : L\n       and  G |- V1[s1] == V2 [s2]\n       and  G |- V3[s3] == V4 [s5]\n       and  Ds is a set of all all possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators\n    *) ltinit (GB, k, (Us, Vs), UsVs\', sc, ac, Ds)  = ltinitW (GB, k, whnfEta (Us, Vs), UsVs\', sc, ac, Ds)ltinitW (GB, k, (Us, Vs as (Root _, _)), UsVs\', sc, ac, Ds)  = lt (GB, k, (Us, Vs), UsVs\', sc, ac, Ds) | ltinitW ((G, B), k, ((Lam (D1, U), s1), (Pi (D2, V), s2)), ((U\', s1\'), (V\', s2\')), sc, ac, Ds)  = ltinit ((Decl (G, decSub (D1, s1), (* = I.decSub (D2, s2) *) ), Decl (B, Parameter NONE)), k + 1, ((U, dot1 s1), (V, dot1 s2)), ((U\', comp (s1\', shift)), (V\', comp (s2\', shift))), sc, ac, Ds)(* lt (GB, k, ((U, s1), (V, s2)), (U\', s\'), sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G = G0, Gp    (G0, global context, Gp, parameter context)\n       and  |Gp| = k\n       and  G |- s1 : G1   G1 |- U1 : V1   (U1 [s1] in  whnf)\n       and  G |- s2 : G2   G2 |- V2 : L    (V2 [s2] in  whnf)\n            G |- s3 : G1   G1 |- U3 : V3\n       and  G |- s4 : G2   G2 |- V4 : L\n       and  k is the length of the local context\n       and  G |- V1[s1] == V2 [s2]\n       and  G |- V3[s3] == V4 [s5]\n       and  Ds is a set of already calculuate possible states\n       and  sc is success continuation\n           then Ds\' is an extension of Ds, containing all\n                recursion operators\n    *) (* Vs is Root!!! *) (* (Us\',Vs\') may not be eta-expanded!!! *) lt (GB, k, (Us, Vs), (Us\', Vs\'), sc, ac, Ds)  = ltW (GB, k, (Us, Vs), whnfEta (Us\', Vs\'), sc, ac, Ds)ltW (GB, k, (Us, Vs), ((Root (Const c, S\'), s\'), Vs\'), sc, ac, Ds)  = ltSpine (GB, k, (Us, Vs), ((S\', s\'), (constType c, id)), sc, ac, Ds) | ltW (GB as (G, B), k, (Us, Vs), ((Root (BVar n, S\'), s\'), Vs\'), sc, ac, Ds)  = (*          if n <= k then  (* n must be a local variable *) *)  (* k might not be needed any more: Check --cs *)  (match ctxLookup (B, n) with Parameter _ -> let Dec (_, V\') = ctxDec (G, n) in ltSpine (GB, k, (Us, Vs), ((S\', s\'), (V\', id)), sc, ac, Ds) | Lemma _ -> Ds) | ltW (GB, _, _, ((EVar _, _), _), _, _, Ds)  = Ds | ltW (GB as (G, B), k, ((U, s1), (V, s2)), ((Lam (D as Dec (_, V1\'), U\'), s1\'), (Pi ((Dec (_, V2\'), _), V\'), s2\')), sc, ac, Ds)  = (* ctxBlock (GB, I.EClo (V1\', s1\'), k, sc, ac, Ds) *) let Ds\' = Ds in if equiv (targetFam V, targetFam V1\')(* == I.targetFam V2\' *)  then (* enforce that X gets only bound to parameters *) (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\', s1\')) let sc\' = fun Ds\'\' -> set_parameter (GB, X, k, sc, ac, Ds\'\') in lt (GB, k, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc\', ac, Ds\') else if below (targetFam V1\', targetFam V) then (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\', s1\')) in lt (GB, k, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc, ac, Ds\') else Ds\'ltSpine (GB, k, (Us, Vs), (Ss\', Vs\'), sc, ac, Ds)  = ltSpineW (GB, k, (Us, Vs), (Ss\', whnf Vs\'), sc, ac, Ds)ltSpineW (GB, k, (Us, Vs), ((Nil, _), _), _, _, Ds)  = Ds | ltSpineW (GB, k, (Us, Vs), ((SClo (S, s\'), s\'\'), Vs\'), sc, ac, Ds)  = ltSpineW (GB, k, (Us, Vs), ((S, comp (s\', s\'\')), Vs\'), sc, ac, Ds) | ltSpineW (GB, k, (Us, Vs), ((App (U\', S\'), s1\'), (Pi ((Dec (_, V1\'), _), V2\'), s2\')), sc, ac, Ds)  = let Ds\' = le (GB, k, (Us, Vs), ((U\', s1\'), (V1\', s2\')), sc, ac, Ds) in ltSpine (GB, k, (Us, Vs), ((S\', s1\'), (V2\', Dot (Exp (EClo (U\', s1\')), s2\'))), sc, ac, Ds\')(* eq (GB, ((U, s1), (V, s2)), (U\', s\'), sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G |- s1 : G1   G1 |- U1 : V1   (U1 [s1] in  whnf)\n       and  G |- s2 : G2   G2 |- V2 : L    (V2 [s2] in  whnf)\n            G |- s3 : G1   G1 |- U3 : V3\n       and  G |- s4 : G2   G2 |- V4 : L\n       and  G |- V1[s1] == V2 [s2]\n       and  G |- V3[s3] == V4 [s5]\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators resulting from U[s1] = U\'[s\']\n    *) eq ((G, B), (Us, Vs), (Us\', Vs\'), sc, ac, Ds)  = (trail (fun () -> if unifiable (G, Vs, Vs\') && unifiable (G, Us, Us\') then sc Ds else Ds))(* le (G, k, ((U, s1), (V, s2)), (U\', s\'), sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G = G0, Gp    (G0, global context, Gp, parameter context)\n       and  |Gp| = k\n       and  G |- s1 : G1   G1 |- U1 : V1   (U1 [s1] in  whnf)\n       and  G |- s2 : G2   G2 |- V2 : L    (V2 [s2] in  whnf)\n                G |- s3 : G1   G1 |- U3 : V3\n       and  G |- s4 : G2   G2 |- V4 : L\n       and  k is the length of the local context\n       and  G |- V1[s1] == V2 [s2]\n       and  G |- V3[s3] == V4 [s5]\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators resulting from U[s1] <= U\'[s\']\n    *) le (GB, k, (Us, Vs), (Us\', Vs\'), sc, ac, Ds)  = let Ds\' = eq (GB, (Us, Vs), (Us\', Vs\'), sc, ac, Ds) in leW (GB, k, (Us, Vs), whnfEta (Us\', Vs\'), sc, ac, Ds\')leW (GB as (G, B), k, ((U, s1), (V, s2)), ((Lam (D as Dec (_, V1\'), U\'), s1\'), (Pi ((Dec (_, V2\'), _), V\'), s2\')), sc, ac, Ds)  = let Ds\' = ac (GB, (V1\', s1\'), Ds) in if equiv (targetFam V, targetFam V1\')(* == I.targetFam V2\' *)  then (* = I.newEVar (I.EClo (V2\', s2\')) *) (* enforces that X can only bound to parameter *) let X = newEVar (G, EClo (V1\', s1\')) let sc\' = fun Ds\'\' -> set_parameter (GB, X, k, sc, ac, Ds\'\') in le (GB, k, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc\', ac, Ds\') else if below (targetFam V1\', targetFam V) then (* = I.newEVar (I.EClo (V2\', s2\')) *) (*              val sc\'\' = fn Ds\'\' => set_parameter (GB, X, k, sc, ac, Ds\'\')   (* BUG -cs *)\n                val Ds\'\'\' =  le (GB, k, ((U, s1), (V, s2)),\n                                 ((U\', I.Dot (I.Exp (X), s1\')),\n                                  (V\', I.Dot (I.Exp (X), s2\'))), sc\'\', ac, Ds\'\') *) let X = newEVar (G, EClo (V1\', s1\')) let sc\' = sc let Ds\'\' = le (GB, k, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc\', ac, Ds\') in Ds\'\' else Ds\' | leW (GB, k, (Us, Vs), (Us\', Vs\'), sc, ac, Ds)  = lt (GB, k, (Us, Vs), (Us\', Vs\'), sc, ac, Ds)(* ordlt (GB, O1, O2, sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G |- O1 augmented subterms\n       and  G |- O2 augmented subterms\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators of all instantiations of EVars s.t. O1 is\n            lexicographically smaller than O2\n    *) ordlt (GB, Arg UsVs, Arg UsVs\', sc, ac, Ds)  = ltinit (GB, 0, UsVs, UsVs\', sc, ac, Ds) | ordlt (GB, Lex L, Lex L\', sc, ac, Ds)  = ordltLex (GB, L, L\', sc, ac, Ds) | ordlt (GB, Simul L, Simul L\', sc, ac, Ds)  = ordltSimul (GB, L, L\', sc, ac, Ds)(* ordltLex (GB, L1, L2, sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators of all instantiations of EVars s.t. L1 is\n            lexicographically less then L2\n    *) ordltLex (GB, nil, nil, sc, ac, Ds)  = Ds | ordltLex (GB, O :: L, O\' :: L\', sc, ac, Ds)  = let Ds\' = trail (fun () -> ordlt (GB, O, O\', sc, ac, Ds)) in ordeq (GB, O, O\', fun Ds\'\' -> ordltLex (GB, L, L\', sc, ac, Ds\'\'), ac, Ds\')(* ordltSimul (GB, L1, L2, sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators of all instantiations of EVars s.t. L1 is\n            simultaneously smaller than L2\n    *) ordltSimul (GB, nil, nil, sc, ac, Ds)  = Ds | ordltSimul (GB, O :: L, O\' :: L\', sc, ac, Ds)  = let Ds\'\' = trail (fun () -> ordlt (GB, O, O\', fun Ds\' -> ordleSimul (GB, L, L\', sc, ac, Ds\'), ac, Ds)) in ordeq (GB, O, O\', fun Ds\' -> ordltSimul (GB, L, L\', sc, ac, Ds\'), ac, Ds\'\')(* ordleSimul (GB, L1, L2, sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators of all instantiations of EVars s.t. L1 is\n            simultaneously smaller than or equal to L2\n    *) ordleSimul (GB, nil, nil, sc, ac, Ds)  = sc Ds | ordleSimul (GB, O :: L, O\' :: L\', sc, ac, Ds)  = ordle (GB, O, O\', fun Ds\' -> ordleSimul (GB, L, L\', sc, ac, Ds\'), ac, Ds)(* ordeq (GB, O1, O2, sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G |- O1 augmented subterms\n       and  G |- O2 augmented subterms\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators of all instantiations of EVars s.t. O1 is\n            convertible to O2\n    *) ordeq ((G, B), Arg (Us, Vs), Arg (Us\', Vs\'), sc, ac, Ds)  = if unifiable (G, Vs, Vs\') && unifiable (G, Us, Us\') then sc Ds else Ds | ordeq (GB, Lex L, Lex L\', sc, ac, Ds)  = ordeqs (GB, L, L\', sc, ac, Ds) | ordeq (GB, Simul L, Simul L\', sc, ac, Ds)  = ordeqs (GB, L, L\', sc, ac, Ds)(* ordlteqs (GB, L1, L2, sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators of all instantiations of EVars s.t. L1 is\n            convertible to L2\n    *) ordeqs (GB, nil, nil, sc, ac, Ds)  = sc Ds | ordeqs (GB, O :: L, O\' :: L\', sc, ac, Ds)  = ordeq (GB, O, O\', fun Ds\' -> ordeqs (GB, L, L\', sc, ac, Ds\'), ac, Ds)(* ordeq (GB, O1, O2, sc, ac, Ds) = Ds\'\n\n       Invariant:\n       If   G |- O1 augmented subterms\n       and  G |- O2 augmented subterms\n       and  Ds is a set of already calculuated possible states\n       and  sc is success continuation\n       then Ds\' is an extension of Ds, containing all\n            recursion operators of all instantiations of EVars s.t. O1 is\n            convertible to O2 or smaller than O2\n    *) ordle (GB, O, O\', sc, ac, Ds)  = let Ds\' = trail (fun () -> ordeq (GB, O, O\', sc, ac, Ds)) in ordlt (GB, O, O\', sc, ac, Ds\') (* skolem (n, (du, de), GB, w, F, sc) = (GB\', s\')\n\n       Invariant:\n       If   GB, Ds |- w : GB\n       and  GB, G |- F formula\n       and  du = #universal quantifiers in F\n       and  de = #existential quantifiers in F\n       and  sc is a continuation which\n            for all GB, Ds |- s\' : GB\n            returns s\'\'  of type  GB, Ds, G\'[...] |- w\'\' : GB, G\n            and     V\'\'  mapping (GB, Ds, G\'[...] |- V  type)  to (GB, Ds |- {G\'[...]} V type)\n            and     F\'\'  mapping (GB, Ds, G\'[...] |- F) to (GB, Ds |- {{G\'[...]}} F formula)\n       then GB\' = GB, Ds\'\n       and  |Ds\'| = de\n       and  each declaration in Ds\' corresponds to one existential quantifier in F\n       and  GB\' |- s\' : GB\n    *) let rec skolem ((du, de), GB, w, True, sc)  = (GB, w) | skolem ((du, de), GB, w, All (Prim D, F), sc)  = skolem ((du + 1, de), GB, w, F, fun (s, de\') -> (* s\'  :  GB, Ds |- s : GB   *) (* s\'  : GB, Ds, G\'[...] |- s\' : GB, G *) (* V\'  : maps (GB, Ds, G\'[...] |- V type) to (GB, Ds |- {G\'[...]} V type) *) (* F\'  : maps (GB, Ds, G\'[...] |- F for) to (GB, Ds |- {{G\'[...]}} F for) *) let (s\', V\', F\') = sc (s, de\') in (dot1 s\', (* _   : GB, Ds, G\'[...], D[?] |- _ : GB, G, D *) , fun V -> V\' (piDepend ((normalizeDec (D, s\'), Meta), normalize (V, id))), (* _   : maps (GB, Ds, G\'[....], D[?] |- V : type) to  (GB, Ds, |- {G[....], D[?]} V : type) *) , fun F -> F\' (All (Prim (decSub (D, s\')), F)), (* _   : maps (GB, Ds, G\'[....], D[?] |- F : for) to  (GB, Ds, |- {{G[....], D[?]}} F : for) *) )) | skolem ((du, de), (G, B), w, Ex (Dec (name, V), F), sc)  = (* V   : GB, G |- V type *)  (* s\'  : GB, Ds, G\'[...] |- s\' : GB, G *) (* V\'  : maps  (GB, Ds, G\'[...] |- V : type)   to   (GB, Ds |- {G\'[...]} V : type) *) (* F\'  : maps  (GB, Ds, G\'[...] |- F : for)    to   (GB, Ds |- {{G\'[...]}} F : for) *) (* V1  : GB, Ds, G\'[...] |- V1 = V [s\'] : type *) (* V2  : GB, Ds |- {G\'[...]} V2 : type *) (* F1  : GB, Ds, G\'[...] |- F1 : for *) (* F2  : GB, Ds |- {{G\'[...]}} F2 : for *) (* D2  : GB, Ds |- D2 : type *) (* T2  : GB, Ds |- T2 : tag *) let (s\', V\', F\') = sc (w, de) let V1 = EClo (V, s\') let V2 = normalize (V\' V1, id) let F1 = Ex (Dec (name, V1), True) let F2 = F\' F1 let _ = if ! doubleCheck then isFor (G, F2) else () let D2 = Dec (NONE, V2) let T2 = (match F2 with All _ -> Lemma (RL) | _ -> Lemma (Splits (! maxSplit))) in skolem ((du, de + 1), (Decl (G, D2), Decl (B, T2)), comp (w, shift), F, fun (s, de\') -> (* s   : GB, Ds, D2 |- s : GB *) (* s\'  : GB, Ds, D2, G\'[...] |- s\' : GB, G *) (* V\'  : maps (GB, Ds, D2, G\'[...] |- V type) to (GB, Ds, D2 |- {G\'[...]} V type) *) (* F\'  : maps (GB, Ds, D2, G\'[...] |- F for) to (GB, Ds, D2 |- {{G\'[...]}} F for) *) let (s\', V\', F\') = sc (s, de\') in (Dot (Exp (Root (BVar (du + (de\' - de)), spine du)), s\'), (* _ : GB, Ds, D2, G\'[...] |- s\'\' : GB, G, D *) , V\', F\')) (* updateState (S, (Ds, s))\n\n       Invariant:\n       G context\n       G\' |- S state\n       G |- Ds new decs\n       G\' |- s : G\n    *) let rec updateState (S, (nil, s))  = S | updateState (S as State (n, (G, B), (IH, OH), d, O, H, F), (Lemma (n\', Frl\') :: L, s))  = let ((G\'\', B\'\'), s\') = skolem ((0, 0), (G, B), id, forSub (Frl\', s), fun (s\', _) -> (s\', fun V\' -> V\', fun F\' -> F\')) let s\'\' = comp (s, s\') in updateState (State (n, (G\'\', B\'\'), (IH, OH), d, orderSub (O, s\'), (n\', forSub (Frl\', s\'\')) :: map (fun (n\', F\') -> (n\', forSub (F\', s\'))) H, forSub (F, s\')), (L, s\'\')) (* selectFormula (n, G, (G0, F, O), S) = S\'\n\n       Invariant:\n       If   G |- s : G0  and  G0 |- F formula and  G0 |- O order\n       and  S is a state\n       then S\' is the state with\n       sc returns with all addition assumptions/residual lemmas for a certain\n       branch of the theorem.\n    *) let rec selectFormula (n, (G0, All (Prim (D as Dec (_, V)), F), All (_, O)), S)  = selectFormula (n, (Decl (G0, D), F, O), S) | selectFormula (n, (G0, And (F1, F2), And (O1, O2)), S)  = let (n\', S\') = selectFormula (n, (G0, F1, O1), S) in selectFormula (n, (G0, F2, O2), S\') | selectFormula (nih, (Gall, Fex, Oex), S as State (ncurrent, (G0, B0), (_, _), _, Ocurrent, H, F))  = let Ds = recursion ((nih, Gall, Fex, Oex), (ncurrent, (G0, B0), nil, Ocurrent, H, F)) in (nih + 1, updateState (S, (Ds, id))) let rec expand (S as State (n, (G, B), (IH, OH), d, O, H, F))  = let _ = if (! doubleCheck) then isState S else () let (_, S\') = selectFormula (1, (Null, IH, OH), S) in S\' let rec apply S  = (if (! doubleCheck) then isState S else (); S) let rec menu _  = "Recursion (calculates ALL new assumptions & residual lemmas)" let rec handleExceptions f P  = try  with let expand = handleExceptions expand let apply = apply let menu = menu  (* local *)  end\n(* functor MTPRecursion *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {})])
('Error parsing code:', '(* MTP Strategy: Version 1.3 *) (* Author: Carsten Schuermann *) module MTPStrategy (module MTPGlobal : MTPGLOBALmodule StateSyn\' : STATESYNmodule MTPFilling : MTPFILLINGMTPFillingStateSynStateSyn\'module MTPData : MTPDATAmodule MTPSplitting : MTPSPLITTINGMTPSplittingStateSynStateSyn\'module MTPRecursion : MTPRECURSIONMTPRecursionStateSynStateSyn\'module Inference : INFERENCEInferenceStateSynStateSyn\'module MTPrint : MTPRINTMTPrintStateSynStateSyn\'module Timers : TIMERS) : MTPSTRATEGY = struct module StateSyn = StateSyn\' module S = StateSynlet rec printInit ()  = if ! chatter > 3 then print "Strategy\\n" else () let rec printFilling ()  = if ! chatter > 5 then print ("[Filling ... ") else if ! chatter > 4 then print ("F") else () let rec printRecursion ()  = if ! chatter > 5 then print ("[Recursion ...") else if ! chatter > 4 then print ("R") else () let rec printInference ()  = if ! chatter > 5 then print ("[Inference ...") else if ! chatter > 4 then print ("I") else () let rec printSplitting splitOp  = (* if !Global.chatter > 5 then print ("[" ^ MTPSplitting.menu splitOp) *)  if ! chatter > 5 then print ("[Splitting ...") else if ! chatter > 4 then print ("S") else () let rec printCloseBracket ()  = if ! chatter > 5 then print ("]\\n") else () let rec printQed ()  = (if ! chatter > 3 then print ("[QED]\\n") else (); if ! chatter > 4 then print ("Statistics: required Twelf.Prover.maxFill := " ^ (toString (! maxFill)) ^ "\\n") else ()) (* findMin L = Sopt\n\n       Invariant:\n\n       If   L be a set of splitting operators\n       then Sopt = NONE if L = []\n       else Sopt = SOME S, s.t. index S is minimal among all elements in L\n    *) let rec findMin nil  = NONE | findMin L  = let rec findMin\' (nil, result)  = result | findMin\' (O\' :: L\', NONE)  = if applicable O\' then findMin\' (L\', SOME O\') else findMin\' (L\', NONE) | findMin\' (O\' :: L\', SOME O)  = if applicable O\' then match compare (O\', O) with LESS -> findMin\' (L\', SOME O\') | _ -> findMin\' (L\', SOME O) else findMin\' (L\', SOME O) in findMin\' (L, NONE) (* split   (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n       recurse (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n       fill    (givenStates, (openStates, solvedStates)) = (openStates\', solvedStates\')\n\n       Invariant:\n       openStates\' extends openStates and\n         contains the states resulting from givenStates which cannot be\n         solved using Filling, Recursion, and Splitting\n       solvedStates\' extends solvedStates and\n         contains the states resulting from givenStates which can be\n         solved using Filling, Recursion, and Splitting\n    *) let rec split (S :: givenStates, os as (openStates, solvedStates))  = match findMin ((time splitting expand) S) with NONE -> fill (givenStates, (S :: openStates, solvedStates)) | SOME splitOp -> let _ = printSplitting splitOp let SL = (time splitting apply) splitOp let _ = printCloseBracket () let _ = printRecursion () let SL\' = map (fun S -> (time recursion apply) (expand S)) SL let _ = printInference () let SL\'\' = map (fun S -> (time inference apply) (expand S)) SL\' in fill (SL\'\' @ givenStates, os)fill (nil, os)  = os | fill (S :: givenStates, os as (openStates, solvedStates))  = (match (time recursion expand) S with fillingOp -> try  with ) (* Note: calling splitting in case filling fails, may cause the prover to succeed\n              if there are no cases to split -- however this may in fact be wrong -bp*) (* for comparing depth-first search (logic programming) with iterative deepening search\n              in the meta-theorem prover, we must disallow splitting :\n\n                handle TimeLimit.TimeOut =>  raise Filling.Error "Time Out: Time limit exceeded\\n"\n                handle MTPFilling.Error msg =>  raise Filling.Error msg\n                  ) handle MTPFilling.Error msg =>  raise Filling.Error msg\n            *) (* run givenStates = (openStates\', solvedStates\')\n\n       Invariant:\n       openStates\' contains the states resulting from givenStates which cannot be\n         solved using Filling, Recursion, and Splitting\n       solvedStates\' contains the states resulting from givenStates which can be\n         solved using Filling, Recursion, and Splitting\n     *) let rec run givenStates  = (let _ = printInit () let (openStates, solvedStates) = fill (givenStates, (nil, nil)) let openStates\' = map nameState openStates let solvedStates\' = map nameState solvedStates let _ = match openStates with nil -> printQed () | _ -> () in (openStates\', solvedStates\')) let run = run  (* local *)  end\n(* functor StrategyFRS *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* State for Proof Search *) (* Author: Carsten Schuermann *) module StateSyn ((*! structure IntSyn' : INTSYN !*) (*! structure FunSyn' : FUNSYN !*) (*! sharing FunSyn'.IntSyn = IntSyn' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn' !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn' !*) ) : STATESYN = struct (*! structure IntSyn = IntSyn' !*)  (*! structure FunSyn = FunSyn' !*)  type Order = Arg of (Exp * Sub) * (Exp * Sub) | Lex of Order list | Simul of Order list | All of Dec * Order | And of Order * Order (*     | O1 ^ O2              *)  type Info = Splits of int | RL | RLdone type Tag = Parameter of label option | Lemma of Info | None type State = State of int(* Part of theorem                   *)  * (dctx(* Context of Hypothesis in general not named *)  * Tag Ctx)(* Status information *)  * (For * Order)(* Induction hypothesis, order       *)  * int(* length of meta context            *)  * Order(* Current Order *)  * int * For list(* History of residual lemmas *)  * For (* Formula *)  module F = FunSynmodule I = IntSyn(* orderSub (O, s) = O'\n\n       Invariant:\n       If   G' |- O order    and    G |- s : G'\n       then G |- O' order\n       and  G |- O' == O[s] order\n    *) let rec orderSub (Arg ((U, s1), (V, s2)), s)  = Arg ((U, comp (s1, s)), (V, comp (s2, s))) | orderSub (Lex Os, s)  = Lex (map (fun O -> orderSub (O, s)) Os) | orderSub (Simul Os, s)  = Simul (map (fun O -> orderSub (O, s)) Os) (* by invariant: no case for All and And *) (* normalizeOrder (O) = O'\n\n       Invariant:\n       If   G |- O order\n       then G |- O' order\n       and  G |- O = O' order\n       and  each sub term of O' is in normal form.\n    *) let rec normalizeOrder (Arg (Us, Vs))  = Arg ((normalize Us, id), (normalize Vs, id)) | normalizeOrder (Lex Os)  = Lex (map normalizeOrder Os) | normalizeOrder (Simul Os)  = Simul (map normalizeOrder Os) (* by invariant: no case for All and And *) (* convOrder (O1, O2) = B'\n\n       Invariant:\n       If   G |- O1 order\n       and  G |- O2 order\n       then B' holds iff G |- O1 == O2 order\n    *) let rec convOrder (Arg (Us1, _), Arg (Us2, _))  = conv (Us1, Us2) | convOrder (Lex Os1, Lex Os2)  = convOrders (Os1, Os2) | convOrder (Simul Os1, Simul Os2)  = convOrders (Os1, Os2)convOrders (nil, nil)  = true | convOrders (O1 :: L1, O2 :: L2)  = convOrder (O1, O2) && convOrders (L1, L2) (* by invariant: no case for All and And *) (* decrease T = T'\n\n       Invariant:\n       T is either an Assumption or Induction tag\n       T' = T - 1\n    *) let rec decreaseInfo (Splits k)  = Splits (k - 1) | decreaseInfo RL  = RL | decreaseInfo RLdone  = RLdone let rec (* decrease (Assumption k) = Assumption (k-1)\n      | *) decrease (Lemma (Sp))  = Lemma (decreaseInfo Sp) | decrease None  = None let rec splitDepth (Splits k)  = k (* normalizeTag (T, s) = T'\n\n       Invariant:\n       If   G |- T : tag\n            G' |- s : G\n       then G' |- T' = T[s] tag\n    *) let rec normalizeTag (T as Parameter _, _)  = T | normalizeTag (Lemma (K), s)  = Lemma (K) let orderSub = orderSub let decrease = decrease let splitDepth = splitDepth let normalizeOrder = normalizeOrder let convOrder = convOrder let normalizeTag = normalizeTag  (* local *)  end\n(* signature STATESYN *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Meta Prover Interface *) (* Author: Carsten Schuermann *) module MTPi (module MTPGlobal : MTPGLOBAL(*! structure IntSyn : INTSYN !*) (*! structure FunSyn\' : FUNSYN !*) (*! sharing FunSyn\'.IntSyn = IntSyn !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.IntSyn = IntSyn !*) (*! sharing StateSyn\'.FunSyn = FunSyn\' !*) module RelFun : RELFUN(*! sharing RelFun.FunSyn = FunSyn\' !*) module Formatter : FORMATTERmodule Print : PRINT(*! sharing Print.IntSyn = IntSyn !*) PrintFormatterFormattermodule FunTypeCheck : FUNTYPECHECK(*! sharing FunTypeCheck.FunSyn = FunSyn\' !*) FunTypeCheckStateSynStateSyn\'module MTPData : MTPDATAmodule MTPInit : MTPINIT(*! sharing MTPInit.FunSyn = FunSyn\' !*) MTPInitStateSynStateSyn\'module MTPFilling : MTPFILLING(*! sharing MTPFilling.FunSyn = FunSyn\' !*) MTPFillingStateSynStateSyn\'module Inference : INFERENCE(*! sharing Inference.FunSyn = FunSyn\' !*) InferenceStateSynStateSyn\'module MTPSplitting : MTPSPLITTINGMTPSplittingStateSynStateSyn\'module MTPRecursion : MTPRECURSIONMTPRecursionStateSynStateSyn\'module MTPStrategy : MTPSTRATEGYMTPStrategyStateSynStateSyn\'module MTPrint : MTPRINTMTPrintStateSynStateSyn\'module Order : ORDER(*! sharing Order.IntSyn = IntSyn !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn !*) module Timers : TIMERSmodule Ring : RING) : MTPI = struct exception Error of string (*! structure FunSyn = FunSyn\' !*)  module StateSyn = StateSyn\' module I = IntSynmodule F = FunSynmodule S = StateSynmodule Fmt = Formattertype MenuItem = Filling of operator | Recursion of operator | Splitting of operator | Inference of operator let Open : State ring ref = ref (init []) let Solved : State ring ref = ref (init []) let History : State ring * State ring list ref = ref nil let Menu : MenuItem list option ref = ref NONE let rec initOpen ()  = Open := init [] let rec initSolved ()  = Solved := init [] let rec empty ()  = empty (! Open) let rec current ()  = current (! Open) let rec delete ()  = Open := delete (! Open) let rec insertOpen S  = Open := insert (! Open, S) let rec insertSolved S  = Solved := insert (! Solved, S) let rec insert S  = insertOpen S let rec collectOpen ()  = foldr :: nil (! Open) let rec collectSolved ()  = foldr :: nil (! Solved) let rec nextOpen ()  = Open := next (! Open) let rec pushHistory ()  = History := (! Open, ! Solved) :: (! History) let rec popHistory ()  = match (! History) with nil -> raise (Error "History stack empty") | (Open\', Solved\') :: History\' -> (History := History\'; Open := Open\'; Solved := Solved\') let rec abort s  = (print ("* " ^ s); raise (Error s)) let rec reset ()  = (initOpen (); initSolved (); History := nil; Menu := NONE) let rec cLToString (nil)  = "" | cLToString (c :: nil)  = (conDecName (sgnLookup c)) | cLToString (c :: L)  = (conDecName (sgnLookup c)) ^ ", " ^ (cLToString L) let rec printFillResult (_, P)  = let rec formatTuple (G, P)  = let rec formatTuple\' (Unit)  = nil | formatTuple\' (Inx (M, Unit))  = [formatExp (G, M)] | formatTuple\' (Inx (M, P\'))  = (formatExp (G, M) :: String "," :: Break :: formatTuple\' P\') in match P with (Inx (_, Unit)) -> Hbox (formatTuple\' P) | _ -> HVbox0 1 1 1 (String "(" :: (formatTuple\' P @ [String ")"])) let State (n, (G, B), (IH, OH), d, O, H, F) = current () in print ("Filling successful with proof term:\\n" ^ (makestring_fmt (formatTuple (G, P))) ^ "\\n") let rec SplittingToMenu (nil, A)  = A | SplittingToMenu (O :: L, A)  = SplittingToMenu (L, Splitting O :: A) let rec FillingToMenu (O, A)  = Filling O :: A let rec RecursionToMenu (O, A)  = Recursion O :: A let rec InferenceToMenu (O, A)  = Inference O :: A let rec menu ()  = if empty () then Menu := NONE else let S = current () let SplitO = expand S let InfO = expand S let RecO = expand S let FillO = expand S in Menu := SOME (FillingToMenu (FillO, RecursionToMenu (RecO, InferenceToMenu (InfO, SplittingToMenu (SplitO, nil))))) let rec format k  = if k < 10 then (toString k) ^ ".  " else (toString k) ^ ". " let rec menuToString ()  = let rec menuToString\' (k, nil, (NONE, _))  = (SOME k, "") | menuToString\' (k, nil, (kopt\' as SOME _, _))  = (kopt\', "") | menuToString\' (k, Splitting O :: M, kOopt\' as (NONE, NONE))  = let kOopt\'\' = if applicable O then (SOME k, SOME O) else kOopt\' let (kopt as SOME k\'\', s) = menuToString\' (k + 1, M, kOopt\'\') in (kopt, if k = k\'\' then s ^ "\\n* " ^ (format k) ^ (menu O) else s ^ "\\n  " ^ (format k) ^ (menu O)) | menuToString\' (k, Splitting O :: M, kOopt\' as (SOME k\', SOME O\'))  = let kOopt\'\' = if applicable O then match compare (O, O\') with LESS -> (SOME k, SOME O) | _ -> kOopt\' else kOopt\' let (kopt as SOME k\'\', s) = menuToString\' (k + 1, M, kOopt\'\') in (kopt, if k = k\'\' then s ^ "\\n* " ^ (format k) ^ (menu O) else s ^ "\\n  " ^ (format k) ^ (menu O)) | menuToString\' (k, Filling O :: M, kOopt)  = let (kopt, s) = menuToString\' (k + 1, M, kOopt) in (kopt, s ^ "\\n  " ^ (format k) ^ (menu O)) | menuToString\' (k, Recursion O :: M, kOopt)  = let (kopt, s) = menuToString\' (k + 1, M, kOopt) in (kopt, s ^ "\\n  " ^ (format k) ^ (menu O)) | menuToString\' (k, Inference O :: M, kOopt)  = let (kopt, s) = menuToString\' (k + 1, M, kOopt) in (kopt, s ^ "\\n  " ^ (format k) ^ (menu O)) in match ! Menu with NONE -> raise (Error "Menu is empty") | SOME M -> let (kopt, s) = menuToString\' (1, M, (NONE, NONE)) in s let rec printMenu ()  = if empty () then (print "[QED]\\n"; print ("Statistics: required Twelf.Prover.maxFill := " ^ (toString (! maxFill)) ^ "\\n")) else let S = current () let _ = if ! doubleCheck then isState S else () in (print "\\n"; print (stateToString S); print "\\nSelect from the following menu:\\n"; print (menuToString ()); print "\\n") let rec contains (nil, _)  = true | contains (x :: L, L\')  = (exists (fun x\' -> x = x\') L\') && contains (L, L\') let rec equiv (L1, L2)  = contains (L1, L2) && contains (L2, L1) let rec transformOrder\' (G, Arg k)  = let k\' = (ctxLength G) - k + 1 let Dec (_, V) = ctxDec (G, k\') in Arg ((Root (BVar k\', Nil), id), (V, id)) | transformOrder\' (G, Lex Os)  = Lex (map (fun O -> transformOrder\' (G, O)) Os) | transformOrder\' (G, Simul Os)  = Simul (map (fun O -> transformOrder\' (G, O)) Os) let rec transformOrder (G, All (Prim D, F), Os)  = All (D, transformOrder (Decl (G, D), F, Os)) | transformOrder (G, And (F1, F2), O :: Os)  = And (transformOrder (G, F1, [O]), transformOrder (G, F2, Os)) | transformOrder (G, Ex _, [O])  = transformOrder\' (G, O) let rec select c  = (try  with ) let rec init (k, names)  = let cL = map (fun x -> valOf (constLookup (valOf (stringToQid x)))) names let _ = maxFill := k let _ = reset () let F = convertFor cL let O = transformOrder (Null, F, map select cL) let Slist = init (F, O) let _ = if length Slist = 0 then raise (Domain) else () in (try  with ) let rec select k  = let rec select\' (k, nil)  = abort ("No such menu item") | select\' (1, Splitting O :: _)  = let S\' = (time splitting apply) O let _ = pushHistory () let _ = delete () let _ = map (fun S -> insert (nameState S)) S\' in (menu (); printMenu ()) | select\' (1, Recursion O :: _)  = let S\' = (time recursion apply) O let _ = pushHistory () let _ = delete () let _ = insert (nameState S\') in (menu (); printMenu ()) | select\' (1, Inference O :: _)  = let S\' = (time recursion apply) O let _ = pushHistory () let _ = delete () let _ = insert (nameState S\') in (menu (); printMenu ()) | select\' (1, Filling O :: _)  = let P = try  with  let _ = printFillResult P let _ = delete () let _ = print "\\n[Subgoal finished]\\n" let _ = print "\\n" in (menu (); printMenu ()) | select\' (k, _ :: M)  = select\' (k - 1, M) in try  with let rec solve ()  = if empty () then raise (Error "Nothing to prove") else let S = current () let (Open\', Solved\') = try  with  let _ = pushHistory () let _ = delete () let _ = map insertOpen Open\' let _ = map insertSolved Solved\' in (menu (); printMenu ()) let rec check ()  = if empty () then raise (Error "Nothing to check") else let S = current () in isState S let rec auto ()  = let (Open\', Solved\') = try  with  let _ = pushHistory () let _ = initOpen () let _ = map insertOpen Open\' let _ = map insertSolved Solved\' in (menu (); printMenu ()) let rec next ()  = (nextOpen (); menu (); printMenu ()) let rec undo ()  = (popHistory (); menu (); printMenu ()) let init = init let select = select let print = printMenu let next = next let reset = reset let solve = solve let auto = auto let check = check let undo = undo  (* local *)  end\n(* functor MPI *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: (* Data aquired during proof search *) (* Author: Carsten Schuermann *) module type MTPDATA = sig val maxFill : int ref end
(* signature MTPDATA *) 
('Error parsing code:', '(* Filling  Version 1.3*) (* Author: Carsten Schuermann *) module MTPFilling (module MTPGlobal : MTPGLOBAL(*! structure IntSyn : INTSYN !*) (*! structure FunSyn\' : FUNSYN !*) (*! sharing FunSyn\'.IntSyn = IntSyn !*) module StateSyn\' : STATESYN(*! sharing StateSyn\'.FunSyn = FunSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn !*) module MTPData : MTPDATAmodule Search : MTPSEARCHSearchStateSynStateSyn\'module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) ) : MTPFILLING = struct (*! structure FunSyn = FunSyn\' !*)  module StateSyn = StateSyn\' exception Error of string exception TimeOut type operator = (unit -> int * Pro) module S = StateSynmodule F = FunSynmodule I = IntSynexception Success of int (* Checking for constraints: Used to be in abstract, now must be done explicitly! --cs*) (* createEVars (G, F) = (Xs\', P\')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- F = [[x1:A1]] .. [[xn::An]] formula\n       then Xs\' = (X1\', .., Xn\') a list of EVars\n       and  G |- Xi\' : A1 [X1\'/x1..X(i-1)\'/x(i-1)]          for all i <= n\n       and  G; D |- P\' = <X1\', <.... <Xn\', <>> ..> in F     for some D\n    *) let rec createEVars (G, (True, s))  = (nil, Unit) | createEVars (G, (Ex (Dec (_, V), F), s))  = let X = newEVar (G, EClo (V, s)) let X\' = lowerEVar X let (Xs, P) = createEVars (G, (F, Dot (Exp X, s))) in (X\' :: Xs, Inx (X, P)) (*    fun checkConstraints nil = raise Success\n      | checkConstraints (X :: L) =\n        if Abstract.closedExp (I.Null, (Whnf.normalize (X, I.id), I.id)) then checkConstraints L\n        else ()\n*) (* expand\' S = op\'\n\n       Invariant:\n       If   |- S state\n       then op\' is an operator which performs the filling operation\n    *) let rec expand (S as State (n, (G, B), (IH, OH), d, O, H, F))  = let _ = if (! doubleCheck) then typeCheckCtx (G) else () let (Xs, P) = createEVars (G, (F, id)) in fun () -> (try  with ) (* apply op = B\'\n\n       Invariant:\n       If op is a filling operator\n       then B\' holds iff the filling operation was successful\n    *) let rec apply f  = f () (* menu op = s\'\n\n       Invariant:\n       If op is a filling operator\n       then s\' is a string describing the operation in plain text\n    *) let rec menu _  = "Filling   (tries to close this subgoal)" let expand = expand let apply = apply let menu = menu  (* local *)  end\n(* functor Filling *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Converter from relational representation to a functional\n   representation of proof terms *) (* Author: Carsten Schuermann *) module RelFun (module Global : GLOBAL(*! structure FunSyn\' : FUNSYN !*) module ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = FunSyn\'.IntSyn !*) module Names : NAMES(*! sharing Names.IntSyn = FunSyn\'.IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = FunSyn\'.IntSyn !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = FunSyn\'.IntSyn !*) module Weaken : WEAKEN(*! sharing Weaken.IntSyn = FunSyn\'.IntSyn !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = FunSyn\'.IntSyn !*) module FunWeaken : FUNWEAKEN(*! sharing FunWeaken.FunSyn = FunSyn\' !*) module FunNames : FUNNAMES(*! sharing FunNames.FunSyn = FunSyn\' !*) ) : RELFUN = struct (*! structure FunSyn = FunSyn\' !*)  exception Error of string module F = FunSynmodule I = IntSynmodule M = ModeSyn(* ctxSub (G, s) = (G\', s\')\n\n       Invariant:\n       if   Psi |- G ctx\n       and  Psi\' |- s : Psi\n       then Psi\' |- G\' ctx\n       and  Psi\', G\' |- s\' : G\n       and  G\' = G [s],  declarationwise defined\n    *) let rec ctxSub (Null, s)  = (Null, s) | ctxSub (Decl (G, D), s)  = let (G\', s\') = ctxSub (G, s) in (Decl (G\', decSub (D, s\')), dot1 s) let rec convertOneFor cid  = (* convertFor\' (V, mS, w1, w2, n) = (F\', F\'\')\n\n           Invariant:\n           If   G |- V = {{G\'}} type :kind\n           and  G |- w1 : G+\n           and  G+, G\'+, G- |- w2 : G\n           and  G+, G\'+, G- |- ^n : G+\n           and  mS is a spine for G\'\n           then F\'  is a formula excepting a another formula as argument s.t.\n                If G+, G\'+ |- F formula,\n                then . |- F\' F formula\n           and  G+, G\'+ |- F\'\' formula\n        *) (* shiftPlus (mS) = s\'\n\n         Invariant:\n         s\' = ^(# of +\'s in mS)\n         *) let V = match sgnLookup cid with ConDec (name, _, _, _, V, Kind) -> V | _ -> raise (Error "Type Constant declaration expected") let mS = match modeLookup cid with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let rec convertFor\' (Pi ((D, _), V), Mapp (Marg (Plus, _), mS), w1, w2, n)  = let (F\', F\'\') = convertFor\' (V, mS, dot1 w1, Dot (Idx n, w2), n - 1) in (fun F -> All (Prim (strengthenDec (D, w1)), F\' F), F\'\') | convertFor\' (Pi ((D, _), V), Mapp (Marg (Minus, _), mS), w1, w2, n)  = let (F\', F\'\') = convertFor\' (V, mS, comp (w1, shift), dot1 w2, n + 1) in (F\', Ex (decSub (D, w2), F\'\')) | convertFor\' (Uni Type, Mnil, _, _, _)  = (fun F -> F, True) | convertFor\' _  = raise (Error "type family must be +/- moded") let rec shiftPlus mS  = let rec shiftPlus\' (Mnil, n)  = n | shiftPlus\' (Mapp (Marg (Plus, _), mS\'), n)  = shiftPlus\' (mS\', n + 1) | shiftPlus\' (Mapp (Marg (Minus, _), mS\'), n)  = shiftPlus\' (mS\', n) in shiftPlus\' (mS, 0) let n = shiftPlus mS let (F, F\') = convertFor\' (V, mS, id, Shift n, n) in F F\' (* convertFor L = F\'\n\n       Invariant:\n       If   L is a list of type families\n       then F\' is the conjunction of the logical interpretation of each\n            type family\n     *) let rec convertFor nil  = raise (Error "Empty theorem") | convertFor [a]  = convertOneFor a | convertFor (a :: L)  = And (convertOneFor a, convertFor L) (* occursInExpN (k, U) = B,\n\n       Invariant:\n       If    U in nf\n       then  B iff k occurs in U\n    *) let rec occursInExpN (k, Uni _)  = false | occursInExpN (k, Pi (DP, V))  = occursInDecP (k, DP) || occursInExpN (k + 1, V) | occursInExpN (k, Root (H, S))  = occursInHead (k, H) || occursInSpine (k, S) | occursInExpN (k, Lam (D, V))  = occursInDec (k, D) || occursInExpN (k + 1, V) | occursInExpN (k, FgnExp csfe)  = fold csfe (fun (U, B) -> B || occursInExpN (k, normalize (U, id))) false(* no case for Redex, EVar, EClo *) occursInHead (k, BVar (k\'))  = (k = k\') | occursInHead (k, Const _)  = false | occursInHead (k, Def _)  = false | occursInHead (k, FgnConst _)  = false(* no case for FVar *) occursInSpine (_, Nil)  = false | occursInSpine (k, App (U, S))  = occursInExpN (k, U) || occursInSpine (k, S)(* no case for SClo *) occursInDec (k, Dec (_, V))  = occursInExpN (k, V)occursInDecP (k, (D, _))  = occursInDec (k, D)occursInExp (k, U)  = occursInExpN (k, normalize (U, id)) (* dot1inv w = w\'\n\n       Invariant:\n       If   G, A |- w : G\', A\n       then G |- w\' : G\'\n       and  w = 1.w\' o ^\n    *) let rec dot1inv (w)  = strengthenSub (comp (shift, w), shift) (* shiftinv (w) = w\'\n\n       Invariant:\n       If   G, A |- w : G\'\n       and  1 does not occur in w\n       then w  = w\' o ^\n    *) let rec shiftinv (w)  = strengthenSub (w, shift) let rec eqIdx (Idx (n), Idx (k))  = (n = k) | eqIdx _  = false let rec peel w  = if eqIdx (bvarSub (1, w), Idx 1) then dot1inv w else shiftinv w let rec peeln (0, w)  = w | peeln (n, w)  = peeln (n - 1, peel w) (* domain (G2, w) = n\'\n\n       Invariant:\n       If   G2 |- w: G1   and w weakening substitution\n       then n\' = |G1|\n    *) let rec domain (G, Dot (Idx _, s))  = domain (G, s) + 1 | domain (Null, Shift 0)  = 0 | domain (G as Decl _, Shift 0)  = domain (G, Dot (Idx 1, Shift 1)) | domain (Decl (G, _), Shift n)  = domain (G, Shift (n - 1)) (* strenghten (Psi, (a, S), w, m) = (Psi\', w\')\n\n       Invariant:\n       If   |- Psi ctx\n       and  |- Psi1 ctx      where Psi1 is a subcontext of Psi\n       and  |- Psi2 ctx\n       and  Sigma (a) = {x1:A1} .. {xn:An} type\n       and  Psi |- S : m1{x1:A1} .. mn{xn:An} > type\n       and  Psi |- w : Psi1\n       and  m mode\n       then |- Psi\' ctx\n       and  Psi |- w\' : Psi\'\n       where Psi\' extends Psi1\n    *) let rec strengthen (Psi, (a, S), w, m)  = (* testBlock (G, (bw, w1)) = (bw\', w\')\n\n           Invariant:\n           If   |- G ctx\n           and  |- G1 ctx\n           and  |- G2 ctx\n           and  G1 |- w1 : G2, G\n           and  bw is a boolean value\n           then there ex. a G1\'\n           s.t. |- G1\' ctx\n           and  G1\' |- w\' : G2\n           and  bw\' = bw or (G1 =/= G1\')\n         *) (* strengthen\' (Psi1, Psi2, S, w1) =  (Psi\', w\')\n\n           Invariant:\n           If   |- Psi1 ctx\n           and  Psi1 |- Psi2 ctx      (Psi2 is a list to maintain order)\n           and  |- Psi3 ctx\n           and  Psi1 |- w1 : Psi3     where w1 is a weakening substitution\n           and  Psi1, Psi2 |- S : V1 > V2\n           then |- Psi\' ctx\n           and  Psi1 |- w\' : Psi\'     where w\' is a weakening substitution\n           where Psi3 < Psi\' < Psi1   (Psi\' contains all variables of Psi3\n                                       and all variables occuring in m\n                                       position in S)\n        *) let mS = match modeLookup a with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let rec args (Nil, Mnil)  = nil | args (App (U, S\'), Mapp (Marg (m\', _), mS))  = let L = args (S\', mS) in (match modeEqual (m, m\') with true -> U :: L | false -> L) let rec strengthenArgs (nil, s)  = nil | strengthenArgs (U :: L, s)  = strengthenExp (U, s) :: strengthenArgs (L, s) let rec occursInArgs (n, nil)  = false | occursInArgs (n, U :: L)  = (occursInExp (n, U) || occursInArgs (n, L)) let rec occursInPsi (n, (nil, L))  = occursInArgs (n, L) | occursInPsi (n, (Prim (Dec (_, V)) :: Psi1, L))  = occursInExp (n, V) || occursInPsi (n + 1, (Psi1, L)) | occursInPsi (n, (Block (CtxBlock (l, G)) :: Psi1, L))  = occursInG (n, G, fun n\' -> occursInPsi (n\', (Psi1, L)))occursInG (n, Null, k)  = k n | occursInG (n, Decl (G, Dec (_, V)), k)  = occursInG (n, G, fun n\' -> occursInExp (n\', V) || k (n\' + 1)) let rec occursBlock (G, (Psi2, L))  = let rec occursBlock (Null, n)  = false | occursBlock (Decl (G, D), n)  = occursInPsi (n, (Psi2, L)) || occursBlock (G, n + 1) in occursBlock (G, 1) let rec inBlock (Null, (bw, w1))  = (bw, w1) | inBlock (Decl (G, D), (bw, w1))  = if eqIdx (bvarSub (1, w1), Idx 1) then inBlock (G, (true, dot1inv w1)) else inBlock (G, (bw, strengthenSub (w1, shift))) let rec blockSub (Null, w)  = (Null, w) | blockSub (Decl (G, Dec (name, V)), w)  = let (G\', w\') = blockSub (G, w) let V\' = strengthenExp (V, w\') in (Decl (G\', Dec (name, V\')), dot1 w\') let rec strengthen\' (Null, Psi2, L, w1, (* =  I.id *) )  = (Null, id) | strengthen\' (Decl (Psi1, LD as Prim (Dec (name, V))), Psi2, L, w1)  = let (bw, w1\') = if eqIdx (bvarSub (1, w1), Idx 1) then (true, dot1inv w1) else (false, strengthenSub (w1, shift)) in if bw || occursInPsi (1, (Psi2, L)) then let (Psi1\', w\') = strengthen\' (Psi1, LD :: Psi2, L, w1\') let V\' = strengthenExp (V, w\') in (Decl (Psi1\', Prim (Dec (name, V\'))), dot1 w\') else let w2 = shift let (Psi2\', w2\') = strengthenPsi\' (Psi2, w2) let L\' = strengthenArgs (L, w2\') let (Psi1\'\', w\') = strengthen\' (Psi1, Psi2\', L\', w1\') in (Psi1\'\', comp (w\', shift)) | strengthen\' (Decl (Psi1, LD as Block (CtxBlock (name, G))), Psi2, L, w1)  = let (bw, w1\') = inBlock (G, (false, w1)) in if bw || occursBlock (G, (Psi2, L)) then let (Psi1\', w\') = strengthen\' (Psi1, LD :: Psi2, L, w1\') let (G\'\', w\'\') = blockSub (G, w\') in (Decl (Psi1\', Block (CtxBlock (name, G\'\'))), w\'\') else let w2 = Shift (ctxLength G) let (Psi2\', w2\') = strengthenPsi\' (Psi2, w2) let L\' = strengthenArgs (L, w2\') in strengthen\' (Psi1, Psi2\', L\', w1\') in strengthen\' (Psi, nil, args (S, mS), w) let rec recursion L  = let F = convertFor L let rec name [a]  = conDecName (sgnLookup a) | name (a :: L)  = conDecName (sgnLookup a) ^ "/" ^ (name L) in fun p -> Rec (MDec (SOME (name L), F), p) (* abstract a = P\'\n\n       Invariant:\n       If   a is a type family\n       and  Sigma (a) = {x1:A1}..{xn:An} type\n       then for all P s.t.\n            +x1:A1, .., +xn:An; . |- P in [[-x1:A1]] .. [[-xn:An]] true\n            . ;. |- (P\' P) in [[+x1:A1]] .. [[+xn:An]] [[-x1:A1]] .. [[-xn:An]] true\n    *) let rec abstract (a)  = (* abstract\' ((V, mS), w) = P\'\n\n           Invariant:\n           If  Sigma (a) = {x1:A1} .. {xn:An} type\n           and  Psi |- S : m1{x1:A1} .. mn{xn:An} type > type\n           and  Gamma= x1:A1, .. x(j-1):A(j-1)\n           and  Gamma |- w : Gamma+\n           then P\' is a Lam abstraction\n        *) let mS = match modeLookup a with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let V = match sgnLookup a with ConDec (name, _, _, _, V, Kind) -> V | _ -> raise (Error "Type Constant declaration expected") let rec abstract\' ((_, Mnil), w)  = (fun p -> p) | abstract\' ((Pi ((D, _), V2), Mapp (Marg (Plus, _), mS)), w)  = let D\' = strengthenDec (D, w) let P = abstract\' ((V2, mS), dot1 w) in fun p -> Lam (Prim D\', P p) | abstract\' ((Pi (_, V2), Mapp (Marg (Minus, _), mS)), w)  = abstract\' ((V2, mS), comp (w, shift)) in abstract\' ((V, mS), id) (* transformInit (Psi, (a, S), w1) = (w\', s\')\n\n       Invariant:\n       If   |- Psi ctx\n       and  Sigma (a) = {x1:A1} .. {xn:An} type\n       and  Psi |- S : m1{x1:A1} .. mn{xn:An} type > type\n       and  Psi |- w1 : Psi+\n       then |- Gamma+ ctx\n       and  Gamma+ = +x(k1):A(k1), ... +x(km):A(km)\n       and  Psi+ |- s\' : Gamma+\n       and  x1:A1 .. xn:An |- w: Gamma+    (w weakening substitution)\n    *) let rec transformInit (Psi, (a, S), w1)  = (* transformInit\' ((S, mS), V, (w, s)) = (w\', s\')\n\n           Invariant:\n           If   Psi |- S : V > type\n           and  x1:A1...x(j-1):A(j-1) |- V = mj{xj:Aj} .. mn{xn:An} type : kind\n           and  x1:A1...x(j-1):A(j-1) |- w : +x1:A1... +x(j-1):A(j-1)\n           and  Psi |- w1 : Psi+\n           and  Psi+ |- s : +x1:A1... +x(j-1):A(j-1)\n           then x1:A1...xn:An |- w\' : +x1:A1... +xn:An\n           and  Psi+ |- s\' : +x1:A1 .. +xn:An\n        *) let mS = match modeLookup a with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let V = match sgnLookup a with ConDec (name, _, _, _, V, Kind) -> V | _ -> raise (Error "Type Constant declaration expected") let rec transformInit\' ((Nil, Mnil), Uni Type, (w, s))  = (w, s) | transformInit\' ((App (U, S), Mapp (Marg (Minus, _), mS)), Pi (_, V2), (w, s))  = let w\' = comp (w, shift) let s\' = s in transformInit\' ((S, mS), V2, (w\', s\')) | transformInit\' ((App (U, S), Mapp (Marg (Plus, _), mS)), Pi ((Dec (name, V1), _), V2), (w, s))  = let V1\' = strengthenExp (V1, w) let w\' = dot1 w let U\' = strengthenExp (U, w1) let s\' = dotEta (Exp (U\'), s) in transformInit\' ((S, mS), V2, (w\', s\')) in transformInit\' ((S, mS), V, (id, Shift (lfctxLength Psi))) (* transformDec (c\'\', (Psi+-, G0), d, (a, S), w1, w2, t) = (d\', w\', s\', t\', Ds)\n\n       Invariant:\n       If   |- Psi ctx\n       and  Psi |- G0 ctx\n       and  d = |Delta|\n       and  Sigma (a) = {x1:A1} .. {xn:An} type\n       and  Psi, G0 |- S : m1{x1:A1} .. mn{xn:An} type > type\n       and  Psi, G0 |- w1 : Psi+, G0[w1^-1]\n       and  Psi |- w2 : Psi+-\n       and  Psi+- |- t0 : Psi+\n       then |- Gamma+ ctx\n       and  Gamma+ = +x(k1):A(k1), ... +x(km):A(km)\n       and  Psi |- s\' : Gamma+\n       and  x1:A1 .. xn:An |- w\': Gamma+    (w weakening substitution)\n       and  Psi+- |- t\' : Psi+, -x(k1):{G0} A(k1), ... -x(km):{G0} A(km)\n       and  d\' = |Delta\'|\n    *) let rec transformDec (Ts, (Psi, G0), d, (a, S), w1, w2, t0)  = (* raiseExp (G, U, a) = U\'\n\n           Invariant:\n           If   |- Psi ctx         (for some given Psi)\n           and  Psi |- G ctx\n           and  Psi, G |- U : V    (for some V)\n           then Psi, G |- [[G]] U : {{G}} V     (wrt subordination)\n        *) (* raiseType (G, U, a) = U\'\n\n           Invariant:\n           If   |- Psi ctx         (for some given Psi)\n           and  Psi |- G ctx\n           and  Psi, G |- U : V    (for some V)\n           then Psi, G |- [[G]] U : {{G}} V     (wrt subordination)\n           and  Psi, G, x:{{G}} V |- x G : V\n        *) (* exchangeSub (G0) = s\'\n\n           Invariant:\n           For some Psi, some G, some V:\n           Psi, V, G0 |- s\' : Psi, G0, V\n        *) (* transformDec\' (d, (S, mS), V, (z1, z2), (w, t)) = (d\', w\', t\', (Ds+, Ds-))\n\n           Invariant:\n           If   Psi, G0 |- S : V > type\n           and  S doesn\'t contain Skolem constants\n           and  d = |Delta|\n           and  x1:A1...x(j-1):A(j-1) |- V = mj{xj:Aj} .. mn{xn:An} type : kind\n           and  x1:A1...x(j-1):A(j-1) |- w : +x1:A1... +x(j-1):A(j-1)\n           and  Psi, G0 |- w1 : Psi+, G0[w1^-1]\n           and  Psi |- w2 : Psi+-\n           and  Psi+- |- t : Psi+, -x1:{{G0}} A1... -xj:{{G0}} Aj\n           and  Psi+, -x1:{{G0}} A1...-x(j-1):{{G0}} A(j-1) |- z1: Psi+\n           and  Psi+, -x1:{{G0}} A1...-x(j-1):{{G0}} A(j-1), G0 |- z2: x1:A1...x(j-1):A(j-1)\n           then x1:A1...xn:An |- w\' : +x1:A1... +xn:An\n           and  Psi+- |- s\' : +x1:A1 .. +xn:An\n           and  Psi+- |- t\' : Psi+, -x1:{{G0}} A1... -xn:{{G0}} An\n           and  d\' = |Delta\'|\n        *) (* head Ts (w, t, (d, Dplus, Dminus)) = (d\', w\', t\', P\')\n\n             Invariant:\n             If   a not in Ts  then d\'= d+1,  P\' makes a lemma call\n             If   Ts = [a]     then d\'= d     P\' used directly the ih.\n             If   Ts = a1 .. ai ... and ai = a\n             then d\' = d+i   and P\' select ih, and then decomposes is, using\n                  (i-1) Rights and 1 Left\n          *) let mS = match modeLookup a with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let V = match sgnLookup a with ConDec (name, _, _, _, V, Kind) -> V | _ -> raise (Error "Type Constant declaration expected") let rec raiseExp (G, U, a)  = (* raiseExp G = (w\', k)\n\n               Invariant:\n               If   |-  Psi ctx\n               and  Psi |- G ctx\n               and  Psi |- G\' ctx   which ARE subordinate to a\n               then Psi, G |- w : Psi, G\'\n               and  k is a continuation calculuting the right exprssion:\n                    for all U, s.t. Psi, G |- U : V\n                    Psi |- [[G\']] U : {{G\'}} V\n            *) let rec raiseExp\' Null  = (id, fun x -> x) | raiseExp\' (Decl (G, D as Dec (_, V)))  = let (w, k) = raiseExp\' G in if belowEq (targetFam V, a) then (dot1 w, fun x -> k (Lam (strengthenDec (D, w), x))) else (comp (w, shift), k) let (w, k) = raiseExp\' G in k (strengthenExp (U, w)) let rec raiseType (G, U, a)  = (* raiseType (G, n) = (w\', k, S\')\n\n              Invariant:\n              If   |-  Psi ctx\n              and  Psi |- G, Gv ctx\n              and  Psi |- G\' ctx   which ARE subordinate to a\n              and  n = |Gv| + 1\n              then Psi, G |- w : Psi, G\'\n              and  k is a continuation calculating the right exprssion:\n                   for all U, s.t. Psi, G |- U : V\n                   Psi |- [[G\']] U : {{G\'}} V\n              and  k\' is a continuation calculating the corresponding spine:\n                   for all S, s.t. Psi, G, G0,|- ... refine\n            *) let rec raiseType\' (Null, n)  = (id, fun x -> x, fun S -> S) | raiseType\' (Decl (G, D as Dec (_, V)), n)  = let (w, k, k\') = raiseType\' (G, n + 1) in if belowEq (targetFam V, a) then (dot1 w, fun x -> k (Pi ((strengthenDec (D, w), Maybe), x)), fun S -> App (Root (BVar n, Nil), S)) else (comp (w, shift), k, k\') let (w, k, k\') = raiseType\' (G, 2) in (k (strengthenExp (U, w)), Root (BVar 1, k\' Nil)) let rec exchangeSub (G0)  = let g0 = ctxLength G0 let rec exchangeSub\' (0, s)  = s | exchangeSub\' (k, s)  = exchangeSub\' (k - 1, Dot (Idx (k), s)) in Dot (Idx (g0 + 1), exchangeSub\' (g0, Shift (g0 + 1))) let rec transformDec\' (d, (Nil, Mnil), Uni Type, (z1, z2), (w, t))  = (w, t, (d, fun (k, Ds) -> Ds k, fun _ -> Empty)) | transformDec\' (d, (App (U, S), Mapp (Marg (Minus, _), mS)), Pi ((Dec (_, V1), DP), V2), (z1, z2), (w, t))  = let g = ctxLength G0 let w1\' = peeln (g, w1) let (G1, _) = strengthenCtx (G0, w1\') let (G2, _) = ctxSub (G1, z1) let (V1\'\', Ur) = raiseType (G2, EClo (V1, z2), targetFam V1) let w\' = (match DP with Maybe -> dot1 w | No -> comp (w, shift)) let U0 = raiseExp (G0, U, targetFam V1\'\') let U\' = strengthenExp (U0, w2) let t\' = dotEta (Exp (U\'), t) let z1\' = comp (z1, shift) let xc = exchangeSub G0 let z2n = comp (z2, comp (shift, xc)) let Ur\' = EClo (Ur, xc) let z2\' = dotEta (Exp (Ur\'), z2n) let (w\'\', t\'\', (d\', Dplus, Dminus)) = transformDec\' (d + 1, (S, mS), V2, (z1\', z2\'), (w\', t\')) in (w\'\', t\'\', (d\', Dplus, fun k -> Split (k, Dminus 1))) | transformDec\' (d, (App (U, S), Mapp (Marg (Plus, _), mS)), Pi ((Dec (name, V1), _), V2), (z1, z2), (w, t))  = let V1\' = strengthenExp (V1, w) let w\' = dot1 w let U\' = strengthenExp (U, w1) let t\' = t let z1\' = dot1n (G0, z1) let z2\' = Dot (Exp (EClo (U\', z1\')), z2) let (w\'\', t\'\', (d\', Dplus, Dminus)) = transformDec\' (d + 1, (S, mS), V2, (z1, z2\'), (w\', t\')) in (w\'\', t\'\', (d\', fun (k, Ds) -> App ((k, U\'), Dplus (1, Ds)), Dminus)) let (w\'\', t\'\', (d\', Dplus, Dminus)) = transformDec\' (d, (S, mS), V, (id, Shift (domain (Psi, t0) + ctxLength G0)), (id, t0)) let rec varHead Ts (w\'\', t\'\', (d\', Dplus, Dminus))  = let rec head\' ([a\'], d1, k1)  = (d1, k1) | head\' (a\' :: Ts\', d1, k1)  = if a = a\' then (d1 + 1, fun xx -> Left (xx, (k1 1))) else let (d2, k2) = head\' (Ts\', d1 + 1, k1) in (d2, fun xx -> Right (xx, (k2 1))) let (d2, k2) = head\' (Ts, d\', fun xx -> Dplus (xx, Dminus)) in (d2, w\'\', t\'\', k2 d) let rec lemmaHead (w\'\', t\'\', (d\', Dplus, Dminus))  = let name = conDecName (sgnLookup a) let l = (match (nameLookup name) with NONE -> raise (Error ("Lemma " ^ name ^ " not defined")) | SOME lemma -> lemma) in (d\' + 1, w\'\', t\'\', Lemma (l, Dplus (1, Dminus))) in if exists (fun x -> x = a) Ts then varHead Ts (w\'\', t\'\', (d\', Dplus, Dminus)) else lemmaHead (w\'\', t\'\', (d\', Dplus, Dminus)) (* transformConc ((a, S), w) = P\n\n       Invariant:\n       If   Sigma (a) = {x1:A1} .. {xn:An} type\n       and  Psi |- S : m1{x1:A1} .. mn{xn:An} type > type\n       and  Psi |- w : PsiAll\n       then P is proof term consisting of all - objects of S,\n            defined in PsiAll\n    *) let rec transformConc ((a, S), w)  = let mS = match modeLookup a with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let rec transformConc\' (Nil, Mnil)  = Unit | transformConc\' (App (U, S\'), Mapp (Marg (Plus, _), mS\'))  = transformConc\' (S\', mS\') | transformConc\' (App (U, S\'), Mapp (Marg (Minus, _), mS\'))  = Inx (strengthenExp (U, w), transformConc\' (S\', mS\')) in transformConc\' (S, mS) (* traverse (Ts, c) = L\'\n\n       Invariant:\n       If   Ts is a list of type families\n       and  c is a type family which entries are currently traversed\n       then L\' is a list of cases\n    *) let rec traverse (Ts, c)  = (* traverseNeg (c\'\', Psi, (V, v), L) = ([w\', d\', PQ\'], L\')    [] means optional\n\n           Invariant:\n           If   Psi0 |- V : type\n           and  Psi0 |- v : Psi\n           and  V[v^-1] does not contain Skolem constants\n           and  c\'\' is the name of the object constant currently considered\n           and  L is a list of cases\n           then L\' list of cases and CL\' extends CL\n           and  Psi |- w\' : Psi\'   (Psi\' is the context of all variables considered so far)\n           and  d\' is the length of Delta\n           and  PQ\'  is a pair, generating the proof term\n        *) let rec traverseNeg (c\'\', Psi, (Pi ((D as Dec (_, V1), Maybe), V2), v), L)  = (match traverseNeg (c\'\', Decl (Psi, Prim (strengthenDec (D, v))), (*                                   (Names.decName (F.makectx Psi, Weaken.strengthenDec (D, v)))),\n*) , (V2, dot1 v), L) with (SOME (w\', d\', PQ\'), L\') -> (SOME (peel w\', d\', PQ\'), L\') | (NONE, L\') -> (NONE, L\')) | traverseNeg (c\'\', Psi, (Pi ((D as Dec (_, V1), No), V2), v), L)  = (match traverseNeg (c\'\', Psi, (V2, comp (v, shift)), L) with (SOME (w\', d\', PQ\'), L\') -> traversePos (c\'\', Psi, Null, (strengthenExp (V1, v), id), SOME (w\', d\', PQ\'), L\') | (NONE, L\') -> traversePos (c\'\', Psi, Null, (strengthenExp (V1, v), id), NONE, L\')) | traverseNeg (c\'\', Psi, (V as Root (Const c\', S), v), L)  = if c = c\' then (* Clause head found *) let S\' = strengthenSpine (S, v) let (Psi\', w\') = strengthen (Psi, (c\', S\'), Shift (lfctxLength Psi), Plus) let (w\'\', s\'\') = transformInit (Psi\', (c\', S\'), w\') in (SOME (w\', 1, (fun p -> (Psi\', s\'\', p), fun wf -> transformConc ((c\', S\'), wf))), L) else (NONE, L)(* traversePos (c, Psi, G, (V, v), [w\', d\', PQ\'], L) =  ([w\'\', d\'\', PQ\'\'], L\'\')\n\n           Invariant:\n           If   Psi, G |- V : type\n           and  Psi, G |- v : Psi\'       (s.t.  Psi\' |- V[v^-1] : type exists)\n           and V[v^-1] does not contain Skolem constants\n           [ and Psi\', G |- w\' : Psi\'\'\n             and |Delta\'| = d\'    for a Delta\'\n             and PQ\' can generate the proof term so far in Delta\'; Psi\'\'\n           ]\n           and  c is the name of the constant currently considered\n           and  L is a list of cases\n           then L\'\' list of cases and L\'\' extends L\n           and  Psi |- w\'\' : Psi2\n           and  |Delta\'\'| = d\'\'  for a Delta\'\n           and  PQ\'\' can genreate the proof term so far in Delta\'\'; Psi2\n        *) traversePos (c\'\', Psi, G, (Pi ((D as Dec (_, V1), Maybe), V2), v), SOME (w, d, PQ), L)  = (match traversePos (c\'\', Psi, Decl (G, strengthenDec (D, v)), (V2, dot1 v), SOME (dot1 w, d, PQ), L) with (SOME (w\', d\', PQ\'), L\') -> (SOME (w\', d\', PQ\'), L\')) | traversePos (c\'\', Psi, G, (Pi ((D as Dec (_, V1), No), V2), v), SOME (w, d, PQ), L)  = (match traversePos (c\'\', Psi, G, (V2, comp (v, shift)), SOME (w, d, PQ), L) with (SOME (w\', d\', PQ\'), L\') -> (match traverseNeg (c\'\', Decl (Psi, Block (CtxBlock (NONE, G))), (V1, v), L\') with (SOME (w\'\', d\'\', (P\'\', Q\'\')), L\'\') -> (SOME (w\', d\', PQ\'), (P\'\' (Q\'\' w\'\')) :: L\'\') | (NONE, L\'\') -> (SOME (w\', d\', PQ\'), L\'\'))) | traversePos (c\'\', Psi, Null, (V, v), SOME (w1, d, (P, Q)), L)  = (* Lemma calls (no context block) *) (* provide typeCheckCtx from typecheck *) let Root (Const a\', S) = normalize (strengthenExp (V, v), id) let (Psi\', w2) = strengthen (Psi, (a\', S), w1, Minus) let _ = if ! doubleCheck then typeCheck (makectx Psi\', (Uni Type, Uni Kind)) else () let w3 = strengthenSub (w1, w2) let (d4, w4, t4, Ds) = transformDec (Ts, (Psi\', Null), d, (a\', S), w1, w2, w3) in (SOME (w2, d4, (fun p -> P (Let (Ds, Case (Opts [(Psi\', t4, p)]))), Q)), L) | traversePos (c\'\', Psi, G, (V, v), SOME (w1, d, (P, Q)), L)  = (* Lemma calls (under a context block) *) (* provide typeCheckCtx from typecheck *) (* change w1 to w1\' and w2 to w2\' below *) let Root (Const a\', S) = strengthenExp (V, v) let (dummy as Decl (Psi\', Block (CtxBlock (name, G2))), w2) = strengthen (Decl (Psi, Block (CtxBlock (NONE, G))), (a\', S), w1, Minus) let _ = if ! doubleCheck then typeCheck (makectx dummy, (Uni Type, Uni Kind)) else () let g = ctxLength G let w1\' = peeln (g, w1) let w2\' = peeln (g, w2) let (G1, _) = strengthenCtx (G, w1\') let w3 = strengthenSub (w1\', w2\') let (d4, w4, t4, Ds) = transformDec (Ts, (Psi\', G), d, (a\', S), w1, w2\', w3) in (SOME (w2\', d4, (fun p -> P (Let (New (CtxBlock (NONE, G1), Ds), Case (Opts [(Psi\', t4, p)]))), Q)), L) | traversePos (c\'\', Psi, G, (Pi ((D as Dec (_, V1), Maybe), V2), v), NONE, L)  = traversePos (c\'\', Psi, Decl (G, strengthenDec (D, v)), (V2, dot1 v), NONE, L) | traversePos (c\'\', Psi, G, (Pi ((D as Dec (_, V1), No), V2), v), NONE, L)  = (match traversePos (c\'\', Psi, G, (V2, comp (v, shift)), NONE, L) with (NONE, L\') -> (match traverseNeg (c\'\', Decl (Psi, Block (CtxBlock (NONE, G))), (V1, v), L\') with (SOME (w\'\', d\'\', (P\'\', Q\'\')), L\'\') -> (NONE, (P\'\' (Q\'\' w\'\')) :: L\'\') | (NONE, L\'\') -> (NONE, L\'\'))) | traversePos (c\'\', Psi, G, (V, v), NONE, L)  = (NONE, L) let rec traverseSig\' (c\'\', L)  = if c\'\' = 1 (sgnSize ()) then L else (match sgnLookup (c\'\') with ConDec (name, _, _, _, V, Type) -> (match traverseNeg (c\'\', Null, (V, id), L) with (SOME (wf, d\', (P\', Q\')), L\') -> traverseSig\' (c\'\' + 1, (P\' (Q\' wf)) :: L\') | (NONE, L\') -> traverseSig\' (c\'\' + 1, L\')) | _ -> traverseSig\' (c\'\' + 1, L)) in traverseSig\' (0, nil) (* convertPro Ts = P\'\n\n       Invariant:\n       If   Ts is a list of type families\n       then P\' is a conjunction of all programs resulting from converting\n            the relational encoding of the function expressed by each type\n            family in Ts into functional form\n    *) let rec convertPro Ts  = let rec convertOnePro a  = let V = match sgnLookup a with ConDec (name, _, _, _, V, Kind) -> V | _ -> raise (Error "Type Constant declaration expected") let mS = match modeLookup a with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let P = abstract a in P (Case (Opts (traverse (Ts, a)))) let rec convertPro\' nil  = raise (Error "Cannot convert Empty program") | convertPro\' [a]  = convertOnePro a | convertPro\' (a :: Ts\')  = Pair (convertOnePro a, convertPro\' Ts\') let R = recursion Ts in R (convertPro\' Ts) let convertFor = convertFor let convertPro = convertPro let traverse = traverse  end(* functor FunSyn *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Internal syntax for functional proof term calculus *) (* Author: Carsten Schuermann *) module type FUNSYN = sig (*! structure IntSyn : INTSYN !*) (* make abstract *) type label = inttype lemma = inttype LabelDecLabelDecstring * Dec list * Dec list(* BB ::= l: SOME Theta. Phi  *) type CtxBlockCtxBlocklabel option * dctx(* B ::= l : Phi              *) type LFDecPrimDecBlockCtxBlock(*      | B                   *) (* ??? *) type lfctx = LFDec Ctx(* Psi ::= . | Psi, LD        *) type ForAllLFDec * ForExDec * ForTrueAndFor * For(*     | F1 ^ F2              *) type ProLamLFDec * ProInxExp * ProUnitRecMDec * ProLetDecs * ProCaseOptsPairPro * Pro and OptsOptslfctx * Sub * Pro list and MDecMDecstring option * For and DecsEmptySplitint * DecsNewCtxBlock * DecsApp(int * Exp) * DecsPApp(int * int) * DecsLemmalemma * DecsLeftint * DecsRightint * Decs(*      | xx = pi2 yy, Ds     *) type LemmaDecLemmaDecstring list * Pro * For(* L ::= c:F = P              *) (* ??? *) type mctx = MDec Ctx(* Delta ::= . | Delta, xx : F*) val labelLookup : label -> LabelDecval labelAdd : LabelDec -> labelval labelSize : unit -> intval labelReset : unit -> unitval lemmaLookup : lemma -> LemmaDecval lemmaAdd : LemmaDec -> lemmaval lemmaSize : unit -> intval mdecSub : MDec * Sub -> MDecval makectx : lfctx -> dctxval lfctxLength : lfctx -> intval lfctxLFDec : (lfctx * int) -> (LFDec * Sub)val dot1n : (dctx * Sub) -> Subval convFor : (For * Sub) * (For * Sub) -> boolval forSub : For * Sub -> Forval normalizeFor : For * Sub -> Forval listToCtx : Dec list -> dctxval ctxToList : dctx -> Dec list end(* Signature FUNSYN *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Theorem Prover Version 1.3 *) (* Author: Carsten Schuermann *) module MTProver (module MTPGlobal : MTPGLOBAL(*! structure IntSyn\' : INTSYN !*) (*! structure FunSyn : FUNSYN !*) (*! sharing FunSyn.IntSyn = IntSyn\' !*) module StateSyn : STATESYN(*! sharing IntSyn = IntSyn\' !*) (*! sharing StateSyn.FunSyn = FunSyn !*) module Order : ORDER(*! sharing Order.IntSyn = IntSyn\' !*) module MTPInit : MTPINIT(*! sharing MTPInit.FunSyn = FunSyn !*) MTPInitStateSynStateSynmodule MTPStrategy : MTPSTRATEGYMTPStrategyStateSynStateSynmodule RelFun : RELFUN(*! sharing RelFun.FunSyn = FunSyn !*) ) : PROVER = struct (*! structure IntSyn = IntSyn\' !*)  exception Error of string module I = IntSynmodule F = FunSynmodule S = StateSyn(* DISCLAIMER: This functor is temporary. Its purpose is to\n       connect the new prover to Twelf  (see also functor below) *) (* List of open states *) let openStates : State list ref = ref nil (* List of solved states *) let solvedStates : State list ref = ref nil let rec transformOrder\' (G, Arg k)  = let k\' = (ctxLength G) - k + 1 let Dec (_, V) = ctxDec (G, k\') in Arg ((Root (BVar k\', Nil), id), (V, id)) | transformOrder\' (G, Lex Os)  = Lex (map (fun O -> transformOrder\' (G, O)) Os) | transformOrder\' (G, Simul Os)  = Simul (map (fun O -> transformOrder\' (G, O)) Os) let rec transformOrder (G, All (Prim D, F), Os)  = All (D, transformOrder (Decl (G, D), F, Os)) | transformOrder (G, And (F1, F2), O :: Os)  = And (transformOrder (G, F1, [O]), transformOrder (G, F2, Os)) | transformOrder (G, Ex _, [O])  = transformOrder\' (G, O) | transformOrder (G, True, [O])  = transformOrder\' (G, O) (* last case: no existentials---order must be trivial *) let rec select c  = (try  with ) let rec error s  = raise (Error s) (* reset () = ()\n\n       Invariant:\n       Resets the internal state of open states/solved states\n    *) let rec reset ()  = (openStates := nil; solvedStates := nil) (* contains (L1, L2) = B\'\n\n       Invariant:\n       B\' holds iff L1 subset of L2 (modulo permutation)\n    *) let rec contains (nil, _)  = true | contains (x :: L, L\')  = (exists (fun x\' -> x = x\') L\') && contains (L, L\') (* equiv (L1, L2) = B\'\n\n       Invariant:\n       B\' holds iff L1 is equivalent to L2 (modulo permutation)\n    *) let rec equiv (L1, L2)  = contains (L1, L2) && contains (L2, L1) (* insertState S = ()\n\n       Invariant:\n       If S is successful prove state, S is stored in solvedStates\n       else S is stored in openStates\n    *) let rec insertState S  = openStates := S :: (! openStates) (* cLtoString L = s\n\n       Invariant:\n       If   L is a list of cid,\n       then s is a string, listing their names\n    *) let rec cLToString (nil)  = "" | cLToString (c :: nil)  = (conDecName (sgnLookup c)) | cLToString (c :: L)  = (conDecName (sgnLookup c)) ^ ", " ^ (cLToString L) (* init (k, cL) = ()\n\n       Invariant:\n       If   k is the maximal search depth\n       and  cL is a complete and consistent list of cids\n       then init initializes the openStates/solvedStates\n       else an Error exception is raised\n    *) let rec init (k, cL as (c :: _))  = (* if no termination ordering given! *) let _ = maxFill := k let _ = reset () let cL\' = try  with  let F = convertFor cL let O = transformOrder (Null, F, map select cL) in if equiv (cL, cL\') then app (fun S -> insertState S) (init (F, O)) else raise (Error ("Theorem by simultaneous induction not correctly stated:" ^ "\\n            expected: " ^ (cLToString cL\'))) (* auto () = ()\n\n       Invariant:\n       Solves as many States in openStates\n       as possible.\n    *) let rec auto ()  = let (Open, solvedStates\') = try  with  let _ = openStates := Open let _ = solvedStates := (! solvedStates) @ solvedStates\' in if (length (! openStates)) > 0 then raise (Error ("A proof could not be found")) else () let rec print ()  = () let rec install _  = () let init = init let auto = auto let print = print let install = install  (* local *)  end(* functor MTProver *) module CombiProver (module MTPGlobal : MTPGLOBAL(*! structure IntSyn\' : INTSYN !*) module ProverOld : PROVER(*! sharing ProverOld.IntSyn = IntSyn\' !*) module ProverNew : PROVER(*! sharing ProverNew.IntSyn = IntSyn\' !*) ) : PROVER = struct (*! structure IntSyn = IntSyn\' !*)  exception Error of string let rec he f  = try  with let rec init Args  = he (fun () -> match ! (prover) with New -> init Args | Old -> init Args) let rec auto Args  = he (fun () -> match ! (prover) with New -> auto Args | Old -> auto Args) let rec print Args  = he (fun () -> match ! (prover) with New -> print Args | Old -> print Args) let rec install Args  = he (fun () -> match ! (prover) with New -> install Args | Old -> install Args) let init = init let auto = auto let print = print let install = install  (* local *)  end(* functor CombiProver *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Weakening substitutions for meta substitutions *) (* Author: Carsten Schuermann *) module type FUNWEAKEN = sig (*! structure FunSyn : FUNSYN !*) val strengthenPsi : (lfctx * Sub) -> (lfctx * Sub)val strengthenPsi' : (LFDec list * Sub) -> (LFDec list * Sub) end(* signature FUNWEAKEN *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Initialization *) (* Author: Carsten Schuermann *) module type MTPINIT = sig (*! structure FunSyn : FUNSYN !*) module StateSyn : STATESYNexception Error of string(* Current restriction to non-mutual inductive theorems ! *) val init : (For * Order) -> State list end\n(* signature MTPINIT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Meta Global parameters *) (* Author: Carsten Schuermann *) module MTPData (module MTPGlobal : MTPGLOBAL) : MTPDATA = struct let maxFill = ref 0 end\n(* structure MTPData*) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Splitting : Version 1.3 *) (* Author: Carsten Schuermann *) module type MTPSPLITTING = sig module StateSyn : STATESYNexception Error of stringtype operatorval expand : State -> operator listval applicable : operator -> boolval apply : operator -> State listval menu : operator -> stringval index : operator -> intval compare : operator * operator -> order end\n(* signature MTPSPLITTING *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Recursion: Version 1.3 *) (* Author: Carsten Schuermann *) module type MTPRECURSION = sig module StateSyn : STATESYNexception Error of stringtype operatorval expand : State -> operatorval apply : operator -> Stateval menu : operator -> string end\n(* signature MTPRECURSION *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Filling: Version 1.3 *) (* Author: Carsten Schuermann *) module type MTPFILLING = sig (*! structure FunSyn : FUNSYN !*) module StateSyn : STATESYNexception Error of stringexception TimeOuttype operatorval expand : State -> operatorval apply : operator -> (int * Pro)val menu : operator -> string end\n(* signature MTPFILLING *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module Cover = Cover(struct module Global = Global module Whnf = Whnf module Conv = Conv module Abstract = Abstract module Unify = UnifyTrail module Constraints = Constraints module ModeTable = ModeTable module UniqueTable = UniqueTable module Index = Index module Subordinate = Subordinate module WorldSyn = WorldSyn module Names = Names module Print = Print module TypeCheck = TypeCheck module Timers = Timers end)
module Total = Total(struct module Global = Global module Table = IntRedBlackTree module Whnf = Whnf module Names = Names module ModeTable = ModeTable module ModeCheck = ModeCheck module Index = Index module Subordinate = Subordinate module Order = Order module Reduces = Reduces module Cover = Cover module Origins = Origins module Timers = Timers end)

('Error parsing code:', '(* Coverage Checking *) (* Author: Frank Pfenning *) module type COVER = sig exception Error of stringval checkNoDef : cid -> unit(* raises Error(msg) *) val checkOut : (dctx * eclo) -> unitval checkCovers : (cid * ModeSpine) -> unitval coverageCheckCases : Worlds * dctx * Sub list * dctx -> unit end\n(* signature COVER *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module Cover = Cover(struct module Global = Global module Whnf = Whnf module Conv = Conv module Abstract = Abstract module Unify = UnifyTrail module Constraints = Constraints module ModeTable = ModeTable module UniqueTable = UniqueTable module Index = Index module Subordinate = Subordinate module WorldSyn = WorldSyn module Names = Names module Print = Print module TypeCheck = TypeCheck module Timers = Timers end)
module Total = Total(struct module Global = Global module Table = IntRedBlackTree module Whnf = Whnf module Names = Names module ModeTable = ModeTable module ModeCheck = ModeCheck module Index = Index module Subordinate = Subordinate module Order = Order module Reduces = Reduces module Cover = Cover module Origins = Origins module Timers = Timers end)

('Error parsing code:', '(* Total Declarations *) (* Author: Frank Pfenning *) module Total (module Global : GLOBALmodule Table : TABLE where keyint(*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = IntSyn\' !*) module ModeCheck : MODECHECKmodule Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) module Order : ORDER(*! sharing Order.IntSyn = IntSyn\' !*) module Reduces : REDUCES(*! sharing Reduces.IntSyn = IntSyn\' !*) module Cover : COVER(*! structure Paths : PATHS !*) module Origins : ORIGINS(*! sharing Origins.Paths = Paths !*) (*! sharing Origins.IntSyn = IntSyn\' !*) module Timers : TIMERS) : TOTAL = struct (*! structure IntSyn = IntSyn\' !*)  exception Error of string module I = IntSynmodule P = Pathsmodule M = ModeSynmodule N = Names(* totalTable (a) = SOME() iff a is total, otherwise NONE *) let totalTable : unit Table = new (0) let rec reset ()  = clear totalTable let rec install (cid)  = insert totalTable (cid, ()) let rec lookup (cid)  = lookup totalTable (cid) let rec uninstall (cid)  = delete totalTable (cid) let reset = reset let install = install let uninstall = (fun cid -> match lookup cid with NONE -> false | SOME _ -> (uninstall cid; true)) let rec total (cid)  = (* call only on constants *)  match lookup cid with NONE -> false | SOME _ -> true exception Error\' of occ * string (* copied from terminates/reduces.fun *) let rec error (c, occ, msg)  = (match originLookup c with (fileName, NONE) -> raise (Error (fileName ^ ":" ^ msg)) | (fileName, SOME occDec) -> raise (Error (wrapLoc\' (Loc (fileName, occToRegionDec occDec occ), linesInfoLookup (fileName), msg)))) (* G is unused here *) let rec checkDynOrder (G, Vs, 0, occ)  = (* raise Error\' (occ, "Output coverage for clauses of order >= 3 not yet implemented") *)  (* Functional calculus now checks this *)  (* Sun Jan  5 12:17:06 2003 -fp *)  (if ! chatter >= 5 then print ("Output coverage: skipping redundant checking of third-order clause\\n") else (); ()) | checkDynOrder (G, Vs, n, occ)  = (* n > 0 *)  checkDynOrderW (G, whnf Vs, n, occ)checkDynOrderW (G, (Root _, s), n, occ)  = () | checkDynOrderW (G, (Pi ((D1 as Dec (_, V1), No), V2), s), n, occ)  = (* dynamic (= non-dependent) assumption --- calculate dynamic order of V1 *)  (checkDynOrder (G, (V1, s), n - 1, label occ); checkDynOrder (Decl (G, D1), (V2, dot1 s), n, body occ)) | checkDynOrderW (G, (Pi ((D1, Maybe), V2), s), n, occ)  = (* static (= dependent) assumption --- consider only body *)  checkDynOrder (Decl (G, D1), (V2, dot1 s), n, body occ) (* checkClause (G, (V, s), occ) = ()\n       checkGoal (G, (V, s), occ) = ()\n       iff local output coverage for V is satisfied\n           for clause V[s] or goal V[s], respectively.\n       Effect: raises Error\' (occ, msg) if coverage is not satisfied at occ.\n\n       Invariants: G |- V[s] : type\n    *) let rec checkClause (G, Vs, occ)  = checkClauseW (G, whnf Vs, occ)checkClauseW (G, (Pi ((D1, Maybe), V2), s), occ)  = (* quantifier *)  let D1\' = decEName (G, decSub (D1, s)) in checkClause (Decl (G, D1\'), (V2, dot1 s), body occ) | checkClauseW (G, (Pi ((D1 as Dec (_, V1), No), V2), s), occ)  = (* subgoal *)  let _ = checkClause (Decl (G, D1), (V2, dot1 s), body occ) in checkGoal (G, (V1, s), label occ) | checkClauseW (G, (Root _, s), occ)  = (* clause head *)  ()checkGoal (G, Vs, occ)  = checkGoalW (G, whnf Vs, occ)checkGoalW (G, (V, s), occ)  = (* can raise Cover.Error for third-order clauses *) let a = targetFam V let _ = if not (total a) then raise (Error\' (occ, "Subgoal " ^ qidToString (constQid a) ^ " not declared to be total")) else () let _ = checkDynOrderW (G, (V, s), 2, occ) in try  with (* checkDefinite (a, ms) = ()\n       iff every mode in mode spine ms is either input or output\n       Effect: raises Error (msg) otherwise\n    *) let rec checkDefinite (a, Mnil)  = () | checkDefinite (a, Mapp (Marg (Plus, _), ms\'))  = checkDefinite (a, ms\') | checkDefinite (a, Mapp (Marg (Minus, _), ms\'))  = checkDefinite (a, ms\') | checkDefinite (a, Mapp (Marg (Star, xOpt), ms\'))  = (* Note: filename and location are missing in this error message *)  (* Fri Apr  5 19:25:54 2002 -fp *)  error (a, top, "Error: Totality checking " ^ qidToString (constQid a) ^ ":\\n" ^ "All argument modes must be input (+) or output (-)" ^ (match xOpt with NONE -> "" | SOME (x) -> " but argument " ^ x ^ " is indefinite (*)")) (* checkOutCover [c1,...,cn] = ()\n       iff local output coverage for every subgoal in ci:Vi is satisfied.\n       Effect: raises Error (msg) otherwise, where msg has filename and location.\n    *) let rec checkOutCover nil  = () | checkOutCover (Const (c) :: cs)  = (if ! chatter >= 4 then print (qidToString (constQid c) ^ " ") else (); if ! chatter >= 6 then print ("\\n") else (); try  with ; checkOutCover cs) | checkOutCover (Def (d) :: cs)  = (if ! chatter >= 4 then print (qidToString (constQid d) ^ " ") else (); if ! chatter >= 6 then print ("\\n") else (); try  with ; checkOutCover cs) (* checkFam (a) = ()\n       iff family a is total in its input arguments.\n       This requires termination, input coverage, and local output coverage.\n       Currently, there is no global output coverage.\n       Effect: raises Error (msg) otherwise, where msg has filename and location.\n    *) let rec checkFam (a)  = (* Ensuring that there is no bad interaction with type-level definitions *) (* a cannot be a type-level definition *) (* Checking termination *) (* Checking input coverage *) (* by termination invariant, there must be consistent mode for a *) (* must be defined and well-moded *) (* all arguments must be either input or output *) (* Checking output coverage *) (* all variables in output args must be free *) let _ = checkNoDef (a) let _ = try  with  let _ = try  with  let SOME (ms) = modeLookup a let _ = checkDefinite (a, ms) let _ = try  with  let _ = if ! chatter >= 4 then print ("Output coverage checking family " ^ qidToString (constQid a) ^ "\\n") else () let _ = checkFreeOut (a, ms) let cs = lookup a let _ = try  with  in ()  end\n(* functor Total *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Total Declarations *) (* Author: Frank Pfenning *) module type TOTAL = sig (*! structure IntSyn : INTSYN !*) exception Error of stringval reset : unit -> unitval install : cid -> unit(* install(a) --- a is total in its input arguments *) val uninstall : cid -> bool(* true: was known to be total *) val checkFam : cid -> unit(* may raise Error(msg) *)  end\n(* signature TOTAL *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Uniqueness Checking *) (* Author: Frank Pfenning *) module type UNIQUE = sig exception Error of stringval checkUnique : (cid * ModeSpine) -> unit(* raises Error(msg) *)  end\n(* signature UNIQUE *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module UniqueTable = ModeTable(module Table = IntRedBlackTree)\nmodule UniqueCheck = ModeCheck(struct module ModeTable = UniqueTable module Whnf = Whnf module Index = Index module Origins = Origins end)\nmodule Unique = Unique(struct module Global = Global module Whnf = Whnf module Abstract = Abstract module Unify = UnifyTrail module Constraints = Constraints module UniqueTable = UniqueTable module UniqueCheck = UniqueCheck module Index = Index module Subordinate = Subordinate module WorldSyn = WorldSyn module Names = Names module Print = Print module TypeCheck = TypeCheck module Timers = Timers end)\n', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module UniqueTable = ModeTable(module Table = IntRedBlackTree)\nmodule UniqueCheck = ModeCheck(struct module ModeTable = UniqueTable module Whnf = Whnf module Index = Index module Origins = Origins end)\nmodule Unique = Unique(struct module Global = Global module Whnf = Whnf module Abstract = Abstract module Unify = UnifyTrail module Constraints = Constraints module UniqueTable = UniqueTable module UniqueCheck = UniqueCheck module Index = Index module Subordinate = Subordinate module WorldSyn = WorldSyn module Names = Names module Print = Print module TypeCheck = TypeCheck module Timers = Timers end)\n', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Termination Order *) (* Author: Carsten Schuermann *) module type ORDER = sig (*! structure IntSyn : INTSYN !*) exception Error of stringtype 'aOrderArg'aLex'a Order listSimul'a Order list(*     | [O1 .. On]           *) type PredicateLessint Order * int OrderLeqint Order * int OrderEqint Order * int Order(* O = O'                     *) type MutualEmptyLEcid * MutualLTcid * Mutual(*     | lex order for  -     *) type TDecTDecint Order * Mutualtype RDecRDecPredicate * Mutualval reset : unit -> unitval resetROrder : unit -> unitval install : cid * TDec -> unitval uninstall : cid -> boolval installROrder : cid * RDec -> unitval uninstallROrder : cid -> boolval selLookup : cid -> int Orderval selLookupROrder : cid -> Predicateval mutLookup : cid -> Mutualval closure : cid -> cid list end\n(* signature ORDER *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module Order = Order(module Table = IntRedBlackTree)\n(* -bp *) (*\nstructure RedOrder = \n    RedOrder ((*! structure IntSyn' = IntSyn !*)\n\t      structure Table = IntRedBlackTree); \n*) ", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module Order = Order(module Table = IntRedBlackTree)\n(* -bp *) (*\nstructure RedOrder = \n    RedOrder ((*! structure IntSyn' = IntSyn !*)\n\t      structure Table = IntRedBlackTree); \n*) ", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Syntax for elaborated modules *) (* Author: Kevin Watkins *) module type MODSYN = sig (*! structure IntSyn : INTSYN !*) module Names : NAMES(*! structure Paths : PATHS !*) exception Error of stringval abbrevify : cid * ConDec -> ConDecval strictify : ConDec -> ConDectype module(*\n  type action = IntSyn.cid * (string * Paths.occConDec option) -> unit\n  type transform = IntSyn.cid * IntSyn.ConDec -> IntSyn.ConDec\n  *) val installStruct : StrDec * module * namespace option * (cid * (string * occConDec option) -> unit)(* action *)  * bool -> unitval installSig : module * namespace option * (cid * (string * occConDec option) -> unit)(* action *)  * bool -> unitval instantiateModule : module * (namespace -> (cid * ConDec -> ConDec))(* Names.namespace -> transform *)  -> module(* Extract some entries of the current global signature table in order\n     to create a self-contained module.\n  *) val abstractModule : namespace * mid option -> moduleval reset : unit -> unitval installSigDef : string * module -> unit(* Error if would shadow *) val lookupSigDef : string -> module optionval sigDefSize : unit -> intval resetFrom : int -> unit end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Syntax for elaborated modules *) (* Author: Kevin Watkins *) module ModSyn (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Names\' : NAMES(*! sharing Names\'.IntSyn = IntSyn\' !*) (*! structure Paths\' : PATHS !*) module Origins : ORIGINS(*! sharing Origins.Paths = Paths\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Strict : STRICT(*! sharing Strict.IntSyn = IntSyn\' !*) module IntTree : TABLE where keyintmodule HashTable : TABLE where keystring) : MODSYN = struct (*! structure IntSyn = IntSyn\' !*)  module Names = Names\' (*! structure Paths = Paths\' !*)  module I = IntSyn exception Error of string type ConstInfo = ConstInfo of ConDec * fixity * string list * string list option * (string * occConDec option) type StructInfo = StructInfo of StrDec (* A module consists of:\n     1. a map from cids to constant entries containing\n          a. a constant declaration entry (IntSyn.ConDec)\n          b. the fixity of the constant\n          c. the name preference for the constant (if any)\n     2. a map from mids to structure entries containing\n          a. a structure declaration entry (IntSyn.StrDec)\n          b. the namespace of the structure\n     3. the top-level namespace of the module *)  type module = StructInfo Table * ConstInfo Table * namespace type action = cid * (string * occConDec option) -> unit type transform = cid * ConDec -> ConDec (* invariant: U in nf, result in nf *)  let rec mapExpConsts f U  = open IntSyn let rec trExp (Uni L)  = Uni L | trExp (Pi ((D, P), V))  = Pi ((trDec D, P), trExp V) | trExp (Root (H, S))  = Root (trHead H, trSpine S) | trExp (Lam (D, U))  = Lam (trDec D, trExp U) | trExp (U as FgnExp csfe)  = apply csfe trExptrDec (Dec (name, V))  = Dec (name, trExp V)trSpine Nil  = Nil | trSpine (App (U, S))  = App (trExp U, trSpine S)trHead (BVar n)  = BVar n | trHead (Const cid)  = trConst cid | trHead (Skonst cid)  = trConst cid | trHead (Def cid)  = trConst cid | trHead (NSDef cid)  = trConst cid | trHead (FgnConst (csid, condec))  = FgnConst (csid, mapConDecConsts f condec)trConst cid  = let cid\' = f cid in match sgnLookup cid\' with ConDec _ -> Const cid\' | SkoDec _ -> Skonst cid\' | ConDef _ -> Def cid\' | AbbrevDef _ -> NSDef cid\' in normalize (trExp U, id)mapConDecConsts f (ConDec (name, parent, i, status, V, L))  = ConDec (name, parent, i, status, mapExpConsts f V, L) | mapConDecConsts f (ConDef (name, parent, i, U, V, L, Anc))  = ConDef (name, parent, i, mapExpConsts f U, mapExpConsts f V, L, Anc) | mapConDecConsts f (AbbrevDef (name, parent, i, U, V, L))  = AbbrevDef (name, parent, i, mapExpConsts f U, mapExpConsts f V, L) | mapConDecConsts f (SkoDec (name, parent, i, V, L))  = SkoDec (name, parent, i, mapExpConsts f V, L) let rec mapStrDecParent f (StrDec (name, parent))  = StrDec (name, f parent) let rec mapConDecParent f (ConDec (name, parent, i, status, V, L))  = ConDec (name, f parent, i, status, V, L) | mapConDecParent f (ConDef (name, parent, i, U, V, L, Anc))  = ConDef (name, f parent, i, U, V, L, Anc) | mapConDecParent f (AbbrevDef (name, parent, i, U, V, L))  = AbbrevDef (name, f parent, i, U, V, L) | mapConDecParent f (SkoDec (name, parent, i, V, L))  = SkoDec (name, f parent, i, V, L) let rec strictify (condec as AbbrevDef (name, parent, i, U, V, Type))  = (try  with ) | strictify (condec as AbbrevDef _)  = condec let rec abbrevify (cid, condec)  = (match condec with ConDec (name, parent, i, _, V, L) -> let U = normalize (Root (Const cid, Nil), id) in AbbrevDef (name, parent, i, U, V, L) | SkoDec (name, parent, i, V, L) -> let U = normalize (Root (Skonst cid, Nil), id) in AbbrevDef (name, parent, i, U, V, L) | ConDef (name, parent, i, U, V, L, Anc) -> AbbrevDef (name, parent, i, U, V, L) | AbbrevDef data -> AbbrevDef data) (* In order to install a module, we walk through the mids in preorder,\n     assigning global mids and building up a translation map from local\n     mids to global mids.  Then we walk through the cids in dependency\n     order, assigning global cids, building up a translation map from\n     local to global cids, and replacing the cids contained in the terms\n     with their global equivalents.\n\n     NOTE that a module might not be closed with respect to the local\n     cids; that is, it might refer to global cids not defined by the\n     module.  It is a global invariant that such cids will still be in\n     scope whenever a module that refers to them is installed. *)  let rec installModule ((structTable, constTable, namespace), topOpt, nsOpt, installAction, transformConDec)  = let structMap : mid Table = new (0) let constMap : cid Table = new (0) let rec mapStruct mid  = valOf (lookup structMap mid) let rec mapParent NONE  = topOpt | mapParent (SOME parent)  = SOME (mapStruct parent) let rec mapConst cid  = (match lookup constMap cid with NONE -> cid | SOME cid\' -> cid\') let rec doStruct (mid, StructInfo strdec)  = let strdec\' = mapStrDecParent mapParent strdec let mid\' = sgnStructAdd strdec\' let parent = strDecParent strdec\' let nsOpt = (match parent with NONE -> nsOpt | SOME mid -> SOME (getComponents mid)) let _ = (match nsOpt with SOME ns -> insertStruct (ns, mid\') | _ -> ()) let _ = (match parent with NONE -> installStructName mid\' | _ -> ()) let ns = newNamespace () let _ = installComponents (mid\', ns) in insert structMap (mid, mid\') let rec doConst (cid, ConstInfo (condec, fixity, namePrefOpt, origin))  = let condec1 = mapConDecParent mapParent condec let condec2 = mapConDecConsts mapConst condec1 let condec3 = transformConDec (cid, condec2) let cid\' = sgnAdd condec3 let parent = conDecParent condec3 let nsOpt = (match parent with NONE -> nsOpt | SOME mid -> SOME (getComponents mid)) let _ = (match nsOpt with SOME ns -> insertConst (ns, cid\') | _ -> ()) let _ = (match parent with NONE -> installConstName cid\' | _ -> ()) let _ = installAction (cid\', origin) let _ = (match fixity with Nonfix -> () | _ -> installFixity (cid\', fixity)) let _ = (match namePrefOpt with NONE -> () | SOME (n1, n2) -> installNamePref (cid\', (n1, n2))) in insert constMap (cid, cid\') in app doStruct structTable; app doConst constTable let decToDef = strictify o abbrevify let rec installStruct (strdec, module, nsOpt, installAction, isDef)  = let transformConDec = if isDef then decToDef else (fun (_, condec) -> condec) let mid = sgnStructAdd strdec let _ = match nsOpt with SOME namespace -> insertStruct (namespace, mid) | _ -> () let _ = installStructName mid let ns = newNamespace () let _ = installComponents (mid, ns) in installModule (module, SOME mid, NONE, installAction, transformConDec) let rec installSig (module, nsOpt, installAction, isDef)  = let transformConDec = if isDef then decToDef else (fun (_, condec) -> condec) in installModule (module, NONE, nsOpt, installAction, transformConDec) let rec abstractModule (namespace, topOpt)  = let structTable : StructInfo Table = new (0) let constTable : ConstInfo Table = new (0) let mapParent = (match topOpt with NONE -> (fun parent -> parent) | SOME mid -> (fun SOME mid\' -> if mid = mid\' then NONE else SOME mid\')) let rec doStruct (_, mid)  = let strdec = sgnStructLookup mid let strdec\' = mapStrDecParent mapParent strdec let ns = getComponents mid in insert structTable (mid, StructInfo strdec\'); doNS nsdoConst (_, cid)  = let condec = sgnLookup cid let condec\' = mapConDecParent mapParent condec let fixity = getFixity cid let namePref = getNamePref cid let origin = originLookup cid in insert constTable (cid, ConstInfo (condec\', fixity, namePref, origin))doNS ns  = (appStructs doStruct ns; appConsts doConst ns) in doNS namespace; (structTable, constTable, namespace) let rec instantiateModule (module as (_, _, namespace), transform)  = let transformConDec = transform namespace let mid = sgnStructAdd (StrDec ("wheresubj", NONE)) let ns = newNamespace () let _ = installComponents (mid, ns) let _ = installModule (module, SOME mid, NONE, fun _ -> (), transformConDec) in abstractModule (ns, SOME mid) let defList : string list ref = ref nil let defCount : int ref = ref 0 let defs : module Table = new (4096) let rec defsClear ()  = clear defs let defsInsert = insertShadow defs let defsLookup = lookup defs let defsDelete = delete defs let rec reset ()  = (defList := nil; defCount := 0; defsClear ()) let rec resetFrom mark  = let rec ct (l, i)  = if i <= mark then l else let h :: t = l in defsDelete h; ct (t, i - 1) in defList := ct (! defList, ! defCount); defCount := mark let rec sigDefSize ()  = ! defCount let rec installSigDef (id, module)  = (match defsInsert (id, module) with NONE -> (defList := id :: (! defList); defCount := ! defCount + 1) | SOME entry -> (raise (Error ("Shadowing: A signature named " ^ id ^ "\\nhas already been declared")); defsInsert entry; ())) let lookupSigDef = defsLookup  end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module ModSyn = ModSyn(struct module Global = Global module Names' = Names module Origins = Origins module Whnf = Whnf module Strict = Strict module IntTree = IntRedBlackTree module HashTable = StringHashTable end)

('Error parsing code:', '(* Tabled Abstract Machine      *) (* Author: Brigitte Pientka     *) module type TABLED = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN !*) val solve : (Goal * Sub) * DProg * (pskeleton -> unit) -> unitval updateGlobalTable : (Goal * bool) -> unitval keepTable : cid -> boolval fillTable : unit -> unitval nextStage : unit -> boolval reset : unit -> unitval tableSize : unit -> intval suspGoalNo : unit -> int end\n(* signature TABLED *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Indexing *) (* Author: Brigitte Pientka *) module type MEMOTABLE = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN !*) (*! structure TableParam : TABLEPARAM !*) (* call check/insert *) (* callCheck (G, D, U, eqn)\n   *\n   * if D, G |- U & eqn     in table  then RepeatedEntry (entries)\n   * if D, G |- U & eqn not in table  then NewEntry (ptrAnswer)\n   * SIDE EFFECT: D, G |- U added to table\n   *) val callCheck : dctx * dctx * dctx * Exp * ResEqn -> callCheckResult(* answer check/insert *) (* answerCheck (G, D, (U,s))\n   * \n   * Assupmtion: D, G |- U is in table\n   *             and A represents the corresponding solutions\n   * \n   * G |- s : D, G\n   * Dk, G |- sk : D, G\n   *\n   * If  (Dk, sk) in A then repeated\n   *  else new\n   *) val answerCheck : Sub * answer * pskeleton -> answState(* reset table *) val reset : unit -> unit(* updateTable \n   *\n   * SIDE EFFECT: \n   *   for each table entry: \n   *       advance lookup pointer\n   *\n   * if Table did not change during last stage \n   *    then updateTable () =  false\n   * else updateTable () = true\n   *) val updateTable : unit -> boolval tableSize : unit -> int end\n(* signature MemoTable *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Abstract Machine for Tracing *) (* Author: Frank Pfenning *) (* Modified: Jeff Polakow, Frank Pfenning, Larry Greenfield, Roberto Virga *) module TMachine ((*! structure IntSyn\' : INTSYN !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Assign : ASSIGN(*! sharing Assign.IntSyn = IntSyn\' !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) module Trace : TRACE(*! sharing Trace.IntSyn = IntSyn\' !*) ) : ABSMACHINE = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure CompSyn = CompSyn\' !*)  module I = IntSynmodule C = CompSynmodule T = Tracemodule N = Names(* We write\n       G |- M : g\n     if M is a canonical proof term for goal g which could be found\n     following the operational semantics.  In general, the\n     success continuation sc may be applied to such M\'s in the order\n     they are found.  Backtracking is modeled by the return of\n     the success continuation.\n\n     Similarly, we write\n       G |- S : r\n     if S is a canonical proof spine for residual goal r which could\n     be found following the operational semantics.  A success continuation\n     sc may be applies to such S\'s in the order they are found and\n     return to indicate backtracking.\n  *) let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a let rec eqHead (Const a, Const a\')  = a = a\' | eqHead (Def a, Def a\')  = a = a\' | eqHead _  = false (* Wed Mar 13 10:27:00 2002 -bp  *) (* should probably go to intsyn.fun *) let rec compose (G, Null)  = G | compose (G, Decl (G\', D))  = Decl (compose (G, G\'), D) let rec shiftSub (Null, s)  = s | shiftSub (Decl (G, D), s)  = dot1 (shiftSub (G, s)) let rec subgoalNum (Nil)  = 1 | subgoalNum (App (U, S))  = 1 + subgoalNum S (* currently unused *) let rec goalToType (All (D, g), s)  = Pi ((decSub (D, s), Maybe), goalToType (g, dot1 s)) | goalToType (Impl (_, A, _, g), s)  = Pi ((Dec (NONE, EClo (A, s)), No), goalToType (g, dot1 s)) | goalToType (Atom (p), s)  = EClo (p, s) (* solve\' ((g, s), dp, sc) = ()\n     Invariants:\n       dp = (G, dPool) where  G ~ dPool  (context G matches dPool)\n       G |- s : G\'\n       G\' |- g  goal\n       if  G |- M : g[s]\n       then  sc M  is evaluated to\n\n     Effects: instantiation of EVars in g, s, and dp\n              any effect  sc M  might have\n  *) let rec solve\' ((Atom (p), s), dp as DProg (G, dPool), sc)  = matchAtom ((p, s), dp, sc) | solve\' ((Impl (r, A, Ha, g), s), DProg (G, dPool), sc)  = let D\' as Dec (SOME (x), _) = decUName (G, Dec (NONE, EClo (A, s))) let _ = signal (G, IntroHyp (Ha, D\')) in solve\' ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (fun M -> (signal (G, DischargeHyp (Ha, D\')); sc (Lam (D\', M))))) | solve\' ((All (D, g), s), DProg (G, dPool), sc)  = let D\' as Dec (SOME (x), V) = decUName (G, decSub (D, s)) let Ha = targetHead V let _ = signal (G, IntroParm (Ha, D\')) in solve\' ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Parameter)), (fun M -> (signal (G, DischargeParm (Ha, D\')); sc (Lam (D\', M)))))(* rSolve\' ((p,s\'), (r,s), dp, (Hc, Ha), sc) = T\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       G\' |- r  resgoal\n       G |- s\' : G\'\'\n       G\'\' |- p : H @ S\' (mod whnf)\n       if G |- S : r[s]\n       then sc S is evaluated\n       Hc is the clause which generated this residual goal\n       Ha is the target family of p and r (which must be equal)\n     Effects: instantiation of EVars in p[s\'], r[s], and dp\n              any effect  sc S  might have\n  *) rSolve (ps\', (Eq (Q), s), DProg (G, dPool), HcHa, sc)  = (signal (G, Unify (HcHa, EClo (Q, s), EClo ps\')); match unifiable\' (G, (Q, s), ps\')(* effect: instantiate EVars *)  with NONE -> (signal (G, Resolved HcHa); sc Nil; (* call success continuation *) true)(* deep backtracking *)  | SOME (msg) -> (signal (G, FailUnify (HcHa, msg)); false)) | rSolve (ps\', (Assign (Q, eqns), s), dp as DProg (G, dPool), HcHa, sc)  = (* Do not signal unification events for optimized clauses *)  (* Optimized clause heads lead to unprintable substitutions *)  ((* T.signal (G, T.Unify (HcHa, I.EClo (Q, s), I.EClo ps\')); *) match assignable (G, ps\', (Q, s)) with SOME (cnstr) -> aSolve ((eqns, s), dp, HcHa, cnstr, (fun () -> sc Nil)) | NONE -> ((* T.signal (G, T.FailUnify (HcHa, "Assignment failed")); *) false)) | rSolve (ps\', (And (r, A, g), s), dp as DProg (G, dPool), HcHa, sc)  = (* is this EVar redundant? -fp *) let X = newEVar (G, EClo (A, s)) in rSolve (ps\', (r, Dot (Exp (X), s)), dp, HcHa, (fun S -> (signal (G, Subgoal (HcHa, fun () -> subgoalNum S)); solve\' ((g, s), dp, (fun M -> sc (App (M, S))))))) | rSolve (ps\', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), HcHa, sc)  = let X = newEVar (G, EClo (A, s)) in rSolve (ps\', (r, Dot (Exp (X), s)), dp, HcHa, (fun S -> sc (App (X, S)))) | rSolve (ps\', (Axists (ADec (_, d), r), s), dp as DProg (G, dPool), HcHa, sc)  = let X = newAVar () in rSolve (ps\', (r, Dot (Exp (EClo (X, Shift (~ d))), s)), dp, HcHa, sc)(* we don\'t increase the proof term here! *)(* aSolve ((ag, s), dp, HcHa, sc) = T\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       if G |- ag[s] auxgoal\n       then sc () is evaluated\n\n     Effects: instantiation of EVars in ag[s], dp and sc () *) aSolve ((Trivial, s), dp as DProg (G, dPool), HcHa, cnstr, sc)  = if solveCnstr cnstr then (signal (G, Resolved HcHa); sc (); true) else ((* T.signal (G, T.FailUnify (HcHa, "Dynamic residual equations failed")); *) false) | aSolve ((UnifyEq (G\', e1, N, eqns), s), dp as DProg (G, dPool), HcHa, cnstr, sc)  = let G\'\' = compose (G, G\') let s\' = shiftSub (G\', s) in if unifiable (G\'\', (N, s\'), (e1, s\')) then aSolve ((eqns, s), dp, HcHa, cnstr, sc) else ((* T.signal (G, T.FailUnify (HcHa, "Static residual equations failed")); *) false)(* matchatom ((p, s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       G\' |- p : type, p = H @ S mod whnf\n       if G |- M :: p[s]\n       then sc M is evaluated with return value res\n       else res = False\n     Effects: instantiation of EVars in p[s] and dp\n              any effect  sc M  might have\n\n     This first tries the local assumptions in dp then\n     the static signature.\n  *) matchAtom (ps\' as (Root (Ha, S), s), dp as DProg (G, dPool), sc)  = (* matchSig [c1,...,cn] = ()\n           try each constant ci in turn for solving atomic goal ps\', starting\n           with c1.\n\n           #succeeds >= 1 (succeeds at least once)\n        *) (* matchSigDet [c1,...,cn] = ()\n           try each constant ci in turn for solving atomic goal ps\', starting\n           with c1. -- succeeds exactly once\n\n           succeeds exactly once (#succeeds = 1)\n        *) (* matchDProg (dPool, k) = ()\n           where k is the index of dPool in global dPool from call to matchAtom.\n           Try each local assumption for solving atomic goal ps\', starting\n           with the most recent one.\n        *) let tag = tagGoal () let _ = signal (G, SolveGoal (tag, Ha, EClo ps\')) let deterministic = detTableCheck (cidFromHead Ha) exception SucceedOnce of Spine let rec matchSig nil  = (signal (G, FailGoal (tag, Ha, EClo ps\')); ()) | matchSig (Hc :: sgn\')  = let SClause (r) = sProgLookup (cidFromHead Hc) in (* trail to undo EVar instantiations *) if trail (fun () -> rSolve (ps\', (r, id), dp, (Hc, Ha), (fun S -> (signal (G, SucceedGoal (tag, (Hc, Ha), EClo ps\')); sc (Root (Hc, S)))))) then (* deep backtracking *) (signal (G, RetryGoal (tag, (Hc, Ha), EClo ps\')); ()) else (* shallow backtracking *) (); matchSig sgn\' let rec matchSigDet nil  = (signal (G, FailGoal (tag, Ha, EClo ps\')); ()) | matchSigDet (Hc :: sgn\')  = let SClause (r) = sProgLookup (cidFromHead Hc) in (* trail to undo EVar instantiations *) try  with let rec matchDProg (Null, _)  = (* dynamic program exhausted, try signature *)  if deterministic then matchSigDet (lookup (cidFromHead Ha)) else matchSig (lookup (cidFromHead Ha)) | matchDProg (Decl (dPool\', Dec (r, s, Ha\')), k)  = if eqHead (Ha, Ha\') then (if deterministic then (* #succeeds = 1 *) (try  with ) else (* #succeeds >= 1 -- allows backtracking *) (if trail (fun () -> rSolve (ps\', (r, comp (s, Shift (k))), dp, (BVar (k), Ha), (fun S -> (SucceedGoal (tag, (BVar (k), Ha), EClo ps\'); sc (Root (BVar (k), S)))))) then (* deep backtracking *) (signal (G, RetryGoal (tag, (BVar (k), Ha), EClo ps\')); ()) else (* shallow backtracking *) (); matchDProg (dPool\', k + 1))) else matchDProg (dPool\', k + 1) | matchDProg (Decl (dPool\', Parameter), k)  = matchDProg (dPool\', k + 1) let rec matchConstraint (cnstrSolve, try)  = let succeeded = trail (fun () -> match (cnstrSolve (G, SClo (S, s), try)) with SOME (U) -> (sc U; true) | NONE -> false) in if succeeded then matchConstraint (cnstrSolve, try + 1) else () in match constStatus (cidFromHead Ha) with (Constraint (cs, cnstrSolve)) -> matchConstraint (cnstrSolve, 0) | _ -> matchDProg (dPool, 1) let rec solve (gs, dp, sc)  = (init (); solve\' (gs, dp, sc))  (* local ... *)  end\n(* functor TMachine *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {})])
('Error parsing code:', 'module TableParam = TableParam(module Global = Global)', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Abstract Machine execution guided by proof skeleton *) (* Author: Brigitte Pientka *) (* Modified: Jeff Polakow, Frank Pfenning, Larry Greenfield, Roberto Virga, Brigitte Pientka *) (* Proof term reconstruction from proof skeleton *) module PtRecon ((*! structure IntSyn\' : INTSYN !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Assign : ASSIGN(*! sharing Assign.IntSyn = IntSyn\' !*) (*! structure TableParam : TABLEPARAM !*) module MemoTable : MEMOTABLE(*! sharing MemoTable.TableParam = TableParam !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) (* CPrint currently unused *) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) ) : PTRECON = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure CompSyn = CompSyn\' !*)  (*! structure TableParam = TableParam !*)  module I = IntSynmodule C = CompSynmodule MT = MemoTableexception Error of string let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a let rec eqHead (Const a, Const a\')  = a = a\' | eqHead (Def a, Def a\')  = a = a\' | eqHead _  = false let rec compose\' (Null, G)  = G | compose\' (Decl (G, D), G\')  = Decl (compose\' (G, G\'), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) (* We write\n       G |- M : g\n     if M is a canonical proof term for goal g which could be found\n     following the operational semantics.  In general, the\n     success continuation sc may be applied to such M\'s in the order\n     they are found.  Backtracking is modeled by the return of\n     the success continuation.\n\n     Similarly, we write\n       G |- S : r\n     if S is a canonical proof spine for residual goal r which could\n     be found following the operational semantics.  A success continuation\n     sc may be applies to such S\'s in the order they are found and\n     return to indicate backtracking.\n\n     Non-determinism within the rules is resolved by oracle\n  *) (* solve\' (o, (g, s), dp, sc) => ()\n     Invariants:\n       o = oracle\n       dp = (G, dPool) where  G ~ dPool  (context G matches dPool)\n       G |- s : G\'\n       G\' |- g  goal\n       if  G |- M : g[s]\n       then  sc M  is evaluated\n     Effects: instantiation of EVars in g, s, and dp\n              any effect  sc M  might have\n  *) let rec solve\' (O, (Atom (p), s), dp as DProg (G, dPool), sc)  = matchAtom (O, (p, s), dp, sc) | solve\' (O, (Impl (r, A, Ha, g), s), DProg (G, dPool), sc)  = let D\' = Dec (NONE, EClo (A, s)) in if (! strengthen) then (match memberCtx ((G, EClo (A, s)), G) with SOME (D) -> let X = newEVar (G, EClo (A, s)) in (* need to reuse label for this assumption .... *) solve\' (O, (g, Dot (Exp (X), s)), DProg (G, dPool), (fun (O, M) -> sc (O, Lam (D\', M)))) | NONE -> solve\' (O, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (fun (O, M) -> sc (O, Lam (D\', M))))) else solve\' (O, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (fun (O, M) -> sc (O, (Lam (D\', M)))))(*      solve\' (O, (g, I.dot1 s), C.DProg (I.Decl(G, D\'), I.Decl (dPool, C.Dec (r, s, Ha))),\n               (fn (O,M) => sc (O, (I.Lam (D\', M)))))*) | solve\' (O, (All (D, g), s), DProg (G, dPool), sc)  = (* val D\' = I.decSub (D, s) *) let D\' = decLUName (G, decSub (D, s)) in solve\' (O, (g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Parameter)), (fun (O, M) -> sc (O, (Lam (D\', M)))))(* rsolve (O, (p,s\'), (r,s), dp, sc) = ()\n     Invariants:\n       O = oracle\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       G\' |- r  resgoal\n       G |- s\' : G\'\'\n       G\'\' |- p : H @ S\' (mod whnf)\n       if G |- S : r[s]\n       then sc S is evaluated\n     Effects: instantiation of EVars in p[s\'], r[s], and dp\n              any effect  sc S  might have\n  *) rSolve (O, ps\', (Eq (Q), s), DProg (G, dPool), sc)  = if unifiable (G, (Q, s), ps\')(* effect: instantiate EVars *)  then sc (O, Nil)(* call success continuation *)  else (let _ = (print "Unification Failed -- SHOULD NEVER HAPPEN!\\n"; print (expToString (G, EClo (ps\')) ^ " unify "); print (expToString (G, EClo (Q, s)) ^ "\\n")) in ()) | rSolve (O, ps\', (Assign (Q, eqns), s), dp as DProg (G, dPool), sc)  = (match assignable (G, ps\', (Q, s)) with SOME (cnstr) -> if aSolve ((eqns, s), dp, cnstr) then sc (O, Nil) else print "aSolve cnstr not solvable -- SHOULD NEVER HAPPEN\\n" | NONE -> print "Clause Head not assignable -- SHOULD NEVER HAPPEN\\n") | rSolve (O, ps\', (And (r, A, g), s), dp as DProg (G, dPool), sc)  = (* is this EVar redundant? -fp *) let X = newEVar (G, EClo (A, s)) in rSolve (O, ps\', (r, Dot (Exp (X), s)), dp, (fun (O, S) -> solve\' (O, (g, s), dp, (fun (O, M) -> sc (O, (App (M, S))))))) | rSolve (O, ps\', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), sc)  = let X = newEVar (G, EClo (A, s)) in rSolve (O, ps\', (r, Dot (Exp (X), s)), dp, (fun (O, S) -> sc (O, (App (X, S))))) | rSolve (O, ps\', (Axists (ADec (SOME (X), d), r), s), dp as DProg (G, dPool), sc)  = let X\' = newAVar () in rSolve (O, ps\', (r, Dot (Exp (EClo (X\', Shift (~ d))), s)), dp, sc)(* we don\'t increase the proof term here! *)(* aSolve ((ag, s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       if G |- ag[s] auxgoal\n       then sc () is evaluated with return value res\n       else res = Fail\n     Effects: instantiation of EVars in ag[s], dp and sc () *) aSolve ((Trivial, s), dp, cnstr)  = solveCnstr cnstr | aSolve ((UnifyEq (G\', e1, N, eqns), s), dp as DProg (G, dPool), cnstr)  = let (G\'\') = compose\' (G\', G) let s\' = shift (G\', s) in unifiable (G\'\', (N, s\'), (e1, s\')) && aSolve ((eqns, s), dp, cnstr)(* matchatom (O, (p, s), dp, sc) => ()\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       G\' |- p : type, p = H @ S mod whnf\n       if G |- M :: p[s]\n       then sc M is evaluated\n     Effects: instantiation of EVars in p[s] and dp\n              any effect  sc M  might have\n\n     This first tries the local assumptions in dp then\n     the static signature.\n  *) matchAtom ((Ho :: O), ps\' as (Root (Ha, S), s), dp as DProg (G, dPool), sc)  = (* matchSig [c1,...,cn] = ()\n           try each constant ci in turn for solving atomic goal ps\', starting\n           with c1.\n        *) (* matchDProg (dPool, k) = ()\n           where k is the index of dPool in global dPool from call to matchAtom.\n           Try each local assumption for solving atomic goal ps\', starting\n           with the most recent one.\n        *) let rec matchSig (nil, k)  = raise (Error (" \\noracle #Pc does not exist \\n")) | matchSig (((Hc as (Const c)) :: sgn\'), k)  = if c = k then let SClause (r) = sProgLookup (cidFromHead Hc) in rSolve (O, ps\', (r, id), dp, (fun (O, S) -> sc (O, (Root (Hc, S))))) else matchSig (sgn\', k) | matchSig (((Hc as (Def d)) :: sgn\'), k)  = if d = k then let SClause (r) = sProgLookup (cidFromHead Hc) in rSolve (O, ps\', (r, id), dp, (fun (O, S) -> sc (O, (Root (Hc, S))))) else matchSig (sgn\', k) let rec matchDProg (Null, i, k)  = (* dynamic program exhausted -- shouldn\'t happen *)  raise (Error ("\\n selected dynamic clause number does not exist in current dynamic clause pool!\\n")) | matchDProg (Decl (dPool\', Dec (r, s, Ha\')), 1, k)  = if eqHead (Ha, Ha\') then rSolve (O, ps\', (r, comp (s, Shift (k))), dp, (fun (O, S) -> sc (O, (Root (BVar (k), S))))) else (* shouldn\'t happen *) raise (Error ("\\n selected dynamic clause does not match current goal!\\n")) | matchDProg (Decl (dPool\', dc), i, k)  = matchDProg (dPool\', i - 1, k) in (match Ho with Pc i -> matchSig (lookup (cidFromHead Ha), i) | Dc i -> matchDProg (dPool, i, i) | Csolver U -> sc (O, U)) let rec solve (O, (g, s), dp as DProg (G, dPool), sc)  = try  with  (* local ... *)  end\n(* functor PtRecon *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Global Table parameters *) (* Author: Brigitte Pientka *) module type TABLEPARAM = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN !*) (*! structure RBSet : RBSET !*) exception Error of string(* Residual equation *) type ResEqnTrivialUnifydctx * Exp(* call unify *)  * Exp * ResEqntype answer = {solutions: (dctx * Sub) * pskeleton list; lookup: int} reftype StatusCompleteIncompleteval globalTable : dctx * dctx * dctx * Exp * ResEqn * answer * Status list refval resetGlobalTable : unit -> unitval emptyAnsw : unit -> answer(* destructively updates answers *) val addSolution : ((dctx * Sub) * pskeleton) * answer -> unitval updateAnswLookup : int * answer -> unitval solutions : answer -> (dctx * Sub) * pskeleton listval lookup : answer -> intval noAnswers : answer -> bool(* ---------------------------------------------------------------------- *) type asub = Exp ordSetval aid : unit -> asubtype callCheckResultNewEntryanswerRepeatedEntry(Sub * Sub) * answer * StatusDivergingEntrySub * answertype answStatenewrepeated(* ---------------------------------------------------------------------- *) type StrategyVariantSubsumptionval strategy : Strategy refval stageCtr : int refval divHeuristic : bool ref\nval termDepth : int option refval ctxDepth : int option refval ctxLength : int option refval strengthen : bool ref end\n(* signature TABLEPARAM *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Indexing *) (* Author: Brigitte Pientka *) module type TABLEINDEX = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN !*) type answer = {solutions: (dctx * Sub) * pskeleton list; lookup: int}type StrategyVariantSubsumptionval strategy : Strategy refval termDepth : int option refval ctxDepth : int option refval ctxLength : int option refval strengthen : bool refval query : dctx * dctx * Exp * Sub * (pskeleton -> unit) option reftype answStateNewRepeated(* table: G, Gdprog |- goal , \n            (answ list (ith stage) , answ list (1 to i-1 th stage))\n   *) val table : (int ref * dctx * dctx * Exp) * answer list refval noAnswers : (dctx * dctx * Exp) * answer list -> bool(* call check/insert *) (* callCheck (G, D, U)\n   *\n   * if D, G |- U     in table  \n   *    then SOME(entries)\n   * if D, G |- U not in table \n   *    then NONE  \n   *          SIDE EFFECT: D, G |- U added to table\n   *) val callCheck : dctx * dctx * Exp -> (dctx * dctx * Exp) * answer list option(* answer check/insert *) (* answerCheck (G, D, (U,s))\n   * \n   * Assumption: D, G |- U is in table\n   *             and A represents the corresponding solutions\n   * \n   * G |- s : D, G\n   * Dk, G |- sk : D, G\n   *\n   * If  (Dk, sk) in A then repeated\n   *  else New\n   *) val answerCheck : dctx * dctx * Exp * Sub * pskeleton -> answState(* reset table *) val reset : unit -> unitval printTable : unit -> unitval printTableEntries : unit -> unit(* updateTable \n   *\n   * SIDE EFFECT: \n   *   for each table entry: \n   *       advance lookup pointer\n   *\n   * if Table did not change during last stage \n   *    then updateTable () =  false\n   * else updateTable () = true\n   *) val updateTable : unit -> boolval solutions : answer -> (dctx * Sub) * pskeleton listval lookup : answer -> int end\n(* signature TABLEINDEX *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Abstract Machine for tabling*) (* Author: Brigitte Pientka *) (* Based on abstract machine in absmachine.fun *) module Tabled ((*! structure IntSyn\' : INTSYN !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module TabledSyn : TABLEDSYN(*!  sharing TabledSyn.IntSyn = IntSyn\' !*) module Assign : ASSIGN(*!  sharing Assign.IntSyn = IntSyn\' !*) module Index : INDEX(*!  sharing Index.IntSyn = IntSyn\' !*) module Queue : QUEUE(*! structure TableParam : TABLEPARAM !*) (*!  sharing TableParam.IntSyn = IntSyn\' !*) (*!  sharing TableParam.CompSyn = CompSyn\' !*) module AbstractTabled : ABSTRACTTABLED(*!  sharing AbstractTabled.IntSyn = IntSyn\' !*) (*! sharing AbstractTabled.TableParam = TableParam !*) module MemoTable : MEMOTABLE(*!  sharing MemoTable.IntSyn = IntSyn\' !*) (*!  sharing MemoTable.CompSyn = CompSyn\'  !*) (*! sharing MemoTable.TableParam = TableParam  !*) (* CPrint currently unused *) module CPrint : CPRINT(*!  sharing CPrint.IntSyn = IntSyn\' !*) (*!  sharing CPrint.CompSyn = CompSyn\' !*) (* CPrint currently unused *) module Print : PRINT(*!  sharing Print.IntSyn = IntSyn\' !*) (*              structure Names : NAMES *) (*!  sharing Names.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*!  sharing CSManager.IntSyn = IntSyn\'!*) ) : TABLED = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure CompSyn = CompSyn\' !*)  module Unify = Unify module TabledSyn = TabledSyn (*! structure TableParam = TableParam !*)  (*  structure Match = Match*)  module I = IntSynmodule C = CompSynmodule A = AbstractTabledmodule T = TableParammodule MT = MemoTable(* ---------------------------------------------------------------------- *) (* Suspended goal: SuspType, s, G, sc, ftrail, answerRef, i\n\n       where\n       s is a substitution for the existential variables in D such that G |- s : G, D\n       sc        : is the success continuation\n       ftrail    : is a forward trail\n       answerRef : pointer to potential answers in the memo-table\n       i         : Number of answer which already have been consumed  by this\n                   current program state\n\n    *) type SuspType = Loop | Divergence of ((Exp * Sub) * DProg) let SuspGoals : SuspType * (dctx * Exp * Sub) * (pskeleton -> unit) * unifTrail * ((Sub * Sub) * answer) * int ref list ref = ref [] exception Error of string (* ---------------------------------------------------------------------- *) let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a let rec eqHead (Const a, Const a\')  = a = a\' | eqHead (Def a, Def a\')  = a = a\' | eqHead _  = false let rec append (Null, G)  = G | append (Decl (G\', D), G)  = Decl (append (G\', G), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Lam (D, V)) let rec compose (Null, G)  = G | compose (Decl (G, D), G\')  = Decl (compose (G, G\'), D) (* ---------------------------------------------------------------------- *) (* We write\n       G |- M : g\n     if M is a canonical proof term for goal g which could be found\n     following the operational semantics.  In general, the\n     success continuation sc may be applied to such M\'s in the order\n     they are found.  Backtracking is modeled by the return of\n     the success continuation.\n\n     Similarly, we write\n       G |- S : r\n     if S is a canonical proof spine for residual goal r which could\n     be found following the operational semantics.  A success continuation\n     sc may be applies to such S\'s in the order they are found and\n     return to indicate backtracking.\n    *) (* ---------------------------------------------------------------------- *) (* ctxToEVarSub D = s\n\n     if D is a context for existential variables,\n        s.t. u_1:: A_1,.... u_n:: A_n = D\n     then . |- s : D where s = X_n....X_1.id\n\n    *) let rec ctxToEVarSub (Null, s)  = s | ctxToEVarSub (Decl (G, Dec (_, A)), s)  = let X = newEVar (Null, A) in Dot (Exp (X), ctxToEVarSub (G, s)) let rec ctxToAVarSub (Null, s)  = s | ctxToAVarSub (Decl (G, Dec (_, A)), s)  = let X = newEVar (Null, A) in Dot (Exp (X), ctxToAVarSub (G, s)) | ctxToAVarSub (Decl (G, ADec (_, d)), s)  = let X = newAVar () in Dot (Exp (EClo (X, Shift (~ d))), ctxToAVarSub (G, s)) (* ---------------------------------------------------------------------- *) (* Solving  variable definitions *) (* solveEqn ((VarDef, s), G) = bool\n\n    if G\'\' |- VarDef and G  . |- s : G\'\'\n       G   |- VarDef[s]\n    then\n       return true, if VarDefs are solvable\n              false otherwise\n *) let rec solveEqn ((Trivial, s), G)  = true | solveEqn ((Unify (G\', e1, N, eqns), s), G)  = (* D, G, G\' |- e1 and D, G, G\' |- N and D, G |- eqns *)  (* . |- s : D *)  (* G, G\' |- s\' : D, G, G\' *) let G\'\' = append (G\', G) let s\' = shift (G\'\', s) in unifiable (G\'\', (N, s\'), (e1, s\')) && solveEqn ((eqns, s), G) let rec unifySub\' (G, s1, s2)  = try  with let rec unify (G, Us, Us\')  = try  with let rec getHypGoal (DProg, (Atom p, s))  = (DProg, (p, s)) | getHypGoal (DProg (G, dPool), (Impl (r, A, Ha, g), s))  = let D\' = Dec (NONE, EClo (A, s)) in if (! strengthen) then (match memberCtx ((G, EClo (A, s)), G) with SOME (_) -> ((* is g always atomic? *) let Atom (p) = g let X = newEVar (G, EClo (A, s)) in getHypGoal (DProg (G, dPool), (g, Dot (Exp (X), s)))) | NONE -> getHypGoal (DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (g, dot1 s))) else getHypGoal (DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (g, dot1 s)) | getHypGoal (DProg (G, dPool), (All (D, g), s))  = let D\' = decSub (D, s) in getHypGoal (DProg (Decl (G, D\'), Decl (dPool, Parameter)), (g, dot1 s)) let rec updateGlobalTable (goal, flag)  = let (dProg as DProg (G, dPool), (p, s)) = getHypGoal (DProg (Null, Null), (goal, id)) let (G\', DAVars, DEVars, U\', eqn\', s\') = abstractEVarCtx (dProg, p, s) let _ = if solveEqn ((eqn\', s\'), G\') then () else print "\\nresidual equation not solvable!\\n" let status = if flag then Complete else Incomplete in if keepTable (targetFam U\') then match callCheck (DAVars, DEVars, G\', U\', eqn\', status) with RepeatedEntry (_, answRef, _) -> (globalTable := ((DAVars, DEVars, G\', U\', eqn\', answRef, status) :: (! globalTable))) | _ -> raise (Error "Top level goal should always in the table\\n") else () let rec keepTable c  = keepTable c let rec fillTable ()  = let rec insert (nil)  = () | insert ((DAVars, DEVars, G\', U\', eqn\', answRef, status) :: T)  = match insertIntoTree (DAVars, DEVars, G\', U\', eqn\', answRef, status) with NewEntry (_) -> insert T | _ -> () in insert (! globalTable) (*------------------------------------------------------------------------------------------*) (* retrieve\' ((G, U, s), asub, AnswerList, sc) = ()\n\n     retrieval for subsumption must take into account the asub substitution\n\n     Invariants:\n     if\n       Goal:                        Answer substitution from index:\n       D   |- Pi G. U\n       .   |- s : D        and      D\' |- s1 : D1\n       D   |- asub : D1    and      .  |- s1\' : D\' (reinstantiate evars)\n\n                                scomp = s1 o s1\'\n                                  .  |- scomp : D1\n\n       .  |- [esub]asub : D1  where\n       .  |- esub : D      and  G |- esub^|G| : D , G\n       .  |- s : D         and  G |- s^|G| : D, G\n     then\n       unify (G, esub^|G|, s^|G|) and unify (G, ([esub]asub)^|G|, scomp^|G|)\n       if unification succeeds\n         then we continue solving the success continuation.\n         otherwise we fail\n\n     Effects: instantiation of EVars in s, s1\' and esub\n     any effect  sc O1  might have\n\n   *) let rec retrieve\' ((G, U, s), asub, [], sc)  = () | retrieve\' ((G, U, s), (esub, asub), (((D\', s1), O1) :: A), sc)  = let s1\' = ctxToEVarSub (D\', Shift (ctxLength (D\')), (* I.id *) ) let scomp = comp (s1, s1\') let ss = shift (G, s) let ss1 = shift (G, scomp) let a = comp (asub, s) let ass = shift (G, a) let easub = comp (asub, esub) in trail (fun () -> if (unifySub\' (G, shift (G, esub), ss) && unifySub\' (G, shift (G, comp (asub, esub)), ss1)) then (sc O1)(* Succeed *)  else ()); (* Fail *) retrieve\' ((G, U, s), (esub, asub), A, sc) (* currently not used -- however, it may be better to not use the same retrieval function for\n      subsumption and variant retrieval, and we want to revive this function *) (* retrieveV ((G, U, s), answerList, sc)\n      if\n        . |- [s]Pi G.U\n        . |- s : DAVars, DEVars\n\n        ((DEVars_i, s_i), O_i) is an element in answer list\n         DEVars_i |- s_i : DAVars, DEVars\n         and O_i is a proof skeleton\n      then\n        sc O_i is evaluated\n        Effects: instantiation of EVars in s\n\n   *) let rec retrieveV ((G, U, s), [], sc)  = () | retrieveV ((G, U, s), (((DEVars, s1), O1) :: A), sc)  = (* for subsumption we must combine it with asumb!!! *) let s1\' = ctxToEVarSub (DEVars, Shift (ctxLength (DEVars)), (* I.id *) ) let scomp = comp (s1, s1\') let ss = shift (G, s) let ss1 = shift (G, scomp) in trail (fun () -> if unifySub\' (G, ss, ss1) then (sc O1) else ()); retrieveV ((G, U, s), A, sc) let rec retrieveSW ((G, U, s), asub, AnswL, sc)  = retrieve\' ((G, U, s), asub, AnswL, sc) (* currently not used -- however, it may be better to  not use the same retrieval function for\n      subsumption and variant retrieval, and we want to revive this function *) (* fun retrieveSW ((G, U, s), asub, AnswL, sc) =\n     case (!TableParam.strategy) of\n       TableParam.Variant =>  retrieveV ((G, U, s), AnswL, sc)\n     | TableParam.Subsumption => retrieve\' ((G, U, s), asub, AnswL, sc) *) (* retrieve (k, (G, s), (asub, answRef), sc) = ()\n      Invariants:\n      If\n         G |-   s : G, D   where s contains free existential variables defined in D\n         answRef is a pointer to the AnswerList\n\n        G |- asub : D, G  asub is the identity in the variant case\n        G |- asub : D, G  asub instantiates existential variables in s.\n\n     then the success continuation sc is triggered.\n\n     Effects: instantiation of EVars in s, and asub\n   *) let rec retrieve (k, (G, U, s), (asub, answRef), sc)  = let lkp = lookup (answRef) let asw\' = take (rev (solutions (answRef)), lookup (answRef)) let answ\' = drop (asw\', ! k) in k := lkp; retrieveSW ((G, U, s), asub, answ\', sc) (* ---------------------------------------------------------------------- *) (* solve ((g, s), dp, sc) => ()\n     Invariants:\n     dp = (G, dPool) where  G ~ dPool  (context G matches dPool)\n     G |- s : G\'\n     G\' |- g  goal\n     if  G |- M : g[s]\n       then  sc M  is evaluated\n     Effects: instantiation of EVars in g, s, and dp\n     any effect  sc M  might have\n     *) let rec solve ((Atom (p), s), dp as DProg (G, dPool), sc)  = if tabledLookup (targetFam p) then (* Invariant about abstraction:\n              Pi DAVars. Pi DEVars. Pi G\'. U\'    : abstracted linearized goal\n              .  |- s\' : DAVars, DEVars             k = |G\'|\n              G\' |- s\'^k : DAVars, DEVars, G\'\n               . |- [s\'](Pi G\'. U\')     and  G |- [s\'^k]U\' = [s]p *) let (G\', DAVars, DEVars, U\', eqn\', s\') = abstractEVarCtx (dp, p, s) let _ = if solveEqn ((eqn\', s\'), G\') then () else print "\\nresidual equation not solvable! -- This should never happen! \\n" in match callCheck (DAVars, DEVars, G\', U\', eqn\', Incomplete)(* Side effect: D\', G\' |- U\' added to table *)  with NewEntry (answRef) -> matchAtom ((p, s), dp, (fun pskeleton -> match answerCheck (s\', answRef, pskeleton) with repeated -> () | new -> (sc pskeleton))) | RepeatedEntry (asub, answRef, Incomplete) -> if noAnswers answRef then (* loop detected\n                  * NOTE: we might suspend goals more than once.\n                  *     example: answer list for goal (p,s) is saturated\n                  *              but not the whole table is saturated.\n                  *) (SuspGoals := ((Loop, (G\', U\', s\'), sc, suspend (), (asub, answRef), ref 0) :: (! SuspGoals)); ()) else (* loop detected\n                  * new answers available from previous stages\n                  * resolve current goal with all possible answers\n                  *) let le = lookup (answRef) in SuspGoals := ((Loop, (G\', U\', s\'), sc, suspend (), (asub, answRef), ref le) :: (! SuspGoals)); retrieve (ref 0, (G\', U\', s\'), (asub, answRef), sc) | RepeatedEntry (asub, answRef, Complete) -> if noAnswers answRef then (* Subgoal is not provable *) () else (* Subgoal is provable - loop detected\n                  * all answers are available from previous run\n                  * resolve current goal with all possible answers\n                  *) retrieve (ref 0, (G\', U\', s\'), (asub, answRef), sc) | DivergingEntry (asub, answRef) -> (* loop detected  -- currently not functioning correctly.\n                    we might be using this as part of a debugger which suggests diverging goals\n                    to the user so the user can prove a generalized goal first.\n                    Wed Dec 22 08:27:24 2004 -bp\n                  *) (SuspGoals := ((Divergence ((p, s), dp), (G\', U\', s\'), sc, suspend (), ((id, (* this is a hack *) , asub), answRef), ref 0) :: (! SuspGoals)); ()) else matchAtom ((p, s), dp, sc) | solve ((Impl (r, A, Ha, g), s), DProg (G, dPool), sc)  = let D\' = Dec (NONE, EClo (A, s)) in if (! strengthen) then (match memberCtx ((G, EClo (A, s)), G) with SOME (_) -> (let X = newEVar (G, EClo (A, s)) in solve ((g, Dot (Exp (X), s)), DProg (G, dPool), (fun O -> sc O))) | NONE -> solve ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (fun O -> sc O))) else solve ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), (fun O -> sc O)) | solve ((All (D, g), s), DProg (G, dPool), sc)  = let D\' = decSub (D, s) in solve ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Parameter)), (fun O -> sc O))(* rsolve ((p,s\'), (r,s), dp, sc) = ()\n    Invariants:\n    dp = (G, dPool) where G ~ dPool\n    G |- s : G\'\n    G\' |- r  resgoal\n    G |- s\' : G\'\'\n    G\'\' |- p : H @ S\' (mod whnf)\n    if G |- S : r[s]\n       then sc S is evaluated\n     Effects: instantiation of EVars in p[s\'], r[s], and dp\n     any effect  sc S  might have\n     *) rSolve (ps\', (Eq (Q), s), DProg (G, dPool), sc)  = (if unifiable (G, ps\', (Q, s))(* effect: instantiate EVars *)  then sc [](* call success continuation *)  else ()) | rSolve (ps\', (Assign (Q, eqns), s), dp as DProg (G, dPool), sc)  = (match assignable (G, ps\', (Q, s)) with SOME (cnstr) -> aSolve ((eqns, s), dp, cnstr, (fun S -> sc S)) | NONE -> ()) | rSolve (ps\', (And (r, A, g), s), dp as DProg (G, dPool), sc)  = (* is this EVar redundant? -fp *) let X = newEVar (G, EClo (A, s)) in rSolve (ps\', (r, Dot (Exp (X), s)), dp, (fun S1 -> solve ((g, s), dp, (fun S2 -> sc (S1 @ S2))))) | rSolve (ps\', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), sc)  = let X = newEVar (G, EClo (A, s)) in rSolve (ps\', (r, Dot (Exp (X), s)), dp, (fun S -> sc S)) | rSolve (ps\', (Axists (ADec (SOME (X), d), r), s), dp as DProg (G, dPool), sc)  = let X\' = newAVar () in rSolve (ps\', (r, Dot (Exp (EClo (X\', Shift (~ d))), s)), dp, sc)(* we don\'t increase the proof term here! *)(* aSolve ((ag, s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       if G |- ag[s] auxgoal\n       then sc () is evaluated with return value res\n       else res = Fail\n     Effects: instantiation of EVars in ag[s], dp and sc () *) aSolve ((Trivial, s), dp, cnstr, sc)  = (if solveCnstr cnstr then (sc []) else ()) | aSolve ((UnifyEq (G\', e1, N, eqns), s), dp as DProg (G, dPool), cnstr, sc)  = let (G\'\') = append (G\', G) let s\' = shift (G\', s) in if unifiable (G\'\', (N, s\'), (e1, s\')) then aSolve ((eqns, s), dp, cnstr, sc) else ()(* matchatom ((p, s), dp, sc) => ()\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       G\' |- p : type, p = H @ S mod whnf\n       if G |- M :: p[s]\n       then sc M is evaluated\n     Effects: instantiation of EVars in p[s] and dp\n              any effect  sc M  might have\n\n     This first tries the local assumptions in dp then\n     the static signature.\n  *) matchAtom (ps\' as (Root (Ha, S), s), dp as DProg (G, dPool), sc)  = (* matchSig [c1,...,cn] = ()\n           try each constant ci in turn for solving atomic goal ps\', starting\n           with c1.\n        *) (* matchDProg (dPool, k) = ()\n           where k is the index of dPool in global dPool from call to matchAtom.\n           Try each local assumption for solving atomic goal ps\', starting\n           with the most recent one.\n        *) let rec matchSig nil  = () | matchSig ((Hc as Const c) :: sgn\')  = let SClause (r) = sProgLookup (cidFromHead Hc) in (* trail to undo EVar instantiations *) trail (fun () -> rSolve (ps\', (r, id), dp, (fun S -> sc ((Pc c) :: S)))); matchSig sgn\' let rec matchDProg (Null, Null, _)  = (* dynamic program exhausted, try signature *)  matchSig (lookup (cidFromHead Ha)) | matchDProg (Decl (G, _), Decl (dPool\', Dec (r, s, Ha\')), k)  = if eqHead (Ha, Ha\') then (* trail to undo EVar instantiations *) (trail (fun () -> rSolve (ps\', (r, comp (s, Shift (k))), dp, (fun S -> sc ((Dc k) :: S)))); matchDProg (G, dPool\', k + 1)) else matchDProg (G, dPool\', k + 1) | matchDProg (Decl (G, _), Decl (dPool\', Parameter), k)  = matchDProg (G, dPool\', k + 1) let rec matchConstraint (solve, try)  = let succeeded = trail (fun () -> match (solve (G, SClo (S, s), try)) with SOME (U) -> (sc [Csolver U]; true) | NONE -> false) in if succeeded then matchConstraint (solve, try + 1) else () in match constStatus (cidFromHead Ha) with (Constraint (cs, solve)) -> matchConstraint (solve, 0) | _ -> matchDProg (G, dPool, 1) (* retrieval ((p, s), dp, sc, answRef, n) => ()\n     Invariants:\n     dp = (G, dPool) where  G ~ dPool  (context G matches dPool)\n     G |- s : G\'\n     G\' |- p  goal\n     answRef : pointer to corresponding answer list\n     n       : #number of answers which were already consumed\n               by the current goal\n\n     if answers are available\n      then retrieve all new answers\n     else fail\n     *) let rec retrieval (Loop, (G\', U\', s\'), sc, (asub, answRef), n)  = if noAnswers answRef then (* still  no answers available from previous stages *) (* NOTE: do not add the susp goal to suspGoal list\n                because it is already in the suspGoal list *) () else (*  new answers available from previous stages\n       * resolve current goal with all "new" possible answers\n       *) retrieve (n, (G\', U\', s\'), (asub, answRef), sc) | retrieval (Divergence ((p, s), dp), (G\', U\', s\'), sc, (asub, answRef), n)  = matchAtom ((p, s), dp, (fun pskeleton -> match answerCheck (s\', answRef, pskeleton) with repeated -> () | new -> sc pskeleton)) let rec tableSize ()  = tableSize () let rec suspGoalNo ()  = length (! SuspGoals) (*  nextStage () = bool\n     Side effect: advances lookup pointers\n   *) let rec nextStage ()  = let rec resume []  = () | resume (((Susp, s, sc, trail, (asub, answRef), k) :: Goals))  = (trail (fun () -> (resume trail; retrieval (Susp, s, sc, (asub, answRef), k))); resume (Goals)) let SG = rev (! SuspGoals) in if updateTable () then (* table changed during previous stage *) (stageCtr := (! stageCtr) + 1; resume (SG); true) else (* table did not change during previous stage *) false let rec reset ()  = (SuspGoals := []; reset (); stageCtr := 0) let rec solveQuery ((g, s), dp as DProg (G, dPool), sc)  = (* only works when query is atomic -- if query is not atomic,\n      then the subordination relation might be extended and strengthening may not be sound *)  solve ((g, s), dp, sc)  (* local ... *)  let solve = solveQuery end\n(* functor Tabled *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', 'module SwMachine (module Trace : TRACEmodule AbsMachine : ABSMACHINEmodule TMachine : ABSMACHINE(*! sharing TMachine.IntSyn = AbsMachine.IntSyn !*) (*! sharing TMachine.CompSyn = AbsMachine.CompSyn !*) ) : ABSMACHINE = struct (*! structure IntSyn = AbsMachine.IntSyn !*)  (*! structure CompSyn = AbsMachine.CompSyn !*)  let rec solve args  = if tracing () then solve args else solve args end\n(* functor SwMachine *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Abstract Machine *) (* Author: Iliano Cervesato *) (* Modified: Jeff Polakow *) (* Modified: Frank Pfenning *) module type ABSMACHINESBT = sig (*! structure IntSyn  : INTSYN !*) (*! structure CompSyn : COMPSYN !*) val solve : (Goal * Sub) * DProg * (Flatterm list -> unit) -> unit end\n(* signature ABSMACHINESBT *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module AbsMachine = AbsMachine(struct module Unify = UnifyTrail module Assign = Assign module Index = Index module CPrint = CPrint module Print = Print module Names = Names end)
module AbstractTabled = AbstractTabled(struct module Print = Print module Whnf = Whnf module Unify = UnifyTrail module Constraints = Constraints module Subordinate = Subordinate module Conv = Conv module Print = Print end)
module MemoTable = MemoTable(struct module Conv = Conv module Whnf = Whnf module Print = Print module AbstractTabled = AbstractTabled module Table = IntRedBlackTree end)module MemoTableInst = MemoTableInst(struct module Conv = Conv module Whnf = Whnf module Match = Match module Assign = Assign module Print = Print module AbstractTabled = AbstractTabled module Table = IntRedBlackTree end)module SwMemoTable = SwMemoTable(struct module MemoTable = MemoTable module MemoTableInst = MemoTableInst end)module Tabled = Tabled(struct module Unify = UnifyTrail module Match = Match module TabledSyn = TabledSyn module Assign = Assign module Index = Index module Queue = Queue module MemoTable = SwMemoTable module AbstractTabled = AbstractTabled module CPrint = CPrint module Print = Print end)
module PtRecon = PtRecon(struct module Unify = UnifyTrail module MemoTable = SwMemoTable module Assign = Assign module Index = Index module CPrint = CPrint module Names = Names end)
module Trace = Trace(struct module Names = Names module Whnf = Whnf module Abstract = Abstract module Print = Print end)
module AbsMachineSbt = AbsMachineSbt(struct module IntSyn' = IntSyn module CompSyn' = CompSyn module SubTree = SubTree module Unify = UnifyTrail module Assign = Assign module Index = Index module CPrint = CPrint module Print = Print module Names = Names module CSManager = CSManager end)
module TMachine = TMachine(struct module Unify = UnifyTrail module Index = Index module Assign = Assign module CPrint = CPrint module Names = Names module Trace = Trace end)
module SwMachine = SwMachine(struct module Trace = Trace module AbsMachine = AbsMachine module TMachine = TMachine end)

('Error parsing code:', '(* Abstraction *) (* Author: Frank Pfenning, Carsten Schuermann *) (* Modified: Roberto Virga, Brigitte Pientka *) module AbstractTabled ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn\' !*) (*! structure TableParam : TABLEPARAM !*) (*! sharing TableParam.IntSyn = IntSyn\' !*) ) : ABSTRACTTABLED = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure TableParam = TableParam !*)  exception Error of string module I = IntSynmodule C = CompSyntype Duplicates = AV of (Exp * int) | FGN of int type seenIn = TypeLabel | Body type ExistVars = EV of Exp let rec lengthSub (Shift n)  = 0 | lengthSub (Dot (E, s))  = 1 + lengthSub s (*\n       We write {{K}} for the context of K, where EVars have\n       been translated to declarations and their occurrences to BVars.\n       For each occurrence of EVar in U, we generate a distinct BVar together with\n       a residual constraint. This enforces that the final abstraction of U is\n       linear. However, we do not linearize the context G.\n\n       We write {{U}}_K, {{S}}_K for the corresponding translation of an\n       expression or spine.\n\n       Just like contexts G, any K is implicitly assumed to be\n       well-formed and in dependency order.\n\n       We write  K ||- U  if all EVars in U are collected in K.\n       In particular, . ||- U means U contains no EVars.  Similarly,\n       for spines K ||- S and other syntactic categories.\n\n       Collection and abstraction raise Error if there are unresolved\n       constraints after simplification.\n    *) let rec compose\' (Null, G)  = G | compose\' (Decl (G\', D), G)  = Decl (compose\' (G\', G), D) let rec isId (Shift (n))  = (n = 0) | isId (s as Dot (Idx n, s\'))  = isId\' (s, 0) | isId (s as Dot (Undef, s\'))  = isId\' (s, 0) | isId (Dot (Exp _, s))  = falseisId\' (Shift (n), k)  = (n = k) | isId\' (Dot (Idx (i), s), k)  = let k\' = k + 1 in (i = k\') && isId\' (s, k\') | isId\' (Dot (Undef, s), k)  = isId\' (s, k + 1) let rec equalCtx (Null, s, Null, s\')  = true | equalCtx (Decl (G, D), s, Decl (G\', D\'), s\')  = convDec ((D, s), (D\', s\')) && (equalCtx (G, dot1 s, G\', dot1 s\')) | equalCtx (Decl (G, D), s, Null, s\')  = false | equalCtx (Null, s, Decl (G\', D\'), s\')  = false (* eqEVar X Y = B\n     where B iff X and Y represent same variable\n     *) let rec eqEVarW (EVar (r1, _, _, _)) (EV (EVar (r2, _, _, _)))  = (r1 = r2) | eqEVarW _ _  = false let rec eqEVar X1 (EV (X2))  = (* Sun Dec  1 14:04:17 2002 -bp  may raise exception\n       if strengthening is applied,i.e. the substitution is not always id! *)  let (X1\', s) = whnf (X1, id) let (X2\', s) = whnf (X2, id) in eqEVarW X1\' (EV (X2\')) (* a few helper functions to manage K *) (* member P K = B option *) let rec member\' P K  = let rec exists\' (Null)  = NONE | exists\' (Decl (K\', (l, EV (Y))))  = if P (EV (Y)) then SOME (l) else exists\' (K\') in exists\' K (* member P K = B option *) let rec member P K  = let rec exists\' (Null)  = NONE | exists\' (Decl (K\', (i, Y)))  = if P (Y) then SOME (i) else exists\' (K\') in exists\' K let rec update\' P K  = let rec update\' (Null)  = Null | update\' (Decl (K\', ((label, Y))))  = if (P Y) then Decl (K\', (Body, Y)) else Decl (update\' (K\'), (label, Y)) in update\' K (* member P K = B option *) let rec update P K  = let rec update\' (Null)  = Null | update\' (Decl (K\', ((label, i), Y)))  = if (P Y) then Decl (K\', ((Body, i), Y)) else Decl (update\' (K\'), ((label, i), Y)) in update\' K let rec or (Maybe, _)  = Maybe | or (_, Maybe)  = Maybe | or (Meta, _)  = Meta | or (_, Meta)  = Meta | or (No, No)  = No (* occursInExp (k, U) = DP,\n\n       Invariant:\n       If    U in nf\n       then  DP = No      iff k does not occur in U\n             DP = Maybe   iff k occurs in U some place not as an argument to a Skonst\n             DP = Meta    iff k occurs in U and only as arguments to Skonsts\n    *) let rec occursInExp (k, Uni _)  = No | occursInExp (k, Pi (DP, V))  = or (occursInDecP (k, DP), occursInExp (k + 1, V)) | occursInExp (k, Root (H, S))  = occursInHead (k, H, occursInSpine (k, S)) | occursInExp (k, Lam (D, V))  = or (occursInDec (k, D), occursInExp (k + 1, V)) | occursInExp (k, FgnExp csfe)  = fold csfe (fun (U, DP) -> or (DP, (occursInExp (k, normalize (U, id))))) No(* no case for Redex, EVar, EClo *) occursInHead (k, BVar (k\'), DP)  = if (k = k\') then Maybe else DP | occursInHead (k, Const _, DP)  = DP | occursInHead (k, Def _, DP)  = DP | occursInHead (k, FgnConst _, DP)  = DP | occursInHead (k, Skonst _, No)  = No | occursInHead (k, Skonst _, Meta)  = Meta | occursInHead (k, Skonst _, Maybe)  = Meta(* no case for FVar *) occursInSpine (_, Nil)  = No | occursInSpine (k, App (U, S))  = or (occursInExp (k, U), occursInSpine (k, S))(* no case for SClo *) occursInDec (k, Dec (_, V))  = occursInExp (k, V)occursInDecP (k, (D, _))  = occursInDec (k, D) (* piDepend ((D,P), V) = Pi ((D,P\'), V)\n       where P\' = Maybe if D occurs in V, P\' = No otherwise\n    *) (* optimize to have fewer traversals? -cs *) (* pre-Twelf 1.2 code walk Fri May  8 11:17:10 1998 *) let rec piDepend (DPV as ((D, No), V))  = Pi DPV | piDepend (DPV as ((D, Meta), V))  = Pi DPV | piDepend ((D, Maybe), V)  = Pi ((D, occursInExp (1, V)), V) (* raiseType (G, V) = {{G}} V\n\n       Invariant:\n       If G |- V : L\n       then  . |- {{G}} V : L\n\n       All abstractions are potentially dependent.\n    *) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Pi ((D, Maybe), V)) let rec reverseCtx (Null, G)  = G | reverseCtx (Decl (G, D), G\')  = reverseCtx (G, Decl (G\', D)) let rec ctxToEVarSub (Null, s)  = s | ctxToEVarSub (Decl (G, Dec (_, A)), s)  = let s\' = ctxToEVarSub (G, s) let X = newEVar (Null, EClo (A, s\')) in Dot (Exp (X), s\') (* collectExpW ((Gs, ss), Gl, (U, s), K, DupVars, flag) = (K\', DupVars\')\n\n       Invariant:\n       If    G, Gl |- s : G1     G1 |- U : V      (U,s) in whnf\n                Gs |- ss : G  (Gs is the strengthened context and ss is the strengthening substitution)\n\n       No circularities in U\n             (enforced by extended occurs-check for FVars in Unify)\n       and   K\' = K, K\'\'\n             where K\' contains all EVars in (U,s)\n       and  DupVars\' = DupVars, DupVars\'\'\n            where DupVars\' contains all duplicates in (U,s)\n\n      if flag = true\n        then duplicates of EVars are collected in DupVars\n        otherwise no duplicates are collected\n\n      note : 1) we only need to collect duplicate occurrences of EVars\n                if we need to linearize the term the EVars occur in.\n\n             2) we do not linearize fgnExp\n    *) (* Possible optimization: Calculate also the normal form of the term *) let rec collectExpW (Gss, Gl, (Uni L, s), K, DupVars, flag, d)  = (K, DupVars) | collectExpW (Gss, Gl, (Pi ((D, _), V), s), K, DupVars, flag, d)  = let (K\', _) = collectDec (Gss, (D, s), (K, DupVars), d, false) in (* should we apply I.dot1(ss) ? Tue Oct 15 21:55:16 2002 -bp *) collectExp (Gss, Decl (Gl, decSub (D, s)), (V, dot1 s), K\', DupVars, flag, d) | collectExpW (Gss, Gl, (Root (_, S), s), K, DupVars, flag, d)  = collectSpine (Gss, Gl, (S, s), K, DupVars, flag, d) | collectExpW (Gss, Gl, (Lam (D, U), s), K, DupVars, flag, d)  = let (K\', _) = collectDec (Gss, (D, s), (K, DupVars), d, false) in collectExp (Gss, Decl (Gl, decSub (D, s)), (U, dot1 s), K\', DupVars, flag, d + 1) | collectExpW (Gss, Gl, (X as EVar (r, GX, V, cnstrs), s), K, DupVars, flag, d)  = collectEVar (Gss, Gl, (X, s), K, DupVars, flag, d) | collectExpW (Gss, Gl, (FgnExp csfe, s), K, DupVars, flag, d)  = fold csfe (fun (U, KD\') -> let (K\', Dup) = KD\' in collectExp (Gss, Gl, (U, s), K\', Dup, false, d)) (K, Decl (DupVars, FGN (d)))(* No other cases can occur due to whnf invariant *) (* collectExp (Gss, G, Gl, (U, s), K) = K\'\n       same as collectExpW  but  (U,s) need not to be in whnf\n    *) collectExp (Gss, Gl, Us, K, DupVars, flag, d)  = collectExpW (Gss, Gl, whnf Us, K, DupVars, flag, d)(* collectSpine (Gss, Gl, (S, s), K, DupVars, flag) = (K\', DupVars\')\n\n       Invariant:\n       If    G, Gl |- s : G1     G1 |- S : V > P\n                Gs |- ss : G\n       then  K\' = K, K\'\' and DupVars\' = DupVars, DupVars\'\'\n       where K\'\' contains all EVars in (S, s)\n       and DupVars\'\' contains all duplicates in (S, s)\n     *) collectSpine (Gss, Gl, (Nil, _), K, DupVars, flag, d)  = (K, DupVars) | collectSpine (Gss, Gl, (SClo (S, s\'), s), K, DupVars, flag, d)  = collectSpine (Gss, Gl, (S, comp (s\', s)), K, DupVars, flag, d) | collectSpine (Gss, Gl, (App (U, S), s), K, DupVars, flag, d)  = let (K\', DupVars\') = collectExp (Gss, Gl, (U, s), K, DupVars, flag, d) in collectSpine (Gss, Gl, (S, s), K\', DupVars\', flag, d)collectEVarFapStr (Gss, Gl, ((X\', V\'), w), (X as EVar (r, GX, V, cnstrs), s), K, DupVars, flag, d)  = match member\' (eqEVar X) K with SOME (label) -> (* we have seen X before *) (if flag then collectSub (Gss, Gl, s, K, Decl (DupVars, AV (X, d)), flag, d)(* case label of\n                     Body => collectSub(Gss, Gl, s, K, I.Decl(DupVars, AV(X,d)), flag, d)\n                   | TypeLabel =>\n                       let\n                         val K\' = update\' (eqEVar X) K\n                       in\n                         collectSub(Gss, Gl, s, K\', DupVars, flag, d)\n                       end *) (* since X has occurred before, we do not traverse its type V\' *)  else collectSub (Gss, Gl, s, K, DupVars, flag, d)) | NONE -> (*          val V\' = raiseType (GX, V) (* inefficient! *)*) let label = if flag then Body else TypeLabel let (K\', DupVars\') = collectExp ((Null, id), Null, (V\', id), K, DupVars, false, d) in collectSub (Gss, Gl, comp (w, s), Decl (K\', (label, EV (X\'))), DupVars\', flag, d)collectEVarNFapStr (Gss, Gl, ((X\', V\'), w), (X as EVar (r, GX, V, cnstrs), s), K, DupVars, flag, d)  = match member\' (eqEVar X) K with SOME (label) -> (* we have seen X before, i.e. it was already strengthened *) (if flag then collectSub (Gss, Gl, s, K, Decl (DupVars, AV (X, d)), flag, d)(* -bp this is a possible optimization for the variant case\n                   case label of\n                   Body => (print "Collect DupVar\\n"; collectSub(Gss, Gl, s, K, I.Decl(DupVars, AV(X, d)), flag, d) )\n                 | TypeLabel =>\n                    let\n                      val _ = print "TypeLabel\\n"\n                      val K\' = update\' (eqEVar X) K\n                    in\n                      collectSub(Gss, Gl, s, K\', DupVars, flag, d)\n                    end*)  else collectSub (Gss, Gl, s, K, DupVars, flag, d)) | NONE -> (* val V\' = raiseType (GX, V) (* inefficient! *)*) let label = if flag then Body else TypeLabel let (K\', DupVars\') = collectExp ((Null, id), Null, (V\', id), K, DupVars, false, d) in if flag then collectSub (Gss, Gl, comp (w, s), Decl (K\', (label, EV (X\'))), Decl (DupVars\', AV (X\', d)), flag, d) else collectSub (Gss, Gl, comp (w, s), Decl (K\', (label, EV (X\'))), DupVars\', flag, d)collectEVarStr (Gss as (Gs, ss), Gl, (X as EVar (r, GX, V, cnstrs), s), K, DupVars, flag, d)  = (* ? *) let w = weaken (GX, targetFam V) let iw = invert w let GX\' = strengthen (iw, GX) let X\' as EVar (r\', _, _, _) = newEVar (GX\', EClo (V, iw)) let _ = instantiateEVar (r, EClo (X\', w), nil) let V\' = raiseType (GX\', EClo (V, iw)) in if isId (comp (w, comp (ss, s)))(* equalCtx (Gs, I.id, GX\', s) *)  then (* fully applied *) collectEVarFapStr (Gss, Gl, ((X\', V\'), w), (X, s), K, DupVars, flag, d) else (* not fully applied *) collectEVarNFapStr (Gss, Gl, ((X\', V\'), w), (X, s), K, DupVars, flag, d)(* X is fully applied pattern *) collectEVarFap (Gss, Gl, (X as EVar (r, GX, V, cnstrs), s), K, DupVars, flag, d)  = match (member (eqEVar X) K) with SOME (label) -> (* we have seen X before *) (if flag then collectSub (Gss, Gl, s, K, Decl (DupVars, AV (X, d)), flag, d)(*\n                 case label of\n                   Body => collectSub(Gss, Gl, s, K, I.Decl(DupVars, AV(X, d)), flag, d)\n                 | TypeLabel =>\n                     let\n                       val K\' = update\' (eqEVar X) K\n                     in\n                       collectSub(Gss, Gl, s, K\', DupVars, flag, d)\n                     end *) (* since X has occurred before, we do not traverse its type V\' *)  else collectSub (Gss, Gl, s, K, DupVars, flag, d)) | NONE -> (* val _ = checkEmpty !cnstrs *) (* inefficient! *) let label = if flag then Body else TypeLabel let V\' = raiseType (GX, V) let (K\', DupVars\') = collectExp ((Null, id), Null, (V\', id), K, DupVars, false, d) in collectSub (Gss, Gl, s, Decl (K\', (label, EV (X))), DupVars\', flag, d)collectEVarNFap (Gss, Gl, (X as EVar (r, GX, V, cnstrs), s), K, DupVars, flag, d)  = match member\' (eqEVar X) K with SOME (label) -> (if flag then collectSub (Gss, Gl, s, K, Decl (DupVars, AV (X, d)), flag, d)(* case label of\n                   Body => collectSub(Gss, Gl, s, K, I.Decl(DupVars, AV(X, d)), flag, d)\n                   | TypeLabel =>\n                     let\n                       val K\' = update\' (eqEVar X) K\n                     in\n                       collectSub(Gss, Gl, s, K\', DupVars, flag, d)\n                     end             *)  else collectSub (Gss, Gl, s, K, DupVars, flag, d)) | NONE -> (* inefficient! *) let label = if flag then Body else TypeLabel let V\' = raiseType (GX, V) let (K\', DupVars\') = collectExp ((Null, id), Null, (V\', id), K, DupVars, false, d) in if flag then collectSub (Gss, Gl, s, Decl (K\', (label, EV (X))), Decl (DupVars, AV (X, d)), flag, d) else collectSub (Gss, Gl, s, Decl (K\', (label, EV (X))), DupVars, flag, d)collectEVar (Gss, Gl, (X as EVar (r, GX, V, cnstrs), s), K, DupVars, flag, d)  = if (! strengthen) then collectEVarStr (Gss, Gl, (X, s), K, DupVars, flag, d) else if isId (s)(* equalCtx (compose\'(Gl, G), s, GX, s)  *)  then (* X is fully applied *) collectEVarFap (Gss, Gl, (X, s), K, DupVars, flag, d) else (* X is not fully applied *) collectEVarNFap (Gss, Gl, (X, s), K, DupVars, flag, d)(* collectDec (Gss, G, (x:V, s), K, DupVars, flag) = (K\', DupVars\')\n\n       Invariant:\n       If    G |- s : G1     G1 |- V : L\n            Gs |- ss : G\n       then  K\' = K, K\'\' and DupVars\' = DupVars, DupVars\'\'\n       where K\'\' contains all EVars in (V, s)\n       and DupVars\'\' contains all duplicates in (S, s)\n    *) collectDec (Gss, (Dec (_, V), s), (K, DupVars), d, flag)  = (*      val (K\',DupVars\') =  collectExp (Gss, I.Null, (V, s), K, I.Null, false, d)*) let (K\', DupVars\') = collectExp (Gss, Null, (V, s), K, DupVars, flag, d) in (K\', DupVars\')(* collectSub (G, s, K, DupVars, flag) = (K\', DupVars)\n\n       Invariant:\n       If    G |- s : G1\n\n       then  K\' = K, K\'\' and DupVars\' = DupVars, DupVars\'\'\n       where K\'\' contains all EVars in s\n       and DupVars\'\' contains all duplicates in s\n    *) collectSub (Gss, Gl, Shift _, K, DupVars, flag, d)  = (K, DupVars) | collectSub (Gss, Gl, Dot (Idx _, s), K, DupVars, flag, d)  = collectSub (Gss, Gl, s, K, DupVars, flag, d) | collectSub (Gss, Gl, Dot (Exp (X as EVar (ref (SOME U), _, _, _)), s), K, DupVars, flag, d)  = (* inefficient? *) let U\' = normalize (U, id) let (K\', DupVars\') = collectExp (Gss, Gl, (U\', id), K, DupVars, flag, d) in collectSub (Gss, Gl, s, K\', DupVars\', flag, d) | collectSub (Gss, Gl, Dot (Exp (U as AVar (ref (SOME U\'))), s), K, DupVars, flag, d)  = let (K\', DupVars\') = collectExp (Gss, Gl, (U\', id), K, DupVars, flag, d) in collectSub (Gss, Gl, s, K\', DupVars\', flag, d) | collectSub (Gss, Gl, Dot (Exp (EClo (U\', s\')), s), K, DupVars, flag, d)  = (* inefficient? *) let U = normalize (U\', s\') let (K\', DupVars\') = collectExp (Gss, Gl, (U, id), K, DupVars, flag, d) in collectSub (Gss, Gl, s, K\', DupVars\', flag, d) | collectSub (Gss, Gl, Dot (Exp (U), s), K, DupVars, flag, d)  = let (K\', DupVars\') = collectExp (Gss, Gl, (U, id), K, DupVars, flag, d) in collectSub (Gss, Gl, s, K\', DupVars\', flag, d) | collectSub (Gss, Gl, Dot (Undef, s), K, DupVars, flag, d)  = collectSub (Gss, Gl, s, K, DupVars, flag, d) (* collectCtx (Gss, G0, G, K) = (K\', DupVars)\n       Invariant:\n       If G0 |- G ctx,\n       then G0\' = G0,G\n       and K\' = K, K\'\' where K\'\' contains all EVars in G\n    *) let rec collectCtx (Gss, DProg (Null, Null), (K, DupVars), d)  = (K, DupVars) | collectCtx (Gss, DProg (Decl (G, D), Decl (dPool, Parameter)), (K, DupVars), d)  = let (K\', DupVars\') = collectCtx (Gss, DProg (G, dPool), (K, DupVars), d - 1) in collectDec (Gss, (D, id), (K\', DupVars\'), d - 1, false) | collectCtx (Gss, DProg (Decl (G, D), Decl (dPool, Dec (r, s, Ha))), (K, DupVars), d)  = let (K\', DupVars\') = collectCtx (Gss, DProg (G, dPool), (K, DupVars), d - 1) in collectDec (Gss, (D, id), (K\', DupVars\'), d - 1, false) (* abstractExpW (epos, apos, Vars, Gl, total, depth, (U, s), eqn) = (epos\', apos\', Vars\', U\', eqn\')\n      (abstraction and linearization of existential variables in (U,s))\n\n       U\' = {{U[s]}}_(K, Dup)\n\n       Invariant:\n       If     G, Gl |- U[s] : V and  U[s] is in whnf\n       and   |Gl| = depth\n             |Dup, K| = total\n\n       and epos = (total(K) + l) - #replaced expressions in U    (generate no additional constraints)\n       and apos = (total(Dup) + + total(K) + l) - #replaced expressions in U\n                  (generate additional constraints (avars))\n\n       and Vars\'  = Vars, Vars\'\'\n           where Vars contains pairs ((label, i), EV X) of all EVars (EV X),\n           where label refers to where we have seen the existential variable (typeLabel or body) and\n           i corresponds to the bvar-index assigned to X in U[s]\n\n       and   K ~ Vars (we can obtain K from Vars by dropping the first component of\n             each pair (_, EV X) in Vars\' )\n\n       then   {{Dup}}, {{K}}  ||- U\n       and {{Dup}} {{K}} , G, Gl |-  U\' : V\'\n       and eqn\' = eqn, eqn\'\' where eqn\'\' are residual equations relating between elements\n           in {{K}} and {{Dup}}\n\n       and . ||- Pi G. U\'  and   U\' is in nf\n\n       if flag then linearize U else allow duplicates.\n\n    *) let rec abstractExpW (flag, Gs, posEA, Vars, Gl, total, depth, (U as Uni (L), s), eqn)  = (posEA, Vars, U, eqn) | abstractExpW (flag, Gs, posEA, Vars, Gl, total, depth, (Pi ((D, P), V), s), eqn)  = let (posEA\', Vars\', D, _) = abstractDec (Gs, posEA, Vars, Gl, total, depth, (D, s), NONE) let (posEA\'\', Vars\'\', V\', eqn2) = abstractExp (flag, Gs, posEA\', Vars\', Gl, total, depth + 1, (V, dot1 s), eqn) in (posEA\'\', Vars\'\', piDepend ((D, P), V\'), eqn2) | abstractExpW (flag, Gs, posEA, Vars, Gl, total, depth, (Root (H, S), s), eqn)  = let (posEA\', Vars\', S, eqn\') = abstractSpine (flag, Gs, posEA, Vars, Gl, total, depth, (S, s), eqn) in (posEA\', Vars\', Root (H, S), eqn\') | abstractExpW (flag, Gs, posEA, Vars, Gl, total, depth, (Lam (D, U), s), eqn)  = let (posEA\', Vars\', D\', _) = abstractDec (Gs, posEA, Vars, Gl, total, depth, (D, s), NONE) let (posEA\'\', Vars\'\', U\', eqn2) = abstractExp (flag, Gs, posEA\', Vars\', Decl (Gl, D\'), total, depth + 1, (U, dot1 s), eqn) in (posEA\'\', Vars\'\', Lam (D\', U\'), eqn2) | abstractExpW (flag, Gs as (Gss, ss), posEA as (epos, apos), Vars, Gl, total, depth, (X as EVar (_, GX, VX, _), s), eqn)  = (* X is possibly strengthened ! *)  if isId (comp (ss, s)) then (* X is fully applied *) abstractEVarFap (flag, Gs, posEA, Vars, Gl, total, depth, (X, s), eqn) else (* s =/= id, i.e. X is not fully applied *) abstractEVarNFap (flag, Gs, posEA, Vars, Gl, total, depth, (X, s), eqn)(*      | abstractExpW (posEA, Vars, Gl, total, depth, (X as I.FgnExp (cs, ops), s), eqn) =  *) (*      let\n          val (X, _) = #map(ops) (fn U => abstractExp (posEA, Vars, Gl, total, depth, (U, s), eqn))\n        in        abstractFgn (posEA, Vars, Gl, total, depth, X, eqn)\n        end\n*) (* abstractExp (posEA, Vars, Gl, total, depth, (U, s)) = U\'\n\n       same as abstractExpW, but (U,s) need not to be in whnf\n    *) abstractExp (flag, Gs, posEA, Vars, Gl, total, depth, Us, eqn)  = abstractExpW (flag, Gs, posEA, Vars, Gl, total, depth, whnf Us, eqn)abstractEVarFap (flag, Gs, posEA as (epos, apos), Vars, Gl, total, depth, (X, s), eqn)  = match (member (eqEVar X) Vars) with SOME (label, i) -> (* we have seen X before *) if flag then (* enforce linearization *) match label with Body -> let BV = BVar (apos + depth) let BV\' = BVar (i + depth) let BV1 = BVar (apos + depth) let (posEA\', Vars\', S, eqn1) = abstractSub (flag, Gs, (epos, apos - 1), Vars, Gl, total, depth, s, Nil, eqn) in (posEA\', Vars\', Root (BV, Nil), Unify (Gl, Root (BV\', S), Root (BV1, Nil), eqn1)) | TypeLabel -> let Vars\' = update (eqEVar X) Vars let (posEA\', Vars\'\', S, eqn1) = abstractSub (flag, Gs, (epos, apos), Vars\', Gl, total, depth, s, Nil, eqn) in (posEA\', Vars\'\', Root (BVar (i + depth), S), eqn1) else (* do not enforce linearization -- used for type labels *) let (posEA\', Vars\', S, eqn1) = abstractSub (flag, Gs, (epos, apos), Vars, Gl, total, depth, s, Nil, eqn) in (posEA\', Vars\', Root (BVar (i + depth), S), eqn1) | NONE -> (* we see X for the first time *) let label = if flag then Body else TypeLabel let BV = BVar (epos + depth) let pos = (epos - 1, apos) let (posEA\', Vars\', S, eqn1) = abstractSub (flag, Gs, pos, Decl (Vars, ((label, epos), EV X)), Gl, total, depth, s, Nil, eqn) in (posEA\', Vars\', Root (BV, S), eqn1)abstractEVarNFap (flag, Gs, posEA as (epos, apos), Vars, Gl, total, depth, (X, s), eqn)  = match (member (eqEVar X) Vars) with SOME (label, i) -> (* we have seen X before *) if flag then (* enforce linearization *) let BV = BVar (apos + depth) let BV\' = BVar (i + depth) let BV1 = BVar (apos + depth) let (posEA\', Vars\', S, eqn1) = abstractSub (flag, Gs, (epos, apos - 1), Vars, Gl, total, depth, s, Nil, eqn) in (posEA\', Vars\', Root (BV, Nil), Unify (Gl, Root (BV\', S), Root (BV1, Nil), eqn1))(* (case label of\n               Body =>\n                 let\n                  val _ = print "abstractEVarNFap -- flag true; we have seen X before\\n"\n                   val BV = I.BVar(apos + depth)\n                   val BV\' = I.BVar(i + depth)\n                   val BV1 = I.BVar(apos + depth)\n                   val (posEA\', Vars\', S, eqn1) = abstractSub (flag, Gs, (epos, apos - 1), Vars, Gl, total, depth, s, I.Nil, eqn)\n                 in\n                   (posEA\', Vars\', I.Root(BV, I.Nil), TableParam.Unify(Gl, I.Root(BV\', S), I.Root(BV1, I.Nil ), eqn1))\n                 end\n              | TyeLabel =>\n                 let\n                   val Vars\' = update (eqEVar X) Vars\n                   val (posEA\', Vars\'\', S, eqn1) = abstractSub (flag, Gs, (epos, apos), Vars\', Gl, total, depth, s, I.Nil, eqn)\n                 in\n                   (posEA\', Vars\'\', I.Root(I.BVar(i + depth), S), eqn1)\n                 end) *)  else (* do not enforce linearization -- used for type labels *) let (posEA\', Vars\', S, eqn1) = abstractSub (flag, Gs, (epos, apos), Vars, Gl, total, depth, s, Nil, eqn) in (posEA\', Vars\', Root (BVar (i + depth), S), eqn1) | NONE -> (* we have not seen X before *) if flag then (* enforce linearization since X is not fully applied *) let label = if flag then Body else TypeLabel let BV = BVar (apos + depth) let BV\' = BVar (epos + depth) let BV1 = BVar (apos + depth) let (posEA\', Vars\', S, eqn1) = abstractSub (flag, Gs, (epos - 1, apos - 1), Decl (Vars, ((label, epos), EV X)), Gl, total, depth, s, Nil, eqn) in (posEA\', Vars\', Root (BV, Nil), Unify (Gl, Root (BV\', S), Root (BV1, Nil), eqn1)) else (* do not enforce linearization -- used for type labels *) let (posEA\', Vars\', S, eqn1) = abstractSub (flag, Gs, (epos - 1, apos), Decl (Vars, ((TypeLabel, epos), EV X)), Gl, total, depth, s, Nil, eqn) in (posEA\', Vars\', Root (BVar (epos + depth), S), eqn1)(* abstractSub (flag, Gs, posEA, Vars, Gl, total, depth, s, S, eqn) = (posEA\', Vars\', S\', eqn\')\n\n       (implicit raising)\n       (for posEA, Vars, eqn explanation see above)\n\n       let K* = K, Dup\n\n       S\' = {{s}}_K* @@ S\n\n       Invariant:\n       If    G, Gl |- s : G1\n       and  |Gl| = depth\n\n       and   {{Dup}} {{K}} ||- s\n       then {{Dup}} {{K}}, G, Gl |- S\' : {G1}.W > W   (for some W)\n       and  . ||- S\'\n    *) abstractSub (flag, Gs, posEA, Vars, Gl, total, depth, Shift (k), S, eqn)  = if k < depth then abstractSub (flag, Gs, posEA, Vars, Gl, total, depth, Dot (Idx (k + 1), Shift (k + 1)), S, eqn) else (* k = depth *) (posEA, Vars, S, eqn) | abstractSub (flag, Gs, posEA, Vars, Gl, total, depth, Dot (Idx (k), s), S, eqn)  = abstractSub (flag, Gs, posEA, Vars, Gl, total, depth, s, App (Root (BVar (k), Nil), S), eqn) | abstractSub (flag, Gs, posEA, Vars, Gl, total, depth, Dot (Exp (U), s), S, eqn)  = let (posEA\', Vars\', U\', eqn\') = abstractExp (flag, Gs, posEA, Vars, Gl, total, depth, (U, id), eqn) in abstractSub (flag, Gs, posEA\', Vars\', Gl, total, depth, s, App (U\', S), eqn\')(* abstractSpine (flag, Gs, posEA, Vars, Gl, total, depth, (S, s), eqn) = (posEA\', Vars\', S\', eqn\')\n       where S\' = {{S[s]}}_K*   and K* = K, Dup\n\n       Invariant:\n       If   Gl, G |- s : G1     G1 |- S : V > P\n       and  K* ||- S\n       and  |G| = depth\n\n       then {{K*}}, G, G |- S\' : V\' > P\'\n       and  . ||- S\'\n    *) abstractSpine (flag, Gs, posEA, Vars, Gl, total, depth, (Nil, _), eqn)  = (posEA, Vars, Nil, eqn) | abstractSpine (flag, Gs, posEA, Vars, Gl, total, depth, (SClo (S, s\'), s), eqn)  = abstractSpine (flag, Gs, posEA, Vars, Gl, total, depth, (S, comp (s\', s)), eqn) | abstractSpine (flag, Gs, posEA, Vars, Gl, total, depth, (App (U, S), s), eqn)  = let (posEA\', Vars\', U\', eqn\') = abstractExp (flag, Gs, posEA, Vars, Gl, total, depth, (U, s), eqn) let (posEA\'\', Vars\'\', S\', eqn\'\') = abstractSpine (flag, Gs, posEA\', Vars\', Gl, total, depth, (S, s), eqn\') in (posEA\'\', Vars\'\', App (U\', S\'), eqn\'\')(* abstractSub\' (flag, Gs, epos, K, Gl, total, s) = (epos\', K\', s\')      (implicit raising)\n\n        Invariant:\n        If   G |- s : G1\n       and  |G| = depth\n       and  K ||- s\n       and {{K}}, G |- {{s}}_K : G1\n       then Gs, G |- s\' : G1    where  s\' == {{s}}_K\n\n         *) abstractSub\' (flag, Gs, epos, Vars, total, Shift (k))  = if k < 0 then raise (Error ("Substitution out of range\\n")) else (epos, Vars, Shift (k + total)) | abstractSub\' (flag, Gs, epos, Vars, total, Dot (Idx (k), s))  = let (epos\', Vars\', s\') = abstractSub\' (flag, Gs, epos, Vars, total, s) in (epos\', Vars\', Dot (Idx (k), s\')) | abstractSub\' (flag, Gs, epos, Vars, total, Dot (Exp (U), s))  = let ((ep, _), Vars\', U\', _) = abstractExp (false, Gs, (epos, 0), Vars, Null, total, 0, (U, id), Trivial) let (epos\'\', Vars\'\', s\') = abstractSub\' (flag, Gs, ep, Vars\', total, s) in (epos\'\', Vars\'\', Dot (Exp (U\'), s\'))(* abstractDec (Gs, posEA, Vars, Gl, total, depth, (x:V, s)) = (posEA\', Vars\', x:V\')\n       where V = {{V[s]}}_K*\n\n       Invariant:\n       If   G |- s : G1     G1 |- V : L\n       and  K* ||- V\n       and  |G| = depth\n\n       then {{K*}}, G |- V\' : L\n       and  . ||- V\'\n    *) abstractDec (Gs, posEA, Vars, Gl, total, depth, (Dec (x, V), s), NONE)  = (*      val (posEA\', Vars\', V\', _) = abstractExp (false, Gs, posEA, Vars, Gl, total, depth, (V, s), TableParam.Trivial)*) let (posEA\', Vars\', V\', eqn) = abstractExp (false, Gs, posEA, Vars, Gl, total, depth, (V, s), Trivial) in (posEA\', Vars\', Dec (x, V\'), eqn) | abstractDec (Gs, posEA, Vars, Gl, total, depth, (Dec (x, V), s), SOME (eqn))  = (*      val (posEA\', Vars\', V\', _) = abstractExp (false, Gs, posEA, Vars, Gl, total, depth, (V, s), TableParam.Trivial)*) let (posEA\', Vars\', V\', eqn\') = abstractExp (true, Gs, posEA, Vars, Gl, total, depth, (V, s), eqn) in (posEA\', Vars\', Dec (x, V\'), eqn\') (* abstractCtx (Gs, epos, K, total, depth, C.DProg(G,dPool)) = (epos\', K\', G\')\n       where G\' = {{G}}_K\n\n       Invariants:\n       If K ||- G\n       and |G| = depth\n       then {{K}} |- G\' ctx\n       and . ||- G\'\n       and epos = current epos\n\n       note: we will linearize all dynamic assumptions in G.\n    *) let rec abstractCtx\' (Gs, epos, Vars, total, depth, DProg (Null, Null), G\', eqn)  = (epos, Vars, G\', eqn) | abstractCtx\' (Gs, epos, Vars, total, depth, DProg (Decl (G, D), Decl (dPool, Parameter)), G\', eqn)  = let d = ctxLength (G) let ((epos\', _), Vars\', D\', _) = abstractDec (Gs, (epos, total), Vars, Null, total, depth - 1, (D, id), NONE) in abstractCtx\' (Gs, epos\', Vars\', total, depth - 1, DProg (G, dPool), Decl (G\', D\'), eqn) | abstractCtx\' (Gs, epos, Vars, total, depth, DProg (Decl (G, D), Decl (dPool, _)), G\', eqn)  = let d = ctxLength (G) let ((epos\', _), Vars\', D\', _) = abstractDec (Gs, (epos, total), Vars, Null, total, depth - 1, (D, id), NONE) in abstractCtx\' (Gs, epos\', Vars\', total, depth - 1, DProg (G, dPool), Decl (G\', D\'), eqn) (*        let\n          val d = IntSyn.ctxLength (G)\n          val ((epos\', _), Vars\', D\', eqn\') = abstractDec (Gs, (epos, total), Vars, I.Null, total , depth - 1, (D, I.id), SOME(eqn))\n        in\n          abstractCtx\' (Gs, epos\', Vars\', total, depth - 1, C.DProg(G, dPool), I.Decl (G\', D\'), eqn\')\n        end\n*) let rec abstractCtx (Gs, epos, Vars, total, depth, dProg)  = abstractCtx\' (Gs, epos, Vars, total, depth, dProg, Null, Trivial) (* makeEVarCtx (Gs, Kall, D, K, eqn) = G\'  *) let rec makeEVarCtx (Gs, Vars, DEVars, Null, total)  = DEVars | makeEVarCtx (Gs, Vars, DEVars, Decl (K\', (_, EV (E as EVar (_, GX, VX, _)))), total)  = let V\' = raiseType (GX, VX) let (_, Vars\', V\'\', _) = abstractExp (false, Gs, (0, 0), Vars, Null, 0, (total - 1), (V\', id), Trivial) let DEVars\' = makeEVarCtx (Gs, Vars\', DEVars, K\', total - 1) let DEVars\'\' = Decl (DEVars\', Dec (NONE, V\'\')) in DEVars\'\' let rec makeAVarCtx (Vars, DupVars)  = let rec avarCtx (Vars, Null, k)  = Null | avarCtx (Vars, Decl (K\', AV (E as EVar (ref NONE, GX, VX, _), d)), k)  = Decl (avarCtx (Vars, K\', k + 1), ADec (SOME ("AVar " ^ toString k ^ "--" ^ toString d), d)) | avarCtx (Vars, Decl (K\', AV (E as EVar (_, GX, VX, _), d)), k)  = Decl (avarCtx (Vars, K\', k + 1), ADec (SOME ("AVar " ^ toString k ^ "--" ^ toString d), d)) in avarCtx (Vars, DupVars, 0) (* add case for foreign expressions ? *) (* lowerEVar\' (G, V[s]) = (X\', U), see lowerEVar *) let rec lowerEVar\' (X, G, (Pi ((D\', _), V\'), s\'))  = let D\'\' = decSub (D\', s\') let (X\', U) = lowerEVar\' (X, Decl (G, D\'\'), whnf (V\', dot1 s\')) in (X\', Lam (D\'\', U)) | lowerEVar\' (X, G, Vs\')  = let X\' = X in (X\', X\')(* lowerEVar1 (X, V[s]), V[s] in whnf, see lowerEVar *) (* lowerEVar1 (X, I.EVar (r, G, _, _), (V as I.Pi _, s)) = *) lowerEVar1 (X, EVar (r, G, _, _), (V as Pi _, s))  = let (X\', U) = lowerEVar\' (X, G, (V, s)) in EVar (ref (SOME (U)), Null, V, ref nil) | lowerEVar1 (_, X, _)  = X(* lowerEVar (X) = X\'\n\n       Invariant:\n       If   G |- X : {{G\'}} P\n            X not subject to any constraints\n       then G, G\' |- X\' : P\n\n       Effect: X is instantiated to [[G\']] X\' if G\' is empty\n               otherwise X = X\' and no effect occurs.\n    *) lowerEVar (E, X as EVar (r, G, V, ref nil))  = lowerEVar1 (E, X, whnf (V, id)) | lowerEVar (E, EVar _)  = (* It is not clear if this case can happen *)  (* pre-Twelf 1.2 code walk, Fri May  8 11:05:08 1998 *)  raise (Error "abstraction : LowerEVars: Typing ambiguous -- constraint of functional type cannot be simplified") (* evarsToSub (K, s\') = s\n      Invariant:\n      if K = EV Xn ... EV X2, EV X1\n        then\n        s = X1 . X2 . ... s\'\n     *) let rec evarsToSub (Null, s)  = s | evarsToSub (Decl (K\', (_, EV (E as EVar (I as (ref NONE), GX, VX, cnstr)))), s)  = (* redundant ? *) let V\' = raiseType (GX, VX) let X = lowerEVar1 (E, EVar (I, Null, V\', cnstr), whnf (V\', id)) let s\' = evarsToSub (K\', s) in Dot (Exp (X), s\') (* evarsToSub (K, s\') = s\n      Invariant:\n      if K = AV Xn ... AV X2, EV X1\n        then\n        s = X1 . X2 . ... s\'\n     *) let rec avarsToSub (Null, s)  = s | avarsToSub (Decl (Vars\', (AV (E as EVar (I, GX, VX, cnstr), d))), s)  = let s\' = avarsToSub (Vars\', s) let X\' as AVar (r) = newAVar () in Dot (Exp (EClo (X\', Shift (~ d))), s\') (* abstractEVarCtx (G, p, s) = (G\', D\', U\', s\')\n\n     if G |- p[s] and s contains free variables X_n .... X_1\n     then\n       D\' |- Pi  G\' . U\'\n       where D\' is the abstraction over the free vars X_n .... X_1\n\n       and s\' is a substitution the free variables\n            X_n .... X_1, s.t.\n\n       . |- s\' : D\'\n\n       . |- (Pi G\' .U\' )[s\']  is equivalent to . |- Pi G . p[s]\n\n       Note: G\' and U\' are possibly strengthened\n   *) let rec abstractEVarCtx (dp as DProg (G, dPool), p, s)  = (* K ||- G i.e. K contains all EVars in G *) (* DupVars\' , K\' ||- p[s]  i.e. K\' contains all EVars in (p,s) and G and\n                                         DupVars\' contains all duplicate EVars p[s] *) (* {{G}}_Vars\' , i.e. abstract over the existential variables in G*) (* abstract over existential variables in p[s] and linearize the expression *) (* note: depth will become negative during makeEVarCtx *) let (Gs, ss, d) = (if (! strengthen) then let w\' = weaken (G, targetFam p) let iw = invert w\' let G\' = strengthen (iw, G) let d\' = ctxLength (G\') in (G\', iw, d\') else (G, id, ctxLength (G))) let (K, DupVars) = collectCtx ((Gs, ss), dp, (Null, Null), d) let (K\', DupVars\') = collectExp ((Gs, ss), Null, (p, s), K, DupVars, true, d) let epos = ctxLength (K\') let apos = ctxLength (DupVars\') let total = epos + apos let (epos\', Vars\', G\', eqn) = abstractCtx ((Gs, ss), epos, Null, total, d, dp) let (posEA\'\', (* = 0 *) , Vars\'\', U\', eqn\') = abstractExp (true, (Gs, ss), (epos\', total), Vars\', Null, total, d, (p, s), eqn) let DAVars = makeAVarCtx (Vars\'\', DupVars\') let DEVars = makeEVarCtx ((Gs, ss), Vars\'\', Null, Vars\'\', 0, (* depth *) ) let s\' = avarsToSub (DupVars\', id) let s\'\' = evarsToSub (Vars\'\', s\') let G\'\' = reverseCtx (G\', Null) in if (! strengthen) then let w\' = weaken (G\'\', targetFam U\') let iw = invert w\' let Gs\' = strengthen (iw, G\'\') in (Gs\', DAVars, DEVars, U\', eqn\', s\'\') else (G\'\', DAVars, DEVars, U\', eqn\', s\'\') let abstractEVarCtx = abstractEVarCtx (* abstractAnswSub s = (D\', s\')\n\n   if  |- s : Delta\' and s may contain free variables and\n     D |- Pi G. U  and  |- s : D and  |- (Pi G . U)[s]\n    then\n\n    D\' |- s\' : D   where D\' contains all the\n    free variables from s\n   *) let abstractAnswSub = (fun s -> (* no linearization for answer substitution *) let (K, _) = collectSub ((Null, id), Null, s, Null, Null, false, 0) let epos = ctxLength K let (_, (*0 *) , Vars, s\') = abstractSub\' (false, (Null, id), epos, Null, epos, (* total *) , s) let DEVars = makeEVarCtx ((Null, id), Vars, Null, Vars, 0) let s1\' = ctxToEVarSub (DEVars, id) in (DEVars, s\')) let raiseType = (fun (G, U) -> raiseType (G, U))  end\n(* functor AbstractTabled *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', 'module SwMemoTable ((* structure TableParam : TABLEPARAM *) module MemoTable : MEMOTABLEmodule MemoTableInst : MEMOTABLE(*! sharing MemoTableInst.IntSyn = MemoTable.IntSyn !*) (*! sharing MemoTableInst.CompSyn = MemoTable.CompSyn !*) (*! sharing MemoTableInst.TableParam = MemoTable.TableParam !*) ) : MEMOTABLE = struct (*! structure IntSyn = MemoTable.IntSyn !*)  (*! structure CompSyn = MemoTable.CompSyn !*)  (*! structure TableParam = MemoTable.TableParam !*)  let rec callCheck args  = match (! strategy) with Variant -> callCheck args | Subsumption -> callCheck args let rec insertIntoTree args  = match (! strategy) with Variant -> insertIntoTree args | Subsumption -> insertIntoTree args let rec answerCheck args  = match (! strategy) with Variant -> answerCheck args | Subsumption -> answerCheck args let rec reset ()  = match (! strategy) with Variant -> reset () | Subsumption -> reset () let rec updateTable ()  = match (! strategy) with Variant -> updateTable () | Subsumption -> updateTable () let rec tableSize ()  = match (! strategy) with Variant -> tableSize () | Subsumption -> tableSize () let rec memberCtx args  = match (! strategy) with Subsumption -> memberCtx args | Variant -> memberCtx args end\n(* functor SwMemoTable *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module TableParam = TableParam(module Global = Global)', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Trace ((*! structure IntSyn\' : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) ) : TRACE = struct (*! structure IntSyn = IntSyn\' !*)  module I = IntSynmodule P = Printmodule N = Names(* Printing Utilities *) let rec headToString (G, Const (c))  = qidToString (constQid c) | headToString (G, Def (d))  = qidToString (constQid d) | headToString (G, BVar (k))  = bvarName (G, k) let rec expToString (GU)  = expToString (GU) ^ ". " let rec decToString (GD)  = decToString (GD) ^ ". " let rec eqnToString (G, U1, U2)  = expToString (G, U1) ^ " = " ^ expToString (G, U2) ^ ". " let rec newline ()  = print "\\n" let rec printCtx (Null)  = print "No hypotheses or parameters. " | printCtx (Decl (Null, D))  = print (decToString (Null, D)) | printCtx (Decl (G, D))  = (printCtx (G); newline (); print (decToString (G, D))) let rec evarsToString (Xnames)  = let inst = evarInstToString (Xnames) let constrOpt = evarCnstrsToStringOpt (Xnames) in match constrOpt with NONE -> inst | SOME (constr) -> inst ^ "\\nConstraints:\\n" ^ constr let rec varsToEVarInst (nil)  = nil | varsToEVarInst (name :: names)  = match getEVarOpt name with NONE -> (print ("Trace warning: ignoring unknown variable " ^ name ^ "\\n"); varsToEVarInst (names)) | SOME (X) -> (X, name) :: varsToEVarInst (names) let rec printVars (names)  = print (evarsToString (varsToEVarInst names)) let rec printVarstring (line)  = printVars (tl (tokens isSpace line)) type Spec = None | Some of \'a list | All let traceSpec : string Spec ref = ref None let breakSpec : string Spec ref = ref None let rec trace (None)  = traceSpec := None | trace (Some (names))  = traceSpec := Some (names) | trace (All)  = traceSpec := All let rec break (None)  = breakSpec := None | break (Some (names))  = breakSpec := Some (names) | break (All)  = breakSpec := All let detail = ref 1 let rec setDetail (NONE)  = print ("Trace warning: detail is not a valid integer\\n") | setDetail (SOME (n))  = if 0 <= n(* andalso n <= 2 *)  then detail := n else print ("Trace warning: detail must be positive\\n") let traceTSpec : cid Spec ref = ref None let breakTSpec : cid Spec ref = ref None let rec toCids (nil)  = nil | toCids (name :: names)  = (match stringToQid name with NONE -> (print ("Trace warning: ignoring malformed qualified identifier " ^ name ^ "\\n"); toCids names) | SOME qid -> (match constLookup qid with NONE -> (print ("Trace warning: ignoring undeclared constant " ^ qidToString qid ^ "\\n"); toCids names) | SOME cid -> cid :: toCids names)) let rec initTrace (None)  = traceTSpec := None | initTrace (Some (names))  = traceTSpec := Some (toCids names) | initTrace (All)  = traceTSpec := All let rec initBreak (None)  = breakTSpec := None | initBreak (Some (names))  = breakTSpec := Some (toCids names) | initBreak (All)  = breakTSpec := All let rec printHelp ()  = print "<newline> - continue --- execute with current settings\\n\\\n\\n - next --- take a single step\\n\\\n\\r - run --- remove all breakpoints and continue\\n\\\n\\s - skip --- skip until current subgoals succeeds, is retried, or fails\\n\\\n\\s n - skip to n --- skip until goal (n) is considered\\n\\\n\\t - trace --- trace all events\\n\\\n\\u - untrace --- trace no events\\n\\\n\\d n - detail --- set trace detail to n (0, 1, or 2)\\n\\\n\\h - hypotheses --- show current hypotheses\\n\\\n\\g - goal --- show current goal\\n\\\n\\i - instantiation --- show instantiation of variables in current goal\\n\\\n\\v X1 ... Xn - variables --- show instantiation of X1 ... Xn\\n\\\n\\? for help" let currentGoal : dctx * Exp ref = ref (Null, Uni (Type)) (* dummy initialization *) let currentEVarInst : Exp * string list ref = ref nil let rec setEVarInst (Xs)  = currentEVarInst := map (fun X -> (X, evarName (Null, X))) Xs let rec setGoal (G, V)  = (currentGoal := (G, V); setEVarInst (collectEVars (G, (V, id), nil))) type goalTag = int option let tag : goalTag ref = ref NONE let rec tagGoal ()  = match ! tag with NONE -> NONE | SOME (n) -> (tag := SOME (n + 1); ! tag) let watchForTag : goalTag ref = ref NONE let rec initTag ()  = (watchForTag := NONE; match (! traceTSpec, ! breakTSpec) with (None, None) -> tag := NONE | _ -> tag := SOME (0)) let rec setWatchForTag (NONE)  = (watchForTag := ! tag) | setWatchForTag (SOME (n))  = (watchForTag := SOME (n)) let rec breakAction (G)  = let _ = print " " let line = inputLine97 (stdIn) in match sub (line, 0) with \'\\n\' -> () | \'n\' -> (breakTSpec := All) | \'r\' -> (breakTSpec := None) | \'s\' -> (setWatchForTag (fromString (extract (line, 1, NONE)))) | \'t\' -> (traceTSpec := All; print "% Now tracing all"; breakAction (G)) | \'u\' -> (traceTSpec := None; print "% Now tracing none"; breakAction (G)) | \'d\' -> (setDetail (fromString (extract (line, 1, NONE))); print ("% Trace detail now " ^ toString (! detail)); breakAction (G)) | \'h\' -> (printCtx G; breakAction (G)) | \'g\' -> (print (expToString (! currentGoal)); breakAction (G)) | \'i\' -> (print (evarsToString (rev (! currentEVarInst))); breakAction (G)) | \'v\' -> (printVarstring (line); breakAction (G)) | \'?\' -> (printHelp (); breakAction (G)) | _ -> (print "unrecognized command (? for help)"; breakAction (G)) let rec init ()  = (initTrace (! traceSpec); initBreak (! breakSpec); initTag ()) type Event = IntroHyp of Head * Dec | DischargeHyp of Head * Dec | IntroParm of Head * Dec | DischargeParm of Head * Dec | Resolved of Head * Head | Subgoal of (Head * Head) * (unit -> int) | SolveGoal of goalTag * Head * Exp | SucceedGoal of goalTag * (Head * Head) * Exp | CommitGoal of goalTag * (Head * Head) * Exp | RetryGoal of goalTag * (Head * Head) * Exp | FailGoal of goalTag * Head * Exp | Unify of (Head * Head) * Exp * Exp | FailUnify of (Head * Head) * string (* failure message *) let rec eventToString (G, IntroHyp (_, D))  = "% Introducing hypothesis\\n" ^ decToString (G, D) | eventToString (G, DischargeHyp (_, Dec (SOME (x), _)))  = "% Discharging hypothesis " ^ x | eventToString (G, IntroParm (_, D))  = "% Introducing parameter\\n" ^ decToString (G, D) | eventToString (G, DischargeParm (_, Dec (SOME (x), _)))  = "% Discharging parameter " ^ x | eventToString (G, Resolved (Hc, Ha))  = "% Resolved with clause " ^ headToString (G, Hc) ^ "\\n" ^ evarsToString (rev (! currentEVarInst)) | eventToString (G, Subgoal ((Hc, Ha), msg))  = "% Solving subgoal (" ^ toString (msg ()) ^ ") of clause " ^ headToString (G, Hc) | eventToString (G, SolveGoal (SOME (tag), _, V))  = "% Goal " ^ toString tag ^ ":\\n" ^ expToString (G, V) | eventToString (G, SucceedGoal (SOME (tag), _, V))  = "% Goal " ^ toString tag ^ " succeeded" | eventToString (G, CommitGoal (SOME (tag), _, V))  = "% Goal " ^ toString tag ^ " committed to first solution" | eventToString (G, RetryGoal (SOME (tag), (Hc, Ha), V))  = "% Backtracking from clause " ^ headToString (G, Hc) ^ "\\n" ^ "% Retrying goal " ^ toString tag ^ ":\\n" ^ expToString (G, V) | eventToString (G, FailGoal (SOME (tag), _, V))  = "% Failed goal " ^ toString tag | eventToString (G, Unify ((Hc, Ha), Q, P))  = "% Trying clause " ^ headToString (G, Hc) ^ "\\n" ^ eqnToString (G, Q, P) | eventToString (G, FailUnify ((Hc, Ha), msg))  = "% Unification failed with clause " ^ headToString (G, Hc) ^ ":\\n" ^ msg let rec traceEvent (G, e)  = print (eventToString (G, e)) let rec monitorHead (cids, Const (c))  = exists (fun c\' -> c = c\') cids | monitorHead (cids, Def (d))  = exists (fun c\' -> d = c\') cids | monitorHead (cids, BVar (k))  = false let rec monitorHeads (cids, (Hc, Ha))  = monitorHead (cids, Hc) || monitorHead (cids, Ha) let rec monitorEvent (cids, IntroHyp (H, _))  = monitorHead (cids, H) | monitorEvent (cids, DischargeHyp (H, _))  = monitorHead (cids, H) | monitorEvent (cids, IntroParm (H, _))  = monitorHead (cids, H) | monitorEvent (cids, DischargeParm (H, _))  = monitorHead (cids, H) | monitorEvent (cids, SolveGoal (_, H, V))  = monitorHead (cids, H) | monitorEvent (cids, SucceedGoal (_, (Hc, Ha), _))  = monitorHeads (cids, (Hc, Ha)) | monitorEvent (cids, CommitGoal (_, (Hc, Ha), _))  = monitorHeads (cids, (Hc, Ha)) | monitorEvent (cids, RetryGoal (_, (Hc, Ha), _))  = monitorHeads (cids, (Hc, Ha)) | monitorEvent (cids, FailGoal (_, H, _))  = monitorHead (cids, H) | monitorEvent (cids, Resolved (Hc, Ha))  = monitorHeads (cids, (Hc, Ha)) | monitorEvent (cids, Subgoal ((Hc, Ha), _))  = monitorHeads (cids, (Hc, Ha)) | monitorEvent (cids, Unify ((Hc, Ha), _, _))  = monitorHeads (cids, (Hc, Ha)) | monitorEvent (cids, FailUnify ((Hc, Ha), _))  = monitorHeads (cids, (Hc, Ha)) let rec monitorDetail (Unify _)  = ! detail >= 2 | monitorDetail (FailUnify _)  = ! detail >= 2 | monitorDetail _  = ! detail >= 1 (* expensive if tracing Unify! *) (* but: maintain only if break or trace is on *) (* may not be sufficient for some information *) let rec maintain (G, SolveGoal (_, _, V))  = setGoal (G, V) | maintain (G, RetryGoal (_, _, V))  = setGoal (G, V) | maintain (G, FailGoal (_, _, V))  = setGoal (G, V) | maintain (G, Unify (_, Q, P))  = (* show substitution for variables in clause head if tracing unification *)  setEVarInst (collectEVars (G, (P, id), collectEVars (G, (Q, id), nil))) | maintain _  = () let rec monitorBreak (None, G, e)  = false | monitorBreak (Some (cids), G, e)  = if monitorEvent (cids, e) then (maintain (G, e); traceEvent (G, e); breakAction (G); true) else false | monitorBreak (All, G, e)  = (maintain (G, e); traceEvent (G, e); breakAction (G); true) let rec monitorTrace (None, G, e)  = false | monitorTrace (Some (cids), G, e)  = if monitorEvent (cids, e) then (maintain (G, e); traceEvent (G, e); newline (); true) else false | monitorTrace (All, G, e)  = (maintain (G, e); traceEvent (G, e); newline (); true) let rec watchFor (e)  = match ! watchForTag with NONE -> false | SOME (t) -> (match e with SolveGoal (SOME (t\'), _, _) -> (t\' = t) | SucceedGoal (SOME (t\'), _, _) -> (t\' = t) | CommitGoal (SOME (t\'), _, _) -> (t\' = t) | RetryGoal (SOME (t\'), _, _) -> (t\' = t) | FailGoal (SOME (t\'), _, _) -> (t\' = t) | _ -> false) let rec skipping ()  = match ! watchForTag with NONE -> false | SOME _ -> true let rec signal (G, e)  = if monitorDetail (e) then if skipping () then if watchFor (e) then (watchForTag := NONE; signal (G, e)) else (monitorTrace (! traceTSpec, G, e); ()) else if monitorBreak (! breakTSpec, G, e)(* stops, continues after input *)  then () else (monitorTrace (! traceTSpec, G, e); ())(* prints trace, continues *)  else () let rec showSpec (msg, None)  = print (msg ^ " = None\\n") | showSpec (msg, Some (names))  = (print (msg ^ " = Some ["); app (fun name -> print (" " ^ name)) names; print "]\\n") | showSpec (msg, All)  = print (msg ^ " = All\\n") let rec tracing ()  = (match (! traceSpec, ! breakSpec) with (None, None) -> false | _ -> true) let rec show ()  = (showSpec ("trace", ! traceSpec); showSpec ("break", ! breakSpec); print ("detail = " ^ toString (! detail) ^ "\\n")) let rec reset ()  = (trace (None); break (None); detail := 1)  end\n(* functor Trace *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Abstraction *) (* Author: Brigitte Pientka *) module type ABSTRACTTABLED = sig (*! structure IntSyn : INTSYN !*) (*! structure TableParam : TABLEPARAM !*) exception Error of stringval abstractEVarCtx : (DProg * Exp * Sub) -> (dctx * dctx * dctx * Exp * ResEqn * Sub)val abstractAnswSub : Sub -> dctx * Subval raiseType : dctx * Exp -> Exp end\n(* signature ABSTRACTTABLED *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Abstract Machine *) (* Author: Iliano Cervesato *) (* Modified: Jeff Polakow, Frank Pfenning, Larry Greenfield, Roberto Virga *) module AbsMachine ((*! structure IntSyn' : INTSYN !*) (*! structure CompSyn' : COMPSYN !*) (*! sharing CompSyn'.IntSyn = IntSyn' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn' !*) module Assign : ASSIGN(*! sharing Assign.IntSyn = IntSyn' !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn' !*) (* CPrint currently unused *) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn' !*) (*! sharing CPrint.CompSyn = CompSyn' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn' !*) ) : ABSMACHINE = struct (*! structure IntSyn = IntSyn' !*)  (*! structure CompSyn = CompSyn' !*)  module I = IntSynmodule C = CompSyn(* We write\n       G |- M : g\n     if M is a canonical proof term for goal g which could be found\n     following the operational semantics.  In general, the\n     success continuation sc may be applied to such M's in the order\n     they are found.  Backtracking is modeled by the return of\n     the success continuation.\n\n     Similarly, we write\n       G |- S : r\n     if S is a canonical proof spine for residual goal r which could\n     be found following the operational semantics.  A success continuation\n     sc may be applies to such S's in the order they are found and\n     return to indicate backtracking.\n  *) let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a let rec eqHead (Const a, Const a')  = a = a' | eqHead (Def a, Def a')  = a = a' | eqHead _  = false (* Wed Mar 13 10:27:00 2002 -bp  *) (* should probably go to intsyn.fun *) let rec compose (G, Null)  = G | compose (G, Decl (G', D))  = Decl (compose (G, G'), D) let rec shiftSub (Null, s)  = s | shiftSub (Decl (G, D), s)  = dot1 (shiftSub (G, s)) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Pi ((D, Maybe), V)) (* solve ((g, s), dp, sc) = ()\n     Invariants:\n       dp = (G, dPool) where  G ~ dPool  (context G matches dPool)\n       G |- s : G'\n       G' |- g  goal\n       if  G |- M : g[s]\n       then  sc M  is evaluated\n\n     Effects: instantiation of EVars in g, s, and dp\n              any effect  sc M  might have\n  *) let rec solve ((Atom (p), s), dp as DProg (G, dPool), sc)  = matchAtom ((p, s), dp, sc) | solve ((Impl (r, A, Ha, g), s), DProg (G, dPool), sc)  = let D' = Dec (NONE, EClo (A, s)) in solve ((g, dot1 s), DProg (Decl (G, D'), Decl (dPool, Dec (r, s, Ha))), (fun M -> sc (Lam (D', M)))) | solve ((All (D, g), s), DProg (G, dPool), sc)  = (*      val D' = I.decSub (D, s) *) let D' = decLUName (G, decSub (D, s)) in solve ((g, dot1 s), DProg (Decl (G, D'), Decl (dPool, Parameter)), (fun M -> sc (Lam (D', M))))(* rSolve ((p,s'), (r,s), dp, sc) = ()\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G'\n       G' |- r  resgoal\n       G |- s' : G''\n       G'' |- p : H @ S' (mod whnf)\n       if G |- S : r[s]\n       then sc S is evaluated\n     Effects: instantiation of EVars in p[s'], r[s], and dp\n              any effect  sc S  might have\n  *) rSolve (ps', (Eq (Q), s), DProg (G, dPool), sc)  = if unifiable (G, (Q, s), ps')(* effect: instantiate EVars *)  then sc Nil(* call success continuation *)  else () | rSolve (ps', (Assign (Q, eqns), s), dp as DProg (G, dPool), sc)  = (match assignable (G, ps', (Q, s)) with SOME (cnstr) -> aSolve ((eqns, s), dp, cnstr, (fun () -> sc Nil)) | NONE -> ()) | rSolve (ps', (And (r, A, g), s), dp as DProg (G, dPool), sc)  = (* is this EVar redundant? -fp *) (* same effect as s^-1 *) let X = newEVar (G, EClo (A, s)) in rSolve (ps', (r, Dot (Exp (X), s)), dp, (fun S -> solve ((g, s), dp, (fun M -> sc (App (M, S)))))) | rSolve (ps', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), sc)  = let X = newEVar (G, EClo (A, s)) in rSolve (ps', (r, Dot (Exp (X), s)), dp, (fun S -> sc (App (X, S)))) | rSolve (ps', (Axists (ADec (_, d), r), s), dp as DProg (G, dPool), sc)  = let X' = newAVar () in rSolve (ps', (r, Dot (Exp (EClo (X', Shift (~ d))), s)), dp, sc)(* we don't increase the proof term here! *)(* aSolve ((ag, s), dp, sc) = ()\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G'\n       if G |- ag[s] auxgoal\n       then sc () is evaluated\n     Effects: instantiation of EVars in ag[s], dp and sc () *) aSolve ((Trivial, s), dp, cnstr, sc)  = if solveCnstr cnstr then sc () else () | aSolve ((UnifyEq (G', e1, N, eqns), s), dp as DProg (G, dPool), cnstr, sc)  = let G'' = compose (G, G') let s' = shiftSub (G', s) in if unifiable (G'', (N, s'), (e1, s')) then aSolve ((eqns, s), dp, cnstr, sc) else ()(* matchatom ((p, s), dp, sc) => ()\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G'\n       G' |- p : type, p = H @ S mod whnf\n       if G |- M :: p[s]\n       then sc M is evaluated\n     Effects: instantiation of EVars in p[s] and dp\n              any effect  sc M  might have\n\n     This first tries the local assumptions in dp then\n     the static signature.\n  *) matchAtom (ps' as (Root (Ha, S), s), dp as DProg (G, dPool), sc)  = (* matchSig [c1,...,cn] = ()\n           try each constant ci in turn for solving atomic goal ps', starting\n           with c1.\n\n           #succeeds >= 1 (succeeds at least once)\n        *) (* matchSigDet [c1,...,cn] = ()\n           try each constant ci in turn for solving atomic goal ps', starting\n           with c1.\n\n           succeeds exactly once (#succeeds = 1)\n        *) (* matchDProg (dPool, k) = ()\n           where k is the index of dPool in global dPool from call to matchAtom.\n           Try each local assumption for solving atomic goal ps', starting\n           with the most recent one.\n        *) let deterministic = detTableCheck (cidFromHead Ha) exception SucceedOnce of Spine let rec matchSig nil  = () | matchSig (Hc :: sgn')  = let SClause (r) = sProgLookup (cidFromHead Hc) in (* trail to undo EVar instantiations *) trail (fun () -> rSolve (ps', (r, id), dp, (fun S -> sc (Root (Hc, S))))); matchSig sgn' let rec matchSigDet nil  = () | matchSigDet (Hc :: sgn')  = let SClause (r) = sProgLookup (cidFromHead Hc) in (* trail to undo EVar instantiations *) try  with let rec matchDProg (Null, _)  = (* dynamic program exhausted, try signature *)  if deterministic then matchSigDet (lookup (cidFromHead Ha)) else matchSig (lookup (cidFromHead Ha)) | matchDProg (Decl (dPool', Dec (r, s, Ha')), k)  = if eqHead (Ha, Ha') then if deterministic then (* #succeeds = 1 *) (try  with ) else (* #succeeds >= 1 -- allows backtracking *) (trail (* trail to undo EVar instantiations *)  (fun () -> rSolve (ps', (r, comp (s, Shift (k))), dp, (fun S -> sc (Root (BVar (k), S))))); matchDProg (dPool', k + 1)) else matchDProg (dPool', k + 1) | matchDProg (Decl (dPool', Parameter), k)  = matchDProg (dPool', k + 1) let rec matchConstraint (cnstrSolve, try)  = let succeeded = trail (fun () -> match (cnstrSolve (G, SClo (S, s), try)) with SOME (U) -> (sc U; true) | NONE -> false) in if succeeded then matchConstraint (cnstrSolve, try + 1) else () in match constStatus (cidFromHead Ha) with (Constraint (cs, cnstrSolve)) -> matchConstraint (cnstrSolve, 0) | _ -> matchDProg (dPool, 1) let solve = solve  (* local ... *)  end\n(* functor AbsMachine *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Linear Substitution Tree indexing *) (* Linearity: Any variables occurring inside the substitution tree are linear *) (* Any term we insert into the substitution tree is in normalform ! *) (* Instance Checking *) (* Author: Brigitte Pientka *) module MemoTableInst ((*! structure IntSyn\' : INTSYN !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn\' !*) module Whnf : WHNFmodule Match : MATCH(*! sharing Whnf.IntSyn = IntSyn\' !*) (*! structure RBSet : RBSET !*) module Assign : ASSIGN(*! structure TableParam : TABLEPARAM !*) (*! sharing TableParam.IntSyn = IntSyn\' !*) (*! sharing TableParam.CompSyn = CompSyn\' !*) (*! sharing TableParam.RBSet = RBSet !*) module AbstractTabled : ABSTRACTTABLED(*! sharing AbstractTabled.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\'!*) ) : MEMOTABLE = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure CompSyn = CompSyn\' !*)  module AbstractTabled = AbstractTabled (*! structure TableParam = TableParam !*)  (* ---------------------------------------------------------------------- *)  (* Linear substitution tree for linear terms *)  (* normalSubsts: key = int = nvar  (key, (depth, U))\n\n   example:  \\x. f( i1, a)   then i1 = (1, X) = X[x/x]\n\n   *)  (* property: linear *)  type normalSubsts = int(* local depth *)  * Exp ordSet type exSubsts = Front ordSet let nid : unit -> normalSubsts = new let asid : unit -> exSubsts = new let aid = aid let rec isId s  = isEmpty s (* ---------------------------------------------------------------------- *)  (* Context for existential variable *)  type ctx = int * Dec list ref (* functions for handling context for existential variables *)  let rec emptyCtx ()  ctx  = ref [] let rec copy L  ctx  = ref (! L) (* destructively updates L *)  let rec delete (x, L : ctx)  = let rec del (x, [], L)  = NONE | del (x, ((H as (y, E)) :: L), L\')  = if x = y then SOME ((y, E), (rev L\') @ L) else del (x, L, H :: L\') in match del (x, (! L), []) with NONE -> NONE | SOME ((y, E), L\') -> (L := L\'; SOME ((y, E))) let rec member (x, L : ctx)  = let rec memb (x, [])  = NONE | memb (x, (H as (y, E as Dec (n, U)) :: L))  = if x = y then SOME (y, E) else memb (x, L) | memb (x, (H as (y, E as ADec (n, d)) :: L))  = (if x = y then SOME ((y, E)) else memb (x, L)) in memb (x, (! L)) let rec insertList (E, L)  = (L := (E :: (! L))) (* ---------------------------------------------------------------------- *)  (* Substitution Tree *)  (* It is only possible to distribute the evar-ctx because\n     all evars occur exactly once, i.e. they are linear.\n     This allows us to maintain invariant, that every occurrence of an evar is\n     defined in its evar-ctx\n  *)  type Tree = Leaf of (ctx * normalSubsts) * (int(* #EVar *)  * int(* #G *) ) * ctx(* D *)  * dctx(* G *)  * ResEqn * answer * int * Status list ref | Node of (ctx * normalSubsts) * Tree ref list let rec makeTree ()  = ref (Node ((emptyCtx (), nid ()), [])) let rec noChildren C  = (C = []) type Retrieval = Variant of (int * Exp) | NotCompatible type CompSub = SplitSub of ((ctx * normalSubsts(* sigma *) ) * (ctx * normalSubsts(* rho1 *) ) * (ctx * normalSubsts(* rho2 *) )) | InstanceSub of (exSubsts * (ctx * normalSubsts(* rho2 *) )) | VariantSub of (ctx * normalSubsts(* rho2 *) ) | NoCompatibleSub (* Index array\n\n   All type families have their own substitution tree and all substitution trees\n   are stored in an array [a1,...,an]   where ai is a substitution tree for type family ai\n   *)  let indexArray = tabulate (maxCid, (fun i -> (ref 0, makeTree ()))) exception Error of string module I = IntSynmodule C = CompSynmodule S = RBSetmodule A = AbstractTabledmodule T = TableParamexception Assignment of string exception Instance of string exception Generalization of string exception DifferentSpines let rec emptyAnswer ()  = emptyAnsw () let answList : answer list ref = ref [] let added = ref false type nvar = int (* index for normal variables *) type bvar = int (* index for bound variables *) type bdepth = int (* depth of locally bound variables *) (* ------------------------------------------------------ *) (* for debugging only *) let rec expToS (G, U)  = (try  with ) let rec printSub (G, Shift n)  = print ("I.Shift " ^ toString n ^ "\\n") | printSub (G, Dot (Idx n, s))  = (print ("Idx " ^ toString n ^ " . "); printSub (G, s)) | printSub (G, Dot (Exp (X as EVar (ref (SOME (U)), _, _, _)), s))  = (print ("Exp ( EVar " ^ expToS (G, X) ^ ")."); printSub (G, s)) | printSub (G, Dot (Exp (X as EVar (_, _, _, _)), s))  = (print ("Exp ( EVar  " ^ expToS (G, X) ^ ")."); printSub (G, s)) | printSub (G, Dot (Exp (AVar (_)), s))  = (print ("Exp (AVar _ ). "); printSub (G, s)) | printSub (G, Dot (Exp (EClo (AVar (ref (SOME (U))), s\')), s))  = (print ("Exp (AVar " ^ expToS (G, EClo (U, s\')) ^ ")."); printSub (G, s)) | printSub (G, Dot (Exp (X as EClo (EVar (ref (SOME (U)), _, _, _), s\')), s))  = (print ("Exp (EVarClo " ^ expToS (G, EClo (U, s\')) ^ ") "); printSub (G, s)) | printSub (G, Dot (Exp (X as EClo (U, s\')), s))  = (print ("Exp (EClo " ^ expToS (G, normalize (U, s\')) ^ ") "); printSub (G, s)) | printSub (G, Dot (Exp (E), s))  = (print ("Exp ( " ^ expToS (G, E) ^ " ). "); printSub (G, s)) | printSub (G, Dot (Undef, s))  = (print ("Undef . "); printSub (G, s)) (* auxiliary function  -- needed to dereference AVars -- expensive?*) let rec normalizeSub (Shift n)  = Shift n | normalizeSub (Dot (Exp (EClo (AVar (ref (SOME (U))), s\')), s))  = Dot (Exp (normalize (U, s\')), normalizeSub s) | normalizeSub (Dot (Exp (EClo (EVar (ref (SOME (U)), _, _, _), s\')), s))  = Dot (Exp (normalize (U, s\')), normalizeSub s) | normalizeSub (Dot (Exp (U), s))  = Dot (Exp (normalize (U, id)), normalizeSub s) | normalizeSub (Dot (Idx n, s))  = Dot (Idx n, normalizeSub s) (* ------------------------------------------------------ *) (* Auxiliary functions *) (* etaSpine (S, n) = true\n\n   iff S is a spine n;n-1;..;1;nil\n\n   no permutations or eta-expansion of arguments are allowed\n   *) let rec etaSpine (Nil, n)  = (n = 0) | etaSpine (App (Root (BVar k, Nil), S), n)  = (k = n && etaSpine (S, n - 1)) | etaSpine (App (A, S), n)  = false let rec cidFromHead (Const c)  = c | cidFromHead (Def c)  = c let rec dotn (0, s)  = s | dotn (i, s)  = dotn (i - 1, dot1 s) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Lam (D, V)) (* compose (Decl(G\',D1\'), G) =   G. .... D3\'. D2\'.D1\'\n       where G\' = Dn\'....D3\'.D2\'.D1\' *) let rec compose (Null, G)  = G | compose (Decl (G\', D), G)  = Decl (compose (G\', G), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) (* ---------------------------------------------------------------------- *) (* ctxToEVarSub D = s\n\n     if D is a context for existential variables,\n        s.t. u_1:: A_1,.... u_n:: A_n = D\n     then . |- s : D where s = X_n....X_1.id\n\n    *) let rec ctxToEVarSub (Null, s)  = s | ctxToEVarSub (Decl (G, Dec (_, A)), s)  = let X = newEVar (Null, A) in Dot (Exp (X), ctxToEVarSub (G, s)) (* ---------------------------------------------------------------------- *) (* Matching for linear terms based on assignment *) (* lowerEVar\' (G, V[s]) = (X\', U), see lowerEVar *) let rec lowerEVar\' (X, G, (Pi ((D\', _), V\'), s\'))  = let D\'\' = decSub (D\', s\') let (X\', U) = lowerEVar\' (X, Decl (G, D\'\'), whnf (V\', dot1 s\')) in (X\', Lam (D\'\', U)) | lowerEVar\' (X, G, Vs\')  = let X\' = X in (X\', X\')(* lowerEVar1 (X, V[s]), V[s] in whnf, see lowerEVar *) (* lowerEVar1 (X, I.EVar (r, G, _, _), (V as I.Pi _, s)) = *) lowerEVar1 (X, EVar (r, G, _, _), (V as Pi _, s))  = let (X\', U) = lowerEVar\' (X, G, (V, s)) in EVar (ref (SOME (U)), Null, V, ref nil) | lowerEVar1 (_, X, _)  = X(* lowerEVar (X) = X\'\n\n       Invariant:\n       If   G |- X : {{G\'}} P\n            X not subject to any constraints\n       then G, G\' |- X\' : P\n\n       Effect: X is instantiated to [[G\']] X\' if G\' is empty\n               otherwise X = X\' and no effect occurs.\n    *) lowerEVar (E, X as EVar (r, G, V, ref nil))  = lowerEVar1 (E, X, whnf (V, id)) | lowerEVar (E, EVar _)  = (* It is not clear if this case can happen *)  (* pre-Twelf 1.2 code walk, Fri May  8 11:05:08 1998 *)  raise (Error "abstraction : LowerEVars: Typing ambiguous -- constraint of functional type cannot be simplified") let rec ctxToAVarSub (G\', Null, s)  = s | ctxToAVarSub (G\', Decl (D, Dec (_, A)), s)  = let E as EVar (r, _, _, cnstr) = newEVar (Null, A) in Dot (Exp (E), ctxToAVarSub (G\', D, s)) | ctxToAVarSub (G\', Decl (D, ADec (_, d)), s)  = let X = newAVar () in Dot (Exp (EClo (X, Shift (~ d))), ctxToAVarSub (G\', D, s)) (* assign(d, Dec(n, V), X as I.Root(BVar k, S), U, asub) = ()\n      Invariant:\n      if D ; G |- U : V\n         D ; G |- X : V\n      then\n         add (X, U) to asub\n         where  assub is a set of substitutions for existential variables)\n    *) (* [asub]E1  = U *) let rec assign ((* total as (t, passed)*) , d, Dec1 as Dec (n, V), E1 as Root (BVar k, S1), U, asub)  = (* it is an evar -- (k-d, EVar (SOME(U), V)) *)  let E as EVar (r, _, _, cnstr) = newEVar (Null, V) let X = lowerEVar1 (E, EVar (r, Null, V, cnstr), whnf (V, id)) let _ = (r := SOME (U)) in insert asub (k - d, Exp (X)) | assign ((* total as (t, passed)*) , d, Dec1 as ADec (n, d\'), E1 as Root (BVar k, S1), U, asub)  = (* it is an Avar and d = d\' (k-d, AVar(SOME(U)) *)  let A as AVar (r) = newAVar () let _ = (r := SOME (U)) let Us = whnf (U, Shift (~ d\')) in insert asub (k - d, Exp (EClo (A, Shift (~ d\')))) (* terms are in normal form *) (* exception Assignment of string *) (* assignExp (fasub, (l, ctxTotal as (r, passed), d) (D1, U1), (D2, U2))) = fasub\'\n\n     invariant:\n      G, G0 |- U1 : V1   U1 in nf\n      G, G0 |- U2 : V2   U2 in nf\n     and U1, U2 are linear higher-order patterns\n      D1 contains all existential variables of U1\n      D2 contains all existential variables of U2\n\n      ctxTotal = (r + passed) = |G|\n            where G refers to the globally bound variables\n      d = |G0| where G\' refers to the locally bound variables\n\n      then fasub\' is a success continuation\n        which builds up a substitution s\n              with domain D1 and  U1[s] = U2\n\n      NOTE: We only allow assignment for fully applied evars --\n      and we will fail otherwise. This essentially only allows first-order assignment.\n      To generalize this, we would need to linearize the ctx and have more complex\n      abstraction algorithm.\n\n   *) let rec assignExp (fasub, (ctxTotal as (r, passed), d), (D1, U1 as Root (H1, S1)), (D2, U2 as Root (H2, S2)))  = (match (H1, H2) with (Const (c1), Const (c2)) -> if (c1 = c2) then assignSpine (fasub, (ctxTotal, d), (D1, S1), (D2, S2)) else raise (Assignment "Constant clash") | (Def (c1), Def (c2)) -> (* we do not expand definitions here -- this is very conservative! *) if (c1 = c2) then assignSpine (fasub, (ctxTotal, d), (D1, S1), (D2, S2)) else let U1\' = normalize (expandDef (U1, id)) let U2\' = normalize (expandDef (U2, id)) in assignExp (fasub, (ctxTotal, d), (D1, U1\'), (D2, U2\')) | (Def (c1), _) -> (* we do not expand definitions here -- this is very conservative! *) let U1\' = normalize (expandDef (U1, id)) in assignExp (fasub, (ctxTotal, d), (D1, U1\'), (D2, U2)) | (_, Def (c2)) -> (* we do not expand definitions here -- this is very conservative! *) let U2\' = normalize (expandDef (U2, id)) in assignExp (fasub, (ctxTotal, d), (D1, U1), (D2, U2\')) | (BVar (k1), BVar k2) -> (if k1 <= (r + d)(* if (k1 - d) >= l *)  then (* k1 is a globally bound variable *) if k2 <= (r + d) then (* k2 is globally bound *) (if k2 = k1 then fasub else raise (Assignment "BVar clash")) else raise (Assignment "BVar - EVar clash") else (* k1 is an existial variable *) (match member (k1 - d + passed, D1) with NONE -> raise (Assignment "EVar nonexistent") | SOME (x, Dec) -> if k2 <= (r + d) then (* k2 is globally bound *) raise (Assignment "EVar - BVar clash") else (if k2 = k1 then (* denote the same evar *) (fun asub -> (fasub asub; assign ((* ctxTotal,*) , d, Dec, U1, U2, asub))) else raise (Assignment "EVars are different -- outside of the allowed fragment")))) | (Skonst (c1), Skonst (c2)) -> if (c1 = c2) then assignSpine (fasub, (ctxTotal, d), (D1, S1), (D2, S2)) else raise (Assignment "Skolem constant clash")(* can this happen ? -- definitions should be already expanded ?*)  | _ -> (raise (Assignment ("Head mismatch ")))) | assignExp (fasub, (ctxTotal, d), (D1, Lam (Dec1, U1)), (D2, Lam (Dec2, U2)))  = (* type labels are ignored *)  assignExp (fasub, (ctxTotal, d + 1), (D1, U1), (D2, U2)) | assignExp (fasub, (ctxTotal, d), (D1, Pi ((Dec1 as Dec (_, V1), _), U1)), (D2, Pi ((Dec2 as Dec (_, V2), _), U2)))  = (* is this necessary? Tue Aug  3 11:56:17 2004 -bp *) let fasub\' = assignExp (fasub, (ctxTotal, d), (D1, V1), (D2, V2)) in assignExp (fasub\', (ctxTotal, d + 1), (D1, U1), (D2, U2)) | assignExp (fasub, (ctxTotal, d), (D1, EClo (U, s\' as Shift (0))), (D2, U2))  = assignExp (fasub, (ctxTotal, d), (D1, U), (D2, U2)) | assignExp (fasub, (ctxTotal, d), (D1, U1), (D2, EClo (U, s as Shift (0))))  = assignExp (fasub, (ctxTotal, d), (D1, U1), (D2, U))assignSpine (fasub, (ctxTotal, d), (D1, Nil), (D2, Nil))  = fasub | assignSpine (fasub, (ctxTotal, d), (D1, App (U1, S1)), (D2, App (U2, S2)))  = let fasub\' = assignExp (fasub, (ctxTotal, d), (D1, U1), (D2, U2)) in assignSpine (fasub\', (ctxTotal, d), (D1, S1), (D2, S2)) (* assignCtx (fasub, ctxTotal as (r, passed), (D1, G), (D2, G\')) = fasub\'\n      invariant\n         |G| = |G\'| = r\n         |G0| = |G0\'| = passed\n         |G, G0| = |G\', G0\'| = (r + passed) = ctxTotal\n\n         D1 contains all existential variables occuring in (G, G0)\n         D2 contains all existential variables occuring in (G\', G0\')\n\n         fasub\' is a success continuation\n            which builds up a substitution s\n              with domain D1 and  (G, G0)[s] = (G, G0)\n\n         NOTE : [fasub]G = G\' Sun Nov 28 18:55:21 2004 -bp\n    *) let rec assignCtx (fasub, ctxTotal, (D1, Null), (D2, Null))  = fasub | assignCtx (fasub, (ctxTotal as (r, passed)), (D1, Decl (G1, Dec (_, V1))), (D2, Decl (G2, Dec (_, V2))))  = let fasub\' = assignExp (fasub, ((r - 1, passed + 1), 0), (D1, V1), (D2, V2)) in assignCtx (fasub\', ((r - 1, passed + 1)), (D1, G1), (D2, G2)) (* ------------------------------------------------------ *) (*  Variable b    : bound variable\n    Variable n    : index variable\n    linear term  U ::=  Root(c, S) | Lam (D, U) | Root(b, S)\n    linear Spine S ::= p ; S | NIL\n    indexed term t ::= Root(n, NIL) |  Root(c, S) | Lam (D, p) | Root(b, S)\n    indexed spines S_i ::= t ; S_i | NIL\n    Types   A\n    Context G : context for bound variables (bvars)\n    (type information is stored in the context)\n\n       G ::= . | G, x : A\n       Set of all index variables:  N\n\n    linear terms are well-typed in G:     G |- p\n    indexed terms are well-typed in (N ; G) |- t\n\n    Let s is a substitution for index variables (nvar)\n    and s1 o s2 o .... o sn = s, s.t.\n    forall nvar in CODOM(sk).\n     exists i . nvar in DOM(si) and i > k.\n\n    IMAGE (s) = the index variables occurring in the CODOM(s)\n\n    Let N1 ... Nn be the path from the root N1 to the leaf Nn,\n    and si the substitution associated with node Ni.\n\n    IMAGE(sn) = empty\n    s1 o s2 o ... o sn = s and IMAGE(s) = empty\n    i.e. index variables are only internally used and no\n         index variable is left.\n\n    A linear term U (and an indexed term t) can be decomposed into a term t\' together with\n    a sequenence of substitutions s1, s2, ..., sn such that s1 o s2 o .... o sn = s\n    and the following holds:\n\n    If    N  ; G |- t\n    then  N\' ; G |- t\'\n          N  ; G |- s : N\' ; G\n          N  ; G |- t\'[s]     and t\'[s] = t\n\n   if we have a linear term then N will be empty, but the same holds.\n\n   In addition:\n   all expressions in the index are closed and linear and in normalform i.e.\n   an expression is first linearized before it is inserted into the index\n\n   *) (* ---------------------------------------------------------------*) (* nctr = |D| =  #index variables *) let nctr = ref 1 let rec newNVar ()  = (nctr := ! nctr + 1; NVar (! nctr)) let rec equalDec (Dec (_, U), Dec (_, U\'))  = conv ((U, id), (U\', id)) | equalDec (ADec (_, d), ADec (_, d\'))  = (d = d\') | equalDec (_, _)  = false (* too restrictive if we require order of both eqn must be the same ?\n     Sun Sep  8 20:37:48 2002 -bp *) (* s = s\' = I.id *) let rec equalCtx (Null, s, Null, s\')  = true | equalCtx (Decl (G, D as Dec (_, A)), s, Decl (G\', D\' as Dec (_, A\')), s\')  = convDec ((D, s), (D\', s\')) && (equalCtx (G, dot1 s, G\', dot1 s\')) | equalCtx (_, s, _, s\')  = false (* equalEqn (e, e\') = (e = e\') *) let rec equalEqn (Trivial, Trivial)  = true | equalEqn (Unify (G, X, N, eqn), (Unify (G\', X\', N\', eqn\')))  = equalCtx (G, id, G\', id) && conv ((X, id), (X\', id)) && conv ((N, id), (N\', id)) && equalEqn (eqn, eqn\') | equalEqn (_, _)  = false (* equalEqn\' (d, (D, e), (D\', e\'), asub) = (e = e\')\n\n       destructively updates asub such that all the evars occurring in D\'\n       will be instantiated and  D |- asub : D\'\n\n       if D |- e and D\' |- e\'  and d = depth of context G\'\n          asub partially instantiates variables from D\'\n       then\n         D |- asub : D\'\n\n    *) let rec equalEqn\' (d, (D, Trivial), (D\', Trivial), asub)  = true | equalEqn\' (d, (D, Unify (G, X as Root (BVar k, S), N, (* AVar *) , eqn)), (D\', Unify (G\', X\', N\', (* AVar *) , eqn\')), asub)  = if (equalCtx (G, id, G\', id) && conv ((X, id), (X\', id)) && conv ((N, id), (N\', id))) then ((* X is the evar in the query, X\' is the evar in the index,\n             potentially X\' is not yet instantiated and X\' in D\' but X\' not in asub *) let d\' = d + ctxLength (G\') in (if (k - d\') > 0 then (match member (k - d\', D\') with NONE -> () | SOME (x, Dec) -> (* k refers to an evar *) (match lookup asub (k - d\') with NONE -> ((* it is not instantiated yet *) delete (x, D\'); insert asub (k - d\', Idx (k - d\'))) | SOME (_) -> ()))(* it is instantiated;\n                                          since eqn were solvable, eqn\' would be solvable too *)  else (* k refers to a bound variable *) (print "Impossible -- Found BVar instead of EVar\\n"; raise (Error "Impossibe -- Found BVar instead of EVar "))); equalEqn\' (d, (D, eqn), (D\', eqn\'), asub)) else false | equalEqn\' (d, _, _, asub)  = false (* equalSub (s, s\') = (s=s\') *) let rec equalSub (Shift k, Shift k\')  = (k = k\') | equalSub (Dot (F, S), Dot (F\', S\'))  = equalFront (F, F\') && equalSub (S, S\') | equalSub (Dot (F, S), Shift k)  = false | equalSub (Shift k, Dot (F, S))  = false(* equalFront (F, F\') = (F=F\') *) equalFront (Idx n, Idx n\')  = (n = n\') | equalFront (Exp U, Exp V)  = conv ((U, id), (V, id)) | equalFront (Undef, Undef)  = true (* equalCtx\' (G, G\') = (G=G\') *) let rec equalCtx\' (Null, Null)  = true | equalCtx\' (Decl (Dk, Dec (_, A)), Decl (D1, Dec (_, A1)))  = (conv ((A, id), (A1, id)) && equalCtx\' (Dk, D1)) | equalCtx\' (Decl (Dk, ADec (_, d\')), Decl (D1, ADec (_, d)))  = ((d = d\') && equalCtx\' (Dk, D1)) | equalCtx\' (_, _)  = false (* ---------------------------------------------------------------*) (* destructively may update asub ! *) let rec instanceCtx (asub, (D1, G1), (D2, G2))  = let d1 = ctxLength G1 let d2 = ctxLength G2 in if d1 = d2 then try  with  else false (* ---------------------------------------------------------------*) (* collect EVars in sub *) (* collectEVar (D, sq) = (D_sub, D\')\n     if D |- sq where D is a set of free variables\n     then Dsq |- sq  and (Dsq u D\') = D\n          Dsq contains all the free variables occuring in sq\n          D\' contains all the free variables corresponding to Gsq\n   *) let rec collectEVar (D, nsub)  = let D\' = emptyCtx () let rec collectExp (d, D\', D, Lam (_, U))  = collectExp (d + 1, D\', D, U) | collectExp (d, D\', D, Root (Const c, S))  = collectSpine (d, D\', D, S) | collectExp (d, D\', D, Root (BVar k, S))  = (match (member (k - d, D)) with NONE -> collectSpine (d, D\', D, S) | SOME (x, Dec) -> (delete (x - d, D); insertList ((x - d, Dec), D\'))) | collectExp (d, D\', D, U as Root (Def k, S))  = let U\' = normalize (expandDef (U, id)) in collectExp (d, D\', D, U\')collectSpine (d, D\', D, Nil)  = () | collectSpine (d, D\', D, App (U, S))  = (collectExp (d, D\', D, U); collectSpine (d, D\', D, S)) in forall nsub (fun (nv, (du, U)) -> collectExp (0, D\', D, U)); (D\', D) (* ---------------------------------------------------------------*) (* most specific linear common generalization *) (* compatible (T, U) = (T\', rho_u, rho_t) opt\n    if T is an indexed term\n       U is a linear term\n       U and T share at least the top function symbol\n   then\n       T\'[rho_u] = U and T\'[rho_t] = T\n   *) let rec convAssSub\' (G, idx_k, D, asub, d, evarsl as (evars, avars))  = (match (lookup asub d) with NONE -> (match member (d, D) with NONE -> Shift (evars + avars(* 0 *) ) | SOME (x, Dec (n, V)) -> (* Found an EVar which is not yet\n                     instantiated -- must be instantiated when\n                     solving residual equations! *) let s = convAssSub\' (G, idx_k + 1, D, asub, d + 1, evarsl) let E as EVar (r, _, _, cnstr) = newEVar (Null, V) in Dot (Exp (EClo (E, Shift (evars + avars))), s) | SOME (x, ADec (n, V)) -> (* should never happen -- all avars should\n                     have been assigned! *) (print ("convAssSub\' -- Found an uninstantiated AVAR\\n"); raise (Error "Unassigned AVar -- should never happen\\n"))) | SOME (F as Exp (E)) -> let E\' = normalize (E, id) in Dot (Exp (E\'), convAssSub\' (G, idx_k + 1, D, asub, d + 1, evarsl))) let rec convAssSub (G, asub, Glength, D\', evarsl)  = convAssSub\' (G, 0, D\', asub, Glength, evarsl) let rec isExists (d, BVar k, D)  = member (k - d, D) (* [s\']T = U so U = query and T is in the index *) let rec instance ((D_t, (dt, T)), (D_u, (du, U)), rho_u, ac)  = let rec instRoot (depth, T as Root (H1 as Const k, S1), U as Root (Const k\', S2), ac)  = if (k = k\') then instSpine (depth, S1, S2, ac) else raise (Instance "Constant mismatch\\n") | instRoot (depth, T as Root (H1 as Def k, S1), U as Root (Def k\', S2), ac)  = if (k = k\') then instSpine (depth, S1, S2, ac) else let T\' = normalize (expandDef (T, id)) let U\' = normalize (expandDef (U, id)) in instExp (depth, T\', U\', ac) | instRoot (depth, T as Root (H1 as Def k, S1), U as Root (H2, S2), ac)  = let T\' = normalize (expandDef (T, id)) in instExp (depth, T\', U, ac) | instRoot (d, T as Root (H1 as BVar k, S1), U as Root (BVar k\', S2), ac)  = if (k > d) && (k\' > d) then (* globally bound variable *) let k1 = (k - d) let k2 = (k\' - d) in match (member (k1, D_t), member (k2, D_u)) with (NONE, NONE) -> ((* both refer to the same globally bound variable in G *) if (k1 = k2) then instSpine (d, S1, S2, ac) else raise (Instance "Bound variable mismatch\\n")) | (SOME (x, Dec1), SOME (x\', Dec2)) -> (* k, k\' refer to the existential *) (if ((k1 = k2) && equalDec (Dec1, Dec2)) then (* they refer to the same existential variable *) (* this is unecessary *) (* since existential variables have the same type\n                             and need to be fully applied in order, S1 = S2 *) let ac\' = instSpine (d, S1, S2, ac) let ac\'\' = (fun asub -> (ac\' asub; (* S.insert asub (k - d, I.Idx (k-d)) *) assign ((* ctxTotal,*) , d, Dec1, T, U, asub))) in ac\'\' else (* instance checking only Sun Oct 27 12:16:10 2002 -bp *) (fun asub -> (ac asub; assign ((* ctxTotal,*) , d, Dec1, T, U, asub))))(* instance checking only Sun Oct 27 12:18:53 2002 -bp *)  | (SOME (x, Dec1 as ADec (n, d\')), NONE) -> (fun asub -> (ac asub; assign ((* ctxTotal,*) , d, Dec1, T, U, asub))) | (SOME (x, Dec1), NONE) -> (fun asub -> (ac asub; assign ((* ctxTotal,*) , d, Dec1, T, U, asub))) | (_, _) -> raise (Instance "Impossible\\n") else (* locally bound variables *) raise (Instance "Bound variable mismatch\\n") | instRoot (d, T as Root (H1 as BVar k, S1), U as Root (Const k\', S2), ac)  = (* this case only should happen during instance checking *)  (match isExists (d, BVar k, D_t) with NONE -> raise (Instance "Impossible\\n") | SOME (x, Dec1 as ADec (_, _)) -> (fun asub -> (ac asub; assign ((* ctxTotal,*) , d, Dec1, T, U, asub))) | SOME (x, Dec1) -> (fun asub -> (ac asub; assign ((* ctxTotal, *) , d, Dec1, T, U, asub)))) | instRoot (d, T as Root (H1 as BVar k, S1), U as Root (Def k\', S2), ac)  = (* this case only should happen during instance checking *)  (match isExists (d, BVar k, D_t) with NONE -> raise (Instance "Impossible\\n") | SOME (x, Dec1 as ADec (_, _)) -> (fun asub -> (ac asub; assign ((* ctxTotal,*) , d, Dec1, T, U, asub))) | SOME (x, Dec1) -> (fun asub -> (ac asub; assign ((* ctxTotal, *) , d, Dec1, T, U, asub)))) | instRoot (depth, T as Root (H1, S1), U as Root (Def k\', S2), ac)  = let U\' = normalize (expandDef (U, id)) in instExp (depth, T, U\', ac) | instRoot (d, T as Root (H1, S1), U as Root (H2, S2), ac)  = raise (Instance "Other Cases impossible\\n")instExp (d, T as NVar n, U as Root (H, S), ac)  = (insert rho_u (n, (d, U)); ac) | instExp (d, T as Root (H1, S1), U as Root (H2, S2), ac)  = instRoot (d, Root (H1, S1), Root (H2, S2), ac) | instExp (d, Lam (D1 as Dec (_, A1), T1), Lam (D2 as Dec (_, A2), U2), ac)  = (* by invariant A1 = A2 -- actually this invariant may be violated, but we ignore it. *)  instExp (d + 1, T1, U2, ac) | instExp (d, T, U, ac)  = (* U = EVar, EClo -- can\'t happen -- Sun Oct 20 13:41:25 2002 -bp *)  (print "instExp -- falls through?\\n"; raise (Instance "Impossible\\n"))instSpine (d, Nil, Nil, ac)  = ac | instSpine (d, App (T, S1), App (U, S2), ac)  = let ac\' = instExp (d, T, U, ac) let ac\'\' = instSpine (d, S1, S2, ac\') in ac\'\' | instSpine (d, Nil, App (_, _), ac)  = (print ("Spines are not the same -- (first one is Nil) -- cannot happen!\\n"); raise (Instance "DifferentSpines\\n")) | instSpine (d, App (_, _), Nil, ac)  = (print ("Spines are not the same -- second one is Nil -- cannot happen!\\n"); raise (Instance "DifferentSpines\\n")) | instSpine (d, SClo (_, _), _, ac)  = (print ("Spine Closure!(1) -- cannot happen!\\n"); raise (Instance "DifferentSpines\\n")) | instSpine (d, _, SClo (_, _), ac)  = (print ("Spine Closure! (2) -- cannot happen!\\n"); raise (Instance " DifferentSpines\\n")) in (* by invariant dt = du *) ac := instExp (dt, T, U, ! ac)(* if it succeeds then it will return a continuation which will\n         instantiate the "evars" and rho_t will contain all\n         nvar instantiations\n         otherwise it will raise Instance *) let rec compHeads ((D_1, Const k), (D_2, Const k\'))  = (k = k\') | compHeads ((D_1, Def k), (D_2, Def k\'))  = (k = k\') | compHeads ((D_1, BVar k), (D_2, BVar k\'))  = (match isExists (0, BVar k, D_1) with NONE -> (k = k\') | SOME (x, Dec) -> true) | compHeads ((D_1, BVar k), (D_2, H2))  = (match isExists (0, BVar k, D_1) with NONE -> false | SOME (x, Dec) -> true) | compHeads ((D_1, H1), (D_2, H2))  = false let rec compatible\' ((D_t, (dt, T)), (D_u, (du, U)), Ds, rho_t, rho_u)  = let rec genNVar ((rho_t, T), (rho_u, U))  = (insert rho_t (! nctr + 1, T); insert rho_u (! nctr + 1, U); (* by invariant dt = du *) newNVar ()) let rec genRoot (d, T as Root (H1 as Const k, S1), U as Root (Const k\', S2))  = if (k = k\') then let S\' = genSpine (d, S1, S2) in Root (H1, S\') else genNVar ((rho_t, (d, T)), (rho_u, (d, U))) | genRoot (d, T as Root (H1 as Def k, S1), U as Root (Def k\', S2))  = if (k = k\') then let S\' = genSpine (d, S1, S2) in Root (H1, S\') else (* could expand definitions here ? -bp*) genNVar ((rho_t, (d, T)), (rho_u, (d, U))) | genRoot (d, T as Root (H1 as BVar k, S1), U as Root (BVar k\', S2))  = if (k > d) && (k\' > d) then (* globally bound variable *) let k1 = (k - d) let k2 = (k\' - d) in match (member (k1, D_t), member (k2, D_u)) with (NONE, NONE) -> (* should never happen *) (if (k1 = k2) then try  with  else genNVar ((rho_t, (d, T)), (rho_u, (d, U)))) | (SOME (x, Dec1), SOME (x\', Dec2)) -> (* k, k\' refer to the existential *) if ((k1 = k2) && equalDec (Dec1, Dec2)) then (* they refer to the same existential variable *) (* this is unecessary -- since existential variables have the same type\n                            and need to be fully applied in order, S1 = S2 *) let S\' = genSpine (d, S1, S2) in (delete (x, D_t); delete (x\', D_u); insertList ((x, Dec1), Ds); Root (H1, S\')) else (* variant checking only *) genNVar ((rho_t, (d, T)), (rho_u, (d, U))) | (_, _) -> genNVar ((rho_t, (d, T)), (rho_u, (d, U))) else (* locally bound variables *) if (k = k\') then try  with  else genNVar ((rho_t, (d, T)), (rho_u, (d, U))) | genRoot (d, T as Root (H1 as BVar k, S1), U as Root (Const k\', S2))  = genNVar ((rho_t, (d, T)), (rho_u, (d, U))) | genRoot (d, T as Root (H1 as BVar k, S1), U as Root (Def k\', S2))  = genNVar ((rho_t, (d, T)), (rho_u, (d, U))) | genRoot (d, T as Root (H1, S1), U as Root (H2, S2))  = genNVar ((rho_t, (d, T)), (rho_u, (d, U)))genExp (d, T as NVar n, U as Root (H, S))  = (insert rho_u (n, (d, U)); T) | genExp (d, T as Root (H1, S1), U as Root (H2, S2))  = genRoot (d, Root (H1, S1), Root (H2, S2)) | genExp (d, Lam (D1 as Dec (_, A1), T1), Lam (D2 as Dec (_, A2), U2))  = (* by invariant A1 = A2 *)  let E = genExp (d + 1, T1, U2) in Lam (D1, E) | genExp (d, T, U)  = (* U = EVar, EClo -- can\'t happen -- Sun Oct 20 13:41:25 2002 -bp *)  (print "genExp -- falls through?\\n"; genNVar ((rho_t, (d, T)), (rho_u, (d, U))))genSpine (d, Nil, Nil)  = Nil | genSpine (d, App (T, S1), App (U, S2))  = let E = genExp (d, T, U) let S\' = genSpine (d, S1, S2) in App (E, S\') | genSpine (d, Nil, App (_, _))  = raise (DifferentSpines) | genSpine (d, App (_, _), Nil)  = raise (DifferentSpines) | genSpine (d, SClo (_, _), _)  = raise (DifferentSpines) | genSpine (d, _, SClo (_, _))  = raise (DifferentSpines) in (* by invariant dt = du *) Variant (dt, genExp (dt, T, U)) let rec compatible ((D_t, T as (d1, Root (H1, S1))), (D_u, U as (d2, Root (H2, S2))), Ds, rho_t, rho_u)  = if compHeads ((D_t, H1), (D_u, H2)) then compatible\' ((D_t, T), (D_u, U), Ds, rho_t, rho_u) else NotCompatible | compatible ((D_t, T), (D_u, U), Ds, rho_t, rho_u)  = compatible\' ((D_t, T), (D_u, U), Ds, rho_t, rho_u) (* compatibleCtx (asub, (Dsq, Gsq, eqn_sq), GR) = option\n\n    if Dsq is a subset of Dsq_complete\n       where Dsq_complete encompasses all evars and avars in the original query\n       Dsq |- Gsq ctx\n       Dsq, Gsq |- eqn_sq\n       there exists (_, D\', G\', eqn\', ansRef\', _, status\') in GR\n       s.t.\n       Gsq is an instance of G\'\n       (andalso eqn_sq = eqn\')\n    then\n      SOME((D\', G\', eqn\'), answRef\', status)\n      and asub is destructively updated s.t. Dsq_complete |- Gsq = [asub]G\'\n\n    else\n      NONE\n   *) let rec compatibleCtx (asub, (Dsq, Gsq, eqn_sq), [])  = NONE | compatibleCtx (asub, (Dsq, Gsq, eqn_sq), ((_, Delta\', G\', eqn\', answRef\', _, status\') :: GRlist))  = if instanceCtx (asub, (Dsq, Gsq), (Delta\', G\')) then SOME ((Delta\', G\', eqn\'), answRef\', status\') else compatibleCtx (asub, (Dsq, Gsq, eqn_sq), GRlist) (* ---------------------------------------------------------------*) (* instanceSub(nsub_t, squery) = (rho_u, asub)\n\n   if DOM(nsub_t) <= DOM(nsub_u)\n      CODOM(nsub_t) : index terms\n      CODOM(nsub_u) : linear terms\n        G_u, Glocal_u |- nsub_u\n    N ; G_t, Glocal_t |- nsub_t\n   then\n     nsub_t = sigma o rho_t\n     nsub_e = sigma o rho_u\n\n    Glocal_e ~ Glocal_t  (have "approximately" the same type)\n    l_g = |Glocal_u|\n\n\n    [asub]nsub_t = squery\n   *) let rec instanceSub ((D_t, nsub_t), (Dsq, squery), asub)  = (* by invariant rho_t = empty, since nsub_t <= squery *) let rho_u = nid () let D_r2 = copy Dsq let ac = ref (fun (asub : exSubsts) -> ()) in try  with (* [asub]nsub_t = sq  where sq is the query substitution *) let rec instChild (N as Leaf ((D_t, nsub_t), GList), (D_sq, sq), asub)  = instanceSub ((D_t, nsub_t), (D_sq, sq), asub) | instChild (N as Node ((D_t, nsub_t), Children\'), (D_sq, sq), asub)  = instanceSub ((D_t, nsub_t), (D_sq, sq), asub) let rec findAllInst (G_r, children, Ds, asub)  = let rec findAllCands (G_r, nil, (Dsq, sub_u), asub, IList)  = IList | findAllCands (G_r, (x :: L), (Dsq, sub_u), asub, IList)  = let asub\' = copy asub in match instChild (! x, (Dsq, sub_u), asub)(* will update asub *)  with NoCompatibleSub -> findAllCands (G_r, L, (Dsq, sub_u), asub\', IList) | InstanceSub (asub, Drho2) -> findAllCands (G_r, L, (Dsq, sub_u), asub\', ((x, Drho2, asub) :: IList)) in findAllCands (G_r, children, Ds, asub, nil) (* Solving  variable definitions *) (* solveEqn ((VarDef, s), G) = bool\n\n    if G\'\' |- VarDef and G   |- s : G\'\'\n       G   |- VarDef[s]\n    then\n       return true, if VarDefs are solvable\n              false otherwise\n *) let rec solveEqn ((Trivial, s), G)  = true | solveEqn ((Unify (G\', e1, N, (* evar *) , eqns), s), G)  = let G\'\' = compose (G\', G) let s\' = shift (G\'\', s) in unifiable (G\'\', (N, s\'), (e1, s\')) && solveEqn ((eqns, s), G) (* Mon Dec 27 11:57:35 2004 -bp *) (* solveEqn\' ((VarDef, s), G) = bool\n\n    if G\'\' |- VarDef and G   |- s : G\'\'\n       G   |- VarDef[s]\n    then\n       return true, if VarDefs are solvable\n              false otherwise\n *) let rec solveEqn\' ((Trivial, s), G)  = true | solveEqn\' ((Unify (G\', e1, N, (* evar *) , eqns), s), G)  = let G\'\' = compose (G\', G) let s\' = shift (G\', s) in unifiable (G\'\', (N, s\'), (e1, s\')) && solveEqn\' ((eqns, s), G) (* Mon Dec 27 12:20:45 2004 -bp\n (* solveEqn\' ((VarDef, s), G) = bool\n\n    if G\'\' |- VarDef and G   |- s : G\'\'\n       G   |- VarDef[s]\n    then\n       return true, if VarDefs are solvable\n              false otherwise\n *)\n  fun solveEqn\' (T.Trivial, s) = true\n    | solveEqn\' (T.Unify(G\',e1, N (* evar *), eqns), s) =\n      let\n        val s\' = shift (G\', s)\n      in\n        Assign.unifiable (G\', (N, s\'),(e1, s\'))\n        andalso solveEqn\' (eqns, s)\n     end\n\n (* solveEqnI\' ((VarDef, s), G) = bool\n\n    if G\'\' |- VarDef and G   |- s : G\'\'\n       G   |- VarDef[s]\n    then\n       return true, if VarDefs are solvable\n              false otherwise\n *)\n  fun solveEqnI\' (T.Trivial, s) = true\n    | solveEqnI\' (T.Unify(G\',e1, N (* evar *), eqns), s) =\n      let\n        val s\' = shift (G\', s)\n        (* note: we check whether N[s\'] is an instance of e1[s\'] !!! *)\n        (* at this point all AVars have been instantiated, and we could use Match.instance directly *)\n      in\n        Assign.instance (G\', (e1, s\'), (N, s\'))\n        andalso solveEqnI\' (eqns, s)\n     end\n Mon Dec 27 11:58:21 2004 -bp *) (* solveEqnI\' ((VarDef, s), G) = bool\n\n    if G\'\' |- VarDef and G   |- s : G\'\'\n       G   |- VarDef[s]\n    then\n       return true, if VarDefs are solvable\n              false otherwise\n *) let rec solveEqnI\' ((Trivial, s), G)  = true | solveEqnI\' ((Unify (G\', e1, N, (* evar *) , eqns), s), G)  = (* note: we check whether N[s\'] is an instance of e1[s\'] !!! *) (* at this point all AVars have been instantiated, and we could use Match.instance directly *) let G\'\' = compose (G\', G) let s\' = shift (G\', s) in instance (G\'\', (e1, s\'), (N, s\')) && solveEqnI\' ((eqns, s), G) (* retrieve all Instances from substitution tree *) (* retreiveInst (Nref, (Dq, sq), s\', GR) = callCheckResult\n\n      Invariant:\n\n      If there exists a path r1 ... rn = p\n         in the substitution tree with root Nref\n         and there exists an assignable substitution s\' (D\n         s.t. [r\']\n      then\n         return RepeatedEntry\n      else raises exception instance\n    *) let rec retrieveInst (Nref, (Dq, sq), asub, GR)  = let rec retrieve\' (N as Leaf ((D, s), GRlistRef), (Dq, sq), asubst, GR\' as (DAEVars as (DEVars, DAVars), G_r, eqn, stage, status))  = (* s and sq are compatible by invariant *)  (* [asub]s = sq   and there exists a path (D1, s1) ... (Dn,sn) from the root to the leaf (D,s)\n           s.t. [asub]s1 o s2 o ... sn o s corresponds to original query\n           *)  (* Dq = (Dsq\' u Dg) where Dsq\' = evars occurring in sq\n                                      D_G = evars occuring in G_sq or only in eqn_sq\n\n               and Dsq = D since there exists a path s1 ... sn from the root to the leaf (D,s)\n                 s.t. [asub]s1 o s2 o ... sn o s corresponds to original query\n             *) let (Dsq, D_G) = collectEVar (Dq, sq) in (match compatibleCtx (asubst, (D_G, G_r, eqn), (! GRlistRef))(* compatibleCtx may destructively update asub ! *)  with NONE -> ((* compatible path -- but different ctx *) raise (Instance "Compatible path -- different ctx\\n")) | SOME ((D\', G\', eqn\'), answRef\', status\') -> (* compatible path -- SAME ctx *) ((* note: previously we checked eqn\' = eqn! -- this is too restrictive\n                 now - Dec  6 2004 -bp we check whether eqn is an instance of eqn\'\n                 note: this is very delicate code.\n               *) (* Since there exists a path (D1, s1) ... (Dn,sn) from the root to the leaf (D,s)\n                   D1\', ...., Dn\', D, D\' = D*\n                   and          G\' |- esub\' : DAEVars, G\'        and       .   |- esub : DAEVars\n                        DAEVars, G |- asub\' : D*, G\'                   DAEVars |- asub : D*\n\n                  note: asub\' may refer to free variables which denote evars in D*\n                        which only occur in eqn\' and hence have not yet been instantiated\n                        however: all avars in D* have been instantiated!\n                 *) (* Residual equation of query:\n                   DAEVars, G\' |- eqn  hence we solve : G\' |= [esub\']eqn *) (*              val _ = if solveEqn\' (eqn, esub)\n                          then () else print " failed to solve eqn_query\\n"  *) (* Residual equations in index:\n                   D*, G\' |- eqn\'    where eqn\' = AVar1 = E1 .... AVarn = En\n                                      and  Ei may contain free variables\n                      G\'  |= [esub](asub) (eqn\')\n\n                      solve eqn\' from path in index using instance or matching ONLY\n                      to instantiate the free variables Ei\n\n                   remark: DAEVars, G\' |= [asub]eqn\'   should work in theory too,\n                           if the free variables in asub are created in such a way that they may depend on DAVars.\n                           otherwise unification or instance checking will fail or the resulting instantiation\n                           for the free variables in asub is too restrictive, s.t. retrieval fails\n                   *) let DAEVars = compose (DEVars, DAVars) let esub = ctxToAVarSub (G\', DAEVars, Shift (0)) let asub = convAssSub (G\', asubst, (ctxLength G\') + 1, D\', (ctxLength (DAVars), ctxLength (DEVars))) let _ = if solveEqn\' ((eqn, shift (G\', esub)), G\', (* = G_r *) ) then () else print " failed to solve eqn_query\\n" let easub = normalizeSub (comp (asub, esub)) in if solveEqnI\' ((eqn\', shift (G\', easub)), G\')(*              if solveEqnI\' (eqn\', easub) *) (* solve residual equations using higher-order matching Wed Dec 22 2004 -bp *)  then RepeatedEntry ((esub, asub), answRef\', status\') else raise (Instance "Compatible path -- resdidual equ. not solvable\\n"))) | retrieve\' (N as Node ((D, sub), children), (Dq, sq), asub, GR as (DAEVars, G_r, eqn, stage, status))  = let InstCand = findAllInst (G_r, children, (Dq, sq), asub) let rec checkCandidates nil  = (* no child is compatible with sq *)  raise (Instance "No compatible child\\n") | checkCandidates ((ChildRef, Drho2, asub) :: ICands)  = (* there is an instance  *)  try  with in checkCandidates InstCand in (fun () -> (), retrieve\' (! Nref, (Dq, sq), asub, GR)) (*---------------------------------------------------------------------------*) (* insert new entry into substitution tree *) (* assuming there is no compatible entry already *) (* compatibleSub(nsub_t, squery) = (sigma, rho_t, rho_u) opt\n\n   if DOM(nsub_t) <= DOM(squery)\n      CODOM(nsub_t) : index terms\n      CODOM(squery) : linear terms\n        G_u, Glocal_u |- squery\n    N ; G_t, Glocal_t |- nsub_t\n   then\n     nsub_t = sigma o rho_t\n     nsub_e = sigma o rho_u\n\n    Glocal_e ~ Glocal_t  (have "approximately" the same type)\n\n   *) let rec compatibleSub ((D_t, nsub_t), (Dsq, squery))  = (* by invariant rho_t = empty, since nsub_t <= squery *) let (sigma, rho_t, rho_u) = (nid (), nid (), nid ()) let Dsigma = emptyCtx () let D_r1 = copy D_t let D_r2 = copy Dsq let choose = ref (fun match : bool -> ()) let _ = forall squery (fun (nv, U) -> (match (lookup nsub_t nv) with SOME (T) -> (* note by invariant Glocal_e ~ Glocal_t *) (match compatible ((D_r1, T), (D_r2, U), Dsigma, rho_t, rho_u) with NotCompatible -> (insert rho_t (nv, T); insert rho_u (nv, U)) | Variant (T\') -> let restc = (! choose) in (insert sigma (nv, T\'); choose := (fun match -> (restc match; if match then () else ()))))(* here Glocal_t will be only approximately correct! *)  | NONE -> insert rho_u (nv, U))) in if isId (rho_t) then (* perfect match under asub and rho_t = nsub_t\n           sigma = rho_t and sigma o asub = rho_u *) ((! choose) true; VariantSub (D_r2, rho_u)) else ((* split -- asub is unchanged *) (! choose) false; if isId (sigma) then NoCompatibleSub else SplitSub ((Dsigma, sigma), (D_r1, rho_t), (D_r2, rho_u)))(* Dsigma |~ sigma, D_r1 |~ rho_t, D_r1 |~ rho_u *) (* ---------------------------------------------------------------------- *) (*  fun mkLeaf (Ds, GR, n) = Leaf (Ds, GR)*) let rec mkNode (Node (_, Children), Dsigma as (Ds, sigma), Drho1 as (D1, rho1), GR as ((evarl, l), dp, eqn, answRef, stage, status), Drho2 as (D2, rho2))  = let (D_rho2, D_G2) = collectEVar (D2, rho2) let GR\' = ((evarl, l), D_G2, dp, eqn, answRef, stage, status) let (sizeSigma, sizeRho1, sizeRho2) = ((size sigma), (size rho1), (size rho2)) in Node (Dsigma, [ref (Leaf ((D_rho2, rho2), ref [GR\'])); ref (Node (Drho1, Children))]) | mkNode (Leaf (c, GRlist), Dsigma as (Ds, sigma), Drho1 as (D1, rho1), GR2 as ((evarl, l), dp, eqn, answRef, stage, status), Drho2 as (D2, rho2))  = let (D_rho2, D_G2) = collectEVar (D2, rho2) let GR2\' = ((evarl, l), D_G2, dp, eqn, answRef, stage, status) in Node (Dsigma, [ref (Leaf ((D_rho2, rho2), ref [GR2\'])); ref (Leaf (Drho1, GRlist))]) (* ---------------------------------------------------------------------- *) let rec compChild (N as Leaf ((D_t, nsub_t), GList), (D_e, nsub_e))  = compatibleSub ((D_t, nsub_t), (D_e, nsub_e)) | compChild (N as Node ((D_t, nsub_t), Children\'), (D_e, nsub_e))  = compatibleSub ((D_t, nsub_t), (D_e, nsub_e)) let rec findAllCandidates (G_r, children, Ds)  = let rec findAllCands (G_r, nil, (Dsq, sub_u), VList, SList)  = (VList, SList) | findAllCands (G_r, (x :: L), (Dsq, sub_u), VList, SList)  = match compChild (! x, (Dsq, sub_u)) with NoCompatibleSub -> findAllCands (G_r, L, (Dsq, sub_u), VList, SList) | SplitSub (Dsigma, Drho1, Drho2) -> findAllCands (G_r, L, (Dsq, sub_u), VList, ((x, (Dsigma, Drho1, Drho2)) :: SList)) | VariantSub (Drho2 as (D_r2, rho2)) -> findAllCands (G_r, L, (Dsq, sub_u), ((x, Drho2, id) :: VList), SList) in findAllCands (G_r, children, Ds, nil, nil) (* ---------------------------------------------------------------------- *) let rec divergingCtx (stage, G, GRlistRef)  = (* this 3 is arbitrary -- lockstep *) let l = ctxLength (G) + 3 in exists (fun ((_, l), D, G\', _, _, stage\', _) -> (stage = stage\' && (l > (ctxLength (G\'))))) (! GRlistRef) let rec eqHeads (Const k, Const k\')  = (k = k\') | eqHeads (BVar k, BVar k\')  = (k = k\') | eqHeads (Def k, Def k\')  = (k = k\') | eqHeads (_, _)  = false (* eqTerm (t2, (t, rho1)) = bool\n    returns true iff t2 = t[rho1]\n  t2 is a linear term which may not contain any nvars!\n  t may contain nvars\n *) let rec eqTerm (Root (H2, S2), (t as Root (H, S), rho1))  = if eqHeads (H2, H) then eqSpine (S2, (S, rho1)) else false | eqTerm (T2, (NVar n, rho1))  = (match (lookup rho1 n) with NONE -> false | SOME ((dt1, T1)) -> eqTerm (T2, (T1, nid ()))) | eqTerm (Lam (D2, T2), (Lam (D, T), rho1))  = eqTerm (T2, (T, rho1)) | eqTerm (_, (_, _))  = falseeqSpine (Nil, (Nil, rho1))  = true | eqSpine (App (T2, S2), (App (T, S), rho1))  = eqTerm (T2, (T, rho1)) && eqSpine (S2, (S, rho1)) let rec divergingSub ((Ds, sigma), (Dr1, rho1), (Dr2, rho2))  = exists rho2 (fun (n2, (dt2, t2)) -> exists sigma (fun (_, (d, t)) -> eqTerm (t2, (t, rho1)))) (* ---------------------------------------------------------------------- *) (* Insert via variant checking *) let rec variantCtx ((G, eqn), [])  = NONE | variantCtx ((G, eqn), ((l\', D_G, G\', eqn\', answRef\', _, status\') :: GRlist))  = (if (equalCtx\' (G, G\') && equalEqn (eqn, eqn\')) then SOME (l\', answRef\', status\') else variantCtx ((G, eqn), GRlist)) (* insert (Nref, (Dq, sq), GR) = TableResult *) let rec insert (Nref, (Dsq, sq), GR)  = let rec insert\' (N as Leaf (_, GRlistRef), (Dsq, sq), GR as (l, G_r, eqn, answRef, stage, status))  = (match variantCtx ((G_r, eqn), (! GRlistRef)) with NONE -> ((* compatible path -- but different ctx! *) (* D_G contains evars occurring only in eqn or G\n                        D_nsub contains evars occurring only in sq\n                        furthermore: D_nsub = D where Leaf((D,s), GRlistRef)\n                     *) let (D_nsub, D_G) = collectEVar (Dsq, sq) let GR\' = (l, D_G, G_r, eqn, answRef, stage, status) in (fun () -> (GRlistRef := (GR\' :: (! GRlistRef)); answList := (answRef :: (! answList))), NewEntry (answRef))) | SOME (_, answRef\', status\') -> ((* compatible path -- SAME ctx and SAME eqn!\n                                          this implies: SAME D_G *) ((fun () -> ()), RepeatedEntry ((id, id), answRef\', status\')))) | insert\' (N as Node ((D, sub), children), (Dsq, sq), GR as (l, G_r, eqn, answRef, stage, status))  = let (VariantCand, SplitCand) = findAllCandidates (G_r, children, (Dsq, sq)) let (D_nsub, D_G) = collectEVar (Dsq, sq) let GR\' = (l, D_G, G_r, eqn, answRef, stage, status) let rec checkCandidates (nil, nil)  = (* no child is compatible with sq *)  (fun () -> (Nref := Node ((D, sub), (ref (Leaf ((D_nsub, sq), ref [GR\']))) :: children); answList := (answRef :: (! answList))), NewEntry (answRef)) | checkCandidates (nil, ((ChildRef, (Dsigma, Drho1, Drho2)) :: _))  = (* split an existing node *)  if ((! divHeuristic) && divergingSub (Dsigma, Drho1, Drho2)) then ((* substree diverging -- splitting node *) (fun () -> (ChildRef := mkNode ((! ChildRef), Dsigma, Drho1, GR, Drho2); answList := (answRef :: (! answList))), DivergingEntry (id, answRef))) else ((* split existing node *) (fun () -> (ChildRef := mkNode ((! ChildRef), Dsigma, Drho1, GR, Drho2); answList := (answRef :: (! answList))), NewEntry (answRef))) | checkCandidates (((ChildRef, Drho2, asub) :: nil), _)  = (* unique "perfect" candidate (left) *)  insert (ChildRef, Drho2, GR) | checkCandidates (((ChildRef, Drho2, asub) :: L), SCands)  = (* there are several "perfect" candidates *)  (match (insert (ChildRef, Drho2, GR)) with (_, NewEntry (answRef)) -> checkCandidates (L, SCands) | (f, RepeatedEntry (asub, answRef, status)) -> ((f, RepeatedEntry (asub, answRef, status))) | (f, DivergingEntry (asub, answRef)) -> ((f, DivergingEntry (asub, answRef)))) in checkCandidates (VariantCand, SplitCand) in insert\' (! Nref, (Dsq, sq), GR) (* ---------------------------------------------------------------------- *) (* answer check and insert\n\n     Invariant:\n        D |- Pi G.U\n          |- (Pi G.U)[s]\n       .  |- s : D\n       {{K}} are all the free variables in s\n        D_k is the linear context of all free variables in {{K}}\n        D_k |- s_k : D  and eqn\n        D_k |- (Pi G.U)[s_k] and eqn\n\n      answerCheck (G, s, answRef, 0) = repeated\n         if (D_k, s_k, eqn)  already occurs in answRef\n      answerCheck (G,s, answRef, O) = new\n         if (D_k, s_k, eqn) did not occur in answRef\n         Sideeffect: update answer list for U\n     *) let rec answCheckVariant (s\', answRef, O)  = let rec member ((D, sk), [])  = false | member ((D, sk), (((D1, s1), _) :: S))  = if equalSub (sk, s1) && equalCtx\' (D, D1) then true else member ((D, sk), S) let (DEVars, sk) = abstractAnswSub s\' in if member ((DEVars, sk), solutions answRef) then repeated else (addSolution (((DEVars, sk), O), answRef); new) (* ---------------------------------------------------------------------- *) let rec reset ()  = (nctr := 1; (* Reset Subsitution Tree *) modify (fun (n, Tree) -> (n := 0; Tree := ! (makeTree ()); answList := []; added := false; (n, Tree))) indexArray) (* makeCtx (n, G, G\') =  unit\n     if G LF ctx\n     then\n      G\' is a set\n      where (i,Di) corresponds to the i-th declaration in G\n\n    note: G\' is destructively updated\n    *) let rec makeCtx (n, Null, DEVars : ctx)  = () | makeCtx (n, Decl (G, D), DEVars : ctx)  = (insertList ((n, D), DEVars); makeCtx (n + 1, G, DEVars)) (* callCheck (a, DAVars, DEVars, G, U, eqn, status) = TableResult\n    if\n      U is atomic (or base type) i.e. U = a S\n\n      DAVars, DEVars, G |- U\n      DAVars, DEVars, G |- eqn\n\n      Tree is the substitution trie associated with type family a\n\n   then\n      if there exists a path r1 o r2 o ... o rn = p in Tree\n         together with some (G\',eqn\', answRef\') at the leaf\n         and DAVars\', DEVars\', G\' |- p\n      and there exists a substitution s\' s.t.\n\n          DAVars, DEVars |- s\' : DAVars\', DEVars\'\n          [s\']G\' = G and [s\']p = U\n\n      and moreover\n          there exists a substitution r\' s.t.  G |- r\' : DAVars, DEVars, G\n          (which re-instantiates evars)\n\n      and\n            G |= [r\']eqn    and [s\']G\' |= [r\'][s\']eqn\'\n     then\n       TableResult = RepeatedEntry(s\', answRef\')\n\n     otherwise\n\n       TableResult = NewEntry (answRef\')\n       and there exists a path r1 o r2 o ... o rk = U in Tree\n           together with (G,eqn, answRef) at the leaf\n\n   *) let rec callCheck (a, DAVars, DEVars, G, U, eqn, status)  = (* n = |G| *) (* Dq = DAVars, DEVars *) (* l = |D| *) let (n, Tree) = sub (indexArray, a) let sq = new () let DAEVars = compose (DEVars, DAVars) let Dq = emptyCtx () let n = ctxLength (G) let _ = makeCtx (n + 1, DAEVars, Dq : ctx) let l = ctxLength (DAEVars) let _ = insert sq (1, (0, U)) let GR = ((l, n + 1), G, eqn, emptyAnswer (), ! stageCtr, status) let GR\' = ((DEVars, DAVars), G, eqn, ! stageCtr, status) let result = try  with  in match result with (sf, NewEntry (answRef)) -> (sf (); added := true; NewEntry (answRef)) | (_, RepeatedEntry (asub, answRef, status)) -> RepeatedEntry (asub, answRef, status) | (sf, DivergingEntry (asub, answRef)) -> (sf (); added := true; DivergingEntry (asub, answRef)) (* we assume we alsways insert new things into the tree *) let rec insertIntoTree (a, DAVars, DEVars, G, U, eqn, answRef, status)  = (* sq = query substitution *) let (n, Tree) = sub (indexArray, a) let sq = new () let DAEVars = compose (DEVars, DAVars) let Dq = emptyCtx () let n = ctxLength (G) let _ = makeCtx (n + 1, DAEVars, Dq : ctx) let l = ctxLength (DAEVars) let _ = insert sq (1, (0, U)) let GR = ((l, n + 1), G, eqn, emptyAnswer (), ! stageCtr, status) let result = insert (Tree, (Dq, sq), ((l, n + 1), G, eqn, answRef, ! stageCtr, status)) in match result with (sf, NewEntry (answRef)) -> (sf (); added := true; NewEntry (answRef)) | (_, RepeatedEntry (asub, answRef, status)) -> RepeatedEntry (asub, answRef, status) | (sf, DivergingEntry (asub, answRef)) -> (sf (); added := true; DivergingEntry (asub, answRef)) let rec answCheck (s\', answRef, O)  = answCheckVariant (s\', answRef, O) let rec updateTable ()  = let rec update [] Flag  = Flag | update (answRef :: AList) Flag  = (let l = length (solutions (answRef)) in if (l = lookup (answRef)) then (* no new solutions were added in the previous stage *) update AList Flag else (* new solutions were added *) (updateAnswLookup (l, answRef); update AList true)) let Flag = update (! answList) false let r = (Flag || (! added)) in added := false; r let reset = reset let callCheck = (fun (DAVars, DEVars, G, U, eqn, status) -> callCheck (cidFromHead (targetHead U), DAVars, DEVars, G, U, eqn, status)) let insertIntoTree = (fun (DAVars, DEVars, G, U, eqn, answRef, status) -> insertIntoTree (cidFromHead (targetHead U), DAVars, DEVars, G, U, eqn, answRef, status)) let answerCheck = answCheck let updateTable = updateTable let tableSize = (fun () -> (length (! answList))) (* memberCtxS ((G,V), G\', n) = bool\n\n       if G |- V and |- G\' ctx\n          exists a V\' in G s.t.  V\'[^n]  is an instance of V\n       then return true\n         otherwise false\n    *) let rec memberCtx ((G, V), G\')  = let rec instanceCtx\' ((G, V), Null, n)  = NONE | instanceCtx\' ((G, V), Decl (G\', D\' as Dec (_, V\')), n)  = if instance (G, (V, id), (V\', Shift n)) then SOME (D\') else instanceCtx\' ((G, V), G\', n + 1) in instanceCtx\' ((G, V), G\', 1)  (* local *)  end\n(* functor MemoTable *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {}), (0, {})])
('Error parsing code:', '(* Abstract Machine *) (* Author: Iliano Cervesato *) (* Modified: Jeff Polakow *) (* Modified: Frank Pfenning *) module type ABSMACHINE = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN !*) val solve : (Goal * Sub) * DProg * (Exp -> unit) -> unit end\n(* signature ABSMACHINE *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Abstract Machine using substitution trees *) (* Author: Iliano Cervesato *) (* Modified: Jeff Polakow, Frank Pfenning, Larry Greenfield, Roberto Virga *) module AbsMachineSbt ((*! structure IntSyn\' : INTSYN !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module SubTree : SUBTREE(*! sharing SubTree.IntSyn = IntSyn\' !*) (*! sharing SubTree.CompSyn = CompSyn\' !*) module Assign : ASSIGN(*! sharing Assign.IntSyn = IntSyn\' !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) (* CPrint currently unused *) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\'!*) ) : ABSMACHINESBT = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure CompSyn = CompSyn\' !*)  module I = IntSynmodule C = CompSynlet mSig : (Exp * Sub) * DProg * (Flatterm list -> unit) -> unit ref = ref (fun (ps, dp, sc) -> ()) (* We write\n       G |- M : g\n     if M is a canonical proof term for goal g which could be found\n     following the operational semantics.  In general, the\n     success continuation sc may be applied to such M\'s in the order\n     they are found.  Backtracking is modeled by the return of\n     the success continuation.\n\n     Similarly, we write\n       G |- S : r\n     if S is a canonical proof spine for residual goal r which could\n     be found following the operational semantics.  A success continuation\n     sc may be applies to such S\'s in the order they are found and\n     return to indicate backtracking.\n  *) let rec cidFromHead (Const a)  = a | cidFromHead (Def a)  = a let rec eqHead (Const a, Const a\')  = a = a\' | eqHead (Def a, Def a\')  = a = a\' | eqHead _  = false (* Wed Mar 13 10:27:00 2002 -bp  *) (* should probably go to intsyn.fun *) let rec compose\' (Null, G)  = G | compose\' (Decl (G, D), G\')  = Decl (compose\' (G, G\'), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) let rec invShiftN (n, s)  = if n = 0 then comp (invShift, s) else comp (invShift, invShiftN (n - 1, s)) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Pi ((D, Maybe), V)) let rec printSub (Shift n)  = print ("Shift " ^ toString n ^ "\\n") | printSub (Dot (Idx n, s))  = (print ("Idx " ^ toString n ^ " . "); printSub s) | printSub (Dot (Exp (EVar (_, _, _, _)), s))  = (print ("Exp (EVar _ ). "); printSub s) | printSub (Dot (Exp (AVar (_)), s))  = (print ("Exp (AVar _ ). "); printSub s) | printSub (Dot (Exp (EClo (AVar (_), _)), s))  = (print ("Exp (AVar _ ). "); printSub s) | printSub (Dot (Exp (EClo (_, _)), s))  = (print ("Exp (EClo _ ). "); printSub s) | printSub (Dot (Exp (_), s))  = (print ("Exp (_ ). "); printSub s) | printSub (Dot (Undef, s))  = (print ("Undef . "); printSub s) (* ctxToEVarSub D = s*) let rec ctxToEVarSub (Gglobal, Null, s)  = s | ctxToEVarSub (Gglobal, Decl (G, Dec (_, A)), s)  = let s\' = ctxToEVarSub (Gglobal, G, s) let X = newEVar (Gglobal, EClo (A, s\')) in Dot (Exp (X), s\') | ctxToEVarSub (Gglobal, Decl (G, ADec (_, d)), s)  = let X = newAVar () in Dot (Exp (EClo (X, Shift (~ d))), ctxToEVarSub (Gglobal, G, s)) (* solve\' ((g, s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where  G ~ dPool  (context G matches dPool)\n       G |- s : G\'\n       G\' |- g  goal\n       if  G |- M : g[s]\n       then  sc M  is evaluated with return value res\n       else Fail\n     Effects: instantiation of EVars in g, s, and dp\n              any effect  sc M  might have\n  *) let rec solve\' ((Atom (p), s), dp as DProg (G, dpool), sc)  = matchAtom ((p, s), dp, sc) | solve\' ((Impl (r, A, Ha, g), s), DProg (G, dPool), sc)  = let D\' = Dec (NONE, EClo (A, s)) in solve\' ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Dec (r, s, Ha))), sc) | solve\' ((All (D, g), s), DProg (G, dPool), sc)  = let D\' = decLUName (G, decSub (D, s)) in solve\' ((g, dot1 s), DProg (Decl (G, D\'), Decl (dPool, Parameter)), sc)(* rSolve ((p,s\'), (r,s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       G\' |- r  resgoal\n       G |- s\' : G\'\'\n       G\'\' |- p : H @ S\' (mod whnf)\n       if G |- S : r[s]\n       then sc S is evaluated with return value res\n       else Fail\n     Effects: instantiation of EVars in p[s\'], r[s], and dp\n              any effect  sc S  might have\n  *) rSolve (ps\', (Eq (Q), s), DProg (G, dPool), sc)  = (if unifiable (G, ps\', (Q, s))(* effect: instantiate EVars *)  then sc nil(* call success continuation *)  else ()) | rSolve (ps\', (Assign (Q, eqns), s), dp as DProg (G, dPool), sc)  = (match assignable (G, ps\', (Q, s)) with SOME (cnstr) -> aSolve ((eqns, s), dp, cnstr, (fun () -> sc nil)) | NONE -> ()) | rSolve (ps\', (And (r, A, g), s), dp as DProg (G, dPool), sc)  = (* is this EVar redundant? -fp *) let X = newEVar (G, EClo (A, s)) in rSolve (ps\', (r, Dot (Exp (X), s)), dp, (fun skel1 -> solve\' ((g, s), dp, (fun skel2 -> sc (skel1 @ skel2))))) | rSolve (ps\', (Exists (Dec (_, A), r), s), dp as DProg (G, dPool), sc)  = let X = newEVar (G, EClo (A, s)) in rSolve (ps\', (r, Dot (Exp (X), s)), dp, sc) | rSolve (ps\', (Axists (ADec (_, d), r), s), dp as DProg (G, dPool), sc)  = let X\' = newAVar () in rSolve (ps\', (r, Dot (Exp (EClo (X\', Shift (~ d))), s)), dp, sc)(* we don\'t increase the proof term here! *)(* aSolve ((ag, s), dp, sc) = res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       if G |- ag[s] auxgoal\n       then sc () is evaluated with return value res\n       else Fail\n     Effects: instantiation of EVars in ag[s], dp and sc () *) aSolve ((Trivial, s), dp, cnstr, sc)  = (if solveCnstr cnstr then sc () else ()(* Fail *) ) | aSolve ((UnifyEq (G\', e1, N, eqns), s), dp as DProg (G, dPool), cnstr, sc)  = let G\'\' = compose\' (G\', G) let s\' = shift (G\', s) in if unifiable (G\'\', (N, s\'), (e1, s\')) then aSolve ((eqns, s), dp, cnstr, sc) else ()(* Fail *)(* solve subgoals of static program clauses *) (* sSolve ((sg, s) , dp , sc =\n if  dp = (G, dPool) where G ~ dPool\n     G |- s : G\'\n     sg = g1 and g2 ...and gk\n     for every subgoal gi, G\' |- gi\n                           G  | gi[s]\n   then\n      sc () is evaluated\n   else Fail\n\n   Effects: instantiation of EVars in gi[s], dp, sc\n*) sSolve ((True, s), dp, sc)  = sc nil | sSolve ((Conjunct (g, A, Sgoals), s), dp as DProg (G, dPool), sc)  = solve\' ((g, s), dp, (fun skel1 -> sSolve ((Sgoals, s), dp, (fun skel2 -> sc (skel1 @ skel2)))))(* match signature *) matchSig (ps\' as (Root (Ha, S), s), dp as DProg (G, dPool), sc)  = let rec mSig nil  = () | mSig ((Hc as Const c) :: sgn\')  = let SClause (r) = sProgLookup (cidFromHead Hc) in (* trail to undo EVar instantiations *) trail (fun () -> rSolve (ps\', (r, id), dp, (fun S -> sc ((Pc c) :: S)))); mSig (sgn\') in mSig (lookup (cidFromHead Ha))matchIndexSig (ps\' as (Root (Ha, S), s), dp as DProg (G, dPool), sc)  = matchSig (cidFromHead Ha, G, ps\', (fun ((ConjGoals, s), clauseName) -> sSolve ((ConjGoals, s), dp, (fun S -> sc ((Pc clauseName) :: S)))))(* matchatom ((p, s), dp, sc) => res\n     Invariants:\n       dp = (G, dPool) where G ~ dPool\n       G |- s : G\'\n       G\' |- p : type, p = H @ S mod whnf\n       if G |- M :: p[s]\n       then sc M is evaluated with return value res\n       else Fail\n     Effects: instantiation of EVars in p[s] and dp\n              any effect  sc M  might have\n\n     This first tries the local assumptions in dp then\n     the static signature.\n  *) matchAtom (ps\' as (Root (Ha, S), s), dp as DProg (G, dPool), sc)  = (* matchDProg (dPool, k) = ()\n           where k is the index of dPool in global dPool from call to matchAtom.\n           Try each local assumption for solving atomic goal ps\', starting\n           with the most recent one.\n        *) let rec matchDProg (Null, _)  = (* dynamic program exhausted, try signature\n               there is a choice depending on how we compiled signature\n             *)  (! mSig) (ps\', dp, sc) | matchDProg (Decl (dPool\', Dec (r, s, Ha\')), k)  = if eqHead (Ha, Ha\') then (trail (* trail to undo EVar instantiations *)  (fun () -> rSolve (ps\', (r, comp (s, Shift (k))), dp, (fun S -> sc ((Dc k) :: S)))); matchDProg (dPool\', k + 1)) else matchDProg (dPool\', k + 1) | matchDProg (Decl (dPool\', Parameter), k)  = matchDProg (dPool\', k + 1) let rec matchConstraint (solve, try)  = let succeeded = trail (fun () -> match (solve (G, SClo (S, s), try)) with SOME (U) -> (sc [Csolver U]; true) | NONE -> false) in if succeeded then matchConstraint (solve, try + 1) else () in match constStatus (cidFromHead Ha) with (Constraint (cs, solve)) -> matchConstraint (solve, 0) | _ -> matchDProg (dPool, 1) let rec solve args  = (match (! optimize) with No -> (mSig := matchSig; solve\' args) | LinearHeads -> (mSig := matchSig; solve\' args) | Indexing -> (mSig := matchIndexSig; solve\' args))  (* local ... *)  end\n(* functor AbsMachineSbt *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Indexing for table *) (* Author: Brigitte Pientka *) module TableIndex (module Global : GLOBALmodule Queue : QUEUE(*! structure IntSyn\' : INTSYN !*) (*! structure CompSyn\': COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\'                   !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module AbstractTabled : ABSTRACTTABLED(*! sharing AbstractTabled.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) ) : TABLEINDEX = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure CompSyn = CompSyn\' !*)  module Conv = Conv (* TABLE\n\n   table entry : D, G  |- u\n\n   Answer substitution:\n\n                 Dk, G  |- sk : D, G\n\n   Answer :\n                 Dk, G |- u[sk]\n   *)  (* solution: (Dk, sk)\n\n   * lookup  : pointer to the i-th element in solution list\n   *)  type answer = {solutions: (dctx * Sub) * pskeleton list; lookup: int} (* entry = (((i, G, D, U), A)) where i is the access counter\n   *)  type entry = (((int ref * dctx * dctx * Exp) * answer)) type entries = entry list type index = entry list type answState = New | Repeated type Strategy = Variant | Subsumption let added = ref false (* ---------------------------------------------------------------------- *)  (* global search parameters *)  let strategy = ref Variant (* Subsumption *)  (* Variant *)  (* term abstraction after term depth is greater than 5 *)  let termDepth = ref NONE : int option ref let ctxDepth = ref NONE : int option ref let ctxLength = ref NONE : int option ref (*   val termDepth = ref (!globalTermDepth); *)  (*   val ctxDepth = ref (!globalCtxDepth);   *)  (*   val ctxLength = ref (!globalCtxLength); *)  (* apply strengthening during abstraction *)  let strengthen = strengthen (* original query *)  let query : dctx * dctx * Exp * Sub * (pskeleton -> unit) option ref = ref NONE (* ---------------------------------------------------------------------- *)  module I = IntSynmodule C = CompSynmodule A = AbstractTabled(* Global Table *) let table : index ref = ref [] (* concat(Gdp, G) = G\'\'\n     *\n     * if Gdp = ym...y1\n     *    G   = xn...x1\n     * then\n     *    Gdp, G = G\'\'\n     *    ym...y1, xn...x1\n     *\n     *) let rec concat (Null, G\')  = G\' | concat (Decl (G, D), G\')  = Decl (concat (G, G\'), D) let rec reverse (Null, G\')  = G\' | reverse (Decl (G, D), G\')  = reverse (G, Decl (G\', D)) (* ---------------------------------------------------------------------- *) (* printTable () = () *) let rec printTable ()  = let rec proofTerms (G, D, U, [])  = print "" | proofTerms (G, D, U, (((D\', s\'), _) :: S))  = ((* (print (Print.expToString (I.Null,  *) (*              A.raiseType(Names.ctxName(concat(G,D\')), I.EClo(U, s\')))) *) (try  with ); (* do not print pskeletons *) print ", \\n\\t"; proofTerms (G, D, U, S)) let rec printT []  = () | printT (((k, G, D, U), {solutions = S; lookup = i}) :: T)  = match S with [] -> (printT T; print (expToString (Null, raiseType (concat (G, D), U)) ^ ", NONE\\n")) | (a :: answ) -> (printT T; print (expToString (Null, raiseType (concat (G, D), U)) ^ ", [\\n\\t"); proofTerms (G, D, U, (rev S)); print (" ] -- lookup : " ^ toString i ^ "\\n\\n")) in print ("Table: \\n"); printT (! table); print ("End Table \\n"); print ("Number of table entries   : " ^ toString (length (! table)) ^ "\\n") (* printTableEntries () = () *) let rec printTableEntries ()  = let rec printT []  = () | printT (((k, G, D, U), {solutions = S; lookup = i}) :: T)  = (printT T; print (expToString (Null, raiseType (concat (G, D), U)) ^ "\\n Access Counter : " ^ (toString (! k)) ^ " \\n")) in print ("TableEntries: \\n"); printT (! table); print ("End TableEntries \\n"); print ("Number of table entries   : " ^ toString (length (! table)) ^ "\\n") (* ---------------------------------------------------------------------- *) (* Term Abstraction *) let rec lengthSpine (Nil)  = 0 | lengthSpine (SClo (S, s\'))  = 1 + lengthSpine (S) let rec exceedsTermDepth (i)  = match (! termDepth) with NONE -> false | SOME (n) -> (i > n) let rec exceedsCtxDepth (i)  = match (! ctxDepth) with NONE -> false | SOME (n) -> (print ("\\n exceedsCtxDepth " ^ toString i ^ " > " ^ toString n ^ " ? "); (i > n)) let rec exceedsCtxLength (i)  = match (! ctxLength) with NONE -> false | SOME (n) -> (i > n) let rec max (x, y)  = if x > y then x else y let rec oroption (NONE, NONE, NONE)  = false | oroption (SOME (k), _, _)  = true | oroption (_, SOME (n), _)  = true | oroption (_, _, SOME (n))  = true let rec abstractionSet ()  = oroption (! termDepth, ! ctxDepth, ! ctxLength) (* countDepth U =\n         ctr = (ctrTerm, ctrDecl, ctrLength)\n         ctrTerm : max term depth\n         ctrDecl : max type depth in decl\n         ctrLength : length of decl\n\n    *) let rec exceeds (U)  = countDecl (0, 0, U)countDecl (ctrType, ctrLength, Pi ((D, _), V))  = (*         val _ = print ("\\n ctrType\' = " ^ Int.toString ctrType\')  *) let ctrType\' = countDec (0, D) in if ctrType\' > ctrType then countDecl (ctrType\', ctrLength + 1, V) else countDecl (ctrType, ctrLength + 1, V) | countDecl (ctrType, ctrLength, U)  = (*         val _ = print ("\\n 1 ctrTerm = " ^ Int.toString ctrTerm)\n           val _ = print ("\\n 1 ctxLength = " ^ Int.toString ctrLength)\n           val _ = print ("\\n 1 ctxDepth = " ^ Int.toString ctrType)\n*) let ctrTerm = count (0, U) in exceedsCtxDepth (ctrType) || exceedsCtxLength (ctrLength) || exceedsTermDepth (count (0, U))countDec (ctr, Dec (_, U))  = count (ctr, U) | countDec (ctr, BDec (_, s))  = 0count (ctr, (U as Uni (L)))  = ctr | count (ctr, Pi ((D, _), V))  = (*         val _ = print ("\\n ctrTerm = " ^ Int.toString ctrTerm)\n           val _ = print ("\\n ctrType = " ^ Int.toString ctrType)\n*) let ctrTerm = count (ctr, V) let ctrType = countDec (ctr, D) in max (ctrType, ctrTerm)(* to revise ?*) | count (ctr, Root (F, S))  = (*         val _ = print ("\\n spineDepth = " ^ Int.toString ctrDepth)\n           val _ = print ("\\n RootF = " ^ Int.toString(ctrDepth + ctr))\n*) let ctrDepth = countSpine (1, S) in (ctrDepth + 1 + ctr)(*         (ctrLength + ctr) *) | count (ctr, Redex (U, S))  = (*         val _ = print ("\\n SpindeDepth = " ^ Int.toString ctrDepth)\n           val _ = print ("\\n Redex = " ^ Int.toString(max(ctrDepth\',ctrDepth) + ctr))*) let ctrDepth = count (0, U) let ctrDepth\' = countSpine (ctrDepth, S) in (max (ctrDepth\', ctrDepth) + ctr) | count (ctr, Lam (D, U))  = count (ctr + 1, U) | count (ctr, (X as EVar _))  = (* shouldn\'t happen *)  ctr | count (ctr, EClo (E, s))  = count (ctr, E) | count (ctr, (F as FgnExp (cs, ops)))  = (* shouldn\'t happen *)  (ctr)(* count max depth of term in S + length of S *) countSpine (ctrDepth, Nil)  = ctrDepth | countSpine (ctr, SClo (S, s\'))  = (* ? *)  countSpine (ctr, S) | countSpine (ctrDepth, App (U, S))  = let ctrDepth\' = count (0, U) in countSpine (max (ctrDepth\', ctrDepth), S) (* ---------------------------------------------------------------------- *) (* reinstSub (G, D, s) = s\'\n    *\n    * If D\', G |- s : D, G\n    * then  G |- s\' : D, G\n    *) let rec reinstSub (G, Null, s)  = s | reinstSub (G, Decl (D, Dec (_, A)), s)  = let X = newEVar (Null, A) in Dot (Exp (X), reinstSub (G, D, s)) (* ---------------------------------------------------------------------- *) (* variant (U,s) (U\',s\')) = bool   *) let rec variant (Us, Us\')  = conv (Us, Us\') (* subsumes ((G, D, U), (G\', D\', U\')) = bool\n     *\n     * if\n     *    D, G   |- U\n     *    D\', G\' |- U\'\n     * then\n     *      G\' |- s\' : D\', G\'\n     *    return true if D, G |- U is an instance of G\' |- U\'[s\']\n     *    otherwise false\n     *\n     *) let rec subsumes ((G, D, U), (G\', D\', U\'))  = let Upi = raiseType (G, U) let Upi\' = raiseType (G\', U\') let s\' = reinstSub (G\', D\', id) in trail (fun () -> unifiable (D, (Upi\', s\'), (Upi, id))) let rec equalSub (Shift k, Shift k\')  = (k = k\') | equalSub (Dot (F, S), Dot (F\', S\'))  = equalFront (F, F\') && equalSub (S, S\') | equalSub (Dot (F, S), Shift k)  = false | equalSub (Shift k, Dot (F, S))  = falseequalFront (Idx n, Idx n\')  = (n = n\') | equalFront (Exp U, Exp V)  = conv ((U, id), (V, id)) | equalFront (Undef, Undef)  = true let rec equalSub1 (Dot (ms, s), Dot (ms\', s\'))  = equalSub (s, s\') let rec equalCtx (Null, Null)  = true | equalCtx (Decl (Dk, Dec (_, A)), Decl (D1, Dec (_, A1)))  = conv ((A, id), (A1, id)) && equalCtx (Dk, D1) (* ---------------------------------------------------------------------- *) (* Call check and insert *) (* callCheck (G, D, U) = callState\n\n       check whether D, G |- U is in the table\n\n     returns NONE,\n        if D, G |- U is not already in the table\n          Sideeffect: add D, G |- U to table\n\n     returns SOME(A)\n        if D, G |- U is in table and\n          A is an entry in the table together with its answer list\n\n    Variant:\n    if it succeeds there is exactly one table entry which is a variant to U\n    Subsumption:\n    if it succeeds it will return the most general table entry of which U is\n    an instance of (by invariant now, the most general table entry will be found first,\n    any entry found later, will be an instance of this entry)\n    *) let rec callCheckVariant (G, D, U)  = let Upi = raiseType (concat (G, D), U) let rec lookup ((G, D, U), [])  = (table := ((ref 1, G, D, U), {solutions = []; lookup = 0}) :: (! table); (if (! chatter) >= 5 then (print ("\\n \\n Added "); print (expToString (Null, Upi) ^ "\\n to Table \\n")) else ()); added := true; (* if termdepth(U) > n then force the tabled engine to suspend\n               * and treat it like it is already in the table, but no answ available *) if abstractionSet () then ((* print ("\\n term " ^ Print.expToString (I.Null, Upi) ^\n                  " exceeds depth or length ? \\n"); *) if exceeds (raiseType (G, U)) then ((if (! chatter) >= 5 then print ("\\n term " ^ expToString (Null, Upi) ^ " exceeds depth or length \\n") else ()); SOME ([])) else NONE) else NONE) | lookup ((G, D, U), ((H as ((k, G\', D\', U\'), answ)) :: T))  = if variant ((Upi, id), (raiseType (concat (G\', D\'), U\'), id)) then (k := ! k + 1; (if (! chatter) >= 5 then print ("call " ^ expToString (Null, Upi) ^ " found in table \\n ") else ()); SOME [((G\', D\', U\'), answ)]) else lookup ((G, D, U), T) in lookup ((G, D, U), (! table)) (* Subsumption:\n\n       Assumes: Table is in order [tn, ...., t1]\n       i.e. tn is added to the table later than t1\n            this implies that tn is more general than ti (i < n)\n\n       if we find a tn s.t M is an instance of it, then return tn\n       and do not search further\n\n    *) let rec callCheckSubsumes (G, D, U)  = let rec lookup ((G, D, U), [])  = (table := ((ref 1, G, D, U), {solutions = []; lookup = 0}) :: (! table); (if (! chatter) >= 5 then print ("Added " ^ expToString (Null, raiseType (concat (G, D), U)) ^ " to Table \\n") else ()); added := true; if exceeds (raiseType (G, U)) then ((if (! chatter) >= 4 then print ("\\n term " ^ expToString (Null, raiseType (concat (G, D), U)) ^ " exceeds depth or length \\n") else ()); SOME ([])) else NONE) | lookup ((G, D, U), (((k, G\', D\', U\'), answ) :: T))  = if (subsumes ((G, D, U), (G\', D\', U\'))) then ((if (! chatter) >= 5 then print ("call " ^ expToString (Null, raiseType (concat (G, D), U)) ^ "found in table \\n ") else ()); k := ! k + 1; SOME ([((G\', D\', U\'), answ)])) else lookup ((G, D, U), T) in lookup ((G, D, U), (! table)) (* ---------------------------------------------------------------------- *) let rec member ((Dk, sk), [])  = false | member ((Dk, sk), (((D1, s1), _) :: S))  = (* do we really need to compare Gus and Gs1 ?  *)  if equalSub (sk, s1) && equalCtx (Dk, D1) then true else member ((Dk, sk), S) (* answer check and insert\n\n      if     G |- U[s]\n          D, G |- U\n             G |- s : D, G\n\n      answerCheck (G, D, (U,s)) = repeated\n         if s already occurs in answer list for U\n      answerCheck (G, D, (U,s)) = new\n         if s did not occur in answer list for U\n         Sideeffect: update answer list for U\n\n        Dk, G |- sk : D, G\n        Dk, G |- U[sk]\n\n        sk is the abstraction of s and Dk contains all "free" vars\n\n     *) let rec answCheckVariant (G, D, U, s, O)  = let Upi = raiseType (concat (G, D), U) let _ = if (! chatter) >= 5 then (print "\\n AnswCheckInsert: "; print (expToString (Null, EClo (raiseType (G, U), s)) ^ "\\n"); print "\\n Table Index : "; print (expToString (Null, Upi) ^ "\\n")) else () let rec lookup (G, D, U, s) [] T  = (* cannot happen ! *)  (print (expToString (Null, EClo (raiseType (G, U), s)) ^ " call should always be already in the table !\\n"); Repeated) | lookup (G, D, U, s) ((H as ((k, G\', D\', U\'), {solutions = S; lookup = i})) :: T) T\'  = if variant ((Upi, id), (raiseType (concat (G\', D\'), U\'), id)) then let (Dk, sk) = abstractAnswSub s in (* answer check *) if member ((Dk, sk), S) then Repeated else (table := (rev T\') @ (((k, G\', D\', U\'), {solutions = (((Dk, sk), O) :: S); lookup = i}) :: T); (if (! chatter) >= 5 then (print ("\\n Add solution  -- "); print (expToString (Null, EClo (raiseType (G\', U\'), s))); print ("\\n solution added  -- "); print (expToString (Null, raiseType (ctxName (Dk), EClo (raiseType (G\', U\'), sk))))) else ()); New) else lookup (G, D, U, s) T (H :: T\') in lookup (G, D, U, s) (! table) [] (* memberSubsumes ((G, Dk, U, sk), (G\', U\', A)) = bool\n\n   If Dk, G |- U[sk]\n\n      A = ((Dn, sn), On), ....., ((D1, s1), O1)\n\n      for all i in [1, ..., n]\n          Di, G\' |- U\'[si]\n              G\' |- si\' : Di, G\'\n   then\n     exists an i in [1,...,n]  s.t.\n         Dk, G |- U[sk] is an instance of G\' |- U\'[si\']\n   *) let rec memberSubsumes ((G, D, U, s), (G\', U\', []))  = false | memberSubsumes ((G, D, U, s), (G\', U\', (((D1, s1), _) :: A)))  = (* assume G\' and G are the same for now *) let Upi = raiseType (G, U) let Upi\' = raiseType (G\', U\') let s1\' = reinstSub (G\', D1, id) let Vpis = (EClo (Upi\', s1), s1\') let b = trail (fun () -> unifiable (D, (Upi, s), (Vpis))) in if b then ((if (! chatter) >= 5 then print "\\n answer in table subsumes answer \\n " else ()); true) else memberSubsumes ((G, D, U, s), (G\', U\', A)) let rec shift (0, s)  = s | shift (n, s)  = shift (n - 1, dot1 s) let rec answCheckSubsumes (G, D, U, s, O)  = let Upi = raiseType (G, U) let _ = if (! chatter) >= 4 then (print ("\\n AnswCheckInsert (subsumes): "); print (expToString (Null, EClo (Upi, s)) ^ "\\n")) else () let rec lookup ((G, D, U, s), [], T)  = (* cannot happen ! *)  (print (expToString (concat (G, D), EClo (U, s)) ^ " call should always be already in the table !\\n"); Repeated) | lookup ((G, D, U, s), (((k, G\', D\', U\'), {solutions = A; lookup = i}) :: T), T\')  = if (subsumes ((G, D, U), (G\', D\', U\'))) then let (Dk, sk) = abstractAnswSub s in if memberSubsumes ((G, Dk, U, sk), (G\', U\', A)) then Repeated else (*  higher-order matching *) (* reinstantiate us\' *) let s\' = reinstSub (G\', D\', id) let _ = if (! chatter) >= 4 then (print "\\n new answer to be added to Index \\n"; print (expToString (Null, raiseType (concat (G\', D\'), U\')) ^ "\\n"); print "\\n answer added \\n"; print (expToString (Null, raiseType (Dk, EClo (raiseType (G, U), sk))) ^ "\\n")) else () let _ = if (unifiable (Dk, (raiseType (G, U), sk), (raiseType (G\', U\'), s\'))) then (if (! chatter) >= 4 then (print "\\n1 unification successful !\\n"; print (expToString (Null, raiseType (Dk, EClo (raiseType (G\', U\'), s\'))) ^ "\\n")) else ()) else print "\\n1 unification failed! -- should never happen ?" let (Dk\', sk\') = abstractAnsw (Dk, s\') let rs = reinstSub (G\', Dk\', id) in (match ! query with NONE -> ()(* nothing to do *)  | SOME (G1, D1, U1, s1, sc1) -> ((if (! chatter) >= 4 then (print ("Generate answers for: "); print (expToString (Null, EClo (raiseType (G1, U1), s1)) ^ " \\n"); print ("Answer in table: "); print (expToString (Null, raiseType (Dk, EClo (raiseType (G\', U\'), s\'))) ^ " : \\n"); print (expToString (Null, EClo (raiseType (Dk, EClo (raiseType (G\', U\'), sk\')), rs)) ^ " : \\n")) else ()); (if (subsumes ((G1, D1, U1), (G\', D\', U\'))) then (* original query is an instance of the entry we are adding answ to *) trail (fun () -> (if unifiable (D1, (raiseType (G1, U1), s1), (EClo (raiseType (G\', U\'), sk\'), rs)) then let w = if (! strengthen) then weaken (Null, targetFam (EClo (U1, s1))) else id in (* (I.EClo(N1, I.comp(shift(I.ctxLength(Gdp1),s1), w))) *) sc1 O else ())) else ()))); table := ((rev T\') @ (((k, G\', D\', U\'), {solutions = (((Dk\', sk\'), O) :: A); lookup = i}) :: T)); (if (! chatter) >= 5 then (print ("\\n \\n solution (original) was: \\n"); print (expToString (Null, EClo (raiseType (G, U), s)) ^ "\\n"); print ("\\n \\n solution (deref) was: \\n"); print (expToString (Null, raiseType (Dk, EClo (raiseType (G, U), sk))) (*                    print(Print.expToString(I.Null, I.EClo(A.raiseType(concat(G, Dk), U), sk)) *)  ^ "\\n"); print ("\\n solution added  --- "); print (expToString (Null, raiseType (Dk\', EClo (raiseType (G\', U\'), s\'))) ^ "\\n"); print ("\\n solution added (dereferenced) --- "); print (expToString (Null, raiseType (Dk\', EClo (raiseType (G\', U\'), sk\'))) ^ "\\n")) else ()); New else lookup ((G, D, U, s), T, (((k, G\', D\', U\'), {solutions = A; lookup = i}) :: T\')) in lookup ((G, D, U, s), (! table), []) (* ---------------------------------------------------------------------- *) (* TOP LEVEL *) let rec reset ()  = (table := []) let rec solutions {solutions = S; lookup = i}  = S let rec lookup {solutions = S; lookup = i}  = i let rec noAnswers []  = true | noAnswers ((H as ((G\', D\', U\'), answ)) :: L\')  = match (take (solutions (answ), lookup (answ))) with [] -> noAnswers L\' | L -> false let rec callCheck (G, D, U)  = match (! strategy) with Variant -> callCheckVariant (G, D, U) | Subsumption -> callCheckSubsumes (G, D, U) let rec answCheck (G, D, U, s, O)  = match (! strategy) with Variant -> answCheckVariant (G, D, U, s, O) | Subsumption -> answCheckSubsumes (G, D, U, s, O) (* needs to take into account previous size of table *) let rec updateTable ()  = let rec update [] T Flag  = (Flag, T) | update (((k, G, D, U), {solutions = S; lookup = i}) :: T) T\' Flag  = let l = length (S) in if (l = i) then (* no new solutions were added in the previous stage *) update T (((k, G, D, U), {solutions = S; lookup = length (S)}) :: T\') Flag else (* new solutions were added *) update T (((k, G, D, U), {solutions = S; lookup = length (S)}) :: T\') true let (Flag, T) = update (! table) [] false let r = Flag || (! added) in added := false; table := rev (T); (* in each stage incrementally increase termDepth *) (*          termDepth := (!termDepth +1); *) r (*  val termDepth = termDepth\n    val ctxDepth = ctxDepth\n    val ctxLength = ctxLength\n*) let table = table let solutions = solutions let lookup = lookup let noAnswers = noAnswers let reset = reset let printTable = printTable let printTableEntries = printTableEntries let callCheck = callCheck let answerCheck = answCheck let updateTable = updateTable  (* local *)  end\n(* functor TableIndex *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Indexing *) (* Author: Brigitte Pientka *) module type MEMOTABLE = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN !*) (*! structure TableParam : TABLEPARAM !*) (* call check/insert *) (* callCheck (G, D, U, eqn)\n   *\n   * if D, G |- U & eqn     in table  then RepeatedEntry (entries)\n   * if D, G |- U & eqn not in table  then NewEntry (ptrAnswer)\n   * SIDE EFFECT: D, G |- U added to table\n   *) val callCheck : dctx * dctx * dctx * Exp * ResEqn * Status -> callCheckResultval insertIntoTree : dctx * dctx * dctx * Exp * ResEqn * answer * Status -> callCheckResult(* answer check/insert *) (* answerCheck (G, D, (U,s))\n   * \n   * Assupmtion: D, G |- U is in table\n   *             and A represents the corresponding solutions\n   * \n   * G |- s : D, G\n   * Dk, G |- sk : D, G\n   *\n   * If  (Dk, sk) in A then repeated\n   *  else new\n   *) val answerCheck : Sub * answer * pskeleton -> answState(* reset table *) val reset : unit -> unit(* updateTable \n   *\n   * SIDE EFFECT: \n   *   for each table entry: \n   *       advance lookup pointer\n   *\n   * if Table did not change during last stage \n   *    then updateTable () =  false\n   * else updateTable () = true\n   *) val updateTable : unit -> boolval tableSize : unit -> intval memberCtx : (dctx * Exp) * dctx -> Dec option end\n(* signature MemoTable *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module type TRACE = sig (* Program interface *) (*! structure IntSyn : INTSYN !*) type goalTagval tagGoal : unit -> goalTagtype EventIntroHypHead * DecDischargeHypHead * DecIntroParmHead * DecDischargeParmHead * DecResolvedHead * HeadSubgoal(Head * Head) * (unit -> int)SolveGoalgoalTag * Head * ExpSucceedGoalgoalTag * (Head * Head) * ExpCommitGoalgoalTag * (Head * Head) * ExpRetryGoalgoalTag * (Head * Head) * ExpFailGoalgoalTag * Head * ExpUnify(Head * Head) * Exp * ExpFailUnify(Head * Head) * string(* failure message *) val signal : dctx * Event -> unitval init : unit -> unit(* initialize trace, break and tag *) val tracing : unit -> bool(* currently tracing or using breakpoints *) (* User interface *) type 'aSpecNoneSome'a listAllval trace : string Spec -> unitval break : string Spec -> unitval detail : int ref(* 0 = none, 1 = default, 2 = unify *) val show : unit -> unit(* show trace, break, detail *) val reset : unit -> unit(* reset trace, break, detail *)  end\n(* signature TRACE *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Linear Substitution Tree indexing *) (* Linearity: Any variables occurring inside the substitution tree are linear *) (* Any term we insert into the substitution tree is in normalform *) (* Variant Checking *) (* Author: Brigitte Pientka *) module MemoTable ((*! structure IntSyn\' : INTSYN !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) (*! structure RBSet : RBSET !*) (*! structure TableParam : TABLEPARAM !*) (*! sharing TableParam.IntSyn = IntSyn\' !*) (*! sharing TableParam.CompSyn = CompSyn\' !*) (*! sharing TableParam.RBSet = RBSet !*) module AbstractTabled : ABSTRACTTABLED(*! sharing AbstractTabled.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\'!*) ) : MEMOTABLE = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure CompSyn = CompSyn\' !*)  module AbstractTabled = AbstractTabled (*! structure TableParam = TableParam !*)  (* ---------------------------------------------------------------------- *)  (* Linear substitution tree for linear terms *)  (* normalSubsts: key = int = nvar *)  (* property: linear *)  type normalSubsts = Exp ordSet type exSubsts = Exp ordSet let nid : unit -> normalSubsts = new let aid = aid let existId : unit -> normalSubsts = new let rec isId s  = isEmpty s (* ---------------------------------------------------------------------- *)  type ctx = int * Dec list ref let rec emptyCtx ()  ctx  = ref [] let rec copy L  ctx  = ref (! L) (* destructively updates L *)  let rec delete (x, L : ctx)  = let rec del (x, [], L)  = NONE | del (x, ((H as (y, E)) :: L), L\')  = if x = y then SOME ((y, E), (rev L\') @ L) else del (x, L, H :: L\') in match del (x, (! L), []) with NONE -> NONE | SOME ((y, E), L\') -> (L := L\'; SOME ((y, E))) let rec member (x, L : ctx)  = let rec memb (x, [])  = NONE | memb (x, (H as (y, E) :: L))  = if x = y then SOME ((y, E)) else memb (x, L) in memb (x, (! L)) let rec insertList (E, L)  = (L := (E :: (! L)); L) (* ctxToEVarSub D = s\n\n     if D is a context for existential variables,\n        s.t. u_1:: A_1,.... u_n:: A_n = D\n     then . |- s : D where s = X_n....X_1.id\n\n    *)  let rec ctxToEVarSub (Null, s)  = s | ctxToEVarSub (Decl (G, Dec (_, A)), s)  = let s\' = ctxToEVarSub (G, s) let X = newEVar (Null, EClo (A, s\')) in Dot (Exp (X), s\') (* ---------------------------------------------------------------------- *)  (* Substitution Tree *)  (* it is only possible to distribute the evar-ctx because\n     all evars occur exactly once! -- linear\n     this allows us to maintain invariant, that every occurrence of an evar is\n     defined in its evar-ctx\n     *)  type Tree = Leaf of (ctx * normalSubsts) * (int(* #EVar *)  * int(* #G *) ) * dctx * (* G *) ResEqn * answer * int * Status list ref | Node of (ctx * normalSubsts) * Tree ref list let rec makeTree ()  = ref (Node ((emptyCtx (), nid ()), [])) let rec noChildren C  = (C = []) type Retrieval = Variant of Exp | NotCompatible type CompSub = SplitSub of ((ctx * normalSubsts(* sigma *) ) * (ctx * normalSubsts(* rho1 *) ) * (ctx * normalSubsts(* rho2 *) )) | VariantSub of ((* normalSubsts * *) (ctx * normalSubsts(* rho2 *) )) | NoCompatibleSub (* Index array\n\n     All type families have their own substitution tree and all substitution trees\n     are stored in an array [a1,...,an]   where ai is a substitution tree for type family ai\n     *)  let indexArray = tabulate (maxCid, (fun i -> (ref 0, makeTree ()))) exception Error of string module I = IntSynmodule C = CompSynmodule S = RBSetmodule A = AbstractTabledmodule T = TableParamexception Assignment of string exception Generalization of string exception DifferentSpines let rec emptyAnswer ()  = emptyAnsw () let answList : answer list ref = ref [] let added = ref false type nvar = int (* index for normal variables *) type bvar = int (* index for bound variables *) type bdepth = int (* depth of locally bound variables *) (* ------------------------------------------------------ *) (* Auxiliary functions *) let rec cidFromHead (Const c)  = c | cidFromHead (Def c)  = c let rec dotn (0, s)  = s | dotn (i, s)  = dotn (i - 1, dot1 s) let rec compose (Null, G)  = G | compose (Decl (G, D), G\')  = Decl (compose (G, G\'), D) let rec shift (Null, s)  = s | shift (Decl (G, D), s)  = dot1 (shift (G, s)) let rec raiseType (Null, U)  = U | raiseType (Decl (G, D), U)  = raiseType (G, Lam (D, U)) let rec ctxToAVarSub (G\', Null, s)  = s | ctxToAVarSub (G\', Decl (D, Dec (_, A)), s)  = let E as EVar (r, _, _, cnstr) = newEVar (Null, A) in Dot (Exp (E), ctxToAVarSub (G\', D, s)) | ctxToAVarSub (G\', Decl (D, ADec (_, d)), s)  = let X = newAVar () in Dot (Exp (EClo (X, Shift (~ d))), ctxToAVarSub (G\', D, s)) (* solveEqn\' ((VarDef, s), G) = bool\n\n     if G\'\' |- VarDef and G   |- s : G\'\'\n       G   |- VarDef[s]\n    then\n      return true, if VarDefs are solvable\n      false otherwise\n      *) let rec solveEqn\' ((Trivial, s), G)  = true | solveEqn\' ((Unify (G\', e1, N, (* evar *) , eqns), s), G)  = let G\'\' = compose (G\', G) let s\' = shift (G\', s) in unifiable (G\'\', (N, s\'), (e1, s\')) && solveEqn\' ((eqns, s), G) (* ------------------------------------------------------ *) (*  Variable b    : bound variable\n     Variable n    : index variable\n     linear term  U ::=  Root(c, S) | Lam (D, U) | Root(b, S)\n     linear Spine S ::= p ; S | NIL\n     indexed term t ::= Root(n, NIL) |  Root(c, S) | Lam (D, p) | Root(b, S)\n     indexed spines S_i ::= t ; S_i | NIL\n     Types   A\n     Context G : context for bound variables (bvars)\n     (type information is stored in the context)\n        G ::= . | G, x : A\n        Set of all index variables:  N\n\n        linear terms are approximately well-typed in G:  G |- p\n        after erasing all typing dependencies.\n\n\n        Let s be a path in the substitution tree such that\n        s1 o s2 o .... o sn = s,\n\n\n\n        Let N1 ... Nn be the path from the root N1 to the leaf Nn,\n        and si the substitution associated with node Ni.\n\n       IMAGE(sn) = empty\n       s1 o s2 o ... o sn = s and IMAGE(s) = empty\n       i.e. index variables are only internally used and no\n       index variable is left.\n\n       A linear term U (and an indexed term t) can be decomposed into a term t\' together with\n       a sequenence of substitutions s1, s2, ..., sn such that s1 o s2 o .... o sn = s\n       and the following holds:\n\n       If    N  ; G |- t\n       then  N\' ; G |- t\'\n             N  ; G |- s : N\' ; G\n             N  ; G |- t\'[s]     and t\'[s] = t\n\n      if we have a linear term then N will be empty, but the same holds.\n\n      In addition:\n      all expressions in the index are closed and linear, i.e.\n      an expression is first linearized before it is inserted into the index\n      (this makes retrieving all axpressions from the index which unify with\n      a given expression simpler, because we can omit the occurs check)\n\n   *) (* ---------------------------------------------------------------*) (* nctr = |D| =  #index variables *) let nctr = ref 1 let rec newNVar ()  = (nctr := ! nctr + 1; NVar (! nctr)) let rec equalDec (Dec (_, U), Dec (_, U\'))  = conv ((U, id), (U\', id)) | equalDec (ADec (_, d), ADec (_, d\'))  = (d = d\') | equalDec (_, _)  = false (* We require order of both eqn must be the same Sun Sep  8 20:37:48 2002 -bp *) (* s = s\' = I.id *) let rec equalCtx (Null, s, Null, s\')  = true | equalCtx (Decl (G, D), s, Decl (G\', D\'), s\')  = convDec ((D, s), (D\', s\')) && (equalCtx (G, dot1 s, G\', dot1 s\')) | equalCtx (_, _, _, _)  = false (* in general, we need to carry around and build up a substitution *) let rec equalEqn (Trivial, Trivial)  = true | equalEqn (Unify (G, X, N, eqn), (Unify (G\', X\', N\', eqn\')))  = equalCtx (G, id, G\', id) && conv ((X, id), (X\', id)) && conv ((N, id), (N\', id)) && equalEqn (eqn, eqn\') | equalEqn (_, _)  = false let rec equalSub (Shift k, Shift k\')  = (k = k\') | equalSub (Dot (F, S), Dot (F\', S\'))  = equalFront (F, F\') && equalSub (S, S\') | equalSub (Dot (F, S), Shift k)  = false | equalSub (Shift k, Dot (F, S))  = falseequalFront (Idx n, Idx n\')  = (n = n\') | equalFront (Exp U, Exp V)  = conv ((U, id), (V, id)) | equalFront (Undef, Undef)  = true let rec equalSub1 (Dot (ms, s), Dot (ms\', s\'))  = equalSub (s, s\') let rec equalCtx\' (Null, Null)  = true | equalCtx\' (Decl (Dk, Dec (_, A)), Decl (D1, Dec (_, A1)))  = (conv ((A, id), (A1, id)) && equalCtx\' (Dk, D1)) | equalCtx\' (Decl (Dk, ADec (_, d\')), Decl (D1, ADec (_, d)))  = ((d = d\') && equalCtx\' (Dk, D1)) | equalCtx\' (_, _)  = false (* ---------------------------------------------------------------*) let rec compareCtx (G, G\')  = equalCtx\' (G, G\') (* ---------------------------------------------------------------*) (* most specific linear common generalization *) (* compatible (T, U) = (T\', rho_u, rho_t) opt\n    if T is an indexed term\n       U is a linear term\n       U and T share at least the top function symbol\n   then\n       T\'[rho_u] = U and T\'[rho_t] = T\n   *) let rec isExists (d, BVar k, D)  = member (k - d, D) let rec compHeads ((D_1, Const k), (D_2, Const k\'))  = (k = k\') | compHeads ((D_1, Def k), (D_2, Def k\'))  = (k = k\') | compHeads ((D_1, BVar k), (D_2, BVar k\'))  = (match isExists (0, BVar k, D_1) with NONE -> (k = k\') | SOME (x, Dec) -> true) | compHeads ((D_1, BVar k), (D_2, H2))  = (match isExists (0, BVar k, D_1) with NONE -> false | SOME (x, Dec) -> true) | compHeads ((D_1, H1), (D_2, H2))  = false let rec compatible\' ((D_t, T), (D_u, U), Ds, rho_t, rho_u)  = let rec genNVar ((rho_t, T), (rho_u, U))  = (insert rho_t (! nctr + 1, T); insert rho_u (! nctr + 1, U); newNVar ()) let rec genRoot (depth, T as Root (H1 as Const k, S1), U as Root (Const k\', S2))  = if (k = k\') then let S\' = genSpine (depth, S1, S2) in Root (H1, S\') else genNVar ((rho_t, T), (rho_u, U)) | genRoot (depth, T as Root (H1 as Def k, S1), U as Root (Def k\', S2))  = if (k = k\') then let S\' = genSpine (depth, S1, S2) in Root (H1, S\') else genNVar ((rho_t, T), (rho_u, U)) | genRoot (d, T as Root (H1 as BVar k, S1), U as Root (BVar k\', S2))  = if (k > d) && (k\' > d) then (* globally bound variable *) let k1 = (k - d) let k2 = (k\' - d) in match (member (k1, D_t), member (k2, D_u)) with (NONE, NONE) -> if (k1 = k2) then try  with  else genNVar ((rho_t, T), (rho_u, U)) | (SOME (x, Dec1), SOME (x\', Dec2)) -> (* k, k\' refer to the existential *) if ((k1 = k2) && equalDec (Dec1, Dec2)) then (* they refer to the same existential variable *) (* this is unecessary -- since existential variables have the same type\n                                and need to be fully applied in order, S1 = S2 *) let S\' = genSpine (d, S1, S2) in (delete (x, D_t); delete (x\', D_u); insertList ((x, Dec1), Ds); Root (H1, S\')) else (* variant checking only *) genNVar ((rho_t, T), (rho_u, U)) | (_, _) -> genNVar ((rho_t, T), (rho_u, U)) else (* locally bound variables *) if (k = k\') then try  with  else genNVar ((rho_t, T), (rho_u, U)) | genRoot (d, T as Root (H1 as BVar k, S1), U as Root (Const k\', S2))  = genNVar ((rho_t, T), (rho_u, U)) | genRoot (d, T as Root (H1, S1), U as Root (H2, S2))  = genNVar ((rho_t, T), (rho_u, U))genExp (d, T as NVar n, U as Root (H, S))  = (insert rho_u (n, U); T) | genExp (d, T as Root (H1, S1), U as Root (H2, S2))  = genRoot (d, Root (H1, S1), Root (H2, S2)) | genExp (d, Lam (D1 as Dec (_, A1), T1), Lam (D2 as Dec (_, A2), U2))  = (* by invariant A1 = A2 *)  let E = genExp (d + 1, T1, U2) in Lam (D1, E) | genExp (d, T, U)  = (* U = EVar, EClo -- can\'t happen -- Sun Oct 20 13:41:25 2002 -bp *)  (print "genExp -- falls through?\\n"; genNVar ((rho_t, T), (rho_u, U)))genSpine (d, Nil, Nil)  = Nil | genSpine (d, App (T, S1), App (U, S2))  = let E = genExp (d, T, U) let S\' = genSpine (d, S1, S2) in App (E, S\') | genSpine (d, Nil, App (_, _))  = raise (DifferentSpines) | genSpine (d, App (_, _), Nil)  = raise (DifferentSpines) | genSpine (d, SClo (_, _), _)  = raise (DifferentSpines) | genSpine (d, _, SClo (_, _))  = raise (DifferentSpines) let E = genExp (0, T, U) in Variant E let rec compatible ((D_t, T as Root (H1, S1)), (D_u, U as Root (H2, S2)), Ds, rho_t, rho_u)  = if compHeads ((D_t, H1), (D_u, H2)) then compatible\' ((D_t, T), (D_u, U), Ds, rho_t, rho_u) else NotCompatible | compatible ((D_t, T), (D_u, U), Ds, rho_t, rho_u)  = compatible\' ((D_t, T), (D_u, U), Ds, rho_t, rho_u) (* ---------------------------------------------------------------*) (* compatibleSub(nsub_t, nsub_u) = (sigma, rho_t, rho_u) opt\n\n   if DOM(nsub_t) <= DOM(nsub_u)\n      CODOM(nsub_t) : index terms\n      CODOM(nsub_u) : linear terms\n        G_u, Glocal_u |- nsub_u\n    N ; G_t, Glocal_t |- nsub_t\n   then\n     nsub_t = sigma o rho_t\n     nsub_e = sigma o rho_u\n\n    Glocal_e ~ Glocal_t  (have "approximately" the same type)\n\n   *) let rec compatibleSub ((D_t, nsub_t), (D_u, nsub_u))  = (* by invariant rho_t = empty, since nsub_t <= nsub_u *) let (sigma, rho_t, rho_u) = (nid (), nid (), nid ()) let Dsigma = emptyCtx () let D_r1 = copy D_t let D_r2 = copy D_u let choose = ref (fun match : bool -> ()) let _ = forall nsub_u (fun (nv, U) -> (match (lookup nsub_t nv) with SOME (T) -> (* note by invariant Glocal_e ~ Glocal_t *) (match compatible ((D_r1, T), (D_r2, U), Dsigma, rho_t, rho_u) with NotCompatible -> (insert rho_t (nv, T); insert rho_u (nv, U)) | Variant (T\') -> let restc = (! choose) in (insert sigma (nv, T\'); choose := (fun match -> (restc match; if match then () else ()))))(* here Glocal_t will be only approximately correct! *)  | NONE -> insert rho_u (nv, U))) in if isId (rho_t) then (* perfect match under asub and rho_t = nsub_t\n           sigma = rho_t and sigma o asub = rho_u *) ((! choose) true; VariantSub (D_r2, rho_u)) else ((* split -- asub is unchanged *) (! choose) false; if isId (sigma) then NoCompatibleSub else SplitSub ((Dsigma, sigma), (D_r1, rho_t), (D_r2, rho_u)))(* Dsigma |~ sigma, D_r1 |~ rho_t, D_r1 |~ rho_u *) (* ---------------------------------------------------------------------- *) let rec mkLeaf (Ds, GR, n)  = Leaf (Ds, GR) let rec mkNode (Node (_, Children), Dsigma, Drho1, GR, Drho2)  = Node (Dsigma, [ref (Leaf (Drho2, ref [GR])); ref (Node (Drho1, Children))]) | mkNode (Leaf (c, GRlist), Dsigma, Drho1, GR2, Drho2)  = Node (Dsigma, [ref (Leaf (Drho2, ref [GR2])); ref (Leaf (Drho1, GRlist))]) (* ---------------------------------------------------------------------- *) let rec compatibleCtx ((G, eqn), [])  = NONE | compatibleCtx ((G, eqn), ((l\', G\', eqn\', answRef\', _, status\') :: GRlist))  = (* we may not need to check that the DAVars are the same *)  (if (equalCtx\' (G, G\') && equalEqn (eqn, eqn\')) then SOME (l\', answRef\', status\') else compatibleCtx ((G, eqn), GRlist)) let rec compChild (N as Leaf ((D_t, nsub_t), GList), (D_e, nsub_e))  = compatibleSub ((D_t, nsub_t), (D_e, nsub_e)) | compChild (N as Node ((D_t, nsub_t), Children\'), (D_e, nsub_e))  = compatibleSub ((D_t, nsub_t), (D_e, nsub_e)) let rec findAllCandidates (G_r, children, Ds)  = let rec findAllCands (G_r, nil, (D_u, sub_u), VList, SList)  = (VList, SList) | findAllCands (G_r, (x :: L), (D_u, sub_u), VList, SList)  = match compChild (! x, (D_u, sub_u)) with NoCompatibleSub -> findAllCands (G_r, L, (D_u, sub_u), VList, SList) | SplitSub (Dsigma, Drho1, Drho2) -> findAllCands (G_r, L, (D_u, sub_u), VList, ((x, (Dsigma, Drho1, Drho2)) :: SList)) | VariantSub (Drho2 as (D_r2, rho2)) -> findAllCands (G_r, L, (D_u, sub_u), ((x, Drho2, id) :: VList), SList) in findAllCands (G_r, children, Ds, nil, nil) (* ---------------------------------------------------------------------- *) let rec divergingCtx (stage, G, GRlistRef)  = let l = ctxLength (G) in exists (fun ((evar, l), G\', _, _, stage\', _) -> (stage = stage\' && (l > (ctxLength (G\'))))) (! GRlistRef) let rec eqHeads (Const k, Const k\')  = (k = k\') | eqHeads (BVar k, BVar k\')  = (k = k\') | eqHeads (Def k, Def k\')  = (k = k\') | eqHeads (_, _)  = false (* eqTerm (t2, (t, rho1)) = bool\n    returns true iff t2 = t[rho1]\n  t2 is a linear term which may not contain any nvars!\n  t may contain nvars\n *) let rec eqTerm (Root (H2, S2), (t as Root (H, S), rho1))  = if eqHeads (H2, H) then eqSpine (S2, (S, rho1)) else false | eqTerm (T2, (NVar n, rho1))  = (match (lookup rho1 n) with NONE -> false | SOME (T1) -> eqTerm (T2, (T1, nid ()))) | eqTerm (Lam (D2, T2), (Lam (D, T), rho1))  = eqTerm (T2, (T, rho1)) | eqTerm (_, (_, _))  = falseeqSpine (Nil, (Nil, rho1))  = true | eqSpine (App (T2, S2), (App (T, S), rho1))  = eqTerm (T2, (T, rho1)) && eqSpine (S2, (S, rho1)) | eqSpine (_, _)  = false let rec divergingSub ((Ds, sigma), (Dr1, rho1), (Dr2, rho2))  = exists rho2 (fun (n2, t2) -> exists sigma (fun (_, t) -> eqTerm (t2, (t, rho1)))) (* ---------------------------------------------------------------------- *) (* Insert via variant checking *) (* insert\' (N, (D, nsub), GR) = (f, callCheckResult)\n\n     invariant:\n\n       N is a substitution tree\n       nsub is a normal substitution\n       D contains all the existential variables in nsub\n       GR = (G : bound variable context,\n             eqn: residual equations\n             answRef : ptr to answer list\n\n     if there exists a path p in N s.t. p ~ nsub\n      then\n       f is the identity, and callCheckResult = RepeatedEntry(_,_,answRef)\n     otherwise (f is a function which destructively updates N\n                and once executed, will add a path p ~ nsub to N,\n                 callCheckResult = NewEntry (answRef)\n\n  *) let rec insert (Nref, (D_u, nsub_u), GR)  = let rec insert\' (N as Leaf ((D, _), GRlistRef), (D_u, nsub_u), GR as ((evarl, l), G_r, eqn, answRef, stage, status))  = (* need to compare D and D_u *)  (match compatibleCtx ((G_r, eqn), (! GRlistRef)) with NONE -> ((* compatible path -- but different ctx! *) if ((! divHeuristic) && divergingCtx (stage, G_r, GRlistRef)) then ((* ctx are diverging --- force suspension *) (fun () -> (GRlistRef := (GR :: (! GRlistRef)); answList := (answRef :: (! answList))), DivergingEntry (id, answRef))) else (* compatible path (variant) -- ctx are different *) (fun () -> (GRlistRef := (GR :: (! GRlistRef)); answList := (answRef :: (! answList))), NewEntry (answRef))) | SOME ((evarl\', Glength), answRef\', status\') -> ((* compatible path -- SAME ctx *) ((fun () -> ()), RepeatedEntry ((id, id), answRef\', status\')))) | insert\' (N as Node ((D, sub), children), (D_u, nsub_u), GR as (l, G_r, eqn, answRef, stage, status))  = let (VariantCand, SplitCand) = findAllCandidates (G_r, children, (D_u, nsub_u)) let rec checkCandidates (nil, nil)  = ((* no child is compatible with nsub_u *) (fun () -> (Nref := Node ((D, sub), (ref (Leaf ((D_u, nsub_u), ref [GR]))) :: children); answList := (answRef :: (! answList))), NewEntry (answRef))) | checkCandidates (nil, ((ChildRef, (Dsigma, Drho1, Drho2)) :: _))  = (* split an existing node *)  if ((! divHeuristic) && divergingSub (Dsigma, Drho1, Drho2)) then ((* substree divering -- splitting node *) (fun () -> (ChildRef := mkNode ((! ChildRef), Dsigma, Drho1, GR, Drho2); answList := (answRef :: (! answList))), DivergingEntry (id, answRef))) else ((* split existing node *) (fun () -> (ChildRef := mkNode ((! ChildRef), Dsigma, Drho1, GR, Drho2); answList := (answRef :: (! answList))), NewEntry (answRef))) | checkCandidates (((ChildRef, Drho2, asub) :: nil), _)  = (* unique "perfect" candidate (left) *)  insert (ChildRef, Drho2, GR) | checkCandidates (((ChildRef, Drho2, asub) :: L), SCands)  = (* there are several "perfect" candidates *)  (match (insert (ChildRef, Drho2, GR)) with (_, NewEntry (answRef)) -> checkCandidates (L, SCands) | (f, RepeatedEntry (asub, answRef, status)) -> ((f, RepeatedEntry (asub, answRef, status))) | (f, DivergingEntry (asub, answRef)) -> ((f, DivergingEntry (asub, answRef)))) in checkCandidates (VariantCand, SplitCand) in insert\' (! Nref, (D_u, nsub_u), GR) (* ---------------------------------------------------------------------- *) (* answer check and insert\n\n     Invariant:\n        D |- Pi G.U\n          |- (Pi G.U)[s]\n       .  |- s : D\n       {{K}} are all the free variables in s\n        D_k is the linear context of all free variables in {{K}}\n        D_k |- s_k : D  and eqn\n        D_k |- (Pi G.U)[s_k] and eqn\n\n      answerCheck (G, s, answRef, 0) = repeated\n         if (D_k, s_k, eqn)  already occurs in answRef\n      answerCheck (G,s, answRef, O) = new\n         if (D_k, s_k, eqn) did not occur in answRef\n         Sideeffect: update answer list for U\n     *) let rec answCheckVariant (s\', answRef, O)  = let rec member ((D, sk), [])  = false | member ((D, sk), (((D1, s1), _) :: S))  = if equalSub (sk, s1) && equalCtx\' (D, D1) then true else member ((D, sk), S) let (DEVars, sk) = abstractAnswSub s\' in if member ((DEVars, sk), solutions answRef) then repeated else (addSolution (((DEVars, sk), O), answRef); new) (* ---------------------------------------------------------------------- *) let rec reset ()  = (nctr := 1; modify (fun (n, Tree) -> (n := 0; Tree := ! (makeTree ()); answList := []; added := false; (n, Tree))) indexArray) let rec makeCtx (n, Null, DEVars : ctx)  = n | makeCtx (n, Decl (G, D), DEVars : ctx)  = (insertList ((n, D), DEVars); makeCtx (n + 1, G, DEVars)) (* callCheck (a, DA, DE, G, U eqn) = callCheckResult\n\n       invariant:\n       DA, DE, G |- U\n       a is the type family of U\n\n       if U is not already in the index, then it is inserted.\n       otherwise we return\n             a pointer answRef to the answer list.\n             (for variant checking, asub = I.id, and varDefs = NONE)\n     *) let rec callCheck (a, DAVars, DEVars, G, U, eqn, status)  = let (n, Tree) = sub (indexArray, a) let nsub_goal = new () let DAEVars = compose (DEVars, DAVars) let D = emptyCtx () let n = ctxLength (G) let _ = makeCtx (n + 1, DAEVars, D : ctx) let l = ctxLength (DAEVars) let _ = insert nsub_goal (1, U) let result = insert (Tree, (D, nsub_goal), ((l, n + 1), G, eqn, emptyAnswer (), ! stageCtr, status)) let esub = ctxToAVarSub (G, DAEVars, Shift (0)) let _ = if solveEqn\' ((eqn, shift (G, esub)), G) then () else print " failed to solve eqn_query\\n" in match result with (sf, NewEntry (answRef)) -> (sf (); added := true; if ! chatter >= 5 then print "\\t -- Add goal \\n" else (); NewEntry (answRef)) | (_, RepeatedEntry (s as (_, asub), answRef, status)) -> (if ! chatter >= 5 then print "\\t -- Suspend goal\\n" else (); RepeatedEntry ((esub, asub), answRef, status)) | (sf, DivergingEntry (answRef)) -> (sf (); added := true; if ! chatter >= 5 then print "\\t -- Add diverging goal\\n" else (); DivergingEntry (answRef)) (* insertIntoSTre (a, DA, DE, G, U eqn) = Succeeds\n\n       invariant:\n       DA, DE, G |- U\n       a is the type family of U\n\n       U is not already in the index, then it is inserted.\n       otherwise we return\n             a pointer answRef to the answer list.\n             (for variant checking, asub = I.id, and varDefs = NONE)\n     *) let rec insertIntoTree (a, DAVars, DEVars, G, U, eqn, answRef, status)  = let (n, Tree) = sub (indexArray, a) let nsub_goal = new () let DAEVars = compose (DEVars, DAVars) let D = emptyCtx () let n = ctxLength (G) let _ = makeCtx (n + 1, DAEVars, D : ctx) let l = ctxLength (DAEVars) let _ = insert nsub_goal (1, U) let result = insert (Tree, (D, nsub_goal), ((l, n + 1), G, eqn, answRef, ! stageCtr, status)) in match result with (sf, NewEntry (answRef)) -> (added := true; if ! chatter >= 5 then print "\\t -- Add goal \\n" else (); NewEntry (answRef)) | (_, RepeatedEntry (asub, answRef, status)) -> (if ! chatter >= 5 then print "\\t -- Suspend goal\\n" else (); RepeatedEntry (asub, answRef, status)) | (sf, DivergingEntry (answRef)) -> (sf (); added := true; if ! chatter >= 5 then print "\\t -- Add diverging goal\\n" else (); DivergingEntry (answRef)) let rec answCheck (s\', answRef, O)  = answCheckVariant (s\', answRef, O) let rec updateTable ()  = let rec update [] Flag  = Flag | update (answRef :: AList) Flag  = (let l = length (solutions (answRef)) in if (l = lookup (answRef)) then (* no new solutions were added in the previous stage *) update AList Flag else (* new solutions were added *) (updateAnswLookup (l, answRef); update AList true)) let Flag = update (! answList) false let r = (Flag || (! added)) in added := false; r let reset = reset let callCheck = (fun (DAVars, DEVars, G, U, eqn, status) -> callCheck (cidFromHead (targetHead U), DAVars, DEVars, G, U, eqn, status)) let insertIntoTree = (fun (DAVars, DEVars, G, U, eqn, answRef, status) -> insertIntoTree (cidFromHead (targetHead U), DAVars, DEVars, G, U, eqn, answRef, status)) let answerCheck = answCheck let updateTable = updateTable let tableSize = (fun () -> (length (! answList))) (* memberCtx ((G,V), G\', n) = bool\n\n       if G |- V and |- G\' ctx\n          exists a V\' in G s.t. V = V\'[^n]\n       then return true\n         otherwise false\n     *) let rec memberCtx ((G, V), G\')  = let rec memberCtx\' ((G, V), Null, n)  = NONE | memberCtx\' ((G, V), Decl (G\', D\' as Dec (_, V\')), n)  = if conv ((V, id), (V\', Shift n)) then SOME (D\') else memberCtx\' ((G, V), G\', n + 1) in memberCtx\' ((G, V), G\', 1)  (* local *)  end\n(* functor MemoTable *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {}), (0, {})])
('Error parsing code:', '(* Abstract Machine guided by proof skeleton *) (* Author: Brigitte Pientks *) (* Modified: Jeff Polakow *) (* Modified: Frank Pfenning *) (* Proof term reconstruction by proof skeleton *) module type PTRECON = sig (*! structure IntSyn : INTSYN !*) (*! structure CompSyn : COMPSYN !*) exception Error of stringval solve : pskeleton * (Goal * Sub) * DProg * (pskeleton * Exp -> unit) -> unit end\n(* signature PTRECON *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Parsing Fixity Declarations *) (* Author: Frank Pfenning *) module type PARSE_FIXITY = sig (*! structure Parsing : PARSING !*) module Names : NAMESval parseFixity' : (Qid * region) * fixity parserval parseNamePref' : (Qid * region) * (string list * string list) parser end\n(* signature PARSE_FIXITY *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Elaboration for module expressions *) (* Author: Kevin Watkins *) module ReconModule (module Global : GLOBAL(*! structure IntSyn : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn !*) (*! structure Paths\' : PATHS !*) module ReconTerm\' : RECON_TERM(*! sharing ReconTerm\'.IntSyn = IntSyn !*) (*! sharing ReconTerm\'.Paths = Paths\' !*) module ModSyn\' : MODSYN(*! sharing ModSyn\'.IntSyn = IntSyn !*) ModSyn\'NamesNamesmodule IntTree : TABLE where keyint) : RECON_MODULE = struct module ExtSyn = ReconTerm\' (*! structure Paths = Paths\' !*)  module ModSyn = ModSyn\' exception Error of string let rec error (r, msg)  = raise (Error (wrap (r, msg))) type strexp = unit -> mid * region let rec strexp (ids, id, r) ()  = let qid = Qid (ids, id) in match structLookup qid with NONE -> error (r, "Undeclared structure " ^ qidToString (valOf (structUndef qid))) | SOME mid -> (mid, r) let rec strexpToStrexp (f : strexp)  = 1 (f ()) type Inst = External of term | Internal of cid type eqn = cid * Inst * region type inst = namespace * eqn list -> eqn list let rec coninst ((ids, id, r1), tm, r2) (ns, eqns)  = let qid = Qid (ids, id) in match constLookupIn (ns, qid) with NONE -> error (r1, "Undeclared identifier " ^ qidToString (valOf (constUndefIn (ns, qid)))) | SOME cid -> (cid, External tm, (* this is wrong because constants in the sig being instantiated might incorrectly appear in tm -kw *) , r2) :: eqns let rec addStructEqn (rEqns, r1, r2, ids, mid1, mid2)  = let ns1 = getComponents mid1 let ns2 = getComponents mid2 let rec push eqn  = rEqns := eqn :: (! rEqns) let rec doConst (name, cid1)  = match constLookupIn (ns2, Qid (nil, name)) with NONE -> error (r1, "Instantiating structure lacks component " ^ qidToString (Qid (rev ids, name))) | SOME cid2 -> push (cid1, Internal cid2, r2) let rec doStruct (name, mid1)  = match structLookupIn (ns2, Qid (nil, name)) with NONE -> error (r1, "Instantiating structure lacks component " ^ qidToString (Qid (rev ids, name))) | SOME mid2 -> addStructEqn (rEqns, r1, r2, name :: ids, mid1, mid2) in appConsts doConst ns1; appStructs doStruct ns1 let rec strinst ((ids, id, r1), strexp, r3) (ns, eqns)  = let qid = Qid (ids, id) let mid1 = (match structLookupIn (ns, qid) with NONE -> error (r1, "Undeclared structure " ^ qidToString (valOf (structUndefIn (ns, qid)))) | SOME mid1 -> mid1) let (mid2, r2) = strexp () let rEqns = ref eqns in addStructEqn (rEqns, r2, r3, nil, mid1, mid2); ! rEqns type whereclause = namespace -> eqn list type sigexp = module option -> module * whereclause list let rec thesig (SOME module)  = (module, nil) let rec sigid (id, r) NONE  = (match lookupSigDef id with NONE -> error (r, "Undefined signature " ^ id) | SOME module -> (module, nil)) let rec wheresig (sigexp, instList) moduleOpt  = let (module, wherecls) = sigexp moduleOpt let rec wherecl ns  = foldr (fun (inst, eqns) -> inst (ns, eqns)) nil instList in (module, wherecls @ [wherecl]) let rec sigexpToSigexp (sigexp, moduleOpt)  = sigexp moduleOpt type sigdef = module option -> string option * module * whereclause list let rec sigdef (idOpt, sigexp) moduleOpt  = let (module, wherecls) = sigexp moduleOpt in (idOpt, module, wherecls) let rec sigdefToSigdef (sigdef, moduleOpt)  = sigdef moduleOpt type StructDec = StructDec of string option * module * whereclause list | StructDef of string option * mid type structdec = module option -> StructDec let rec structdec (idOpt, sigexp) moduleOpt  = let (module, inst) = sigexp moduleOpt in StructDec (idOpt, module, inst) let rec structdef (idOpt, strexp) NONE  = let mid = strexpToStrexp strexp in StructDef (idOpt, mid) let rec structdecToStructDec (structdec, moduleOpt)  = structdec moduleOpt type eqnTable = Inst * region list ref Table let rec applyEqns wherecl namespace  = let eqns = wherecl namespace let table : eqnTable = new (0) let rec add (cid, Inst, r)  = (match lookup table cid with NONE -> insert table (cid, ref [(Inst, r)]) | SOME rl -> rl := (Inst, r) :: (! rl)) let _ = app add eqns let rec doInst ((Internal cid, r), condec)  = (try  with ) | doInst ((External tm, r), condec)  = strictify (externalInst (condec, tm, r)) let rec transformConDec (cid, condec)  = (match lookup table cid with NONE -> condec | SOME (ref l) -> foldr doInst condec l) in transformConDec let rec moduleWhere (module, wherecl)  = (* val _ = IntSyn.resetFrom (mark, markStruct) *) let (mark, markStruct) = sgnSize () let module\' = instantiateModule (module, applyEqns wherecl) let _ = resetFrom (mark, markStruct) in module\' end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Parsing Signature Entries *) (* Author: Frank Pfenning *) module ParseConDec ((*! structure Parsing\' : PARSING !*) module ExtConDec\' : EXTCONDECmodule ParseTerm : PARSE_TERM(*! sharing ParseTerm.Lexer = Parsing\'.Lexer !*) ParseTermExtSynExtConDec\'ExtSyn) : PARSE_CONDEC = struct (*! structure Parsing = Parsing\' !*)  module ExtConDec = ExtConDec\' module L = Lexermodule LS = LexerStream(* parseConDec3  "U" *) let rec parseConDec3 (optName, optTm, s)  = let (tm\', f\') = parseTerm\' (expose s) in (condef (optName, tm\', optTm), f\') (* parseConDec2  "= U" | "" *) let rec parseConDec2 (optName, (tm, Cons ((EQUAL, r), s\')))  = parseConDec3 (optName, SOME (tm), s\') | parseConDec2 (SOME (name), (tm, f))  = (condec (name, tm), f) | parseConDec2 (NONE, (tm, Cons ((t, r), s\')))  = error (r, "Illegal anonymous declared constant") (* parseConDec1  ": V = U" | "= U" *) let rec parseConDec1 (optName, Cons ((COLON, r), s\'))  = parseConDec2 (optName, parseTerm\' (expose s\')) | parseConDec1 (optName, Cons ((EQUAL, r), s\'))  = parseConDec3 (optName, NONE, s\') | parseConDec1 (optName, Cons ((t, r), s\'))  = error (r, "Expected `:\' or `=\', found " ^ toString t) (* BlockDec parser *) let rec parseBlock (Cons ((ID (_, "block"), r), s\'))  = parseCtx\' (expose s\') | parseBlock (Cons ((t, r), s\'))  = error (r, "Expected `block\', found " ^ toString t) let rec parseSome (name, Cons ((ID (_, "some"), r), s\'))  = let (g1, f\') = parseCtx\' (expose s\') let (g2, f\'\') = parseBlock f\' in (blockdec (name, g1, g2), f\'\') | parseSome (name, f as Cons ((ID (_, "block"), r), s\'))  = let (g2, f\') = parseBlock f in (blockdec (name, nil, g2), f\') | parseSome (name, Cons ((t, r), s\'))  = error (r, "Expected `some\' or `block\', found " ^ toString t) let rec parseBlockDec1 (name, Cons ((COLON, r), s\'))  = parseSome (name, expose s\') | parseBlockDec1 (name, Cons ((EQUAL, r), s\'))  = let (g, f) = parseQualIds\' (expose s\') in (blockdef (name, g), f) | parseBlockDec1 (name, Cons ((t, r), s\'))  = (* added as a feature request by Carl  -- Wed Mar 16 16:11:44 2011  cs *)  error (r, "`:\' expected, found token " ^ toString t) let rec parseBlockDec\' (Cons ((ID (idCase, name), r), s\'))  = parseBlockDec1 (name, expose s\') | parseBlockDec\' (Cons ((t, r), s\'))  = error (r, "Label identifier expected, found token " ^ toString t) (* parseConDec\' : lexResult front -> ExtConDec.ConDec * lexResult front\n       Invariant: first token in exposed input stream is an identifier or underscore\n    *) let rec parseConDec\' (Cons ((ID (idCase, name), r), s\'))  = parseConDec1 (SOME (name), expose s\') | parseConDec\' (Cons ((UNDERSCORE, r), s\'))  = parseConDec1 (NONE, expose s\') | parseConDec\' (Cons ((BLOCK, r), s\'))  = parseBlockDec\' (expose s\') | parseConDec\' (Cons ((t, r), s\'))  = error (r, "Constant or block declaration expected, found token " ^ toString t) (* parseConDec --- currently not exported *) let rec parseConDec (s)  = parseConDec\' (expose s) let rec parseAbbrev\' (Cons ((ABBREV, r), s))  = parseConDec (s) let rec parseClause\' (Cons ((CLAUSE, r), s))  = parseConDec (s) (* -fp *) let parseConDec\' = parseConDec\' let parseAbbrev\' = parseAbbrev\' let parseClause\' = parseClause\'  (* local ... in *)  end\n(* functor ParseConDec *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Front End Interface *) (* Author: Frank Pfenning *) (* Modified: Carsten Schuermann, Jeff Polakow *) (* Modified: Brigitte Pientka, Roberto Virga *) module Twelf (module Global : GLOBALmodule Timers : TIMERSmodule Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) (*! structure Paths : PATHS !*) module Origins : ORIGINS(*! sharing Origins.Paths = Paths !*) module Lexer : LEXER(*! sharing Lexer.Paths = Paths !*) (*! structure Parsing : PARSING !*) (*! sharing Lexer = Lexer !*) module Parser : PARSERParserNamesNames(*! sharing Parser.ExtSyn.Paths = Paths !*) module TypeCheck : TYPECHECKmodule Strict : STRICT(*! sharing Strict.IntSyn = IntSyn\' !*) (*! sharing Strict.Paths = Paths !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module ReconTerm : RECON_TERM(*! sharing ReconTerm.IntSyn = IntSyn\' !*) (*! sharing ReconTerm.Paths = Paths !*) termterm(* sharing type ReconTerm.Paths.occConDec = Origins.Paths.occConDec *) module ReconConDec : RECON_CONDEC(*! sharing ReconConDec.IntSyn = IntSyn\' !*) (*! sharing ReconConDec.Paths = Paths !*) condeccondecmodule ReconQuery : RECON_QUERYmodule ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = IntSyn\' !*) module ModeCheck : MODECHECK(*! sharing ModeCheck.IntSyn = IntSyn\' !*) (*! sharing ModeCheck.ModeSyn = ModeSyn !*) (*! sharing ModeCheck.Paths = Paths !*) module ReconMode : RECON_MODE(*! sharing ReconMode.ModeSyn = ModeSyn !*) (*! sharing ReconMode.Paths = Paths !*) modedecmodedecmodule ModePrint : MODEPRINT(*! sharing ModePrint.ModeSyn = ModeSyn !*) module ModeDec : MODEDEC(*! sharing ModeDec.ModeSyn = ModeSyn !*) (*! sharing ModeDec.Paths = Paths !*) module StyleCheck : STYLECHECKmodule Unique : UNIQUE(*! sharing Unique.ModeSyn = ModeSyn !*) module UniqueTable : MODETABLEmodule Cover : COVER(*! sharing Cover.IntSyn = IntSyn\' !*) (*! sharing Cover.ModeSyn = ModeSyn !*) module Converter : CONVERTER(*! sharing Converter.IntSyn = IntSyn\' !*) (*! sharing Converter.Tomega = Tomega !*) module TomegaPrint : TOMEGAPRINT(*! sharing TomegaPrint.IntSyn = IntSyn\' !*) (*! sharing TomegaPrint.Tomega = Tomega !*) module TomegaCoverage : TOMEGACOVERAGE(*! sharing TomegaCoverage.IntSyn = IntSyn\' !*) (*! sharing TomegaCoverage.Tomega = Tomega !*) module TomegaTypeCheck : TOMEGATYPECHECK(*! sharing TomegaTypeCheck.IntSyn = IntSyn\' !*) (*! sharing TomegaTypeCheck.Tomega = Tomega !*) module Total : TOTAL(*! sharing Total.IntSyn = IntSyn\' !*) module Reduces : REDUCES(*! sharing Reduces.IntSyn = IntSyn\' !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module IndexSkolem : INDEX(*! sharing IndexSkolem.IntSyn = IntSyn\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) (*! structure CompSyn\' : COMPSYN !*) (*! sharing CompSyn\'.IntSyn = IntSyn\' !*) module Compile : COMPILE(*! sharing Compile.IntSyn = IntSyn\' !*) (*! sharing Compile.CompSyn = CompSyn\' !*) module AbsMachine : ABSMACHINE(*! sharing AbsMachine.IntSyn = IntSyn\' !*) (*! sharing AbsMachine.CompSyn = CompSyn\' !*) (*! structure TableParam : TABLEPARAM !*) module Tabled : TABLED(*! sharing Tabled.IntSyn = IntSyn\' !*) (*! sharing Tabled.CompSyn = CompSyn\' !*) module Solve : SOLVE(*! sharing Solve.IntSyn = IntSyn\' !*) queryquerydefinedefinesolvesolvemodule Fquery : FQUERY(*! sharing Fquery.IntSyn = IntSyn\' !*) queryquerydefinedefinesolvesolve(*! sharing Solve.Paths = Paths !*) module ThmSyn : THMSYN(*! sharing ThmSyn.Paths = Paths !*) ThmSynNamesNamesmodule Thm : THMThmThmSynThmSyn(*! sharing Thm.Paths = Paths !*) module ReconThm : RECON_THMReconThmThmSynThmSyn(*! sharing ReconThm.Paths = Paths !*) (*! sharing ReconThm.ThmSyn.ModeSyn = ModeSyn !*) tdecltdeclrdeclrdecl(* -bp *) tableddecltableddecl(* -bp *) keepTabledeclkeepTabledecl(* -bp *) wdeclwdecltheoremtheoremtheoremdectheoremdecproveproveestablishestablishassertassertmodule ThmPrint : THMPRINTThmPrintThmSynThmSynmodule TabledSyn : TABLEDSYN(*! sharing TabledSyn.IntSyn = IntSyn\' !*) module WorldSyn : WORLDSYN(*! sharing WorldSyn.IntSyn = IntSyn\' !*) module Worldify : WORLDIFY(*   structure WorldPrint : WORLDPRINT *) (*! sharing WorldPrint.Tomega = Tomega !*) module ModSyn : MODSYN(*! sharing ModSyn.IntSyn = IntSyn\' !*) ModSynNamesNames(*! sharing ModSyn.Paths = Paths !*) module ReconModule : RECON_MODULEReconModuleModSynModSynsigdefsigdefstructdecstructdecsigexpsigexpstrexpstrexpmodule MetaGlobal : METAGLOBAL(*! structure FunSyn : FUNSYN !*) (*! sharing FunSyn.IntSyn = IntSyn\' !*) module Skolem : SKOLEM(*! sharing Skolem.IntSyn = IntSyn\' !*) module Prover : PROVER(*! sharing Prover.IntSyn = IntSyn\' !*) module ClausePrint : CLAUSEPRINT(*! sharing ClausePrint.IntSyn = IntSyn\' !*) module Trace : TRACEmodule PrintTeX : PRINT(*! sharing PrintTeX.IntSyn = IntSyn\' !*) module ClausePrintTeX : CLAUSEPRINT(*! sharing ClausePrintTeX.IntSyn = IntSyn\' !*) module CSManager : CS_MANAGER(*! sharing CSManager.IntSyn = IntSyn\' !*) CSManagerFixityNamesFixity(*! sharing CSManager.ModeSyn = ModeSyn !*) module CSInstaller : CS_INSTALLERmodule Compat : COMPATmodule UnknownExn : UNKNOWN_EXNmodule Msg : MSG)TWELF = struct (*! structure IntSyn = IntSyn\' !*) module S = ParserStreamlet rec msg s  = message s let rec chmsg n s  = chMessage n s msg let rec fileOpenMsg (fileName)  = (match ! chatter with 0 -> () | 1 -> msg ("[Loading file " ^ fileName ^ " ...") | _ -> msg ("[Opening file " ^ fileName ^ "]\\n")) let rec fileCloseMsg (fileName)  = (match ! chatter with 0 -> () | 1 -> msg ("]\\n") | _ -> msg ("[Closing file " ^ fileName ^ "]\\n")) (* result of a computation *) type Result = Value of \'a | Exception of exn (* val withOpenIn : string -> (TextIO.instream -> \'a) -> \'a *) (* withOpenIn fileName (fn instream => body) = x\n       opens fileName for input to obtain instream and evaluates body.\n       The file is closed during normal and abnormal exit of body.\n    *) let rec withOpenIn (fileName) (scope)  = let instream = openIn fileName let _ = fileOpenMsg (fileName) let result = try  with  let _ = fileCloseMsg (fileName) let _ = closeIn instream in match result with Value (x) -> x | Exception (exn) -> raise (exn) (* evarInstToString Xs = msg\n       formats instantiated EVars as a substitution.\n       Abbreviate as empty string if chatter level is < 3.\n    *) let rec evarInstToString (Xs)  = if ! chatter >= 3 then evarInstToString (Xs) else "" (* expToString (G, U) = msg\n       formats expression as a string.\n       Abbreviate as empty string if chatter level is < 3.\n    *) let rec expToString GU  = if ! chatter >= 3 then expToString GU else "" let rec printProgTeX ()  = (msg "\\\\begin{bigcode}\\n"; printSgn (); msg "\\\\end{bigcode}\\n") let rec printSgnTeX ()  = (msg "\\\\begin{bigcode}\\n"; printSgn (); msg "\\\\end{bigcode}\\n") (* status ::= OK | ABORT  is the return status of various operations *) type Status = OK | ABORT let rec abort chlev (msg)  = (chmsg chlev (fun () -> msg); ABORT) let rec abortFileMsg chlev (fileName, msg)  = abort chlev (fileName ^ ":" ^ msg ^ "\\n") let rec abortIO (fileName, {cause = SysErr (m, _); function = f; name = n})  = (msg ("IO Error on file " ^ fileName ^ ":\\n" ^ m ^ "\\n"); ABORT) | abortIO (fileName, {function = f; _})  = (msg ("IO Error on file " ^ fileName ^ " from function " ^ f ^ "\\n"); ABORT) (* should move to paths, or into the prover module... but not here! -cs *) let rec joinregion (r, nil)  = r | joinregion (r, r\' :: rs)  = joinregion (join (r, r\'), rs) let rec joinregions (r :: rs)  = joinregion (r, rs) let rec constraintsMsg (cnstrL)  = "Typing ambiguous -- unresolved constraints\\n" ^ cnstrsToString cnstrL (* val handleExceptions : int -> string -> (\'a -> Status) -> \'a -> Status *) (* handleExceptions chlev filename f x = f x\n       where standard exceptions are handled and an appropriate error message is\n       issued if chatter level is greater or equal to chlev.\n       Unrecognized exceptions are re-raised.\n    *) let rec handleExceptions chlev fileName (f : \'a -> Status) (x : \'a)  = (try  with ) (* During elaboration of a signature expression, each constant\n       that that the user declares is added to this table.  At top level,\n       however, the reference holds NONE (in particular, shadowing is\n       allowed).\n    *) let context : namespace option ref = ref NONE let rec installConst fromCS (cid, fileNameocOpt)  = let _ = installOrigin (cid, fileNameocOpt) let _ = install fromCS (Const cid) let _ = install fromCS (Const cid) let _ = (time compiling install) fromCS cid let _ = (time subordinate install) cid let _ = (time subordinate installDef) cid in () (* installConDec fromCS (conDec, ocOpt)\n       installs the constant declaration conDec which originates at ocOpt\n       in various global tables, including the global signature.\n       Note: if fromCS = FromCS then the declaration comes from a Constraint\n       Solver and some limitations on the types are lifted.\n    *) let rec installConDec fromCS (conDec, fileNameocOpt as (fileName, ocOpt), r)  = let _ = (time modes checkD) (conDec, fileName, ocOpt) let cid = sgnAdd conDec let _ = try  with  let _ = installConstName cid let _ = try  with  let _ = installLinesInfo (fileName, getLinesInfo ()) let _ = if ! style >= 1 then checkConDec cid else () in cid let rec installBlockDec fromCS (conDec, fileNameocOpt as (fileName, ocOpt), r)  = (* val _ = Origins.installOrigin (cid, fileNameocOpt) *) let cid = sgnAdd conDec let _ = try  with  let _ = installConstName cid let _ = try  with  let _ = installLinesInfo (fileName, getLinesInfo ()) in cid let rec installBlockDef fromCS (conDec, fileNameocOpt as (fileName, ocOpt), r)  = (* val _ = Origins.installOrigin (cid, fileNameocOpt) *) let cid = sgnAdd conDec let _ = try  with  let _ = installConstName cid let _ = installLinesInfo (fileName, getLinesInfo ()) in cid let rec installStrDec (strdec, module, r, isDef)  = let rec installAction (data as (cid, _))  = (installConst Ordinary data; if ! chatter >= 4 then msg (conDecToString (sgnLookup cid) ^ "\\n") else ()) let _ = try  with  in () let rec includeSig (module, r, isDef)  = let rec installAction (data as (cid, _))  = (installConst Ordinary data; if ! chatter >= 4 then msg (conDecToString (sgnLookup cid) ^ "\\n") else ()) let _ = try  with  in () let rec cidToString a  = qidToString (constQid a) let rec invalidate uninstallFun cids msg  = let uninstalledCids = filter (fun a -> uninstallFun a) cids let _ = match uninstalledCids with nil -> () | _ -> chmsg 4 (fun () -> "Invalidated " ^ msg ^ " properties of families" ^ foldr (fun (a, s) -> " " ^ cidToString a ^ s) "\\n" uninstalledCids) in () (* install1 (decl) = ()\n       Installs one declaration\n       Effects: global state\n                may raise standard exceptions\n    *) let rec install1 (fileName, (ConDec condec, r))  = (* Constant declarations c : V, c : V = U plus variations *)  (try  with ) | install1 (fileName, (AbbrevDec condec, r))  = (* Abbreviations %abbrev c = U and %abbrev c : V = U *)  (try  with ) | install1 (fileName, (ClauseDec condec, r))  = (* Clauses %clause c = U or %clause c : V = U or %clause c : V *)  (* these are like definitions, but entered into the program table *)  (try  with ) | install1 (fileName, (Solve (defines, solve), r))  = (try  with ) | install1 (fileName, (Query (expected, try, query), r))  = (* Solve.query might raise Solve.AbortQuery (msg) *)  (try  with ) | install1 (fileName, (FQuery (query), r))  = (* Solve.query might raise Fquery.AbortQuery (msg) *)  (try  with ) | install1 (fileName, (Querytabled (numSol, try, query), r))  = (* Solve.query might raise Solve.AbortQuery (msg) *)  (try  with ) | install1 (fileName, (TrustMe (dec, r\'), r))  = let _ = if not (! unsafe) then raise (Error ("%trustme not safe: Toggle `unsafe\' flag")) else () let _ = chmsg 3 (fun () -> "[%trustme ...\\n") let _ = match handleExceptions 4 fileName (fun args -> (install1 args; OK)) (fileName, (dec, r)) with OK -> chmsg 3 (fun () -> "trustme subject succeeded\\n") | ABORT -> chmsg 3 (fun () -> "trustme subject failed; continuing\\n") let _ = chmsg 3 (fun () -> "%]\\n") in () | install1 (fileName, (SubordDec (qidpairs), r))  = let rec toCid qid  = match constLookup qid with NONE -> raise (Error ("Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in subord declaration")) | SOME cid -> cid let cidpairs = try  with  let _ = try  with  in if ! chatter >= 3 then msg ("%subord" ^ foldr (fun ((a1, a2), s) -> " (" ^ qidToString (constQid a1) ^ " " ^ qidToString (constQid a2) ^ ")" ^ s) ".\\n" cidpairs) else () | install1 (fileName, (FreezeDec (qids), r))  = let rec toCid qid  = match constLookup qid with NONE -> raise (Error ("Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in freeze declaration")) | SOME cid -> cid let cids = try  with  let frozen = try  with  in (* Subordinate.installFrozen cids *) if ! chatter >= 3 then msg ("%freeze" ^ foldr (fun (a, s) -> " " ^ qidToString (constQid a) ^ s) ".\\n" cids) else (); if ! chatter >= 4 then msg ("Frozen:" ^ foldr (fun (a, s) -> " " ^ qidToString (constQid a) ^ s) "\\n" frozen) else () | install1 (fileName, (ThawDec (qids), r))  = (* invalidate prior meta-theoretic properteis of signatures *) (* exempt only %mode [incremental], %covers [not stored] *) let _ = if not (! unsafe) then raise (Error "%thaw not safe: Toggle `unsafe\' flag") else () let rec toCid qid  = match constLookup qid with NONE -> raise (Error ("Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in thaw declaration")) | SOME cid -> cid let cids = try  with  let thawed = try  with  let _ = if ! chatter >= 3 then msg ("%thaw" ^ foldr (fun (a, s) -> " " ^ cidToString a ^ s) ".\\n" cids) else () let _ = if ! chatter >= 4 then msg ("Thawed" ^ foldr (fun (a, s) -> " " ^ cidToString a ^ s) "\\n" thawed) else () let _ = invalidate uninstall thawed "world" let _ = invalidate uninstallTerminates thawed "termination" let _ = invalidate uninstallReduces thawed "reduction" let _ = invalidate uninstallMode thawed "uniqueness" let _ = invalidate uninstall thawed "totality" in () | install1 (fileName, (DeterministicDec (qids), r))  = let rec toCid qid  = match constLookup qid with NONE -> raise (Error ("Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in deterministic declaration")) | SOME cid -> cid let rec insertCid cid  = detTableInsert (cid, true) let cids = try  with  in map insertCid cids; if ! chatter >= 3 then msg ((if ! chatter >= 4 then "%" else "") ^ "%deterministic" ^ foldr (fun (a, s) -> " " ^ qidToString (constQid a) ^ s) ".\\n" cids) else () | install1 (fileName, (Compile (qids), r))  = (* MOVED -- ABP 4/4/03 *) (* ******************************************* *) (* ******************************************* *) let rec toCid qid  = match constLookup qid with NONE -> raise (Error ("Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in compile assertion")) | SOME cid -> cid let cids = try  with  let rec checkFreeOut nil  = () | checkFreeOut (a :: La)  = let SOME ms = modeLookup a let _ = checkFreeOut (a, ms) in checkFreeOut La let _ = checkFreeOut cids let (lemma, projs, sels) = installPrg cids let P = lemmaDef lemma let F = convertFor cids let _ = checkPrg (Null, (P, F)) let rec f cid  = conDecName (sgnLookup cid) let _ = if ! chatter >= 2 then msg ("\\n" ^ funToString ((map f cids, projs), P) ^ "\\n") else () let _ = if ! chatter >= 3 then msg ((if ! chatter >= 4 then "%" else "") ^ "%compile" ^ foldr (fun (a, s) -> " " ^ qidToString (constQid a) ^ s) ".\\n" cids) else () in () | install1 (fileName, (FixDec ((qid, r), fixity), _))  = (match constLookup qid with NONE -> raise (Error ("Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in fixity declaration")) | SOME cid -> try  with ) | install1 (fileName, (NamePref ((qid, r), namePref), _))  = (match constLookup qid with NONE -> raise (Error ("Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in name preference")) | SOME cid -> try  with ) | install1 (fileName, (ModeDec mterms, r))  = let mdecs = map modeToMode mterms let _ = checkErrors (r) let _ = app (fun (mdec as (a, _), r) -> match modeLookup a with NONE -> () | SOME _ -> if frozen [a] then raise (Error (wrap (r, "Cannot redeclare mode for frozen constant " ^ qidToString (constQid a)))) else ()) mdecs let _ = app (fun (mdec as (a, _), r) -> try  with ) mdecs let _ = app (fun mdec -> checkPure mdec) mdecs let _ = app (fun (mdec, r) -> try  with ) mdecs let _ = if ! chatter >= 3 then msg ("%mode " ^ modesToString (map (fun (mdec, r) -> mdec) mdecs) ^ ".\\n") else () in () | install1 (fileName, (UniqueDec mterms, r))  = (* convert all UniqueTable.Error to Unique.Error *) (* Timing added to coverage --- fix !!! -fp Sun Aug 17 12:17:51 2003 *) (* %unique does not auto-freeze, since family must already be frozen *) let mdecs = map modeToMode mterms let _ = checkErrors (r) let _ = app (fun (mdec as (a, _), r) -> try  with ) mdecs let _ = app (fun (mdec, r) -> try  with ) mdecs let _ = if ! chatter >= 3 then msg ("%unique " ^ modesToString (map (fun (mdec, r) -> mdec) mdecs) ^ ".\\n") else () in () | install1 (fileName, (CoversDec mterms, r))  = (* MERGE Fri Aug 22 13:43:12 2003 -cs *) let mdecs = map modeToMode mterms let _ = checkErrors (r) let _ = app (fun mdec -> checkPure mdec) mdecs let _ = app (fun (mdec, r) -> try  with ) mdecs let _ = if ! chatter >= 3 then msg ("%covers " ^ modesToString (map (fun (mdec, r) -> mdec) mdecs) ^ ".\\n") else () in () | install1 (fileName, (TotalDec lterm, r))  = (* time activities separately in total.fun *)  (* Mon Dec  2 17:20:18 2002 -fp *) (* coverage checker appears to be safe now *) (*\n          val _ = if not (!Global.unsafe)\n                    then raise Total.Error (Paths.wrapLoc (Paths.Loc (fileName, r), "%total not safe: Toggle `unsafe\' flag"))\n                  else ()\n          *) (* ******************************************* *) (*  Temporarily disabled -- cs Thu Oct 30 12:46:44 2003\n          fun checkFreeOut nil = ()\n            | checkFreeOut (a :: La) =\n              let\n                val SOME ms = ModeTable.modeLookup a\n                val _ = ModeCheck.checkFreeOut (a, ms)\n              in\n                checkFreeOut La\n              end\n          val _ = checkFreeOut La\n          val (lemma, projs, sels) = Converter.installPrg La\n\n\n          (* ABP 2/28/03 -- factoring *)\n          val _ = if (!Global.chatter >= 4) then print ("[Factoring ...") else ()\n          val P = Redundant.convert (Tomega.lemmaDef lemma)\n          val _ = if (!Global.chatter >= 4) then print ("]\\n") else ()\n\n          val F = Converter.convertFor La\n\n          val _ = if !Global.chatter >= 2\n                    then print (TomegaPrint.funToString ((map (fn (cid) => IntSyn.conDecName (IntSyn.sgnLookup cid)) La,\n                                                          projs), P) ^ "\\n")\n                  else ()\n\n          val _ = TomegaTypeCheck.checkPrg (IntSyn.Null, (P, F))\n\n          val result1 = (TomegaCoverage.coverageCheckPrg (WorldSyn.lookup (hd La), IntSyn.Null, P); NONE)\n                        handle TomegaCoverage.Error msg => SOME msg\n\n\n(*      val result1 = NONE *)\n\n          fun covererror (SOME msg1, msg2) = raise Cover.Error (Paths.wrap (r, "Functional and relational coverage checker report coverage error:\\n[Functional] "\n                                                                            ^ msg1 ^ "\\n[Relational] " ^ msg2))\n            | covererror (NONE, msg2)      = raise Cover.Error (Paths.wrap (r, "Functional coverage succeeds, relationals fails:\\n[Relational] " ^ msg2))\n\n7 ******************************************* *) (* pre-install for recursive checking *) (*        val _ = case (result1)\n                    of NONE => ()\n                     | SOME msg => raise Cover.Error (Paths.wrap (r, "Relational coverage succeeds, funcational fails:\\n This indicates a bug in the functional checker.\\n[Functional] " ^ msg))\n*) (* %total does not auto-freeze, since the predicate must already be frozen *) let (T, rrs as (r, rs)) = tdeclTotDecl lterm let La = installTotal (T, rrs) let _ = map install La let _ = try  with  let _ = if ! chatter >= 3 then msg ("%total " ^ tDeclToString T ^ ".\\n") else () in () | install1 (fileName, (TerminatesDec lterm, _))  = (* allow re-declaration since safe? *) (* Thu Mar 10 13:45:42 2005 -fp *) (*\n          val _ = ListPair.app (fn ((a, _), r) =>\n                            if Subordinate.frozen [a]\n                              andalso ((Order.selLookup a; true) handle Order.Error _ => false)\n                            then raise Total.Error (fileName ^ ":"\n                                       ^ Paths.wrap (r, "Cannot redeclare termination order for frozen constant "\n                                                   ^ Names.qidToString (Names.constQid a)))\n                            else ())\n                  (callpats, rs)\n          *) let (T, rrs as (r, rs)) = tdeclTotDecl lterm let TDecl (_, Callpats (callpats)) = T let La = installTerminates (T, rrs) let _ = map (time terminate checkFam) La let _ = if ! autoFreeze then (freeze La; ()) else () let _ = if ! chatter >= 3 then msg ("%terminates " ^ tDeclToString T ^ ".\\n") else () in () | install1 (fileName, (ReducesDec lterm, _))  = (* allow re-declaration since safe? *) (* Thu Mar 10 14:06:13 2005 -fp *) (*\n          val _ = ListPair.app (fn ((a, _), r) =>\n                            if Subordinate.frozen [a]\n                              andalso ((Order.selLookupROrder a; true) handle Order.Error _ => false)\n                            then raise Total.Error (fileName ^ ":"\n                                       ^ Paths.wrap (r, "Cannot redeclare reduction order for frozen constant "\n                                                   ^ Names.qidToString (Names.constQid a)))\n                            else ())\n                  (callpats, rs)\n          *) (*  -bp6/12/99.   *) let (R, rrs as (r, rs)) = rdeclTorDecl lterm let RDecl (_, Callpats (callpats)) = R let La = installReduces (R, rrs) let _ = map (time terminate checkFamReduction) La let _ = if ! autoFreeze then (freeze La; ()) else () let _ = if ! chatter >= 3 then msg ("%reduces " ^ rDeclToString R ^ ".\\n") else () in () | install1 (fileName, (TabledDec tdecl, _))  = (*  -bp6/12/99.   *) let (T, r) = tableddeclTotabledDecl tdecl let La = installTabled T let _ = if ! chatter >= 3 then msg ("%tabled " ^ tabledDeclToString T ^ ".\\n") else () in () | install1 (fileName, (KeepTableDec tdecl, _))  = let (T, r) = keepTabledeclToktDecl tdecl let La = installKeepTable T let _ = if ! chatter >= 3 then msg ("%keeptabled " ^ keepTableDeclToString T ^ ".\\n") else () in () | install1 (fileName, (TheoremDec tdec, r))  = let Tdec = theoremDecToTheoremDec tdec let _ = checkErrors (r) let (GBs, E as ConDec (name, _, k, _, V, L)) = theoremDecToConDec (Tdec, r) let _ = labelReset () let _ = foldr (fun ((G1, G2), k) -> labelAdd (LabelDec (toString k, ctxToList G1, ctxToList G2))) 0 GBs let cid = installConDec Ordinary (E, (fileName, NONE), r) let MS = theoremDecToModeSpine (Tdec, r) let _ = installMode (cid, MS) let _ = if ! chatter >= 3 then msg ("%theorem " ^ conDecToString E ^ "\\n") else () in () | install1 (fileName, (ProveDec lterm, r))  = (* La is the list of type constants *) (* times itself *) let (PDecl (depth, T), rrs) = proveToProve lterm let La = installTerminates (T, rrs) let _ = if ! chatter >= 3 then msg ("%prove " ^ (toString depth) ^ " " ^ (tDeclToString T) ^ ".\\n") else () let _ = init (depth, La) let _ = if ! chatter >= 3 then map (fun a -> msg ("%mode " ^ (modeToString (a, valOf (modeLookup a))) ^ ".\\n")) La(* mode must be declared!*)  else [()] let _ = try  with  let _ = if ! chatter >= 3 then msg ("%QED\\n") else () in (install (fun E -> installConDec Ordinary (E, (fileName, NONE), r)); install La) | install1 (fileName, (EstablishDec lterm, r))  = (* La is the list of type constants *) (* times itself *) let (PDecl (depth, T), rrs) = establishToEstablish lterm let La = installTerminates (T, rrs) let _ = if ! chatter >= 3 then msg ("%prove " ^ (toString depth) ^ " " ^ (tDeclToString T) ^ ".\\n") else () let _ = init (depth, La) let _ = if ! chatter >= 3 then map (fun a -> msg ("%mode " ^ (modeToString (a, valOf (modeLookup a))) ^ ".\\n")) La(* mode must be declared!*)  else [()] let _ = try  with  in install (fun E -> installConDec Ordinary (E, (fileName, NONE), r)) | install1 (fileName, (AssertDec aterm, _))  = (* La is the list of type constants *) let _ = if not (! unsafe) then raise (Error "%assert not safe: Toggle `unsafe\' flag") else () let (cp as Callpats (L), rrs) = assertToAssert aterm let La = map (fun (c, P) -> c) L let _ = if ! chatter >= 3 then msg ("%assert " ^ (callpatsToString cp) ^ ".\\n") else () let _ = if ! chatter >= 3 then map (fun a -> msg ("%mode " ^ (modeToString (a, valOf (modeLookup a))) ^ ".\\n")) La(* mode must be declared!*)  else [()] in install La | install1 (fileName, (WorldDec wdecl, _))  = let (WDecl (qids, cp as Callpats cpa), rs) = wdeclTowDecl wdecl let _ = app (fun ((a, _), r) -> if frozen [a] then raise (Error (wrapLoc (Loc (fileName, r), "Cannot declare worlds for frozen family " ^ qidToString (constQid a)))) else ()) (cpa, rs) let rec flatten nil F  = F | flatten (cid :: L) F  = (match sgnLookup cid with BlockDec _ -> flatten L (cid :: F) | BlockDef (_, _, L\') -> flatten (L @ L\') F) let W = Worlds (flatten (map (fun qid -> match constLookup qid with NONE -> raise (Error ("Undeclared label " ^ qidToString (valOf (constUndef qid)) ^ ".")) | SOME cid -> cid) qids) nil) let _ = try  with  let _ = if ! autoFreeze then (freeze (map (fun (a, _) -> a) cpa); ()) else () let _ = if ! chatter >= 3 then msg ("%worlds " ^ worldsToString W ^ " " ^ callpatsToString cp ^ ".\\n") else () in (time worlds (map (fun (a, _) -> worldcheck W a)) cpa; ()(*if !Global.doubleCheck\n             then (map (fn (a,_) => Worldify.worldify a) cpa; ())\n           else  ()  --cs Sat Aug 27 22:04:29 2005 *) ) | install1 (fileName, declr as (SigDef _, _))  = install1WithSig (fileName, NONE, declr) | install1 (fileName, declr as (StructDec _, _))  = install1WithSig (fileName, NONE, declr) | install1 (fileName, declr as (Include _, _))  = install1WithSig (fileName, NONE, declr) | install1 (fileName, declr as (Open _, _))  = install1WithSig (fileName, NONE, declr) | install1 (fileName, (Use name, r))  = (match ! context with NONE -> useSolver (name) | _ -> raise (Error (wrap (r, "%use declaration needs to be at top level"))))install1WithSig (fileName, moduleOpt, (SigDef sigdef, r))  = (* Signature declaration *)  (* FIX: should probably time this -kw *) let (idOpt, module, wherecls) = sigdefToSigdef (sigdef, moduleOpt) let module\' = foldl (fun (inst, module) -> moduleWhere (module, inst)) module wherecls let name = try  with  let _ = if ! chatter >= 3 then msg ("%sig " ^ name ^ " = { ... }.\\n") else () in () | install1WithSig (fileName, moduleOpt, (StructDec structdec, r))  = (* Structure declaration *)  (match structdecToStructDec (structdec, moduleOpt) with StructDec (idOpt, module, wherecls) -> let module\' = foldl (fun (inst, module) -> moduleWhere (module, inst)) module wherecls let name = (match idOpt with SOME id -> (installStrDec (StrDec (id, NONE), module\', r, false); id) | NONE -> "_"(* anonymous *) ) let _ = if ! chatter = 3 then msg ("%struct " ^ name ^ " : { ... }.\\n") else () in () | StructDef (idOpt, mid) -> let ns = getComponents mid let module = abstractModule (ns, SOME mid) let name = (match idOpt with SOME id -> (installStrDec (StrDec (id, NONE), module, r, true); id) | NONE -> "_"(* anonymous *) ) let _ = if ! chatter = 3 then msg ("%struct " ^ name ^ " = " ^ qidToString (structQid mid) ^ ".\\n") else () in ()) | install1WithSig (fileName, moduleOpt, (Include sigexp, r))  = (* Include declaration *)  let (module, wherecls) = sigexpToSigexp (sigexp, moduleOpt) let module\' = foldl (fun (inst, module) -> moduleWhere (module, inst)) module wherecls let _ = includeSig (module\', r, false) let _ = if ! chatter = 3 then msg ("%include { ... }.\\n") else () in () | install1WithSig (fileName, NONE, (Open strexp, r))  = (* Open declaration *)  let mid = strexpToStrexp strexp let ns = getComponents mid let module = abstractModule (ns, SOME mid) let _ = includeSig (module, r, true) let _ = if ! chatter = 3 then msg ("%open " ^ qidToString (structQid mid) ^ ".\\n") else () in () let rec installSubsig (fileName, s)  = (* val _ = ModeTable.resetFrom mark *) (* val _ = Total.resetFrom mark *) (* val _ = Subordinate.resetFrom mark (* ouch! *) *) (* val _ = Reduces.resetFrom mark *) (* Origins, CompSyn, FunSyn harmless? -kw *) (* val _ = IntSyn.resetFrom (mark, markStruct)\n             FIX: DON\'T eliminate out-of-scope cids for now -kw *) let namespace = newNamespace () let (mark, markStruct) = sgnSize () let markSigDef = sigDefSize () let oldContext = ! context let _ = context := SOME namespace let _ = if ! chatter >= 4 then msg ("\\n% begin subsignature\\n") else () let rec install s  = install\' ((time parsing expose) s)install\' (Cons ((BeginSubsig, _), s\'))  = install (installSubsig (fileName, s\')) | install\' (Cons ((EndSubsig, _), s\'))  = s\' | install\' (Cons (declr, s\'))  = (install1 (fileName, declr); install s\') let result = try  with  let _ = context := oldContext let _ = resetFrom (mark, markStruct) let _ = resetFrom mark let _ = resetFrom mark let _ = resetFrom markSigDef in match result with Value (module, s\') -> let Cons (declr, s\'\') = (time parsing expose) s\' in install1WithSig (fileName, SOME module, declr); s\'\' | Exception exn -> raise (exn) (* loadFile (fileName) = status\n       reads and processes declarations from fileName in order, issuing\n       error messages and finally returning the status (either OK or\n       ABORT).\n    *) let rec loadFile (fileName)  = handleExceptions 0 fileName (withOpenIn fileName) (fun instream -> let _ = resetErrors fileName let rec install s  = install\' ((time parsing expose) s)install\' (Empty)  = OK | install\' (Cons ((BeginSubsig, _), s\'))  = install (installSubsig (fileName, s\')) | install\' (Cons (decl, s\'))  = (install1 (fileName, decl); install s\') in install (parseStream instream)) (* loadString (str) = status\n       reads and processes declarations from str, issuing\n       error messages and finally returning the status (either OK or\n       ABORT).\n    *) let rec loadString str  = handleExceptions 0 "string" (fun () -> let _ = resetErrors "string" let rec install s  = install\' ((time parsing expose) s)install\' (Empty)  = OK | install\' (Cons ((BeginSubsig, _), s\'))  = (installSubsig ("string", s\'); install s\') | install\' (Cons (decl, s\'))  = (install1 ("string", decl); install s\') in install (parseStream (openString str))) () (* Interactive Query Top Level *) let rec sLoop ()  = if qLoop () then OK else ABORT let rec topLoop ()  = match (handleExceptions 0 "stdIn" sLoop) ()(* "stdIn" as fake fileName *)  with ABORT -> topLoop () | OK -> () (* top () = () starts interactive query loop *) let rec top ()  = topLoop () let rec installCSMDec (conDec, optFixity, mdecL)  = (* put a more reasonable region here? -kw *) let _ = checkD (conDec, "%use", NONE) let cid = installConDec FromCS (conDec, ("", NONE), Reg (0, 0)) let _ = if ! chatter >= 3 then msg (conDecToString (conDec) ^ "\\n") else () let _ = (match optFixity with SOME (fixity) -> (installFixity (cid, fixity); if ! chatter >= 3 then msg ((if ! chatter >= 4 then "%" else "") ^ toString fixity ^ " " ^ qidToString (constQid cid) ^ ".\\n") else ()) | NONE -> ()) let _ = app (fun mdec -> installMmode (cid, mdec)) mdecL in cid let _ = setInstallFN (installCSMDec) (* reset () = () clears all global tables, including the signature *) let rec reset ()  = (sgnReset (); reset (); reset (); reset (); reset (); (* -fp Wed Mar  9 20:24:45 2005 *) reset (); reset (); reset (); reset (); (* -fp *) reset (); (* -fp *) reset (); (* -bp *) reset (); (* -bp *) labelReset (); sProgReset (); (* necessary? -fp; yes - bp*) detTableReset (); (*  -bp *) sProgReset (); (* resetting substitution trees *) reset (); resetSolvers (); context := NONE) let rec readDecl ()  = handleExceptions 0 "stdIn" (fun () -> let _ = resetErrors "stdIn" let rec install s  = install\' ((time parsing expose) s)install\' (Empty)  = ABORT | install\' (Cons ((BeginSubsig, _), s\'))  = (installSubsig ("stdIn", s\'); OK) | install\' (Cons (decl, s\'))  = (install1 ("stdIn", decl); OK) in install (parseStream stdIn)) () (* decl (id) = () prints declaration of constant id *) let rec decl (id)  = (match stringToQid id with NONE -> (msg (id ^ " is not a well-formed qualified identifier\\n"); ABORT) | SOME qid -> (match constLookup qid with NONE -> (msg (qidToString (valOf (constUndef qid)) ^ " has not been declared\\n"); ABORT) | SOME cid -> decl\' (cid)))decl\' (cid)  = (* val fixity = Names.getFixity (cid) *) (* can\'t get name preference right now *) (* val mode = ModeTable.modeLookup (cid) *) (* can\'t get termination declaration *) let conDec = sgnLookup (cid) in msg (conDecToString conDec ^ "\\n"); OK (* Support tracking file modification times for smart re-appending. *) module ModFilesig type mfileval create : string -> mfileval fileName : mfile -> stringval editName : (string -> string) -> mfile -> mfileval modified : mfile -> boolval makeModified : mfile -> unitval makeUnmodified : mfile -> unit end = struct type mfile = string * time option ref let rec create file  = (file, ref NONE) let rec fileName (file, _)  = file let rec editName edit (file, mtime)  = (edit file, mtime) let rec modified (_, ref NONE)  = true | modified (file, ref (SOME time))  = (match compare (time, modTime file) with EQUAL -> false | _ -> true) let rec makeModified (_, mtime)  = mtime := NONE let rec makeUnmodified (file, mtime)  = mtime := SOME (modTime file) end(* config = ["fileName1",...,"fileName<n>"] *) (* Files will be read in the order given! *) module Config = struct (* A configuration (pwdir, sources) consists of an absolute directory\n         pwdir and a list of source file names (which are interpreted\n         relative to pwdir) along with their modification times.\n         pwdir will be the current working directory\n         when a configuration is loaded, which may not be same as the\n         directory in which the configuration file is located.\n\n         This representation allows shorter file names in chatter and\n         error messages.\n      *)  type config = string * mfile list (* suffix of configuration files: "cfg" by default *)  let suffix = ref "cfg" (* mkRel transforms a relative path into an absolute one\n               by adding the specified prefix. If the path is already\n               absolute, no prefix is added to it.\n            *)  let rec mkRel (prefix, path)  = mkCanonical (if isAbsolute path then path else concat (prefix, path)) (* more efficient recursive version  Sat 08/26/2002 -rv *)  let rec read config  = (* appendUniq (list1, list2) appends list2 to list1, removing all\n               elements of list2 which are already in list1.\n            *) (* isConfig (item) is true iff item has the suffix of a\n               configuration file.\n            *) (* fromUnixPath path transforms path (assumed to be in Unix form)\n               to the local OS conventions.\n            *) let rec appendUniq (l1, l2)  = let rec appendUniq\' (x :: l2)  = if exists (fun y -> x = y) l1 then appendUniq\' l2 else x :: appendUniq\' (l2) | appendUniq\' nil  = rev l1 in rev (appendUniq\' (rev l2)) let rec isConfig item  = let suffix_size = (size (! suffix)) + 1 let suffix_start = (size item) - suffix_size in (suffix_start >= 0) && (substring (item, suffix_start, suffix_size) = ("." ^ ! suffix)) let rec fromUnixPath path  = let vol = getVolume config let isAbs = isPrefix "/" path let arcs = tokens (fun c -> c = \'/\') path in toString {isAbs = isAbs; vol = vol; arcs = arcs} let rec read\' (sources, configs) config  = withOpenIn config (fun instream -> let {dir = configDir; file = _} = splitDirFile config let rec parseItem (sources, configs) item  = if isConfig item then if exists (fun config\' -> item = config\') configs then (sources, configs)(* we have already read this one *)  else read\' (sources, item :: configs) item else if exists (fun source\' -> item = source\') sources then (sources, configs)(* we have already collected this one *)  else (sources @ [item], configs) let rec parseLine (sources, configs) line  = if isEmpty line(* end of file *)  then (sources, configs) else let line\' = dropl isSpace line in parseLine\' (sources, configs) line\'parseLine\' (sources, configs) line  = if isEmpty line || (* empty line *)  || sub (line, 0) = \'%\'(* comment *)  then parseStream (sources, configs) else let line\' = string (takel (not o isSpace) line) let item = mkRel (configDir, fromUnixPath line\') in parseStream (parseItem (sources, configs) item)parseStream (sources, configs)  = let line = full (inputLine97 instream) in parseLine (sources, configs) line in parseStream (sources, configs)) let pwdir = getDir () in (pwdir, map create (1 (read\' (nil, [config]) config)))(*\n            handle IO.Io (ioError) => (abortIO (configFile, ioError); raise IO.io (ioError))\n          *) (* Read a config file s but omit everything that is already in config c\n         XXX: naive and inefficient implementation *)  let rec readWithout (s, c)  = let (d, fs) = read s let (d\', fs\') = c let fns\' = map (fun m -> mkRel (d\', fileName m)) fs\' let rec redundant m  = let n = mkRel (d, fileName m) in exists (fun n\' -> n = n\') fns\' in (d, filter (not o redundant) fs) let rec loadAbort (mfile, OK)  = let status = loadFile (fileName mfile) in match status with OK -> makeUnmodified mfile | _ -> (); status | loadAbort (_, ABORT)  = ABORT (* load (config) = Status\n         resets the global signature and then reads the files in config\n         in order, stopping at the first error.\n      *)  let rec load (config as (_, sources))  = (reset (); app makeModified sources; append (config))(* append (config) = Status\n         reads the files in config in order, beginning at the first\n         modified file, stopping at the first error.\n      *) append (pwdir, sources)  = let rec fromFirstModified nil  = nil | fromFirstModified (sources as x :: xs)  = if modified x then sources else fromFirstModified xs let rec mkAbsolute p  = mkAbsolute {path = p; relativeTo = pwdir} let sources\' = (* allow shorter messages if safe *) if pwdir = getDir () then sources else map (editName mkAbsolute) sources let sources\'\' = fromFirstModified sources\' in foldl loadAbort OK sources\'\' let rec define (sources)  = (getDir (), map create sources) end(* structure Config *) (* make (configFile)\n       read and then load configuration from configFile\n    *) let rec make (fileName)  = load (read fileName) (* re-exporting environment parameters and utilities defined elsewhere *) module Printsig val implicit : bool ref(* false, print implicit args *) val printInfix : bool ref(* false, print fully explicit form infix when possible *) val depth : int option ref(* NONE, limit print depth *) val length : int option ref(* NONE, limit argument length *) val indent : int ref(* 3, indentation of subterms *) val width : int ref(* 80, line width *) val noShadow : bool ref(* if true, don\'t print shadowed constants as "%const%" *) val sgn : unit -> unit(* print signature *) val prog : unit -> unit(* print signature as program *) val subord : unit -> unit(* print subordination relation *) val def : unit -> unit(* print information about definitions *) val domains : unit -> unit(* print available constraint domains *) module TeX : (* print in TeX format *) sig val sgn : unit -> unit(* print signature *) val prog : unit -> unit(* print signature as program *)  end end = struct let implicit = implicit let printInfix = printInfix let depth = printDepth let length = printLength let indent = Indent let width = Pagewidth let noShadow = noShadow let rec sgn ()  = printSgn () let rec prog ()  = printSgn () let rec subord ()  = show () let rec def ()  = showDef () let rec domains ()  = msg (version) module TeX = struct let rec sgn ()  = printSgnTeX () let rec prog ()  = printProgTeX () end endmodule Tracesig type \'aSpecNoneSome\'a listAll(* trace all clauses and families *) val trace : string Spec -> unit(* clauses and families *) val break : string Spec -> unit(* clauses and families *) val detail : int ref(* 0 = none, 1 = default, 2 = unify *) val show : unit -> unit(* show trace, break, and detail *) val reset : unit -> unit(* reset trace, break, and detail *)  end = Tracemodule Timerssig val show : unit -> unit(* show and reset timers *) val reset : unit -> unit(* reset timers *) val check : unit -> unit(* display, but not no reset *)  end = Timersmodule OSsig val chDir : string -> unit(* change working directory *) val getDir : unit -> string(* get working directory *) val exit : unit -> unit(* exit Twelf and ML *)  end = struct let chDir = chDir let getDir = getDir let rec exit ()  = exit (success) endmodule Compilesig OptOptval optimize : Opt ref end = struct OptOpt let optimize = optimize endmodule Reconsig TraceModeTraceModeval trace : bool refval traceMode : TraceMode ref end = struct TraceModeTraceMode let trace = trace let traceMode = traceMode endmodule Reconsig TraceModeTraceModeval trace : bool refval traceMode : TraceMode ref end = struct TraceModeTraceMode let trace = trace let traceMode = traceMode endmodule Proversig (* F=Filling, R=Recursion, S=Splitting *) StrategyStrategy(* FRS or RFS *) val strategy : Strategy ref(* FRS, strategy used for %prove *) val maxSplit : int ref(* 2, bound on splitting  *) val maxRecurse : int ref(* 10, bound on recursion *)  end = struct StrategyStrategy (* FRS or RFS *)  let strategy = strategy let maxSplit = maxSplit let maxRecurse = maxRecurse endlet chatter : int ref = chatter let doubleCheck : bool ref = doubleCheck let unsafe : bool ref = unsafe let autoFreeze : bool ref = autoFreeze let timeLimit : time option ref = timeLimit StatusStatus let reset = reset let loadFile = loadFile let loadString = loadString let readDecl = readDecl let decl = decl let top = top module Configsig type config(* configuration *) val suffix : string ref(* suffix of configuration files *) val read : string -> config(* read configuration from config file *) val readWithout : string * config -> config(* read config file, minus contents of another *) val load : config -> Status(* reset and load configuration *) val append : config -> Status(* load configuration (w/o reset) *) val define : string list -> config(* explicitly define configuration *)  end = Configlet make = make let version = version_string module Tablesig StrategyStrategyval strategy : Strategy refval strengthen : bool refval resetGlobalTable : unit -> unitval top : unit -> unit end = struct StrategyStrategy let strategy = strategy let strengthen = strengthen let resetGlobalTable = resetGlobalTable (* top () = () starts interactive query loop *)  let rec top ()  = let rec sLoopT ()  = if qLoopT () then OK else ABORT let rec topLoopT ()  = match (handleExceptions 0 "stdIn" sLoopT) ()(* "stdIn" as fake fileName *)  with ABORT -> topLoopT () | OK -> () in topLoopT () end (* local *)  end\n(* functor Twelf *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {})])
Code parsed successfully: (* A do-nothing stub for SML implementations without an SML/NJ-like
   exnHistory function.
*) module UnknownExn = UnknownExn()

('Error parsing code:', '(* Parsing Terms and Variable Declarations *) (* Author: Frank Pfenning *) module ParseTerm ((*! structure Parsing\' : PARSING !*) module ExtSyn\' : EXTSYN(*! sharing Parsing\'.Lexer.Paths = ExtSyn\'.Paths !*) module Names : NAMES) : PARSE_TERM = struct (*! structure Parsing = Parsing\' !*)  module ExtSyn = ExtSyn\' (* some shorthands *) module L = Lexermodule LS = LexerStream(*! structure Paths = Lexer.Paths !*) module FX = NamesFixity(* Operators and atoms for operator precedence parsing *) type operator = Atom of \'a | Infix of (precedence * associativity) * (\'a * \'a -> \'a) | Prefix of precedence * (\'a -> \'a) | Postfix of precedence * (\'a -> \'a) (* Predeclared infix operators *) let juxOp = Infix ((inc maxPrec, Left), app) (* juxtaposition *) let arrowOp = Infix ((dec minPrec, Right), arrow) let backArrowOp = Infix ((dec minPrec, Left), backarrow) let colonOp = Infix ((dec (dec minPrec), Left), hastype) let rec infixOp (infixity, tm)  = Infix (infixity, (fun (tm1, tm2) -> app (app (tm, tm1), tm2))) let rec prefixOp (prec, tm)  = Prefix (prec, (fun tm1 -> app (tm, tm1))) let rec postfixOp (prec, tm)  = Postfix (prec, (fun tm1 -> app (tm, tm1))) let rec idToTerm (Lower, ids, name, r)  = lcid (ids, name, r) | idToTerm (Upper, ids, name, r)  = ucid (ids, name, r) | idToTerm (Quoted, ids, name, r)  = quid (ids, name, r) let rec isQuoted (Quoted)  = true | isQuoted _  = false type stack = term operator list type opr = term operator (* The next section deals generically with fixity parsing          *) (* Because of juxtaposition, it is not clear how to turn this      *) (* into a separate module without passing a juxtaposition operator *) (* into the shift and resolve functions                            *) module Psig val reduce : stack -> stackval reduceAll : region * stack -> termval shiftAtom : term * stack -> stackval shift : region * opr * stack -> stackval resolve : region * opr * stack -> stack end = struct (* Stack invariants, refinements of operator list *)  (*\n         <p>       ::= <pStable> | <pRed>\n         <pStable> ::= <pAtom> | <pOp?>\n         <pAtom>   ::= Atom _ :: <pOp?>\n         <pOp?>    ::= nil | <pOp>\n         <pOp>     ::= Infix _ :: <pAtom> :: <pOp?>\n                     | Prefix _ :: <pOp?>\n         <pRed>    ::= Postfix _ :: Atom _ :: <pOp?>\n                     | Atom _ :: <pOp>\n      *)  (* val reduce : <pRed> -> <p> *)  let rec reduce (Atom (tm2) :: Infix (_, con) :: Atom (tm1) :: p\')  = Atom (con (tm1, tm2)) :: p\' | reduce (Atom (tm) :: Prefix (_, con) :: p\')  = Atom (con (tm)) :: p\' | reduce (Postfix (_, con) :: Atom (tm) :: p\')  = Atom (con (tm)) :: p\' (* no other cases should be possible by stack invariant *)  (* val reduceRec : <pStable> -> ExtSyn.term *)  let rec reduceRec (Atom (e) :: nil)  = e | reduceRec (p)  = reduceRec (reduce p) (* val reduceAll : <p> -> ExtSyn.term *)  let rec reduceAll (r, Atom (e) :: nil)  = e | reduceAll (r, Infix _ :: p\')  = error (r, "Incomplete infix expression") | reduceAll (r, Prefix _ :: p\')  = error (r, "Incomplete prefix expression") | reduceAll (r, nil)  = error (r, "Empty expression") | reduceAll (r, p)  = reduceRec (reduce p) (* val shiftAtom : term * <pStable> -> <p> *)  (* does not raise Error exception *)  let rec shiftAtom (tm, p as (Atom _ :: p\'))  = (* insert juxOp operator and reduce *)  (* juxtaposition binds most strongly *)  reduce (Atom (tm) :: juxOp :: p) | shiftAtom (tm, p)  = Atom (tm) :: p (* val shift : Paths.region * opr * <pStable> -> <p> *)  let rec shift (r, opr as Atom _, p as (Atom _ :: p\'))  = (* insert juxOp operator and reduce *)  (* juxtaposition binds most strongly *)  reduce (opr :: juxOp :: p) | shift (r, Infix _, Infix _ :: p\')  = error (r, "Consective infix operators") | shift (r, Infix _, Prefix _ :: p\')  = error (r, "Infix operator following prefix operator") | shift (r, Infix _, nil)  = error (r, "Leading infix operator") | shift (r, opr as Prefix _, p as (Atom _ :: p\'))  = (* insert juxtaposition operator *)  (* will be reduced later *)  opr :: juxOp :: p | shift (r, Postfix _, Infix _ :: p\')  = error (r, "Postfix operator following infix operator") | shift (r, Postfix _, Prefix _ :: p\')  = error (r, "Postfix operator following prefix operator") | shift (r, Postfix _, nil)  = error (r, "Leading postfix operator") | shift (r, opr, p)  = opr :: p (* val resolve : Paths.region * opr * <pStable> -> <p> *)  (* Decides, based on precedence of opr compared to the top of the\n         stack whether to shift the new operator or reduce the stack\n      *)  let rec resolve (r, opr as Infix ((prec, assoc), _), p as (Atom (_) :: Infix ((prec\', assoc\'), _) :: p\'))  = (match (compare (prec, prec\'), assoc, assoc\') with (GREATER, _, _) -> shift (r, opr, p) | (LESS, _, _) -> resolve (r, opr, reduce (p)) | (EQUAL, Left, Left) -> resolve (r, opr, reduce (p)) | (EQUAL, Right, Right) -> shift (r, opr, p) | _ -> error (r, "Ambiguous: infix following infix of identical precedence")) | resolve (r, opr as Infix ((prec, assoc), _), p as (Atom (_) :: Prefix (prec\', _) :: p\'))  = (match compare (prec, prec\') with GREATER -> shift (r, opr, p) | LESS -> resolve (r, opr, reduce (p)) | EQUAL -> error (r, "Ambiguous: infix following prefix of identical precedence")) | resolve (r, opr as Prefix _, p)  = shift (r, opr, p) | resolve (r, opr as Postfix (prec, _), p as (Atom _ :: Prefix (prec\', _) :: p\'))  = (match compare (prec, prec\') with GREATER -> reduce (shift (r, opr, p)) | LESS -> resolve (r, opr, reduce (p)) | EQUAL -> error (r, "Ambiguous: postfix following prefix of identical precedence")) | resolve (r, opr as Postfix (prec, _), p as (Atom _ :: Infix ((prec\', _), _) :: p\'))  = (match compare (prec, prec\') with GREATER -> reduce (shift (r, opr, p)) | LESS -> resolve (r, opr, reduce (p)) | EQUAL -> error (r, "Ambiguous: postfix following infix of identical precedence")) | resolve (r, opr as Postfix _, p as (Atom _ :: nil))  = reduce (shift (r, opr, p)) | resolve (r, opr, p)  = shift (r, opr, p) end(* structure P *) (* parseQualifier\' f = (ids, f\')\n       pre: f begins with L.ID\n\n       Note: precondition for recursive call is enforced by the lexer. *) let rec parseQualId\' (f as Cons ((t as ID (_, id), r), s\'))  = (match expose s\' with Cons ((PATHSEP, _), s\'\') -> let ((ids, (t, r)), f\') = parseQualId\' (expose s\'\') in ((id :: ids, (t, r)), f\') | f\' -> ((nil, (t, r)), f\')) let rec stripBar (Cons ((ID (_, "|"), r), s\'))  = (expose s\') | stripBar (f as Cons ((RPAREN, r), s\'))  = f | stripBar (Cons ((t, r), s\'))  = error (r, "Expected `|\', found token " ^ toString t) let rec parseQualIds1 (ls, f as Cons ((t as ID (_, id), r0), s\'))  = let ((ids, (ID (idCase, name), r1)), f\') = parseQualId\' f let r = join (r0, r1) let f\'\' = stripBar f\' in parseQualIds1 ((ids, name) :: ls, f\'\') | parseQualIds1 (ls, Cons ((RPAREN, r), s\'))  = (ls, expose s\') | parseQualIds1 (ls, Cons ((t, r), s))  = error (r, "Expected label, found token " ^ toString t) let rec parseQualIds\' (Cons ((LPAREN, r), s\'))  = parseQualIds1 (nil, expose s\') | parseQualIds\' (Cons ((t, r), s\'))  = error (r, "Expected list of labels, found token " ^ toString t) (* Copied from parse-mode, should probably try to abstract all\n       of the strip* functions into a common location - gaw *) let rec stripRParen (Cons ((RPAREN, r), s\'))  = expose s\' | stripRParen (Cons ((t, r), s\'))  = (* t = `.\' or ? *)  error (r, "Expected closing `)\', found " ^ toString t) let rec parseSubordPair2 (f as Cons ((ID _, _), _), qid)  = let ((ids, (ID (idCase, name), r1)), f\') = parseQualId\' f in ((qid, (ids, name)), stripRParen f\') | parseSubordPair2 (Cons ((t, r), s\'), qid)  = error (r, "Expected identifier, found token " ^ toString t) let rec parseSubordPair1 (f as Cons ((ID _, _), _))  = let ((ids, (ID (idCase, name), r1)), f\') = parseQualId\' f in parseSubordPair2 (f\', (ids, name)) | parseSubordPair1 (Cons ((t, r), s\'))  = error (r, "Expected identifier, found token " ^ toString t) let rec parseSubord\' (Cons ((LPAREN, r), s\'), qidpairs)  = let (qidpair, f) = parseSubordPair1 (expose s\') in parseSubord\' (f, qidpair :: qidpairs) | parseSubord\' (f as Cons ((DOT, _), _), qidpairs)  = (rev qidpairs, f) | parseSubord\' (Cons ((t, r), s\'), qidpairs)  = error (r, "Expected a pair of identifiers, found token " ^ toString t) let rec parseFreeze\' (f as Cons ((ID _, _), _), qids)  = let ((ids, (ID (idCase, name), r1)), f\') = parseQualId\' f in parseFreeze\' (f\', (ids, name) :: qids) | parseFreeze\' (f as Cons ((DOT, _), _), qids)  = (rev qids, f) | parseFreeze\' (Cons ((t, r), s\'), qids)  = error (r, "Expected identifier, found token " ^ toString t) let rec parseThaw\' (f, qids)  = (* same syntax as %freeze *)  parseFreeze\' (f, qids) let rec parseDeterministic\' (f as Cons ((ID _, _), _), qids)  = let ((ids, (ID (idCase, name), r1)), f\') = parseQualId\' f in parseDeterministic\' (f\', (ids, name) :: qids) | parseDeterministic\' (f as Cons ((DOT, _), _), qids)  = (rev qids, f) | parseDeterministic\' (Cons ((t, r), s\'), qids)  = error (r, "Expected identifier, found token " ^ toString t) (* ABP 4/4/03 *) let rec parseCompile\' (f as Cons ((ID _, _), _), qids)  = let ((ids, (ID (idCase, name), r1)), f\') = parseQualId\' f in parseCompile\' (f\', (ids, name) :: qids) | parseCompile\' (f as Cons ((DOT, _), _), qids)  = (rev qids, f) | parseCompile\' (Cons ((t, r), s\'), qids)  = error (r, "Expected identifier, found token " ^ toString t) (* val parseExp : (L.token * L.region) LS.stream * <p>\n                        -> ExtSyn.term * (L.token * L.region) LS.front *) let rec parseExp (s, p)  = parseExp\' (expose s, p)parseExp\' (f as Cons ((ID _, r0), _), p)  = let ((ids, (ID (idCase, name), r1)), f\') = parseQualId\' f let r = join (r0, r1) let tm = idToTerm (idCase, ids, name, r) in (* Currently, we cannot override fixity status of identifiers *) (* Thus isQuoted always returns false *) if isQuoted (idCase) then parseExp\' (f\', shiftAtom (tm, p)) else match fixityLookup (Qid (ids, name)) with Nonfix -> parseExp\' (f\', shiftAtom (tm, p)) | Infix infixity -> parseExp\' (f\', resolve (r, infixOp (infixity, tm), p)) | Prefix (prec) -> parseExp\' (f\', resolve (r, prefixOp (prec, tm), p)) | Postfix (prec) -> parseExp\' (f\', resolve (r, postfixOp (prec, tm), p)) | parseExp\' (Cons ((UNDERSCORE, r), s), p)  = parseExp (s, shiftAtom (omitted r, p)) | parseExp\' (Cons ((TYPE, r), s), p)  = parseExp (s, shiftAtom (typ r, p)) | parseExp\' (Cons ((COLON, r), s), p)  = parseExp (s, resolve (r, colonOp, p)) | parseExp\' (Cons ((BACKARROW, r), s), p)  = parseExp (s, resolve (r, backArrowOp, p)) | parseExp\' (Cons ((ARROW, r), s), p)  = parseExp (s, resolve (r, arrowOp, p)) | parseExp\' (Cons ((LPAREN, r), s), p)  = decideRParen (r, parseExp (s, nil), p) | parseExp\' (f as Cons ((RPAREN, r), s), p)  = (reduceAll (r, p), f) | parseExp\' (Cons ((LBRACE, r), s), p)  = decideRBrace (r, parseDec (s), p) | parseExp\' (f as Cons ((RBRACE, r), s), p)  = (reduceAll (r, p), f) | parseExp\' (Cons ((LBRACKET, r), s), p)  = decideRBracket (r, parseDec (s), p) | parseExp\' (f as Cons ((RBRACKET, r), s), p)  = (reduceAll (r, p), f) | parseExp\' (f as Cons ((EQUAL, r), s), p)  = (reduceAll (r, p), f) | parseExp\' (f as Cons ((DOT, r), s), p)  = (reduceAll (r, p), f) | parseExp\' (f as Cons ((EOF, r), s), p)  = (reduceAll (r, p), f) | parseExp\' (f as Cons ((SOLVE, r), s), p)  = (reduceAll (r, p), f) | parseExp\' (f as Cons ((DEFINE, r), s), p)  = (reduceAll (r, p), f) | parseExp\' (Cons ((STRING (str), r), s), p)  = parseExp (s, shiftAtom (scon (str, r), p)) | parseExp\' (Cons ((t, r), s), p)  = (* possible error recovery: insert DOT *)  error (r, "Unexpected token " ^ toString t ^ " found in expression")parseDec (s)  = parseDec\' (expose s)parseDec\' (Cons ((ID (Quoted, name), r), s\'))  = (* cannot happen at present *)  error (r, "Illegal bound quoted identifier " ^ name) | parseDec\' (Cons ((ID (idCase, name), r), s\'))  = (match fixityLookup (Qid (nil, name)) with Nonfix -> parseDec1 (SOME (name), expose s\') | Infix _ -> error (r, "Cannot bind infix identifier " ^ name) | Prefix _ -> error (r, "Cannot bind prefix identifier " ^ name) | Postfix _ -> error (r, "Cannot bind postfix identifier " ^ name)) | parseDec\' (Cons ((UNDERSCORE, r), s\'))  = parseDec1 (NONE, expose s\') | parseDec\' (Cons ((EOF, r), s\'))  = error (r, "Unexpected end of stream in declaration") | parseDec\' (Cons ((t, r), s\'))  = error (r, "Expected variable name, found token " ^ toString t)parseDec1 (x, Cons ((COLON, r), s\'))  = let (tm, f\'\') = parseExp (s\', nil) in ((x, SOME tm), f\'\') | parseDec1 (x, f as Cons ((RBRACE, _), _))  = ((x, NONE), f) | parseDec1 (x, f as Cons ((RBRACKET, _), _))  = ((x, NONE), f) | parseDec1 (x, Cons ((t, r), s\'))  = error (r, "Expected optional type declaration, found token " ^ toString t)decideRParen (r0, (tm, Cons ((RPAREN, r), s)), p)  = parseExp (s, shiftAtom (tm, p)) | decideRParen (r0, (tm, Cons ((_, r), s)), p)  = error (join (r0, r), "Unmatched open parenthesis")decideRBrace (r0, ((x, yOpt), Cons ((RBRACE, r), s)), p)  = let dec = (match yOpt with NONE -> dec0 (x, join (r0, r)) | SOME y -> dec (x, y, join (r0, r))) let (tm, f\') = parseExp (s, nil) in parseExp\' (f\', shiftAtom (pi (dec, tm), p)) | decideRBrace (r0, (_, Cons ((_, r), s)), p)  = error (join (r0, r), "Unmatched open brace")decideRBracket (r0, ((x, yOpt), Cons ((RBRACKET, r), s)), p)  = let dec = (match yOpt with NONE -> dec0 (x, join (r0, r)) | SOME y -> dec (x, y, join (r0, r))) let (tm, f\') = parseExp (s, nil) in parseExp\' (f\', shiftAtom (lam (dec, tm), p)) | decideRBracket (r0, (dec, Cons ((_, r), s)), p)  = error (join (r0, r), "Unmatched open bracket") (* Parses contexts of the form  G ::= {id:term} | G, {id:term} *) let rec stripRBrace (Cons ((RBRACE, r), s\'))  = (expose s\', r) | stripRBrace (Cons ((t, r), _))  = error (r, "Expected `}\', found " ^ toString t)(* parseDec "{id:term} | {id}" *) parseBracedDec (r, f)  = let ((x, yOpt), f\') = parseDec\' f let (f\'\', r2) = stripRBrace f\' let d = (match yOpt with NONE -> dec0 (x, join (r, r2)) | SOME y -> dec (x, y, join (r, r2))) in (d, f\'\') (* parseCtx (b, ds, f) = ds\'\n       if   f is a stream "{x1:V1}...{xn:Vn} s"\n       and  b is true if no declarations has been parsed yet\n       and  ds is a context of declarations\n       then ds\' = ds, x1:V1, ..., xn:Vn\n    *) let rec parseCtx (b, ds, Cons (BS as ((LBRACE, r), s\')))  = let (d, f\') = parseBracedDec (r, expose s\') in parseCtx (false, d :: ds, f\') | parseCtx (b, ds, f as Cons ((t, r), s\'))  = if b then error (r, "Expected `{\', found " ^ toString t) else (ds, f) let parseQualId\' = parseQualId\' let parseQualIds\' = parseQualIds\' let parseSubord\' = (fun f -> parseSubord\' (f, nil)) let parseFreeze\' = (fun f -> parseFreeze\' (f, nil)) let parseThaw\' = (fun f -> parseThaw\' (f, nil)) let parseDeterministic\' = (fun f -> parseDeterministic\' (f, nil)) let parseCompile\' = (fun f -> parseCompile\' (f, nil)) (* -ABP 4/4/03 *) let parseTerm\' = (fun f -> parseExp\' (f, nil)) let parseDec\' = parseDec\' let parseCtx\' = (fun f -> (parseCtx (true, nil, f)))  (* local ... in *)  end\n(* functor ParseTerm *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* External syntax for module expressions *) (* Author: Kevin Watkins *) module type MODEXTSYN = sig module ExtSyn : EXTSYN(*! structure Paths : PATHS !*) type strexpval strexp : string list * string * region -> strexptype instval coninst : (string list * string * region) * term * region -> instval strinst : (string list * string * region) * strexp * region -> insttype sigexpval thesig : sigexpval sigid : string * region -> sigexpval wheresig : sigexp * inst list -> sigexptype sigdefval sigdef : string option * sigexp -> sigdeftype structdecval structdec : string option * sigexp -> structdecval structdef : string option * strexp -> structdec end\nmodule type RECON_MODULE = sig include MODEXTSYNmodule ModSyn : MODSYNexception Error of stringtype whereclausetype StructDecStructDecstring option * module * whereclause listStructDefstring option * midval strexpToStrexp : strexp -> midval sigexpToSigexp : sigexp * module option -> module * whereclause listval sigdefToSigdef : sigdef * module option -> string option * module * whereclause listval structdecToStructDec : structdec * module option -> StructDecval moduleWhere : module * whereclause -> module end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Parsing Terms and Declarations *) (* Author: Frank Pfenning *) module type PARSE_TERM = sig (*! structure Parsing : PARSING !*) module ExtSyn : EXTSYNval parseQualId' : string list * lexResult parserval parseQualIds' : string list * string list parserval parseFreeze' : string list * string list parserval parseSubord' : (string list * string) * (string list * string) list parserval parseThaw' : string list * string list parserval parseDeterministic' : string list * string list parserval parseCompile' : string list * string list parser(* -ABP 4/4/03 *) val parseTerm' : term parserval parseDec' : string option * term option parserval parseCtx' : dec list parser end\n(* signature PARSE_TERM *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Parsing modules *) (* Author: Kevin Watkins *) module type PARSE_MODULE = sig (*! structure Parsing : PARSING !*) module ModExtSyn : MODEXTSYN(* val parseSigExp' : ModExtSyn.sigexp Parsing.recparser *) val parseSigDef' : sigdef recparser(* val parseStructExp' : ModExtSyn.strexp Parsing.parser *) val parseStructDec' : structdec recparserval parseInclude' : sigexp recparserval parseOpen' : strexp parser end", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Parsing Thm Declarations *) (* Author: Carsten Schuermann *) (* Modified: Brigitte Pientka *) module ParseThm ((*! structure Paths : PATHS *) (*! structure Parsing\' : PARSING !*) (*! sharing Parsing\'.Lexer.Paths = Paths !*) module ThmExtSyn\' : THMEXTSYN(*! sharing ThmExtSyn\'.Paths = Paths !*) (*! sharing ThmExtSyn\'.ExtSyn.Paths = Paths !*) module ParseTerm : PARSE_TERM(*! sharing ParseTerm.Lexer = Parsing\'.Lexer !*) ParseTermExtSynThmExtSyn\'ExtSyn) : PARSE_THM = struct (*! structure Parsing = Parsing\' !*)  module ThmExtSyn = ThmExtSyn\' module L = Lexermodule LS = LexerStreammodule E = ThmExtSynmodule P = Paths(*--------------------------*) (* %terminates declarations *) (*--------------------------*) (* idToNat (region, (idCase, name)) = n\n       where n an natural number indicated by name, which should consist\n       of all digits.  Raises error otherwise, or if integer it too large\n    *) let rec idToNat (r, name)  = try  with let rec stripRParen (Cons ((RPAREN, r), s\'))  = expose s\' | stripRParen (Cons ((t, r), _))  = error (r, "Expected `)\', found " ^ toString t) let rec decideRBrace (r0, (orders, Cons ((RBRACE, r), s\')))  = (SOME (lex (r0, orders)), expose s\') | decideRBrace (r0, (order, Cons ((t, r), _)))  = error (join (r0, r), "Expected `}\', found " ^ toString t) let rec decideRBracket (r0, (orders, Cons ((RBRACKET, r), s\')))  = (SOME (simul (r0, orders)), expose s\') | decideRBracket (r0, (order, Cons ((t, r), _)))  = error (join (r0, r), "Expected `]\', found " ^ toString t) let rec decideRParen (r0, (ids, Cons ((RPAREN, r), s\')))  = (SOME (varg (r, ids)), expose s\') | decideRParen (r0, (order, Cons ((t, r), _)))  = error (join (r0, r), "Expected `)\', found " ^ toString t) (* parseIds "id ... id" = ["id",...,"id"] *) (* terminated by non-identifier token *) let rec parseIds (Cons ((ID (Upper, id), r), s\'))  = let (ids, f\') = parseIds (expose s\') in (id :: ids, f\') | parseIds (Cons ((t as ID (_, id), r), s\'))  = error (r, "Expecter upper case identifier, found " ^ toString t) | parseIds f  = (nil, f) (* parseArgPat "_id ... _id" = [idOpt,...,idOpt] *) (* terminated by token different from underscore or id *) let rec parseArgPat (Cons ((ID (Upper, id), r), s\'))  = let (idOpts, f\') = parseArgPat (expose s\') in (SOME id :: idOpts, f\') | parseArgPat (Cons ((ID (_, id), r), s\'))  = error (r, "Expected upper case identifier, found " ^ id) | parseArgPat (Cons ((UNDERSCORE, r), s\'))  = let (idOpts, f\') = parseArgPat (expose s\') in (NONE :: idOpts, f\') | parseArgPat f  = (nil, f) (* parseCallPat "id _id ... _id" = (id, region, [idOpt,...,idOpt]) *) let rec parseCallPat (Cons ((ID (_, id), r), s\'))  = let (idOpts, f\' as Cons ((_, r\'), _)) = parseArgPat (expose s\') in ((id, idOpts, join (r, r\')), f\') | parseCallPat (Cons ((t, r), s))  = error (r, "Expected call pattern, found token " ^ toString t) (* parseCallPats "(id _id ... _id)...(id _id ... _id)." *) let rec parseCallPats (Cons ((LPAREN, r), s\'))  = let (cpat, f\') = parseCallPat (expose s\') let (cpats, f\'\') = parseCallPats (stripRParen f\') in (cpat :: cpats, f\'\') | parseCallPats (f as Cons ((DOT, r), s\'))  = (nil, f) | parseCallPats (Cons ((t, r), s))  = error (r, "Expected call patterns, found token " ^ toString t) (* order ::= id | (id ... id)   virtual arguments = subterm ordering\n               | {order ... order}  lexicgraphic order\n               | [order ... order]  simultaneous order\n    *) (* parseOrderOpt (f) = (SOME(order), f\') or (NONE, f) *) (* returns an optional order and front of remaining stream *) let rec parseOrderOpt (Cons ((LPAREN, r), s\'))  = decideRParen (r, parseIds (expose s\')) | parseOrderOpt (Cons ((LBRACE, r), s\'))  = decideRBrace (r, parseOrders (expose s\')) | parseOrderOpt (Cons ((LBRACKET, r), s\'))  = decideRBracket (r, parseOrders (expose s\')) | parseOrderOpt (Cons ((ID (Upper, id), r), s\'))  = (SOME (varg (r, [id])), expose s\') | parseOrderOpt (f as Cons (_, s\'))  = (NONE, f)(* parseOrders (f) = ([order1,...,ordern], f\') *) (* returns a sequence of orders and remaining front of stream *) parseOrders (f)  = parseOrders\' (parseOrderOpt f)parseOrders\' (SOME (order), f\')  = let (orders, f\'\') = parseOrders f\' in (order :: orders, f\'\') | parseOrders\' (NONE, f\')  = (nil, f\') (* parseOrder (f) = (order, f\') *) (* returns an order and front of remaining stream *) let rec parseOrder (f)  = parseOrder\' (parseOrderOpt f)parseOrder\' (SOME (order), f\')  = (order, f\') | parseOrder\' (NONE, Cons ((t, r), s\'))  = error (r, "Expected order, found " ^ toString t) (* parseTDecl "order callPats." *) (* parses Termination Declaration, followed by `.\' *) let rec parseTDecl f  = let (order, f\') = parseOrder f let (callpats, f\'\') = parseCallPats f\' in (tdecl (order, callpats callpats), f\'\') (* parseTerminates\' "%terminates tdecl." *) let rec parseTerminates\' (Cons ((TERMINATES, r), s\'))  = parseTDecl (expose s\') (* ------------------- *) (* %total declaration  *) (* ------------------- *) (* parseTotal\' "%total tdecl." *) let rec parseTotal\' (Cons ((TOTAL, r), s\'))  = parseTDecl (expose s\') (* ------------------- *) (* %prove declarations *) (* ------------------- *) (* parsePDecl "id nat order callpats." *) let rec parsePDecl (Cons ((ID (_, id), r), s\'))  = let depth = idToNat (r, id) let (t\', f\') = parseTDecl (expose s\') in (prove (depth, t\'), f\') | parsePDecl (Cons ((t, r), s\'))  = error (r, "Expected theorem identifier, found " ^ toString t) (* parseProve\' "%prove pdecl." *) let rec parseProve\' (Cons ((PROVE, r), s\'))  = parsePDecl (expose s\') (* ----------------------- *) (* %establish declarations *) (* ----------------------- *) (* parseEDecl "id nat order callpats." *) let rec parseEDecl (Cons ((ID (_, id), r), s\'))  = let depth = idToNat (r, id) let (t\', f\') = parseTDecl (expose s\') in (establish (depth, t\'), f\') | parseEDecl (Cons ((t, r), s\'))  = error (r, "Expected theorem identifier, found " ^ toString t) (* parseEstablish\' "%establish pdecl." *) let rec parseEstablish\' (Cons ((ESTABLISH, r), s\'))  = parseEDecl (expose s\') (* -------------------- *) (* %assert declarations *) (* -------------------- *) (* parseAssert\' "%assert cp" *) let rec parseAssert\' (Cons ((ASSERT, r), s\'))  = let (callpats, f\'\') = parseCallPats (expose s\') in (assert (callpats callpats), f\'\') (* --------------------- *) (* %theorem declarations *) (* --------------------- *) let rec stripRBrace (Cons ((RBRACE, r), s\'))  = (expose s\', r) | stripRBrace (Cons ((t, r), _))  = error (r, "Expected `}\', found " ^ toString t)(* parseDec "{id:term} | {id}" *) parseDec (r, f)  = let ((x, yOpt), f\') = parseDec\' f let (f\'\', r2) = stripRBrace f\' let dec = (match yOpt with NONE -> dec0 (x, join (r, r2)) | SOME y -> dec (x, y, join (r, r2))) in (dec, f\'\')(* parseDecs\' "{id:term}...{id:term}", zero or more, ":term" optional *) parseDecs\' (Drs, Cons (BS as ((LBRACE, r), s\')))  = let (Dr, f\') = parseDec (r, expose s\') in parseDecs\' (decl (Drs, Dr), f\') | parseDecs\' Drs  = Drs(* parseDecs "{id:term}...{id:term}", one ore more, ":term" optional *) parseDecs (Cons (BS as ((LBRACE, r), s\')))  = let (Dr, f\') = parseDec (r, expose s\') in parseDecs\' (decl (null, Dr), f\') | parseDecs (Cons ((t, r), s\'))  = error (r, "Expected `{\', found " ^ toString t) let rec parsePi (Cons ((ID (_, "pi"), r), s\'))  = parseDecs (expose s\') | parsePi (Cons ((t, r), s\'))  = error (r, "Expected `pi\', found " ^ toString t) let rec parseSome (gbs, Cons ((ID (_, "some"), r), s\'))  = let (g1, f\') = parseDecs (expose s\') let (g2, f\'\') = parsePi f\' in parseSome\' ((g1, g2) :: gbs, f\'\') | parseSome (gbs, f as Cons ((ID (_, "pi"), r), s\'))  = let (g2, f\') = parsePi f in parseSome\' ((null, g2) :: gbs, f\') | parseSome (gbs, f as Cons ((RPAREN, r), s\'))  = (gbs, f) | parseSome (gbs, Cons ((t, r), s\'))  = error (r, "Expected `some\' or `pi\', found " ^ toString t)parseSome\' (gbs, f as Cons ((RPAREN, r), s\'))  = (gbs, f) | parseSome\' (gbs, Cons ((ID (_, "|"), r), s\'))  = parseSome (gbs, expose s\') | parseSome\' (gbs, Cons ((t, r), s\'))  = error (r, "Expected `)\' or `|\', found " ^ toString t) let rec stripParen (gbs, Cons ((RPAREN, r), s\'))  = (gbs, expose s\') let rec parseGBs (Cons ((LPAREN, r), s\'))  = stripParen (parseSome (nil, expose s\')) | parseGBs (Cons ((t, r), s\'))  = error (r, "Expected `(\', found " ^ toString t) let rec forallG ((gbs\', f\'), r)  = let (t\'\', f\'\') = parseForallStar f\' in (forallG (gbs\', t\'\'), f\'\')forallStar ((g\', f\'), r)  = let (t\'\', f\'\') = parseForall f\' in (forallStar (g\', t\'\'), f\'\')forall ((g\', f\'), r)  = let (t\'\', f\'\') = parseExists f\' in (forall (g\', t\'\'), f\'\')exists ((g\', f\'), r)  = let (t\'\', f\'\') = parseTrue f\' in (exists (g\', t\'\'), f\'\')top (f\', r)  = (top, f\')(* parseTrue "true" *) parseTrue (Cons ((ID (_, "true"), r), s\'))  = top (expose s\', r) | parseTrue (Cons ((t, r), s\'))  = error (r, "Expected `true\', found " ^ toString t)(* parseExists "exists decs mform | mform" *) parseExists (Cons ((ID (_, "exists"), r), s\'))  = exists (parseDecs (expose s\'), r) | parseExists (Cons ((ID (_, "true"), r), s\'))  = top (expose s\', r) | parseExists (Cons ((t, r), s\'))  = error (r, "Expected `exists\' or `true\', found " ^ toString t)(* parseForall "forall decs mform | mform" *) parseForall (Cons ((ID (_, "forall"), r), s\'))  = forall (parseDecs (expose s\'), r) | parseForall (Cons ((ID (_, "exists"), r), s\'))  = exists (parseDecs (expose s\'), r) | parseForall (Cons ((ID (_, "true"), r), s\'))  = top (expose s\', r) | parseForall (Cons ((t, r), s\'))  = error (r, "Expected `forall\', `exists\', or `true\', found " ^ toString t)(* parseForallStar "forall* decs mform | mform" *) parseForallStar (Cons ((ID (_, "forall*"), r), s\'))  = forallStar (parseDecs (expose s\'), r) | parseForallStar (Cons ((ID (_, "forall"), r), s\'))  = forall (parseDecs (expose s\'), r) | parseForallStar (Cons ((ID (_, "exists"), r), s\'))  = exists (parseDecs (expose s\'), r) | parseForallStar (Cons ((ID (_, "true"), r), s\'))  = top (expose s\', r) | parseForallStar (Cons ((t, r), s\'))  = error (r, "Expected `forall*\', `forall\', `exists\', or `true\', found " ^ toString t)parseCtxScheme (Cons ((ID (_, "forallG"), r), s\'))  = forallG (parseGBs (expose s\'), r) | parseCtxScheme (Cons ((ID (_, "forall*"), r), s\'))  = forallStar (parseDecs (expose s\'), r) | parseCtxScheme (Cons ((ID (_, "forall"), r), s\'))  = forall (parseDecs (expose s\'), r) | parseCtxScheme (Cons ((ID (_, "exists"), r), s\'))  = exists (parseDecs (expose s\'), r) | parseCtxScheme (Cons ((ID (_, "true"), r), s\'))  = top (expose s\', r) | parseCtxScheme (Cons ((t, r), s\'))  = error (r, "Expected `forallG\', `forall*\', `forall\', `exists\', or `true\', found " ^ toString t) (* parseColon ": mform" *) let rec parseColon (Cons ((COLON, r), s\'))  = parseCtxScheme (expose s\') | parseColon (Cons ((t, r), s\'))  = error (r, "Expected `:\', found " ^ toString t) (* parseThDec "id : mform" *) let rec parseThDec (Cons ((ID (_, id), r), s\'))  = let (t\', f\') = parseColon (expose s\') in (dec (id, t\'), f\') | parseThDec (Cons ((t, r), s\'))  = error (r, "Expected theorem identifier, found " ^ toString t) (* parseTheoremDec\' "%theorem thdec." *) (* We enforce the quantifier alternation restriction syntactically *) let rec parseTheoremDec\' (Cons ((THEOREM, r), s\'))  = parseThDec (expose s\') (*  -bp6/5/99. *) (* parsePredicate f = (pred, f\')               *) (* parses the reduction predicate, <, <=, =   *) let rec parsePredicate (Cons ((ID (_, "<"), r), s\'))  = (predicate ("LESS", r), (expose s\')) | parsePredicate (Cons ((ID (_, "<="), r), s\'))  = (predicate ("LEQ", r), (expose s\')) | parsePredicate (Cons ((EQUAL, r), s\'))  = (predicate ("EQUAL", r), (expose s\')) | parsePredicate (Cons ((t, r), s\'))  = error (r, "Expected reduction predicate <, = or <=, found " ^ toString t) (* parseRDecl "order callPats." *) (* parses Reducer Declaration, followed by `.\' *) let rec parseRDecl f  = let (oOut, f1) = parseOrder f let (p, f2) = parsePredicate f1 let (oIn, f3) = parseOrder f2 let (callpats, f4) = parseCallPats f3 in (rdecl (p, oOut, oIn, callpats callpats), f4) (* parseReduces\' "%reduces thedec. " *) let rec parseReduces\' (Cons ((REDUCES, r), s\'))  = parseRDecl (expose s\') let rec parseTabledDecl (f as Cons ((ID (_, id), r), s\'))  = (match (expose s\') with (f as Cons ((DOT, r\'), s)) -> (tableddecl (id, r), f) | _ -> error (r, "Expected .")) (* parseTabled\' "%tabled thedec. " *) let rec parseTabled\' (Cons ((TABLED, r), s\'))  = parseTabledDecl (expose s\') let rec parseKeepTableDecl (f as Cons ((ID (_, id), r), s\'))  = (match (expose s\') with (f as Cons ((DOT, r\'), s)) -> (keepTabledecl (id, r), f) | _ -> error (r, "Expected .")) (* parseKeepTable\' "%keepTabled thedec. " *) let rec parseKeepTable\' (Cons ((KEEPTABLE, r), s\'))  = parseKeepTableDecl (expose s\') let rec parseWDecl f  = (*       val (GBs, f1) = parseGBs f *) let (qids, f1) = parseQualIds\' f let (callpats, f2) = parseCallPats f1 in (wdecl (qids, callpats callpats), f2) let rec parseWorlds\' (Cons ((WORLDS, r), s\'))  = parseWDecl (expose s\') let parseTotal\' = parseTotal\' let parseTerminates\' = parseTerminates\' let parseTheorem\' = parseForallStar let parseTheoremDec\' = parseTheoremDec\' let parseProve\' = parseProve\' let parseEstablish\' = parseEstablish\' let parseAssert\' = parseAssert\' let parseReduces\' = parseReduces\' (*  -bp  6/05/99.*) let parseTabled\' = parseTabled\' (*  -bp 20/11/01.*) let parseKeepTable\' = parseKeepTable\' (*  -bp 20/11/01.*) let parseWorlds\' = parseWorlds\'  (* local ... in *)  end\n(* functor Parser *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Reconstruct Termination Information *) (* Author: Carsten Schuermann *) (* Modified: Brigitte Pientka *) module ReconThm (module Global : GLOBAL(* structure IntSyn : INTSYN *) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn !*) module Constraints : CONSTRAINTSmodule Names : NAMES(*! sharing Names.IntSyn = IntSyn !*) (*! structure Paths\' : PATHS !*) module ThmSyn\' : THMSYNThmSyn\'NamesNamesmodule ReconTerm\' : RECON_TERM(*! sharing ReconTerm\'.IntSyn = IntSyn !*) (*! sharing ReconTerm\'.Paths = Paths\'  !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn !*) ) : RECON_THM = struct module ThmSyn = ThmSyn\' (*! structure Paths = Paths\' !*)  module ExtSyn = ReconTerm\' exception Error of string module M = ModeSynmodule I = IntSynmodule L = ThmSynmodule P = Pathsmodule T = ReconTerm\'let rec error (r, msg)  = raise (Error (wrap (r, msg))) type order = Order * region let rec varg (r, L)  = (Varg L, r) let rec lex (r0, L)  = let rec lex\' nil  = (nil, r0) | lex\' ((O, r) :: L)  = let (Os, r\') = lex\' L in (O :: Os, join (r, r\')) let (Os, r1) = lex\' L in (Lex Os, r1) let rec simul (r0, L)  = let rec simul\' nil  = (nil, r0) | simul\' ((O, r) :: L)  = let (Os, r\') = simul\' L in (O :: Os, join (r, r\')) let (Os, r1) = simul\' L in (Simul Os, r1) type callpats = (Callpats * region list) let rec checkArgNumber (0, Uni (Type), nil, r)  = () | checkArgNumber (0, Pi (_, V2), arg :: args, r)  = checkArgNumber (0, V2, args, r) | checkArgNumber (0, Pi (_, V2), nil, r)  = error (r, "Missing arguments in call pattern") | checkArgNumber (0, Uni (Type), arg :: args, r)  = error (r, "Extraneous arguments in call pattern") | checkArgNumber (i, Pi (_, V2), args, r)  = checkArgNumber (i - 1, V2, args, r) (* everything else should be impossible! *) let rec checkCallPat (ConDec (_, _, i, Normal, V, Kind), P, r)  = checkArgNumber (i, V, P, r) | checkCallPat (ConDec (a, _, _, Constraint _, _, _), P, r)  = error (r, "Illegal constraint constant " ^ a ^ " in call pattern") | checkCallPat (ConDec (a, _, _, Foreign _, _, _), P, r)  = error (r, "Illegal foreign constant " ^ a ^ " in call pattern") | checkCallPat (ConDec (a, _, _, _, _, Type), P, r)  = error (r, "Constant " ^ a ^ " in call pattern not a type family") | checkCallPat (ConDef (a, _, _, _, _, _, _), P, r)  = error (r, "Illegal defined constant " ^ a ^ " in call pattern") | checkCallPat (AbbrevDef (a, _, _, _, _, _), P, r)  = error (r, "Illegal abbreviation " ^ a ^ " in call pattern") | checkCallPat (BlockDec (a, _, _, _), P, r)  = error (r, "Illegal block identifier " ^ a ^ " in call pattern") | checkCallPat (SkoDec (a, _, _, _, _), P, r)  = error (r, "Illegal Skolem constant " ^ a ^ " in call pattern") let rec callpats L  = let rec callpats\' nil  = (nil, nil) | callpats\' ((name, P, r) :: L)  = let (cps, rs) = (callpats\' L) let qid = Qid (nil, name) in (* check whether they are families here? *) match constLookup qid with NONE -> error (r, "Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in call pattern") | SOME cid -> (checkCallPat (sgnLookup cid, P, r); ((cid, P) :: cps, (r :: rs))) let (cps, rs) = callpats\' L in (Callpats (cps), rs) type tdecl = TDecl * (region * region list) let rec tdecl ((O, r), (C, rs))  = (TDecl (O, C), (r, rs)) let rec tdeclTotDecl T  = T (* -bp *) (* predicate *) type predicate = Predicate * region let rec predicate ("LESS", r)  = (Less, r) | predicate ("LEQ", r)  = (Leq, r) | predicate ("EQUAL", r)  = (Eq, r) (* reduces declaration *) type rdecl = RDecl * (region * region list) let rec rdecl ((P, r0), (O1, r1), (O2, r2), (C, rs))  = let r = join (r1, r2) in (RDecl (RedOrder (P, O1, O2), C), (join (r0, r), rs)) let rec rdeclTorDecl T  = T (* tabled declaration *) type tableddecl = (TabledDecl * region) let rec tableddecl (name, r)  = let qid = Qid (nil, name) in (* check whether they are families here? *) match constLookup qid with NONE -> error (r, "Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in call pattern") | SOME cid -> (TabledDecl cid, r) let rec tableddeclTotabledDecl T  = T (* keepTable declaration *) type keepTabledecl = (KeepTableDecl * region) let rec keepTabledecl (name, r)  = let qid = Qid (nil, name) in (* check whether they are families here? *) match constLookup qid with NONE -> error (r, "Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in call pattern") | SOME cid -> (KeepTableDecl cid, r) let rec keepTabledeclToktDecl T  = T (* Theorem and prove declarations *) type prove = PDecl * (region * region list) let rec prove (n, (td, rrs))  = (PDecl (n, td), rrs) let rec proveToProve P  = P type establish = PDecl * (region * region list) let rec establish (n, (td, rrs))  = (PDecl (n, td), rrs) let rec establishToEstablish P  = P type assert = Callpats * region list let rec assert (cp, rs)  = (cp, rs) let rec assertToAssert P  = P type decs = dec Ctx let null = Null let decl = Decl type labeldec = decs * decs type thm = labeldec list * dec Ctx * Mode Ctx * int type theorem = thm -> thm type theoremdec = string * theorem let rec dec (name, t)  = (name, t) let rec ctxAppend (G, Null)  = G | ctxAppend (G, Decl (G\', D))  = Decl (ctxAppend (G, G\'), D) let rec ctxMap f (Null)  = Null | ctxMap f (Decl (G, D))  = Decl (ctxMap f G, f D) let rec ctxBlockToString (G0, (G1, G2))  = let _ = varReset Null let G0\' = ctxName G0 let G1\' = ctxLUName G1 let G2\' = ctxLUName G2 in ctxToString (Null, G0\') ^ "\\n" ^ (match G1\' with Null -> "" | _ -> "some " ^ ctxToString (G0\', G1\') ^ "\\n") ^ "pi " ^ ctxToString (ctxAppend (G0\', G1\'), G2\') let rec checkFreevars (Null, (G1, G2), r)  = () | checkFreevars (G0, (G1, G2), r)  = let _ = varReset Null let G0\' = ctxName G0 let G1\' = ctxLUName G1 let G2\' = ctxLUName G2 in error (r, "Free variables in context block after term reconstruction:\\n" ^ ctxBlockToString (G0\', (G1\', G2\'))) let rec abstractCtxPair (g1, g2)  = (* each block reconstructed independent of others *) let r = (match (ctxRegion g1, ctxRegion g2) with (SOME r1, SOME r2) -> join (r1, r2) | (_, SOME r2) -> r2) let JWithCtx (G1, JWithCtx (G2, _)) = recon (jwithctx (g1, jwithctx (g2, jnothing))) let (G0, [G1\'; G2\']) = (* closed nf *) try  with  let _ = checkFreevars (G0, (G1\', G2\'), r) in (G1\', G2\') let rec top (GBs, g, M, k)  = (GBs, g, M, k) let rec exists (g\', t) (GBs, g, M, k)  = t (GBs, ctxAppend (g, g\'), ctxAppend (M, ctxMap (fun _ -> Minus) g\'), k) let rec forall (g\', t) (GBs, g, M, k)  = t (GBs, ctxAppend (g, g\'), ctxAppend (M, ctxMap (fun _ -> Plus) g\'), k) let rec forallStar (g\', t) (GBs, g, M, _)  = t (GBs, ctxAppend (g, g\'), ctxAppend (M, ctxMap (fun _ -> Plus) g\'), ctxLength g\') let rec forallG (gbs, t : thm -> thm) (_ : thm)  thm  = t (gbs, Null, Null, 0) let rec theoremToTheorem t  = let (gbs, g, M, k) = t (nil, Null, Null, 0) let _ = varReset Null let GBs = map abstractCtxPair gbs let JWithCtx (G, _) = recon (jwithctx (g, jnothing)) in ThDecl (GBs, G, M, k) let rec theoremDecToTheoremDec (name, t)  = (name, theoremToTheorem t) (* World checker *) let rec abstractWDecl W  = let W\' = map Qid W in W\' type wdecl = WDecl * region list let rec wdecl (W, (cp, rs))  = (WDecl (abstractWDecl W, cp), rs) let rec wdeclTowDecl T  = T (* avoid this re-copying? -fp *) type order = order let varg = varg let lex = lex let simul = simul type callpats = callpats let callpats = callpats type tdecl = tdecl let tdecl = tdecl (* -bp *) type predicate = predicate let predicate = predicate (* -bp *) type rdecl = rdecl let rdecl = rdecl type tableddecl = tableddecl let tableddecl = tableddecl type keepTabledecl = keepTabledecl let keepTabledecl = keepTabledecl type prove = prove let prove = prove type establish = establish let establish = establish type assert = assert let assert = assert let tdeclTotDecl = tdeclTotDecl let rdeclTorDecl = rdeclTorDecl let tableddeclTotabledDecl = tableddeclTotabledDecl let keepTabledeclToktDecl = keepTabledeclToktDecl let proveToProve = proveToProve let establishToEstablish = establishToEstablish let assertToAssert = assertToAssert type decs = decs let null = null let decl = decl type theorem = theorem let top = top let forallStar = forallStar let forall = forall let exists = exists let forallG = forallG let theoremToTheorem = theoremToTheorem type theoremdec = theoremdec let dec = dec let theoremDecToTheoremDec = theoremDecToTheoremDec type wdecl = wdecl let wdeclTowDecl = wdeclTowDecl let wdecl = wdecl  (* local *)  end(* functor ReconThm *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Parsing Theorems *) (* Author: Carsten Schuermann *) module type PARSE_THM = sig (*! structure Parsing : PARSING !*) module ThmExtSyn : THMEXTSYNval parseTotal' : tdecl parser(* -fp *) val parseTerminates' : tdecl parserval parseReduces' : rdecl parser(* -bp *) val parseTabled' : tableddecl parser(* -bp *) val parseKeepTable' : keepTabledecl parser(* -bp *) val parseTheorem' : theorem parserval parseTheoremDec' : theoremdec parserval parseWorlds' : wdecl parserval parseProve' : prove parserval parseEstablish' : establish parserval parseAssert' : assert parser end\n(* signature PARSE_THM *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* General basis for parsing modules *) (* Author: Frank Pfenning *) module type PARSING = sig module Stream : STREAM(*\n  structure Lexer : LEXER\n    sharing Lexer.Stream = Stream\n  *) type lexResult = Token * regiontype 'aparser = lexResult front -> 'a * lexResult front(* recursive parser (allows parsing functions that need to parse\n     a signature expression to temporarily suspend themselves) *) type 'aRecParseResultDone'aContinuation'a RecParseResult parsertype 'arecparser = 'a RecParseResult parser(* useful combinator for recursive parsers *) val recwith : 'a recparser * ('a -> 'b) -> 'b recparserexception Error of stringval error : region * string -> 'a(* always raises Error *)  end\n(* signature PARSING *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Top-Level Parser *) (* Author: Frank Pfenning *) module Parser ((*! structure Parsing\' : PARSING !*) module Stream\' : STREAM(* result stream *) module ExtSyn\' : EXTSYN(*! sharing ExtSyn\'.Paths = Parsing\'.Lexer.Paths !*) module Names\' : NAMESmodule ExtConDec\' : EXTCONDECmodule ExtQuery\' : EXTQUERYmodule ExtModes\' : EXTMODESmodule ThmExtSyn\' : THMEXTSYNmodule ModExtSyn\' : MODEXTSYNmodule ParseConDec : PARSE_CONDEC(*! sharing ParseConDec.Lexer = Parsing\'.Lexer !*) ParseConDecExtConDecExtConDec\'module ParseQuery : PARSE_QUERY(*! sharing ParseQuery.Lexer = Parsing\'.Lexer !*) ParseQueryExtQueryExtQuery\'module ParseFixity : PARSE_FIXITY(*! sharing ParseFixity.Lexer = Parsing\'.Lexer !*) ParseFixityNamesNames\'module ParseMode : PARSE_MODE(*! sharing ParseMode.Lexer = Parsing\'.Lexer !*) ParseModeExtModesExtModes\'module ParseThm : PARSE_THM(*! sharing ParseThm.Lexer = Parsing\'.Lexer !*) ParseThmThmExtSynThmExtSyn\'module ParseModule : PARSE_MODULE(*! sharing ParseModule.Parsing = Parsing\' !*) ParseModuleModExtSynModExtSyn\'module ParseTerm : PARSE_TERM(*! sharing ParseTerm.Lexer = Parsing\'.Lexer !*) ParseTermExtSynExtSyn\') : PARSER = struct (*! structure Parsing = Parsing\' !*)  module Stream = Stream\' module ExtSyn = ExtSyn\' module Names = Names\' module ExtConDec = ExtConDec\' module ExtQuery = ExtQuery\' module ExtModes = ExtModes\' module ThmExtSyn = ThmExtSyn\' module ModExtSyn = ModExtSyn\' type fileParseResult = ConDec of condec | FixDec of (Qid * region) * fixity | NamePref of (Qid * region) * (string list * string list) | ModeDec of modedec list | UniqueDec of modedec list | CoversDec of modedec list | TotalDec of tdecl | TerminatesDec of tdecl | WorldDec of wdecl | ReducesDec of rdecl | TabledDec of tableddecl | KeepTableDec of keepTabledecl | TheoremDec of theoremdec | ProveDec of prove | EstablishDec of establish | AssertDec of assert | Query of int option * int option * query | FQuery of query | Compile of Qid list | Querytabled of int option * int option * query | Solve of define list * solve | AbbrevDec of condec | TrustMe of fileParseResult * region | SubordDec of Qid * Qid list | FreezeDec of Qid list | ThawDec of Qid list | DeterministicDec of Qid list | ClauseDec of condec | SigDef of sigdef | StructDec of structdec | Include of sigexp | Open of strexp | BeginSubsig | EndSubsig | Use of string (* Further pragmas to be added later here *)  module L = Lexermodule LS = LexerStreamlet rec stripDot (Cons ((DOT, r), s))  = s | stripDot (Cons ((RPAREN, r), s))  = error (r, "Unexpected right parenthesis") | stripDot (Cons ((RBRACE, r), s))  = error (r, "Unexpected right brace") | stripDot (Cons ((RBRACKET, r), s))  = error (r, "Unexpected right bracket") | stripDot (Cons ((EOF, r), s))  = error (r, "Unexpected end of file") | stripDot (Cons ((EQUAL, r), s))  = error (r, "Unexpected `=\'") | stripDot (Cons ((t, r), s))  = error (r, "Expected `.\', found " ^ toString t) (* Everything else should be impossible *) (*\n    fun stripOptionalDot (LS.Cons ((L.DOT,r), s)) = s\n      | stripOptionalDot f = LS.delay (fn () => f)\n    *) let rec parseBound\' (Cons ((ID (_, "*"), r), s\'))  = (NONE, s\') | parseBound\' (Cons ((ID (_, name), r), s\'))  = (try  with ) | parseBound\' (Cons ((t, r), s\'))  = error (r, "Expected bound `*\' or natural number, found " ^ toString t) (* pass parseStream as theSigParser in order to be able to use\n       this function polymorphically in the definition of parseStream *) let rec recParse (s, recparser, theSigParser, sc)  = delay (fun () -> recParse\' (expose s, recparser, theSigParser, sc))recParse\' (f, recparser, theSigParser, sc)  = (match recparser f with (Done x, f\') -> sc (x, f\') | (Continuation k, Cons ((LBRACE, r1), s\')) -> let rec finish (Cons ((RBRACE, r2), s\'\'))  = Cons ((EndSubsig, r2), recParse (s\'\', k, theSigParser, sc)) | finish (Cons ((t, r), _))  = error (r, "Expected `}\', found " ^ toString t) in Cons ((BeginSubsig, r1), theSigParser (s\', finish)) | (Continuation _, Cons ((t, r), _)) -> error (r, "Expected `{\', found " ^ toString t)) let rec parseStream (s, sc)  = delay (fun () -> parseStream\' (expose s, sc))(* parseStream\' : lexResult front -> fileParseResult front *) (* parseStream\' switches between various specialized parsers *) parseStream\' (f as Cons ((ID (idCase, name), r0), s\'), sc)  = parseConDec\' (f, sc) | parseStream\' (f as Cons ((ABBREV, r), s\'), sc)  = parseAbbrev\' (f, sc) | parseStream\' (f as Cons ((UNDERSCORE, r), s\'), sc)  = parseConDec\' (f, sc) | parseStream\' (f as Cons ((INFIX, r), s\'), sc)  = parseFixity\' (f, sc) | parseStream\' (f as Cons ((PREFIX, r), s\'), sc)  = parseFixity\' (f, sc) | parseStream\' (f as Cons ((POSTFIX, r), s\'), sc)  = parseFixity\' (f, sc) | parseStream\' (f as Cons ((NAME, r1), s\'), sc)  = let (namePref, f\' as Cons ((_, r2), _)) = parseNamePref\' f let r = join (r1, r2) in Cons ((NamePref namePref, r), parseStream (stripDot f\', sc)) | parseStream\' (f as Cons ((DEFINE, r), s\'), sc)  = parseSolve\' (f, sc) | parseStream\' (f as Cons ((SOLVE, r), s\'), sc)  = parseSolve\' (f, sc) | parseStream\' (Cons ((QUERY, r0), s\'), sc)  = let (expected, s1) = parseBound\' (expose s\') let (try, s2) = parseBound\' (expose s1) let (query, f3 as Cons ((_, r\'), _)) = parseQuery\' (expose s2) let r = join (r0, r\') in Cons ((Query (expected, try, query), r), parseStream (stripDot f3, sc)) | parseStream\' (Cons ((FQUERY, r0), s\'), sc)  = let (query, f3 as Cons ((_, r\'), _)) = parseQuery\' (expose s\') let r = join (r0, r\') in Cons ((FQuery query, r), parseStream (stripDot f3, sc)) | parseStream\' (Cons ((QUERYTABLED, r0), s\'), sc)  = let (numSol, s1) = parseBound\' (expose s\') let (try, s2) = parseBound\' (expose s1) let (query, f3 as Cons ((_, r\'), _)) = parseQuery\' (expose s2) let r = join (r0, r\') in Cons ((Querytabled (numSol, try, query), r), parseStream (stripDot f3, sc)) | parseStream\' (f as Cons ((MODE, r), s\'), sc)  = parseMode\' (f, sc) | parseStream\' (f as Cons ((UNIQUE, r), s\'), sc)  = parseUnique\' (f, sc) | parseStream\' (f as Cons ((COVERS, r), s\'), sc)  = parseCovers\' (f, sc) | parseStream\' (f as Cons ((TOTAL, r), s\'), sc)  = parseTotal\' (f, sc) | parseStream\' (f as Cons ((TERMINATES, r), s\'), sc)  = parseTerminates\' (f, sc) | parseStream\' (f as Cons ((BLOCK, r), s\'), sc)  = parseConDec\' (f, sc) | parseStream\' (f as Cons ((WORLDS, r), s\'), sc)  = parseWorlds\' (f, sc) | parseStream\' (f as Cons ((REDUCES, r), s\'), sc)  = parseReduces\' (f, sc) | parseStream\' (f as Cons ((TABLED, r), s\'), sc)  = parseTabled\' (f, sc) | parseStream\' (f as Cons ((KEEPTABLE, r), s\'), sc)  = parseKeepTable\' (f, sc) | parseStream\' (f as Cons ((THEOREM, r), s\'), sc)  = parseTheorem\' (f, sc) | parseStream\' (f as Cons ((PROVE, r), s\'), sc)  = parseProve\' (f, sc) | parseStream\' (f as Cons ((ESTABLISH, r), s\'), sc)  = parseEstablish\' (f, sc) | parseStream\' (f as Cons ((ASSERT, r), s\'), sc)  = parseAssert\' (f, sc) | parseStream\' (f as Cons ((TRUSTME, r), s\'), sc)  = parseTrustMe\' (f, sc) | parseStream\' (f as Cons ((FREEZE, r), s\'), sc)  = parseFreeze\' (f, sc) | parseStream\' (f as Cons ((SUBORD, r), s\'), sc)  = parseSubord\' (f, sc) | parseStream\' (f as Cons ((THAW, r), s\'), sc)  = parseThaw\' (f, sc) | parseStream\' (f as Cons ((DETERMINISTIC, r), s\'), sc)  = parseDeterministic\' (f, sc) | parseStream\' (f as Cons ((COMPILE, r), s\'), sc)  = parseCompile\' (f, sc) | parseStream\' (f as Cons ((CLAUSE, r), s\'), sc)  = parseClause\' (f, sc) | parseStream\' (f as Cons ((SIG, r), s\'), sc)  = parseSigDef\' (f, sc) | parseStream\' (f as Cons ((STRUCT, r), s\'), sc)  = parseStructDec\' (f, sc) | parseStream\' (f as Cons ((INCLUDE, r), s\'), sc)  = parseInclude\' (f, sc) | parseStream\' (f as Cons ((OPEN, r), s\'), sc)  = parseOpen\' (f, sc) | parseStream\' (f as Cons ((USE, r), s\'), sc)  = parseUse\' (expose s\', sc) | parseStream\' (f as Cons ((EOF, _), _), sc)  = sc f | parseStream\' (f as Cons ((RBRACE, _), _), sc)  = sc f | parseStream\' (Cons ((t, r), s\'), sc)  = error (r, "Expected constant name or pragma keyword, found " ^ toString t)parseConDec\' (f as Cons ((_, r0), _), sc)  = let (conDec, f\' as Cons ((_, r\'), _)) = parseConDec\' (f) let r = join (r0, r\') in Cons ((ConDec conDec, r), parseStream (stripDot f\', sc))parseAbbrev\' (f as Cons ((_, r0), _), sc)  = let (conDec, f\' as Cons ((_, r\'), _)) = parseAbbrev\' (f) let r = join (r0, r\') in Cons ((AbbrevDec conDec, r), parseStream (stripDot f\', sc))parseClause\' (f as Cons ((_, r0), _), sc)  = let (conDec, f\' as Cons ((_, r\'), _)) = parseClause\' (f) let r = join (r0, r\') in Cons ((ClauseDec conDec, r), parseStream (stripDot f\', sc))parseFixity\' (f as Cons ((_, r0), _), sc)  = let (fdec, f\' as Cons ((_, r\'), _)) = parseFixity\' (f) let r = join (r0, r\') in Cons ((FixDec fdec, r), parseStream (stripDot f\', sc))parseSolve\' (f as Cons ((_, r0), _), sc)  = let (defnssolve, f\' as Cons ((_, r\'), _)) = parseSolve\' (f) let r = join (r0, r\') in Cons ((Solve defnssolve, r), parseStream (stripDot f\', sc))parseMode\' (f as Cons ((_, r0), _), sc)  = let (mdecs, f\' as Cons ((_, r\'), _)) = parseMode\' (f) let r = join (r0, r\') in Cons ((ModeDec mdecs, r), parseStream (stripDot f\', sc))parseUnique\' (f as Cons ((_, r0), _), sc)  = let (mdecs, f\' as Cons ((_, r\'), _)) = parseMode\' (f) let r = join (r0, r\') in Cons ((UniqueDec mdecs, r), parseStream (stripDot f\', sc))parseCovers\' (f as Cons ((_, r0), _), sc)  = let (mdecs, f\' as Cons ((_, r\'), _)) = parseMode\' (f) let r = join (r0, r\') in Cons ((CoversDec mdecs, r), parseStream (stripDot f\', sc))parseTotal\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseTotal\' (f) let r = join (r0, r\') in Cons ((TotalDec ldec, r), parseStream (stripDot f\', sc))parseTerminates\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseTerminates\' (f) let r = join (r0, r\') in Cons ((TerminatesDec ldec, r), parseStream (stripDot f\', sc))parseReduces\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseReduces\' (f) let r = join (r0, r\') in Cons ((ReducesDec ldec, r), parseStream (stripDot f\', sc))parseTabled\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseTabled\' (f) let r = join (r0, r\') in Cons ((TabledDec ldec, r), parseStream (stripDot f\', sc))parseKeepTable\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseKeepTable\' (f) let r = join (r0, r\') in Cons ((KeepTableDec ldec, r), parseStream (stripDot f\', sc))parseWorlds\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseWorlds\' (f) let r = join (r0, r\') in Cons ((WorldDec ldec, r), parseStream (stripDot f\', sc))parseTheorem\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseTheoremDec\' (f) let r = join (r0, r\') in Cons ((TheoremDec ldec, r), parseStream (stripDot f\', sc))parseProve\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseProve\' (f) let r = join (r0, r\') in Cons ((ProveDec ldec, r), parseStream (stripDot f\', sc))parseEstablish\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseEstablish\' (f) let r = join (r0, r\') in Cons ((EstablishDec ldec, r), parseStream (stripDot f\', sc))parseAssert\' (f as Cons ((_, r0), _), sc)  = let (ldec, f\' as Cons ((_, r\'), _)) = parseAssert\' (f) let r = join (r0, r\') in Cons ((AssertDec ldec, r), parseStream (stripDot f\', sc))parseTrustMe\' (f as Cons ((_, r0), s), sc)  = let rec parseNextDec\' (Cons ((dec, r), s\'))  = Cons ((TrustMe (dec, r), r0), s\') | parseNextDec\' (Empty)  = error (r0, "No declaration after `%trustme\'") in parseNextDec\' (parseStream\' (expose s, sc))parseSubord\' (f as Cons ((_, r0), s), sc)  = let (qidpairs, f\' as Cons ((_, r\'), _)) = parseSubord\' (expose s) let r = join (r0, r\') let qidpairs = map (fun (qid1, qid2) -> (Qid qid1, Qid qid2)) qidpairs in Cons ((SubordDec qidpairs, r), parseStream (stripDot f\', sc))parseFreeze\' (f as Cons ((_, r0), s), sc)  = let (qids, f\' as Cons ((_, r\'), _)) = parseFreeze\' (expose s) let r = join (r0, r\') let qids = map Qid qids in Cons ((FreezeDec qids, r), parseStream (stripDot f\', sc))parseThaw\' (f as Cons ((_, r0), s), sc)  = let (qids, f\' as Cons ((_, r\'), _)) = parseThaw\' (expose s) let r = join (r0, r\') let qids = map Qid qids in Cons ((ThawDec qids, r), parseStream (stripDot f\', sc))parseDeterministic\' (f as Cons ((_, r0), s), sc)  = let (qids, f\' as Cons ((_, r\'), _)) = parseDeterministic\' (expose s) let r = join (r0, r\') let qids = map Qid qids in Cons ((DeterministicDec qids, r), parseStream (stripDot f\', sc))(* ABP 4/4/03 *) parseCompile\' (f as Cons ((_, r0), s), sc)  = let (qids, f\' as Cons ((_, r\'), _)) = parseCompile\' (expose s) let r = join (r0, r\') let qids = map Qid qids in Cons ((Compile qids, r), parseStream (stripDot f\', sc))parseSigDef\' (f as Cons ((_, r1), _), sc)  = let rec finish (sigdef, f\' as Cons ((_, r2), _))  = Cons ((SigDef sigdef, join (r1, r2)), parseStream (stripDot f\', sc)) in recParse\' (f, parseSigDef\', parseStream, finish)parseStructDec\' (f as Cons ((_, r1), _), sc)  = let rec finish (structdec, f\' as Cons ((_, r2), _))  = Cons ((StructDec structdec, join (r1, r2)), parseStream (stripDot f\', sc)) in recParse\' (f, parseStructDec\', parseStream, finish)parseInclude\' (f as Cons ((_, r1), _), sc)  = let rec finish (sigexp, f\' as Cons ((_, r2), _))  = Cons ((Include sigexp, join (r1, r2)), parseStream (stripDot f\', sc)) in recParse\' (f, parseInclude\', parseStream, finish)parseOpen\' (f as Cons ((_, r1), _), sc)  = let (strexp, f\' as Cons ((_, r2), _)) = parseOpen\' (f) in Cons ((Open strexp, join (r1, r2)), parseStream (stripDot f\', sc))parseUse\' (Cons ((ID (_, name), r0), s), sc)  = let f as Cons ((_, r\'), _) = expose s let r = join (r0, r\') in Cons ((Use name, r), parseStream (stripDot f, sc)) | parseUse\' (Cons ((_, r), _), sc)  = error (r, "Constraint solver name expected") let rec parseQ (s)  = delay (fun () -> parseQ\' (expose s))parseQ\' (f)  = let (query, f\') = parseQuery\' (f) in Cons (query, parseQ (stripDot (f\'))) let rec parseTLStream instream  = let rec finish (Cons ((EOF, r), s))  = Empty | finish (Cons ((RBRACE, r), s))  = error (r, "Unmatched `}\'") in parseStream (lexStream instream, finish) let parseStream = parseTLStream let rec parseTerminalQ prompts  = parseQ (lexTerminal prompts)  (* local ... in *)  end\n(* functor Parser *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Lexer *) (* Author: Frank Pfenning *) (* Modified: Brigitte Pientka *) module Lexer (module Stream\' : STREAM(*! structure Paths\' : PATHS !*) ) : LEXER = struct module Stream = Stream\' (*! structure Paths = Paths\' !*)  module P = Pathstype IdCase = Upper | Lower | Quoted (* \'<id>\', currently unused *) type Token = EOF | DOT | PATHSEP | COLON | LPAREN | RPAREN | LBRACKET | RBRACKET | LBRACE | RBRACE | BACKARROW | ARROW | TYPE | EQUAL | ID of IdCase * string | UNDERSCORE | INFIX | PREFIX | POSTFIX | NAME | DEFINE | SOLVE | QUERY | FQUERY | COMPILE | QUERYTABLED | MODE | UNIQUE | COVERS | TOTAL | TERMINATES | REDUCES | TABLED | KEEPTABLE | THEOREM | BLOCK | WORLDS | PROVE | ESTABLISH | ASSERT | ABBREV | TRUSTME | FREEZE | THAW | SUBORD | DETERMINISTIC | CLAUSE | SIG | STRUCT | WHERE | INCLUDE | OPEN | USE | STRING of string (* string constants *) exception Error of string let rec error (r, msg)  = raise (Error (wrap (r, msg))) (* isSym (c) = B iff c is a legal symbolic identifier constituent *) (* excludes quote character and digits, which are treated specially *) (* Char.contains stages its computation *) let isSym : char -> bool = contains "_!&$^+/<=>?@~|#*`;,-\\\\" (* isUFT8 (c) = assume that if a character is not ASCII it must be\n     part of a UTF8 Unicode encoding.  Treat these as lowercase\n     identifiers.  Somewhat of a hack until there is native Unicode\n     string support. *) let rec isUTF8 (c)  = not (isAscii c) (* isQuote (c) = B iff c is the quote character *) let rec isQuote (c)  = (c = \'\'\') (* isIdChar (c) = B iff c is legal identifier constituent *) let rec isIdChar (c)  = isLower (c) || isUpper (c) || isDigit (c) || isSym (c) || isQuote (c) || isUTF8 (c) (* stringToToken (idCase, string, region) = (token, region)\n     converts special identifiers into tokens, returns ID token otherwise\n  *) let rec stringToToken (Lower, "<-", r)  = (BACKARROW, r) | stringToToken (Lower, "->", r)  = (ARROW, r) | stringToToken (Upper, "_", r)  = (UNDERSCORE, r) | stringToToken (Lower, "=", r)  = (EQUAL, r) | stringToToken (Lower, "type", r)  = (TYPE, r) | stringToToken (idCase, s, r)  = (ID (idCase, s), r) (* lex (inputFun) = (token, region) stream\n\n     inputFun maintains state, reading input one line at a time and\n     returning a string terminated by <newline> each time.\n     The end of the stream is signalled by a string consisting only of ^D\n     Argument to inputFun is the character position.\n  *) let rec lex (inputFun : int -> string)  = (* The remaining functions do not access the state or *) (* stream directly, using only functions char and string *) (* Quote characters are part of the name *) (* Treat quoted identifiers as lowercase, since they no longer *) (* override infix state.  Quoted identifiers are now only used *) (* inside pragmas *) (* The main lexing functions take a character c and the next\n       input position i and return a token with its region\n       The name convention is lexSSS, where SSS indicates the state\n       of the lexer (e.g., what has been lexed so far).\n\n       Lexing errors are currently fatal---some error recovery code is\n       indicated in comments.\n    *) local (* local state maintained by the lexer *) ; let s = ref "" and left = ref 0 and right = ref 0; (* position after last character in s *) ; let _ = resetLines (); (* initialize line counter *) ; (* neither lexer nor parser should ever try to look beyond EOF *) ; let EOFString = str \'\\^D\'; (* readNext () = ()\n         Effect: read the next line, updating s, left, and right\n\n         readNext relies on the invariant that identifiers are never\n         spread across lines\n      *) ; let rec readNext ()  = let nextLine = inputFun (! right) let nextSize = size (nextLine) in if nextSize = 0(* end of file? *)  then (s := EOFString; (* fake EOF character string *) left := ! right; right := ! right + 1) else (s := nextLine; left := ! right; right := ! right + nextSize; newLine (! left))(* remember new line position *);  in (* char (i) = character at position i\n         Invariant: i >= !left\n         Effects: will read input if i >= !right\n      *) let rec char (i)  = if i >= ! right then (readNext (); char (i)) else sub (! s, i - ! left)(* string (i,j) = substring at region including i, excluding j\n         Invariant: i >= !left and i < j and j < !right\n                    Note that the relevant parts must already have been read!\n         Effects: None\n      *) let rec string (i, j)  = substring (! s, i - ! left, j - i) end let rec idToToken (idCase, Reg (i, j))  = stringToToken (idCase, string (i, j), Reg (i, j)) let rec qidToToken (Reg (i, j))  = (ID (Lower, string (i, j + 1)), Reg (i, j + 1)) let rec lexInitial (\':\', i)  = (COLON, Reg (i - 1, i)) | lexInitial (\'.\', i)  = (DOT, Reg (i - 1, i)) | lexInitial (\'(\', i)  = (LPAREN, Reg (i - 1, i)) | lexInitial (\')\', i)  = (RPAREN, Reg (i - 1, i)) | lexInitial (\'[\', i)  = (LBRACKET, Reg (i - 1, i)) | lexInitial (\']\', i)  = (RBRACKET, Reg (i - 1, i)) | lexInitial (\'{\', i)  = (LBRACE, Reg (i - 1, i)) | lexInitial (\'}\', i)  = (RBRACE, Reg (i - 1, i)) | lexInitial (\'%\', i)  = lexPercent (char (i), i + 1) | lexInitial (\'_\', i)  = lexID (Upper, Reg (i - 1, i)) | lexInitial (\'\'\', i)  = lexID (Lower, Reg (i - 1, i)) | lexInitial (\'\\^D\', i)  = (EOF, Reg (i - 1, i - 1)) | lexInitial (\'\\"\', i)  = lexString (Reg (i - 1, i)) | lexInitial (c, i)  = if isSpace (c) then lexInitial (char (i), i + 1) else if isUpper (c) then lexID (Upper, Reg (i - 1, i)) else if isDigit (c) then lexID (Lower, Reg (i - 1, i)) else if isLower (c) then lexID (Lower, Reg (i - 1, i)) else if isSym (c) then lexID (Lower, Reg (i - 1, i)) else if isUTF8 (c) then lexID (Lower, Reg (i - 1, i)) else error (Reg (i - 1, i), "Illegal character " ^ toString (c))(* recover by ignoring: lexInitial (char(i), i+1) *) lexID (idCase, Reg (i, j))  = let rec lexID\' (j)  = if isIdChar (char (j)) then lexID\' (j + 1) else idToToken (idCase, Reg (i, j)) in lexID\' (j)(* lexQUID is currently not used --- no quoted identifiers *) lexQUID (Reg (i, j))  = if isSpace (char (j)) then error (Reg (i, j + 1), "Whitespace in quoted identifier")(* recover by adding implicit quote? *) (* qidToToken (i, j) *)  else if isQuote (char (j)) then qidToToken (Reg (i, j)) else lexQUID (Reg (i, j + 1))lexPercent (\'.\', i)  = (EOF, Reg (i - 2, i)) | lexPercent (\'{\', i)  = lexPercentBrace (char (i), i + 1) | lexPercent (\'%\', i)  = lexComment (\'%\', i) | lexPercent (c, i)  = if isIdChar (c) then lexPragmaKey (lexID (Quoted, Reg (i - 1, i))) else if isSpace (c) then lexComment (c, i) else error (Reg (i - 1, i), "Comment character `%\' not followed by white space")lexPragmaKey (ID (_, "infix"), r)  = (INFIX, r) | lexPragmaKey (ID (_, "prefix"), r)  = (PREFIX, r) | lexPragmaKey (ID (_, "postfix"), r)  = (POSTFIX, r) | lexPragmaKey (ID (_, "mode"), r)  = (MODE, r) | lexPragmaKey (ID (_, "unique"), r)  = (UNIQUE, r) | lexPragmaKey (ID (_, "terminates"), r)  = (TERMINATES, r) | lexPragmaKey (ID (_, "block"), r)  = (BLOCK, r) | lexPragmaKey (ID (_, "worlds"), r)  = (WORLDS, r) | lexPragmaKey (ID (_, "covers"), r)  = (COVERS, r) | lexPragmaKey (ID (_, "total"), r)  = (TOTAL, r) | lexPragmaKey (ID (_, "reduces"), r)  = (REDUCES, r) | lexPragmaKey (ID (_, "tabled"), r)  = (TABLED, r) | lexPragmaKey (ID (_, "keepTable"), r)  = (KEEPTABLE, r) | lexPragmaKey (ID (_, "theorem"), r)  = (THEOREM, r) | lexPragmaKey (ID (_, "prove"), r)  = (PROVE, r) | lexPragmaKey (ID (_, "establish"), r)  = (ESTABLISH, r) | lexPragmaKey (ID (_, "assert"), r)  = (ASSERT, r) | lexPragmaKey (ID (_, "abbrev"), r)  = (ABBREV, r) | lexPragmaKey (ID (_, "name"), r)  = (NAME, r) | lexPragmaKey (ID (_, "define"), r)  = (DEFINE, r) | lexPragmaKey (ID (_, "solve"), r)  = (SOLVE, r) | lexPragmaKey (ID (_, "query"), r)  = (QUERY, r) | lexPragmaKey (ID (_, "fquery"), r)  = (FQUERY, r) | lexPragmaKey (ID (_, "compile"), r)  = (COMPILE, r) | lexPragmaKey (ID (_, "querytabled"), r)  = (QUERYTABLED, r) | lexPragmaKey (ID (_, "trustme"), r)  = (TRUSTME, r) | lexPragmaKey (ID (_, "subord"), r)  = (SUBORD, r) | lexPragmaKey (ID (_, "freeze"), r)  = (FREEZE, r) | lexPragmaKey (ID (_, "thaw"), r)  = (THAW, r) | lexPragmaKey (ID (_, "deterministic"), r)  = (DETERMINISTIC, r) | lexPragmaKey (ID (_, "clause"), r)  = (CLAUSE, r) | lexPragmaKey (ID (_, "sig"), r)  = (SIG, r) | lexPragmaKey (ID (_, "struct"), r)  = (STRUCT, r) | lexPragmaKey (ID (_, "where"), r)  = (WHERE, r) | lexPragmaKey (ID (_, "include"), r)  = (INCLUDE, r) | lexPragmaKey (ID (_, "open"), r)  = (OPEN, r) | lexPragmaKey (ID (_, "use"), r)  = (USE, r) | lexPragmaKey (ID (_, s), r)  = error (r, "Unknown keyword %" ^ s ^ " (single line comment starts with `%<whitespace>\' or `%%\')")(* comments are now started by %<whitespace> *) (*\n      | lexPragmaKey (_, (_,j)) = lexComment (char(j), j+1)\n      *) lexComment (\'\\n\', i)  = lexInitial (char (i), i + 1) | lexComment (\'%\', i)  = lexCommentPercent (char (i), i + 1) | lexComment (\'\\^D\', i)  = error (Reg (i - 1, i - 1), "Unclosed single-line comment at end of file") | lexComment (c, i)  = lexComment (char (i), i + 1)lexCommentPercent (\'.\', i)  = (EOF, Reg (i - 2, i)) | lexCommentPercent (c, i)  = lexComment (c, i)lexPercentBrace (c, i)  = lexDComment (c, 1, i)(* functions lexing delimited comments below take nesting level l *) lexDComment (\'}\', l, i)  = lexDCommentRBrace (char (i), l, i + 1) | lexDComment (\'%\', l, i)  = lexDCommentPercent (char (i), l, i + 1) | lexDComment (\'\\^D\', l, i)  = (* pass comment beginning for error message? *)  error (Reg (i - 1, i - 1), "Unclosed delimited comment at end of file") | lexDComment (c, l, i)  = lexDComment (char (i), l, i + 1)lexDCommentPercent (\'{\', l, i)  = lexDComment (char (i), l + 1, i + 1) | lexDCommentPercent (\'.\', l, i)  = error (Reg (i - 2, i), "Unclosed delimited comment at end of file token `%.\'") | lexDCommentPercent (c, l, i)  = lexDComment (c, l, i)lexDCommentRBrace (\'%\', 1, i)  = lexInitial (char (i), i + 1) | lexDCommentRBrace (\'%\', l, i)  = lexDComment (char (i), l - 1, i + 1) | lexDCommentRBrace (c, l, i)  = lexDComment (c, l, i)lexString (Reg (i, j))  = (match char (j) with (\'\\"\') -> (STRING (string (i, j + 1)), Reg (i, j + 1)) | (\'\\n\') -> error (Reg (i - 1, i - 1), "Unclosed string constant at end of line")(* recover: (EOL, (i-1,i-1)) *)  | (\'\\^D\') -> error (Reg (i - 1, i - 1), "Unclosed string constant at end of file")(* recover: (EOF, (i-1,i-1)) *)  | _ -> lexString (Reg (i, j + 1))) let rec lexContinue (j)  = delay (fun () -> lexContinue\' (j))lexContinue\' (j)  = lexContinue\'\' (lexInitial (char (j), j + 1))lexContinue\'\' (mt as (ID _, Reg (i, j)))  = Cons (mt, lexContinueQualId (j)) | lexContinue\'\' (mt as (token, Reg (i, j)))  = Cons (mt, lexContinue (j))lexContinueQualId (j)  = delay (fun () -> lexContinueQualId\' (j))lexContinueQualId\' (j)  = if char (j) = \'.\' then if isIdChar (char (j + 1)) then Cons ((PATHSEP, Reg (j, j + 1)), lexContinue (j + 1)) else Cons ((DOT, Reg (j, j + 1)), lexContinue (j + 1)) else lexContinue\' (j) in lexContinue (0) (* fun lex (inputFun) = let ... in ... end *) let rec lexStream (instream)  = lex (fun i -> inputLine97 (instream)) let rec lexTerminal (prompt0, prompt1)  = lex (fun 0 -> (print (prompt0); inputLine97 (stdIn)) | i -> (print (prompt1); inputLine97 (stdIn))) let rec toString\' (DOT)  = "." | toString\' (PATHSEP)  = "." | toString\' (COLON)  = ":" | toString\' (LPAREN)  = "(" | toString\' (RPAREN)  = ")" | toString\' (LBRACKET)  = "[" | toString\' (RBRACKET)  = "]" | toString\' (LBRACE)  = "{" | toString\' (RBRACE)  = "}" | toString\' (BACKARROW)  = "<-" | toString\' (ARROW)  = "->" | toString\' (TYPE)  = "type" | toString\' (EQUAL)  = "=" | toString\' (UNDERSCORE)  = "_" | toString\' (INFIX)  = "%infix" | toString\' (PREFIX)  = "%prefix" | toString\' (POSTFIX)  = "%postfix" | toString\' (NAME)  = "%name" | toString\' (DEFINE)  = "%define" | toString\' (SOLVE)  = "%solve" | toString\' (QUERY)  = "%query" | toString\' (FQUERY)  = "%fquery" | toString\' (COMPILE)  = "%compile" | toString\' (QUERYTABLED)  = "%querytabled" | toString\' (MODE)  = "%mode" | toString\' (UNIQUE)  = "%unique" | toString\' (COVERS)  = "%covers" | toString\' (TOTAL)  = "%total" | toString\' (TERMINATES)  = "%terminates" | toString\' (BLOCK)  = "%block" | toString\' (WORLDS)  = "%worlds" | toString\' (REDUCES)  = "%reduces" | toString\' (TABLED)  = "%tabled" | toString\' (KEEPTABLE)  = "%keepTable" | toString\' (THEOREM)  = "%theorem" | toString\' (PROVE)  = "%prove" | toString\' (ESTABLISH)  = "%establish" | toString\' (ASSERT)  = "%assert" | toString\' (ABBREV)  = "%abbrev" | toString\' (TRUSTME)  = "%trustme" | toString\' (SUBORD)  = "%subord" | toString\' (FREEZE)  = "%freeze" | toString\' (THAW)  = "%thaw" | toString\' (DETERMINISTIC)  = "%deterministic" | toString\' (CLAUSE)  = "%clause" | toString\' (SIG)  = "%sig" | toString\' (STRUCT)  = "%struct" | toString\' (WHERE)  = "%where" | toString\' (INCLUDE)  = "%include" | toString\' (OPEN)  = "%open" | toString\' (USE)  = "%use" let rec toString (ID (_, s))  = "identifier `" ^ s ^ "\'" | toString (EOF)  = "end of file or `%.\'" | toString (STRING (s))  = "constant string " ^ s | toString (token)  = "`" ^ toString\' token ^ "\'" exception NotDigit of char (* charToNat(c) = n converts character c to decimal equivalent *) (* raises NotDigit(c) if c is not a digit 0-9 *) let rec charToNat (c)  = let digit = ord (c) - ord (\'0\') in if digit < 0 || digit > 9 then raise (NotDigit (c)) else digit (* stringToNat(s) = n converts string s to a natural number *) (* raises NotDigit(c) if s contains character c which is not a digit *) let rec stringToNat (s)  = let l = size s let rec stn (i, n)  = if i = l then n else stn (i + 1, 10 * n + charToNat (sub (s, i))) in stn (0, 0) (* isUpper (s) = true, if s is a string starting with an uppercase\n     letter or underscore (_).\n  *) let rec isUpper ("")  = false | isUpper (s)  = let c = sub (s, 0) in isUpper c || c = \'_\'  (* local ... *)  end\n(* functor Lexer *) module Lexer = Lexer(module Stream\' = Stream)\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "module Parsing (module Stream' : STREAM(*! structure Lexer' : LEXER !*) (*! sharing Lexer'.Stream = Stream' !*) ) : PARSING = struct module Stream = Stream' (*! structure Lexer = Lexer' !*)  type lexResult = Token * region type 'aparser = lexResult front -> 'a * lexResult front type RecParseResult = Done of 'a | Continuation of 'a RecParseResult parser type 'arecparser = 'a RecParseResult parser let rec recwith (recparser, func) f  = (match recparser f with (Done x, f') -> (Done (func x), f') | (Continuation k, f') -> (Continuation (recwith (k, func)), f')) exception Error of string let rec error (r, msg)  = raise (Error (wrap (r, msg))) end\n(* functor Parsing *) module Parsing = Parsing(module Stream' = Stream)\n", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Reconstruct signature entries *) (* Author: Frank Pfenning *) (* Modified: Roberto Virga, Jeff Polakow *) module ReconConDec (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) (*! structure Paths\' : PATHS !*) module ReconTerm\' : RECON_TERM(*! sharing ReconTerm\'.IntSyn = IntSyn\' !*) (*! sharing ReconTerm\'.Paths = Paths\' !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn\' !*) module Strict : STRICT(*! sharing Strict.IntSyn = IntSyn\' !*) (*! sharing Strict.Paths = Paths\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) module Timers : TIMERSmodule Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Msg : MSG) : RECON_CONDEC = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Paths = Paths\' !*)  module ExtSyn = ReconTerm\' exception Error of string (* error (r, msg) raises a syntax error within region r with text msg *)  let rec error (r, msg)  = raise (Error (wrap (r, msg))) type name = string (* Constant declarations *)  type condec = condec of name * term | condef of name option * term * term option | blockdef of string * string list * string list | blockdec of name * dec list * dec list (* condecToConDec (condec, r) = (SOME(cd), SOME(ocd))\n     if condec is a named constant declaration with occurrence tree ocd,\n     NONE if name or occurrence tree is missing\n\n     Free variables in condec are interpreted universally (as FVars)\n     then abstracted as implicit parameters.\n\n     Only works properly when the declaration contains no EVars.\n  *)  (* should printing of result be moved to frontend? *)  (* Wed May 20 08:08:50 1998 -fp *)  let rec condecToConDec (condec (name, tm), Loc (fileName, r), abbFlag)  = let _ = varReset Null let _ = resetErrors fileName let JClass ((V, oc), L) = (time recon recon) (jclass tm) let _ = checkErrors (r) let (i, V\') = try  with  let cd = nameConDec (ConDec (name, NONE, i, Normal, V\', L)) let ocd = dec (i, oc) let _ = if ! chatter >= 3 then message ((time printing conDecToString) cd ^ "\\n") else () let _ = if ! doubleCheck then (time checking check) (V\', Uni L) else () in (SOME (cd), SOME (ocd)) | condecToConDec (condef (optName, tm1, tm2Opt), Loc (fileName, r), abbFlag)  = let _ = varReset Null let _ = resetErrors fileName let f = (match tm2Opt with NONE -> jterm tm1 | SOME tm2 -> jof (tm1, tm2)) let f\' = (time recon recon) f let ((U, oc1), (V, oc2Opt), L) = (match f\' with JTerm ((U, oc1), V, L) -> ((U, oc1), (V, NONE), L) | JOf ((U, oc1), (V, oc2), L) -> ((U, oc1), (V, SOME oc2), L)) let _ = checkErrors (r) let (i, (U\'\', V\'\')) = try  with  let name = match optName with NONE -> "_" | SOME (name) -> name let ocd = def (i, oc1, oc2Opt) let cd = if abbFlag then nameConDec (AbbrevDef (name, NONE, i, U\'\', V\'\', L)) else (check ((U\'\', V\'\'), SOME (ocd)); (* stricter checking of types according to Chris Richards Fri Jul  2 16:33:46 2004 -fp *) (* (case optName of NONE => () | _ => Strict.checkType ((i, V\'\'), SOME(ocd))); *) (nameConDec (ConDef (name, NONE, i, U\'\', V\'\', L, ancestor U\'\')))) let _ = if ! chatter >= 3 then message ((time printing conDecToString) cd ^ "\\n") else () let _ = if ! doubleCheck then ((time checking check) (V\'\', Uni L); (time checking check) (U\'\', V\'\')) else () let optConDec = match optName with NONE -> NONE | SOME _ -> SOME (cd) in (optConDec, SOME (ocd)) | condecToConDec (blockdec (name, Lsome, Lblock), Loc (fileName, r), abbFlag)  = let rec makectx nil  = Null | makectx (D :: L)  = Decl (makectx L, D) let rec ctxToList (Null, acc)  = acc | ctxToList (Decl (G, D), acc)  = ctxToList (G, D :: acc) let rec ctxAppend (G, Null)  = G | ctxAppend (G, Decl (G\', D))  = Decl (ctxAppend (G, G\'), D) let rec ctxBlockToString (G0, (G1, G2))  = let _ = varReset Null let G0\' = ctxName G0 let G1\' = ctxLUName G1 let G2\' = ctxLUName G2 in ctxToString (Null, G0\') ^ "\\n" ^ (match G1\' with Null -> "" | _ -> "some " ^ ctxToString (G0\', G1\') ^ "\\n") ^ "pi " ^ ctxToString (ctxAppend (G0\', G1\'), G2\') let rec checkFreevars (Null, (G1, G2), r)  = () | checkFreevars (G0, (G1, G2), r)  = let _ = varReset Null let G0\' = ctxName G0 let G1\' = ctxLUName G1 let G2\' = ctxLUName G2 in error (r, "Free variables in context block after term reconstruction:\\n" ^ ctxBlockToString (G0\', (G1\', G2\'))) let (gsome, gblock) = (makectx Lsome, makectx Lblock) let r\' = (match (ctxRegion gsome, ctxRegion gblock) with (SOME r1, SOME r2) -> join (r1, r2) | (_, SOME r2) -> r2) let _ = varReset Null let _ = resetErrors fileName let j = jwithctx (gsome, jwithctx (gblock, jnothing)) let JWithCtx (Gsome, JWithCtx (Gblock, _)) = (time recon recon) j let _ = checkErrors (r) let (G0, [Gsome\'; Gblock\']) = (* closed nf *) try  with  let _ = checkFreevars (G0, (Gsome\', Gblock\'), r\') let bd = BlockDec (name, NONE, Gsome\', ctxToList (Gblock\', nil)) let _ = if ! chatter >= 3 then message ((time printing conDecToString) bd ^ "\\n") else () in (SOME bd, NONE) | condecToConDec (blockdef (name, W), Loc (fileName, r), abbFlag)  = let W\' = map Qid W let W\'\' = (map (fun qid -> match constLookup qid with NONE -> raise (Error ("Undeclared label " ^ qidToString (valOf (constUndef qid)) ^ ".")) | SOME cid -> cid) W\') let bd = BlockDef (name, NONE, W\'\') let _ = if ! chatter >= 3 then message ((time printing conDecToString) bd ^ "\\n") else () in (SOME bd, NONE) let rec internalInst _  = raise (Match) let rec externalInst _  = raise (Match) end(* functor ReconConDec *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Reconstruct queries *) (* Author: Frank Pfenning *) (* Modified: Roberto Virga, Jeff Polakow *) module ReconQuery (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) (*! structure Paths\' : PATHS !*) module ReconTerm\' : RECON_TERM(*! sharing ReconTerm\'.IntSyn = IntSyn\' !*) (*! sharing ReconTerm\'.Paths = Paths\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) module Strict : STRICT(*! sharing Strict.IntSyn = IntSyn\' !*) (*! sharing Strict.Paths = Paths\' !*) module Timers : TIMERSmodule Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) ) : RECON_QUERY = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Paths = Paths\' !*)  module ExtSyn = ReconTerm\' module T = ReconTerm\' exception Error of string (* error (r, msg) raises a syntax error within region r with text msg *)  let rec error (r, msg)  = raise (Error (wrap (r, msg))) type name = string (* Queries, with optional proof term variable *)  type query = query of name option * term (* define := <constant name> option * <def body> * <type> option *)  type define = define of string option * term * term option type solve = solve of string option * term * region (* freeVar (XOpt, [(X1,"X1"),...,(Xn,"Xn")]) = true\n     iff XOpt = SOME("Xi"), false otherwise\n  *)  let rec freeVar (SOME (name), Xs)  = exists (fun (_, name\') -> name = name\') Xs | freeVar _  = false (* queryToQuery (q) = (V, XOpt, [(X1,"X1"),...,(Xn,"Xn")])\n     where XOpt is the optional proof term variable\n           X1,...,Xn are the free EVars in the terms with their names\n \n     Free variables in q are interpreted existentially (as EVars).\n\n     Only works properly when the Vars parameter structure\n     is instantiated to EVars, not FVars.\n  *)  (* call TypeCheck... if !doubleCheck = true? *)  (* Wed May 20 08:00:28 1998 -fp *)  let rec queryToQuery (query (optName, tm), Loc (fileName, r))  = (* construct an external term for the result of the query\n        val res = (case optName\n                     of NONE => T.omitted (r)\n                      | SOME name => T.evar (name, r)) *) (* ??? Since the reconstruction of a query is subject to constraints,\n           couldn\'t optName "occur" in a constraint involving the type\n           without being detected by this test?  -kw *) let _ = varReset Null let _ = resetErrors fileName let JClass ((V, oc), L) = (time recon reconQuery) (jclass tm) let _ = checkErrors (r) let _ = (match L with Type -> () | _ -> error (r, "Query was not a type")) let Xs = namedEVars () let _ = if freeVar (optName, Xs) then error (r, "Proof term variable " ^ valOf optName ^ " occurs in type") else () in (V, optName, Xs) let rec finishDefine (define (optName, tm, clsOpt), ((U, oc1), (V, oc2Opt), L))  = (* is this necessary? -kw *) let (i, (U\', V\')) = try  with  let name = match optName with NONE -> "_" | SOME (name) -> name let ocd = def (i, oc1, oc2Opt) let cd = (try  with ) let cd = nameConDec cd let _ = if ! chatter >= 3 then print ((time printing conDecToString) cd ^ "\\n") else () let _ = if ! doubleCheck then ((time checking check) (V\', Uni L); (time checking check) (U\', V\')) else () let conDecOpt = match optName with NONE -> NONE | SOME _ -> SOME (cd) in (conDecOpt, SOME (ocd)) let rec finishSolve (solve (nameOpt, tm, r), U, V)  = (* is this necessary? -kw *) let (i, (U\', V\')) = try  with  let name = match nameOpt with NONE -> "_" | SOME (name) -> name let cd = (try  with ) let cd = nameConDec cd let _ = if ! chatter >= 3 then print ((time printing conDecToString) cd ^ "\\n") else () let _ = if ! doubleCheck then ((time checking check) (V\', Uni Type); (time checking check) (U\', V\')) else () let conDecOpt = match nameOpt with NONE -> NONE | SOME _ -> SOME (cd) in conDecOpt (* queryToQuery (q) = (V, XOpt, [(X1,"X1"),...,(Xn,"Xn")])\n     where XOpt is the optional proof term variable\n           X1,...,Xn are the free EVars in the terms with their names\n \n     Free variables in q are interpreted existentially (as EVars).\n\n     Only works properly when the Vars parameter structure\n     is instantiated to EVars, not FVars.\n  *)  (* call TypeCheck... if !doubleCheck = true? *)  (* Wed May 20 08:00:28 1998 -fp *)  let rec solveToSolve (defines, sol as solve (optName, tm, r0), Loc (fileName, r))  = (* val Xs = Names.namedEVars () *) let _ = varReset Null let _ = resetErrors fileName let rec mkd (define (_, tm1, NONE))  = jterm tm1 | mkd (define (_, tm1, SOME (tm2)))  = jof (tm1, tm2) let rec mkj (nil)  = jnothing | mkj (def :: defs)  = jand (mkd def, mkj defs) let JAnd (defines\', JClass ((V, _), L)) = (time recon reconQuery) (jand (mkj defines, jclass tm)) let _ = checkErrors (r) let _ = (match L with Type -> () | _ -> error (r0, "Query was not a type")) let rec sc (M, nil, _)  = (match finishSolve (sol, M, V) with NONE -> nil | SOME condec -> [(condec, NONE)]) | sc (M, def :: defs, JAnd (JTerm ((U, oc1), V, L), f))  = (match finishDefine (def, ((U, oc1), (V, NONE), L)) with (NONE, _) -> sc (M, defs, f) | (SOME condec, ocdOpt) -> (condec, ocdOpt) :: sc (M, defs, f)) | sc (M, def :: defs, JAnd (JOf ((U, oc1), (V, oc2), L), f))  = (match finishDefine (def, ((U, oc1), (V, SOME oc2), L)) with (NONE, _) -> sc (M, defs, f) | (SOME condec, ocdOpt) -> (condec, ocdOpt) :: sc (M, defs, f)) in (V, fun M -> sc (M, defines, defines\')) end(* functor ReconQuery *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Print an informative message on receipt of an unhandled exception. *) module UnknownExn (val exnHistory : exn -> string list) : UNKNOWN_EXN = struct let rec unknownExn exn  = let history = rev (exnHistory exn) let rec wrap1 x  = "  raised at: " ^ x ^ "\\n" let rec wrapn x  = "             " ^ x ^ "\\n" in concat ("Unrecognized exception " :: (exnName exn) :: "\\n" :: (match history with nil -> [""] | x :: xs -> (wrap1 x :: map wrapn xs))) end\n', 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: module type UNKNOWN_EXN = sig val unknownExn : exn -> string end

('Error parsing code:', '(* Top-Level Parser *) (* Author: Frank Pfenning *) module type PARSER = sig (*! structure Parsing : PARSING !*) module Stream : STREAMmodule ExtSyn : EXTSYNmodule Names : NAMESmodule ExtConDec : EXTCONDECmodule ExtQuery : EXTQUERYmodule ExtModes : EXTMODESmodule ThmExtSyn : THMEXTSYNmodule ModExtSyn : MODEXTSYNtype fileParseResultConDeccondecFixDec(Qid * region) * fixityNamePref(Qid * region) * (string list * string list)ModeDecmodedec listUniqueDecmodedec listCoversDecmodedec listTotalDectdeclTerminatesDectdeclWorldDecwdeclReducesDecrdeclTabledDectableddeclKeepTableDeckeepTabledeclTheoremDectheoremdecProveDecproveEstablishDecestablishAssertDecassertQueryint option * int option * queryFQueryqueryCompileQid listQuerytabledint option * int option * querySolvedefine list * solveAbbrevDeccondecTrustMefileParseResult * regionSubordDecQid * Qid listFreezeDecQid listThawDecQid listDeterministicDecQid listClauseDeccondecSigDefsigdefStructDecstructdecIncludesigexpOpenstrexpBeginSubsigEndSubsigUsestring(* Further declarations to be added here *) val parseStream : instream -> fileParseResult * region streamval parseTerminalQ : string * string -> query stream(* reads from std input *)  end\n(* signature PARSER *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Parsing Mode Declarations *) (* Author: Carsten Schuermann *) module ParseMode ((*! structure Paths : PATHS !*) (*! structure Parsing\' : PARSING !*) (*! sharing Parsing\'.Lexer.Paths = Paths !*) module ExtModes\' : EXTMODES(*! sharing ExtModes\'.Paths = Paths !*) (*! sharing ExtModes\'.ExtSyn.Paths = Paths !*) module ParseTerm : PARSE_TERM(*! sharing ParseTerm.Lexer = Parsing\'.Lexer !*) ParseTermExtSynExtModes\'ExtSyn) : PARSE_MODE = struct (*! structure Parsing = Parsing\' !*)  module ExtModes = ExtModes\' module L = Lexermodule LS = LexerStreammodule E = ExtModesmodule P = Paths(* extract (s, i) = substring of s starting at index i\n       Effect: raises Subscript if i > |s|\n    *) let rec extract (s, i)  = if i = size s then NONE else SOME (extract (s, i, NONE)) (* splitModeId (r, id) = (mode, idOpt) where id = "<mode><idOpt>"\n       Invariant: id <> ""\n    *) let rec splitModeId (r, id)  = match sub (id, 0) with \'*\' -> (star r, extract (id, 1)) | \'-\' -> (if (size id > 1 && sub (id, 1) = \'1\') then (minus1 r, extract (id, 2)) else (minus r, extract (id, 1))) | \'+\' -> (plus r, extract (id, 1)) | _ -> error (r, "Expected mode `+\', `-\', `*\', or `-1\'  found " ^ id) let rec validateMArg (r, mId as (mode, SOME (id)))  = if isUpper id then mId else error (r, "Expected free uppercase variable, found " ^ id) | validateMArg (r, (_, NONE))  = error (r, "Missing variable following mode") let rec validateMode (r, (mode, NONE))  = mode | validateMode (r, (_, SOME (id)))  = error (r, "Expected simple mode, found mode followed by identifier " ^ id) let rec stripRParen (Cons ((RPAREN, r), s\'))  = (expose s\', r) | stripRParen (Cons ((t, r), s\'))  = (* t = `.\' or ? *)  error (r, "Expected closing `)\', found " ^ toString t) let rec stripRBrace (Cons ((RBRACE, r), s\'))  = (expose s\', r) | stripRBrace (Cons ((t, r), _))  = error (r, "Expected `}\', found " ^ toString t) (* parseShortSpine "modeid ... modeid." *) let rec parseShortSpine (f as Cons ((DOT, r), s\'))  = (mnil r, f) | parseShortSpine (f as Cons ((RPAREN, r), s\'))  = (mnil r, f) | parseShortSpine (Cons ((ID (_, id), r), s\'))  = let mId = validateMArg (r, splitModeId (r, id)) let (mS\', f\') = parseShortSpine (expose s\') in (mapp (mId, mS\'), f\') | parseShortSpine (Cons ((t, r), s\'))  = error (r, "Expected mode or `.\', found " ^ toString t) (* parseFull "mode {id:term} ... mode {x:term} term" *) let rec parseFull (Cons (t0 as (ID (c, id), r0), s\'), r1)  = (* Look ahead one token to decide if quantifier follows *)  (match expose s\' with Cons ((LBRACE, r), s\'\') -> (* found quantifier --- id must be mode *) let mId = splitModeId (r0, id) let m = validateMode (r0, mId) let ((x, yOpt), f\') = parseDec\' (expose s\'\') let (f\'\', r\') = stripRBrace f\' let dec = (match yOpt with NONE -> dec0 (x, join (r, r\')) | SOME y -> dec (x, y, join (r, r\'))) let (t\', f\'\'\') = parseFull (f\'\', r1) in (mpi (m, dec, t\'), f\'\'\') | Cons TS -> (* no quantifier --- parse atomic type *) let (t\', f\' as Cons ((_, r), s\')) = parseTerm\' (Cons (t0, cons TS)) in (mroot (t\', join (r, r1)), f\')) | parseFull (Cons ((LPAREN, r0), s\'), r1)  = (* Left paren --- parse atomic type *)  let (t\', f\') = parseTerm\' (expose s\') let (f\'\', r\') = stripRParen f\' in (mroot (t\', join (r\', r1)), f\'\') | parseFull (Cons ((t, r), s\'), _)  = error (r, "Expected mode or identifier, found " ^ toString t) (* parseMode2 switches between full and short mode declarations *) (* lexid could be mode or other identifier *) let rec parseMode2 (lexid, Cons (BS as ((LBRACE, r), s\')), r1)  = let (t\', f\') = parseFull (Cons (lexid, cons BS), r1) in (toModedec t\', f\') | parseMode2 ((ID (_, name), r), f, _)  = let (mS\', f\') = parseShortSpine f in (toModedec (mroot (nil, name, r, mS\')), f\') let rec parseModeParen (Cons ((ID (_, name), r0), s\'), r)  = let (mS\', f\') = parseShortSpine (expose s\') let (f\'\', r\') = stripRParen f\' in (toModedec (mroot (nil, name, join (r, r\'), mS\')), f\'\') | parseModeParen (Cons ((t, r), s\'), _)  = error (r, "Expected identifier, found " ^ toString t) (* parseMode1 parses mdecl *) let rec parseMode1 (Cons (lexid as (ID _, r), s\'))  = parseModeNext (parseMode2 (lexid, expose s\', r)) | parseMode1 (Cons ((LPAREN, r), s\'))  = parseModeNext (parseModeParen (expose s\', r)) | parseMode1 (Cons ((t, r), _))  = error (r, "Expected identifier or mode, found " ^ toString t)parseModeNext (modedec, f as Cons ((DOT, _), s\'))  = (modedec :: nil, f) | parseModeNext (modedec, f)  = let (mdecs, f\') = parseMode1 f in (modedec :: mdecs, f\') (* parseMode\' : lexResult front -> modedec * lexResult front\n       Invariant: exposed input stream starts with MODE\n    *) let rec parseMode\' (Cons ((MODE, r), s\'))  = parseMode1 (expose s\') | parseMode\' (Cons ((UNIQUE, r), s\'))  = parseMode1 (expose s\') | parseMode\' (Cons ((COVERS, r), s\'))  = parseMode1 (expose s\') let parseMode\' = parseMode\'  (* local *)  end\n(* functor ParseMode *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Type Reconstruction with Tracing *) (* Author: Kevin Watkins *) (* Based on a previous implementation by Frank Pfenning *) (* with modifications by Jeff Polakow and Roberto Virga *) (* ------------------- *) (* Type Reconstruction *) (* ------------------- *) module ReconTerm ((*! structure IntSyn\' : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) (*! structure Paths\' : PATHS !*) module Approx : APPROX(*! sharing Approx.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) module StringTree : TABLE where keystringmodule Msg : MSG) : RECON_TERM = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Paths = Paths\' !*)  module F = PrintFormatter module Apx = Approx (* Error handling *)  let delayedList : unit -> unit list ref = ref nil let rec clearDelayed ()  = (delayedList := nil) let rec addDelayed f  = (delayedList := f :: (! delayedList)) let rec runDelayed ()  = let rec run\' nil  = () | run\' (h :: t)  = (run\' t; h ()) in run\' (! delayedList) exception Error of string let errorCount = ref 0 let errorFileName = ref "no file" let errorThreshold = ref (SOME (20)) let rec exceeds (i, NONE)  = false | exceeds (i, SOME (j))  = i > j let rec resetErrors (fileName)  = (errorCount := 0; errorFileName := fileName) let rec die (r)  = raise (Error (wrap (r, " " ^ toString (! errorCount) ^ " error" ^ (if ! errorCount > 1 then "s" else "") ^ " found"))) let rec checkErrors (r)  = if ! errorCount > 0 then die (r) else () (* Since this structure uses a non-standard error reporting mechanism,\n     any errors reported here while chatter = 1 will be printed\n     in between the "[Loading file ..." message and the closing "]",\n     instead of after the closing "]".  If we don\'t emit a newline\n     when chatter = 1, the first such error will appear on the same line\n     as "[Loading file ...", terribly confusing the Emacs error parsing code.\n   *)  let rec chatterOneNewline ()  = if ! chatter = 1 && ! errorCount = 1 then message "\\n" else () let rec fatalError (r, msg)  = (errorCount := ! errorCount + 1; chatterOneNewline (); message (! errorFileName ^ ":" ^ wrap (r, msg) ^ "\\n"); die (r)) let rec error (r, msg)  = (errorCount := ! errorCount + 1; chatterOneNewline (); message (! errorFileName ^ ":" ^ wrap (r, msg) ^ "\\n"); if exceeds (! errorCount, ! errorThreshold) then die (r) else ()) let rec formatExp (G, U)  = try  with (* this is a hack, i know *)  let queryMode = ref false open IntSyn let rec headConDec (Const c)  = sgnLookup c | headConDec (Skonst c)  = sgnLookup c | headConDec (Def d)  = sgnLookup d | headConDec (NSDef d)  = sgnLookup d | headConDec (FgnConst (_, cd))  = cd (* others impossible by invariant *) (* lowerType (G, (V, s)) = (G\', a)\n     if   G0 |- V : type and G |- s : G0\n     and  G |- V[s] = {{G1}} a : type\n     then G\' = G, G1 *) let rec lowerTypeW (G, (Pi ((D, _), V), s))  = let D\' = decSub (D, s) in lowerType (Decl (G, D\'), (V, dot1 s)) | lowerTypeW (G, Vs)  = (G, EClo Vs)lowerType (G, Vs)  = lowerTypeW (G, whnfExpandDef Vs) (* raiseType (G, V) = {{G}} V *) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Pi ((D, Maybe), V))  (* open IntSyn *)  let evarApxTable : Exp Table = new (0) let fvarApxTable : Exp Table = new (0) let fvarTable : Exp Table = new (0) let rec varReset ()  = (clear evarApxTable; clear fvarApxTable; clear fvarTable) let rec getEVarTypeApx name  = (match lookup evarApxTable name with SOME V -> V | NONE -> (match getEVarOpt name with SOME (EVar (_, _, V, _)) -> let (V\', _, (* Type *) ) = classToApx (V) in insert evarApxTable (name, V\'); V\' | NONE -> let V = newCVar () in insert evarApxTable (name, V); V)) let rec getFVarTypeApx name  = (match lookup fvarApxTable name with SOME V -> V | NONE -> let V = newCVar () in insert fvarApxTable (name, V); V) let rec getEVar (name, allowed)  = (match getEVarOpt name with SOME (X as EVar (_, G, V, _)) -> (X, raiseType (G, V)) | NONE -> let V = valOf (lookup evarApxTable name) let V\' = apxToClass (Null, V, Type, allowed) let (G\'\', V\'\') = lowerType (Null, (V\', id)) let X = newEVar (G\'\', V\'\') in addEVar (X, name); (X, V\')) let rec getFVarType (name, allowed)  = (match lookup fvarTable name with SOME V -> V | NONE -> let V = valOf (lookup fvarApxTable name) let V\' = apxToClass (Null, V, Type, allowed) in insert fvarTable (name, V\'); V\')  (* External syntax of terms *)  type term = internal of Exp * Exp * region | constant of Head * region | bvar of int * region | evar of string * region | fvar of string * region | typ of region | arrow of term * term | pi of dec * term | lam of dec * term | app of term * term | hastype of term * term | mismatch of term * term * string * string | omitted of region | lcid of string list * string * region | ucid of string list * string * region | quid of string list * string * region | scon of string * region | omitapx of Exp * Exp * Uni * region | omitexact of Exp * Exp * region and dec = dec of string option * term * region let rec backarrow (tm1, tm2)  = arrow (tm2, tm1) (* for now *)  let rec dec0 (nameOpt, r)  = dec (nameOpt, omitted (r), r) type job = jnothing | jand of job * job | jwithctx of dec Ctx * job | jterm of term | jclass of term | jof of term * term | jof\' of term * Exp let rec termRegion (internal (U, V, r))  = r | termRegion (constant (H, r))  = r | termRegion (bvar (k, r))  = r | termRegion (evar (name, r))  = r | termRegion (fvar (name, r))  = r | termRegion (typ (r))  = r | termRegion (arrow (tm1, tm2))  = join (termRegion tm1, termRegion tm2) | termRegion (pi (tm1, tm2))  = join (decRegion tm1, termRegion tm2) | termRegion (lam (tm1, tm2))  = join (decRegion tm1, termRegion tm2) | termRegion (app (tm1, tm2))  = join (termRegion tm1, termRegion tm2) | termRegion (hastype (tm1, tm2))  = join (termRegion tm1, termRegion tm2) | termRegion (mismatch (tm1, tm2, _, _))  = termRegion tm2 | termRegion (omitted (r))  = r | termRegion (lcid (_, _, r))  = r | termRegion (ucid (_, _, r))  = r | termRegion (quid (_, _, r))  = r | termRegion (scon (_, r))  = r | termRegion (omitapx (U, V, L, r))  = r | termRegion (omitexact (U, V, r))  = rdecRegion (dec (name, tm, r))  = r let rec ctxRegion (Null)  = NONE | ctxRegion (Decl (g, tm))  = ctxRegion\' (g, decRegion tm)ctxRegion\' (Null, r)  = SOME r | ctxRegion\' (Decl (g, tm), r)  = ctxRegion\' (g, join (r, decRegion tm)) open Apx CtxCtx type Dec = Dec of string option * Exp | NDec of string option (* Phase 1:\n       Try to determine an approximate type/kind and level for each subterm.\n       In cases where there\'s a mismatch, it\'s generally better not to report\n       it immediately, but rather to wait until after the exact phase, so that\n       the error message can mention more precise type information.  So instead\n       the bad subterm is wrapped in a `mismatch\' constructor, which also\n       supplies a replacement (always an `omitted\' in the current implementation)\n       so that the invariant that the entire term is approximately well-typed\n       after phase 1 is satisfied even in the presence of the error.\n     *) (* inferApx (G, tm, false) = (tm\', U, V, L)\n       pre: G is an approximate context\n            tm is an approximate subject\n       post: tm\' is an approximate subject\n             U is an approximate subject\n             V is an approximate classifier\n             L is an approximate universe\n             G |- U ~:~ V ~:~ L\n             termToExp tm\' = U\n\n       inferApx (G, tm, true) = (tm\', U, V, L)\n       pre: G is an approximate context\n            tm is an approximate classifier\n       post: tm\' is an approximate classifier\n             U is an approximate classifier\n             V is an approximate classifier\n             L is an approximate universe\n             G |- U ~:~ V ~:~ L\n             termToExp tm\' = U\n     *) let rec filterLevel (tm, L, max, msg)  = let notGround = makeGroundUni L let Level i = whnfUni L in if i > max then fatalError (termRegion tm, "Level too high\\n" ^ msg) else if notGround then error (termRegion tm, "Ambiguous level\\n" ^ "The level of this term could not be inferred\\n" ^ "Defaulting to " ^ (match i with 1 -> "object" | 2 -> "type family" | 3 -> "kind") ^ " level") else () let rec findOmitted (G, qid, r)  = (error (r, "Undeclared identifier " ^ qidToString (valOf (constUndef qid))); omitted (r)) let rec findBVar\' (Null, name, k)  = NONE | findBVar\' (Decl (G, Dec (NONE, _)), name, k)  = findBVar\' (G, name, k + 1) | findBVar\' (Decl (G, NDec _), name, k)  = findBVar\' (G, name, k + 1) | findBVar\' (Decl (G, Dec (SOME (name\'), _)), name, k)  = if name = name\' then SOME (k) else findBVar\' (G, name, k + 1) let rec findBVar fc (G, qid, r)  = (match unqualified qid with NONE -> fc (G, qid, r) | SOME name -> (match findBVar\' (G, name, 1) with NONE -> fc (G, qid, r) | SOME k -> bvar (k, r))) let rec findConst fc (G, qid, r)  = (match constLookup qid with NONE -> fc (G, qid, r) | SOME cid -> (match sgnLookup cid with ConDec _ -> constant (Const cid, r) | ConDef _ -> constant (Def cid, r) | AbbrevDef _ -> constant (NSDef cid, r) | _ -> (error (r, "Invalid identifier\\n" ^ "Identifier `" ^ qidToString qid ^ "\' is not a constant, definition or abbreviation"); omitted (r)))) let rec findCSConst fc (G, qid, r)  = (match unqualified qid with NONE -> fc (G, qid, r) | SOME name -> (match parse name with NONE -> fc (G, qid, r) | SOME (cs, conDec) -> constant (FgnConst (cs, conDec), r))) let rec findEFVar fc (G, qid, r)  = (match unqualified qid with NONE -> fc (G, qid, r) | SOME name -> (if ! queryMode then evar else fvar) (name, r)) let rec findLCID x  = findBVar (findConst (findCSConst findOmitted)) x let rec findUCID x  = findBVar (findConst (findCSConst (findEFVar findOmitted))) x let rec findQUID x  = findConst (findCSConst findOmitted) x let rec inferApx (G, tm as internal (U, V, r))  = let (U\', V\', L\') = exactToApx (U, V) in (tm, U\', V\', L\') | inferApx (G, tm as lcid (ids, name, r))  = let qid = Qid (ids, name) in inferApx (G, findLCID (G, qid, r)) | inferApx (G, tm as ucid (ids, name, r))  = let qid = Qid (ids, name) in inferApx (G, findUCID (G, qid, r)) | inferApx (G, tm as quid (ids, name, r))  = let qid = Qid (ids, name) in inferApx (G, findQUID (G, qid, r)) | inferApx (G, tm as scon (name, r))  = (match parse name with NONE -> (error (r, "Strings unsupported in current signature"); inferApx (G, omitted (r))) | SOME (cs, conDec) -> inferApx (G, constant (FgnConst (cs, conDec), r))) | inferApx (G, tm as constant (H, r))  = let cd = headConDec H let (U\', V\', L\') = exactToApx (Root (H, Nil), conDecType cd) let rec dropImplicit (V, 0)  = V | dropImplicit (Arrow (_, V), i)  = dropImplicit (V, i - 1) let V\'\' = dropImplicit (V\', conDecImp cd) in (tm, U\', V\'\', L\') | inferApx (G, tm as bvar (k, r))  = let Dec (_, V) = ctxLookup (G, k) in (tm, Undefined, V, Type) | inferApx (G, tm as evar (name, r))  = (tm, Undefined, getEVarTypeApx name, Type) | inferApx (G, tm as fvar (name, r))  = (tm, Undefined, getFVarTypeApx name, Type) | inferApx (G, tm as typ (r))  = (tm, Uni Type, Uni Kind, Hyperkind) | inferApx (G, arrow (tm1, tm2))  = let L = newLVar () let (tm1\', V1) = checkApx (G, tm1, Uni Type, Kind, "Left-hand side of arrow must be a type") let (tm2\', V2) = checkApx (G, tm2, Uni L, Next L, "Right-hand side of arrow must be a type or a kind") in (arrow (tm1\', tm2\'), Arrow (V1, V2), Uni L, Next L) | inferApx (G, pi (tm1, tm2))  = let (tm1\', D as Dec (_, V1)) = inferApxDec (G, tm1) let L = newLVar () let (tm2\', V2) = checkApx (Decl (G, D), tm2, Uni L, Next L, "Body of pi must be a type or a kind") in (pi (tm1\', tm2\'), Arrow (V1, V2), Uni L, Next L) | inferApx (G, tm as lam (tm1, tm2))  = let (tm1\', D as Dec (_, V1)) = inferApxDec (G, tm1) let (tm2\', U2, V2, L2) = inferApx (Decl (G, D), tm2) in (lam (tm1\', tm2\'), U2, Arrow (V1, V2), L2) | inferApx (G, tm as app (tm1, tm2))  = (* probably a confusing message if the problem is the level: *) let L = newLVar () let Va = newCVar () let Vr = newCVar () let (tm1\', U1) = checkApx (G, tm1, Arrow (Va, Vr), L, "Non-function was applied to an argument") let (tm2\', _) = checkApx (G, tm2, Va, Type, "Argument type did not match function domain type") in (app (tm1\', tm2\'), U1, Vr, L) | inferApx (G, tm as hastype (tm1, tm2))  = let L = newLVar () let (tm2\', V2) = checkApx (G, tm2, Uni L, Next L, "Right-hand side of ascription must be a type or a kind") let (tm1\', U1) = checkApx (G, tm1, V2, L, "Ascription did not hold") let _ = addDelayed (fun () -> filterLevel (tm, L, 2, "Ascription can only be applied to objects and type families")) in (hastype (tm1\', tm2\'), U1, V2, L) | inferApx (G, omitted (r))  = (* guaranteed not to be used if L is type *) let L = newLVar () let V = newCVar () let U = newCVar () in (omitapx (U, V, L, r), U, V, L)checkApx (G, tm, V, L, location_msg)  = let (tm\', U\', V\', L\') = inferApx (G, tm) in try  withinferApxDec (G, dec (name, tm, r))  = let (tm\', V1) = checkApx (G, tm, Uni Type, Kind, "Classifier in declaration must be a type") let D = Dec (name, V1) in (dec (name, tm\', r), D) let rec inferApxJob (G, jnothing)  = jnothing | inferApxJob (G, jand (j1, j2))  = jand (inferApxJob (G, j1), inferApxJob (G, j2)) | inferApxJob (G, jwithctx (g, j))  = let rec ia (Null)  = (G, Null) | ia (Decl (g, tm))  = let (G\', g\') = ia (g) let _ = clearDelayed () let (tm\', D) = inferApxDec (G\', tm) let _ = runDelayed () in (Decl (G\', D), Decl (g\', tm\')) let (G\', g\') = ia (g) in jwithctx (g\', inferApxJob (G\', j)) | inferApxJob (G, jterm (tm))  = let _ = clearDelayed () let (tm\', U, V, L) = inferApx (G, tm) let _ = filterLevel (tm\', L, 2, "The term in this position must be an object or a type family") let _ = runDelayed () in jterm (tm\') | inferApxJob (G, jclass (tm))  = let _ = clearDelayed () let L = newLVar () let (tm\', V) = checkApx (G, tm, Uni L, Next L, "The term in this position must be a type or a kind") let _ = filterLevel (tm\', Next L, 3, "The term in this position must be a type or a kind") let _ = runDelayed () in jclass (tm\') | inferApxJob (G, jof (tm1, tm2))  = let _ = clearDelayed () let L = newLVar () let (tm2\', V2) = checkApx (G, tm2, Uni L, Next L, "The term in this position must be a type or a kind") let (tm1\', U1) = checkApx (G, tm1, V2, L, "Ascription in declaration did not hold") let _ = filterLevel (tm1\', L, 2, "The term in this position must be an object or a type family") let _ = runDelayed () in jof (tm1\', tm2\') | inferApxJob (G, jof\' (tm1, V))  = let _ = clearDelayed () let L = newLVar () let (V2, _) = classToApx V let (tm1\', U1) = checkApx (G, tm1, V2, L, "Ascription in declaration did not hold") let _ = filterLevel (tm1\', L, 2, "The term in this position must be an object or a type family") let _ = runDelayed () in jof\' (tm1\', V) let rec ctxToApx Null  = Null | ctxToApx (Decl (G, NDec x))  = Decl (ctxToApx G, NDec x) | ctxToApx (Decl (G, Dec (name, V)))  = let (V\', _) = classToApx V in Decl (ctxToApx G, Dec (name, V\')) let rec inferApxJob\' (G, t)  = inferApxJob (ctxToApx G, t)  (* open Apx *)  open IntSyn (* Final reconstruction job syntax *) type Job = JNothing | JAnd of Job * Job | JWithCtx of Dec Ctx * Job | JTerm of (Exp * occExp) * Exp * Uni | JClass of (Exp * occExp) * Uni | JOf of (Exp * occExp) * (Exp * occExp) * Uni (* This little datatype makes it easier to work with eta-expanded terms\n     The idea is that Elim E represents a term U if\n       E (s, S) = U[s] @ S *) type Bidi = Elim of Sub * Spine -> Exp | Intro of Exp let rec elimSub (E, s)  = (fun (s\', S) -> E (comp (s, s\'), S)) let rec elimApp (E, U)  = (fun (s, S) -> E (s, App (EClo (U, s), S))) let rec bvarElim (n)  = (fun (s, S) -> (match bvarSub (n, s) with Idx (n\') -> Root (BVar n\', S) | Exp (U) -> Redex (U, S))) let rec fvarElim (name, V, s)  = (fun (s\', S) -> Root (FVar (name, V, comp (s, s\')), S)) let rec redexElim (U)  = (fun (s, S) -> Redex (EClo (U, s), S)) (* headElim (H) = E\n     assumes H not Proj _ *) let rec headElim (BVar n)  = bvarElim n | headElim (FVar fv)  = fvarElim fv | headElim (NSDef d)  = redexElim (constDef d) | headElim (H)  = (match conDecStatus (headConDec H) with Foreign (csid, f) -> (fun (s, S) -> f S) | _ -> (fun (s, S) -> Root (H, S))) (* although internally EVars are lowered intro forms, externally they\'re\n     raised elim forms.\n     this conforms to the external interpretation:\n     the type of the returned elim form is ([[G]] V) *) let rec evarElim (X as EVar _)  = (fun (s, S) -> EClo (X, spineToSub (S, s))) let rec etaExpandW (E, (Pi ((D as Dec (_, Va), _), Vr), s))  = let U1 = etaExpand (bvarElim (1), (Va, comp (s, shift))) let D\' = decSub (D, s) in Lam (D\', etaExpand (elimApp (elimSub (E, shift), U1), (Vr, dot1 s))) | etaExpandW (E, _)  = E (id, Nil)etaExpand (E, Vs)  = etaExpandW (E, whnfExpandDef Vs) (* preserves redices *) let rec toElim (Elim E)  = E | toElim (Intro U)  = redexElim U let rec toIntro (Elim E, Vs)  = etaExpand (E, Vs) | toIntro (Intro U, Vs)  = U let rec addImplicit1W (G, E, (Pi ((Dec (_, Va), _), Vr), s), i, (* >= 1 *) )  = let X = newLoweredEVar (G, (Va, s)) in addImplicit (G, elimApp (E, X), (Vr, dotEta (Exp (X), s)), i - 1)(* if no implicit arguments, do not expand Vs!!! *) addImplicit (G, E, Vs, 0)  = (E, EClo Vs) | addImplicit (G, E, Vs, i)  = addImplicit1W (G, E, whnfExpandDef Vs, i) (* Report mismatches after the entire process finishes -- yields better\n     error messages *) let rec reportConstraints (Xnames)  = try  with let rec reportInst (Xnames)  = try  with let rec delayMismatch (G, V1, V2, r2, location_msg, problem_msg)  = addDelayed (fun () -> let Xs = collectEVars (G, (V2, id), collectEVars (G, (V1, id), nil)) let Xnames = map (fun X -> (X, evarName (Null, X))) Xs let V1fmt = formatExp (G, V1) let V2fmt = formatExp (G, V2) let diff = Vbox0 0 1 [String "Expected:"; Space; V2fmt; Break; String "Inferred:"; Space; V1fmt] let diff = (match evarCnstrsToStringOpt (Xnames) with NONE -> makestring_fmt diff | SOME (cnstrs) -> makestring_fmt diff ^ "\\nConstraints:\\n" ^ cnstrs) in error (r2, "Type mismatch\\n" ^ diff ^ "\\n" ^ problem_msg ^ "\\n" ^ location_msg)) let rec delayAmbiguous (G, U, r, msg)  = addDelayed (fun () -> let Ufmt = formatExp (G, U) let amb = HVbox [String "Inferred:"; Space; formatExp (G, U)] in error (r, "Ambiguous reconstruction\\n" ^ makestring_fmt amb ^ "\\n" ^ msg)) let rec unifyIdem x  = (* this reset should be unnecessary -- for safety only *) let _ = reset () let _ = try  with  let _ = reset () in () let rec unifiableIdem x  = (* this reset should be unnecessary -- for safety only *) let _ = reset () let ok = unifiable x let _ = if ok then reset () else unwind () in ok (* tracing code *) type TraceMode = Progressive | Omniscient let trace = ref false let traceMode = ref Omniscient let rec report f  = match ! traceMode with Progressive -> f () | Omniscient -> addDelayed f let rec reportMismatch (G, Vs1, Vs2, problem_msg)  = report (fun () -> let Xs = collectEVars (G, Vs2, collectEVars (G, Vs1, nil)) let Xnames = map (fun X -> (X, evarName (Null, X))) Xs let eqnsFmt = HVbox [String "|?"; Space; formatExp (G, EClo Vs1); Break; String "="; Space; formatExp (G, EClo Vs2)] let _ = message (makestring_fmt eqnsFmt ^ "\\n") let _ = reportConstraints Xnames let _ = message ("Failed: " ^ problem_msg ^ "\\n" ^ "Continuing with subterm replaced by _\\n") in ()) let rec reportUnify\' (G, Vs1, Vs2)  = let Xs = collectEVars (G, Vs2, collectEVars (G, Vs1, nil)) let Xnames = map (fun X -> (X, evarName (Null, X))) Xs let eqnsFmt = HVbox [String "|?"; Space; formatExp (G, EClo Vs1); Break; String "="; Space; formatExp (G, EClo Vs2)] let _ = message (makestring_fmt eqnsFmt ^ "\\n") let _ = try  with  let _ = reportInst Xnames let _ = reportConstraints Xnames in () let rec reportUnify (G, Vs1, Vs2)  = (match ! traceMode with Progressive -> reportUnify\' (G, Vs1, Vs2) | Omniscient -> (try  with )) let rec reportInfer\' (G, omitexact (_, _, r), U, V)  = let Xs = collectEVars (G, (U, id), collectEVars (G, (V, id), nil)) let Xnames = map (fun X -> (X, evarName (Null, X))) Xs let omit = HVbox [String "|-"; Space; String "_"; Space; String "==>"; Space; formatExp (G, U); Break; String ":"; Space; formatExp (G, V)] let _ = message (makestring_fmt omit ^ "\\n") let _ = reportConstraints Xnames in () | reportInfer\' (G, mismatch (tm1, tm2, _, _), U, V)  = reportInfer\' (G, tm2, U, V) | reportInfer\' (G, hastype _, U, V)  = () | reportInfer\' (G, tm, U, V)  = let Xs = collectEVars (G, (U, id), collectEVars (G, (V, id), nil)) let Xnames = map (fun X -> (X, evarName (Null, X))) Xs let judg = HVbox [String "|-"; Space; formatExp (G, U); Break; String ":"; Space; formatExp (G, V)] let _ = message (makestring_fmt judg ^ "\\n") let _ = reportConstraints Xnames in () let rec reportInfer x  = report (fun () -> reportInfer\' x) (* inferExact (G, tm) = (tm\', U, V)\n       if  tm is approximately well typed\n       and tm contains no subterm above kind level\n       and tm ~:~ V1\n       then tm = U-\n       and  U : V\n       and  U, V are most general such\n       effect: as for unification *) let rec inferExactN (G, tm as internal (U, V, r))  = (tm, Intro U, V) | inferExactN (G, tm as constant (H, r))  = let cd = headConDec (H) let (E, V) = addImplicit (G, headElim H, (conDecType cd, id), conDecImp cd) in (tm, Elim E, V) | inferExactN (G, tm as bvar (k, r))  = let Dec (_, V) = ctxDec (G, k) in (tm, Elim (bvarElim k), V) | inferExactN (G, tm as evar (name, r))  = (* externally EVars are raised elim forms *) (* necessary? -kw *) let (X, V) = try  with  let s = Shift (ctxLength (G)) in (tm, Elim (elimSub (evarElim X, s)), EClo (V, s)) | inferExactN (G, tm as fvar (name, r))  = (* necessary? -kw *) let V = try  with  let s = Shift (ctxLength (G)) in (tm, Elim (fvarElim (name, V, s)), EClo (V, s)) | inferExactN (G, tm as typ (r))  = (tm, Intro (Uni Type), Uni Kind) | inferExactN (G, arrow (tm1, tm2))  = let (tm1\', B1, _, (* Uni Type *) ) = inferExact (G, tm1) let D = Dec (NONE, toIntro (B1, (Uni Type, id))) let (tm2\', B2, L) = inferExact (G, tm2) let V2 = toIntro (B2, (L, id)) in (arrow (tm1\', tm2\'), Intro (Pi ((D, No), EClo (V2, shift))), L) | inferExactN (G, pi (tm1, tm2))  = let (tm1\', D) = inferExactDec (G, tm1) let (tm2\', B2, L) = inferExact (Decl (G, D), tm2) let V2 = toIntro (B2, (L, id)) in (pi (tm1\', tm2\'), Intro (Pi ((D, Maybe), V2)), L) | inferExactN (G, lam (tm1, tm2))  = let (tm1\', D) = inferExactDec (G, tm1) let (tm2\', B2, V2) = inferExact (Decl (G, D), tm2) let U2 = toIntro (B2, (V2, id)) in (lam (tm1\', tm2\'), Intro (Lam (D, U2)), Pi ((D, Maybe), V2)) | inferExactN (G, app (tm1, tm2))  = let (tm1\', B1, V1) = inferExact (G, tm1) let E1 = toElim (B1) let (Pi ((Dec (_, Va), _), Vr), s) = whnfExpandDef (V1, id) let (tm2\', B2) = checkExact (G, tm2, (Va, s), "Argument type did not match function domain type\\n(Index object(s) did not match)") let U2 = toIntro (B2, (Va, s)) in (app (tm1\', tm2\'), Elim (elimApp (E1, U2)), EClo (Vr, dotEta (Exp U2, s))) | inferExactN (G, hastype (tm1, tm2))  = let (tm2\', B2, L) = inferExact (G, tm2) let V = toIntro (B2, (L, id)) let (tm1\', B1) = checkExact (G, tm1, (V, id), "Ascription did not hold\\n(Index object(s) did not match)") in (hastype (tm1\', tm2\'), B1, V) | inferExactN (G, mismatch (tm1, tm2, location_msg, problem_msg))  = let (tm1\', _, V1) = inferExact (G, tm1) let (tm2\', B, V) = inferExactN (G, tm2) let _ = if ! trace then reportMismatch (G, (V1, id), (V, id), problem_msg) else () let _ = delayMismatch (G, V1, V, termRegion tm2\', location_msg, problem_msg) in (mismatch (tm1\', tm2\', location_msg, problem_msg), B, V) | inferExactN (G, omitapx (U, V, L, r))  = let V\' = try  with  let U\' = try  with  in (omitexact (U\', V\', r), Intro U\', V\')inferExact (G, tm)  = if not (! trace) then inferExactN (G, tm) else let (tm\', B\', V\') = inferExactN (G, tm) in reportInfer (G, tm\', toIntro (B\', (V\', id)), V\'); (tm\', B\', V\')inferExactDec (G, dec (name, tm, r))  = let (tm\', B1, _, (* Uni Type *) ) = inferExact (G, tm) let V1 = toIntro (B1, (Uni Type, id)) let D = Dec (name, V1) in (dec (name, tm\', r), D)checkExact1 (G, lam (dec (name, tm1, r), tm2), Vhs)  = let (Pi ((Dec (_, Va), _), Vr), s) = whnfExpandDef Vhs let ((tm1\', B1, _, (* Uni Type *) ), ok1) = unifyExact (G, tm1, (Va, s)) let V1 = toIntro (B1, (Uni Type, id)) let D = Dec (name, V1) let ((tm2\', B2, V2), ok2) = if ok1 then checkExact1 (Decl (G, D), tm2, (Vr, dot1 s)) else (inferExact (Decl (G, D), tm2), false) let U2 = toIntro (B2, (V2, id)) in ((lam (dec (name, tm1\', r), tm2\'), Intro (Lam (D, U2)), Pi ((D, Maybe), V2)), ok2) | checkExact1 (G, hastype (tm1, tm2), Vhs)  = let ((tm2\', B2, L), ok2) = unifyExact (G, tm2, Vhs) let V = toIntro (B2, (L, id)) let (tm1\', B1) = checkExact (G, tm1, (V, id), "Ascription did not hold\\n(Index object(s) did not match)") in ((hastype (tm1\', tm2\'), B1, V), ok2) | checkExact1 (G, mismatch (tm1, tm2, location_msg, problem_msg), Vhs)  = let (tm1\', _, V1) = inferExact (G, tm1) let ((tm2\', B, V), ok2) = checkExact1 (G, tm2, Vhs) let _ = delayMismatch (G, V1, V, termRegion tm2\', location_msg, problem_msg) in ((mismatch (tm1\', tm2\', location_msg, problem_msg), B, V), ok2) | checkExact1 (G, omitapx (U, V, (* = Vhs *) , L, r), Vhs)  = let V\' = EClo Vhs let U\' = try  with  in ((omitexact (U\', V\', r), Intro U\', V\'), true) | checkExact1 (G, tm, Vhs)  = let (tm\', B\', V\') = inferExact (G, tm) in ((tm\', B\', V\'), unifiableIdem (G, Vhs, (V\', id)))checkExact (G, tm, Vs, location_msg)  = if not (! trace) then let ((tm\', B\', V\'), ok) = checkExact1 (G, tm, Vs) in if ok then (tm\', B\') else (try  with ) else let (tm\', B\', V\') = inferExact (G, tm) in try  withunifyExact (G, arrow (tm1, tm2), Vhs)  = let (Pi ((Dec (_, Va), _), Vr), s) = whnfExpandDef Vhs let ((tm1\', B1, _, (* Uni Type *) ), ok1) = unifyExact (G, tm1, (Va, s)) let V1 = toIntro (B1, (Uni Type, id)) let D = Dec (NONE, V1) let (tm2\', B2, L) = inferExact (G, tm2) let V2 = toIntro (B2, (L, id)) in ((arrow (tm1\', tm2\'), Intro (Pi ((D, No), EClo (V2, shift))), L), ok1 && unifiableIdem (Decl (G, D), (Vr, dot1 s), (V2, shift))) | unifyExact (G, pi (dec (name, tm1, r), tm2), Vhs)  = let (Pi ((Dec (_, Va), _), Vr), s) = whnfExpandDef Vhs let ((tm1\', B1, _, (* Uni Type *) ), ok1) = unifyExact (G, tm1, (Va, s)) let V1 = toIntro (B1, (Uni Type, id)) let D = Dec (name, V1) let ((tm2\', B2, L), ok2) = if ok1 then unifyExact (Decl (G, D), tm2, (Vr, dot1 s)) else (inferExact (Decl (G, D), tm2), false) let V2 = toIntro (B2, (L, id)) in ((pi (dec (name, tm1\', r), tm2\'), Intro (Pi ((D, Maybe), V2)), L), ok2) | unifyExact (G, hastype (tm1, tm2), Vhs)  = (* Vh : L by invariant *) let (tm2\', _, (* Uni L *) , _, (* Uni (Next L) *) ) = inferExact (G, tm2) let ((tm1\', B, L), ok1) = unifyExact (G, tm1, Vhs) in ((hastype (tm1\', tm2\'), B, L), ok1) | unifyExact (G, mismatch (tm1, tm2, location_msg, problem_msg), Vhs)  = let (tm1\', _, L1) = inferExact (G, tm1) let ((tm2\', B, L), ok2) = unifyExact (G, tm2, Vhs) let _ = delayMismatch (G, L1, L, termRegion tm2\', location_msg, problem_msg) in ((mismatch (tm1\', tm2\', location_msg, problem_msg), B, L), ok2) | unifyExact (G, omitapx (V, (* = Vhs *) , L, nL, (* Next L *) , r), Vhs)  = (* cannot raise Ambiguous *) let L\' = apxToClass (G, L, nL, false) let V\' = EClo Vhs in ((omitexact (V\', L\', r), Intro V\', L\'), true) | unifyExact (G, tm, Vhs)  = let (tm\', B\', L\') = inferExact (G, tm) let V\' = toIntro (B\', (L\', id)) in ((tm\', B\', L\'), unifiableIdem (G, Vhs, (V\', id))) let rec occElim (constant (H, r), os, rs, i)  = (* should probably treat a constant with Foreign\n             attribute as a redex *) let r\' = foldr join r rs in (root (r\', leaf r, conDecImp (headConDec H), i, os), r\') | occElim (bvar (k, r), os, rs, i)  = let r\' = foldr join r rs in (root (r\', leaf r, 0, i, os), r\') | occElim (fvar (name, r), os, rs, i)  = let r\' = foldr join r rs in (root (r\', leaf r, 0, i, os), r\') | occElim (app (tm1, tm2), os, rs, i)  = let (oc2, r2) = occIntro tm2 in occElim (tm1, app (oc2, os), r2 :: rs, i + 1) | occElim (hastype (tm1, tm2), os, rs, i)  = occElim (tm1, os, rs, i) | occElim (tm, os, rs, i)  = (* this is some kind of redex or evar-under-substitution\n           also catches simple introduction forms like `type\' *)  let r\' = foldr join (termRegion tm) rs in (leaf r\', r\')occIntro (arrow (tm1, tm2))  = let (oc1, r1) = occIntro tm1 let (oc2, r2) = occIntro tm2 let r\' = join (r1, r2) in (bind (r\', SOME oc1, oc2), r\') | occIntro (pi (dec (name, tm1, r), tm2))  = let (oc1, r1) = occIntro tm1 let (oc2, r2) = occIntro tm2 let r\' = join (r, r2) in (* not quite consistent with older implementation for dec0 *) (bind (r\', SOME oc1, oc2), r\') | occIntro (lam (dec (name, tm1, r), tm2))  = let (oc1, r1) = occIntro tm1 let (oc2, r2) = occIntro tm2 let r\' = join (r, r2) in (* not quite consistent with older implementation for dec0 *) (bind (r\', SOME oc1, oc2), r\') | occIntro (hastype (tm1, tm2))  = occIntro tm1 | occIntro (tm)  = (* still doesn\'t work quite right for the location -> occurrence map? *) let (oc, r) = occElim (tm, nils, nil, 0) in (oc, r) let rec inferExactJob (G, jnothing)  = JNothing | inferExactJob (G, jand (j1, j2))  = JAnd (inferExactJob (G, j1), inferExactJob (G, j2)) | inferExactJob (G, jwithctx (g, j))  = let rec ie (Null)  = (G, Null) | ie (Decl (g, tm))  = let (G\', Gresult) = ie (g) let (_, D) = inferExactDec (G\', tm) in (Decl (G\', D), Decl (Gresult, D)) let (G\', Gresult) = ie (g) in JWithCtx (Gresult, inferExactJob (G\', j)) | inferExactJob (G, jterm (tm))  = (* others impossible *) let (tm\', B, V) = inferExact (G, tm) let U = toIntro (B, (V, id)) let (oc, r) = occIntro (tm\') let rec iu (Uni Type)  = Kind | iu (Pi (_, V))  = iu V | iu (Root _)  = Type | iu (Redex (V, _))  = iu V | iu (Lam (_, V))  = iu V | iu (EClo (V, _))  = iu V in JTerm ((U, oc), V, iu V) | inferExactJob (G, jclass (tm))  = let (tm\', B, L) = inferExact (G, tm) let V = toIntro (B, (L, id)) let (oc, r) = occIntro (tm\') let (Uni L, _) = whnf (L, id) in JClass ((V, oc), L) | inferExactJob (G, jof (tm1, tm2))  = let (tm2\', B2, L2) = inferExact (G, tm2) let V2 = toIntro (B2, (L2, id)) let (tm1\', B1) = checkExact (G, tm1, (V2, id), "Ascription in declaration did not hold\\n" ^ "(Index object(s) did not match)") let U1 = toIntro (B1, (V2, id)) let (oc2, r2) = occIntro tm2\' let (oc1, r1) = occIntro tm1\' let (Uni L2, _) = whnf (L2, id) in JOf ((U1, oc1), (V2, oc2), L2) | inferExactJob (G, jof\' (tm1, V2))  = (*          val (tm2\', B2, L2) = inferExact (G, tm2)\n          val V2 = toIntro (B2, (L2, id)) *) (*          val (oc2, r2) = occIntro tm2\' *) (*          val (Uni L2, _) = Whnf.whnf (L2, id) *) let (tm1\', B1) = checkExact (G, tm1, (V2, id), "Ascription in declaration did not hold\\n" ^ "(Index object(s) did not match)") let U1 = toIntro (B1, (V2, id)) let (oc1, r1) = occIntro tm1\' in JOf ((U1, oc1), (V2, oc1), Type) let rec recon\' (j)  = (* we leave it to the context to call Names.varReset\n             reason: this code allows reconstructing terms containing\n             existing EVars, and future developments might use that *) (* context must already have called resetErrors *) (* we leave it to the context to call checkErrors\n             reason: the caller may want to do further processing on\n             the "best effort" result returned, even if there were\n             errors *) let _ = varReset () let _ = varReset () let j\' = inferApxJob (Null, j) let _ = clearDelayed () let j\'\' = inferExactJob (Null, j\') let _ = runDelayed () in j\'\' let rec recon (j)  = (queryMode := false; recon\' j) let rec reconQuery (j)  = (queryMode := true; recon\' j) (* Invariant, G must be named! *) let rec reconWithCtx\' (G, j)  = (* we leave it to the context to call Names.varReset\n             reason: this code allows reconstructing terms containing\n             existing EVars, and future developments might use that *) (* context must already have called resetErrors *) (* we leave it to the context to call checkErrors\n             reason: the caller may want to do further processing on\n             the "best effort" result returned, even if there were\n             errors *) let _ = varReset () let _ = varReset () let j\' = inferApxJob\' (G, j) let _ = clearDelayed () let j\'\' = inferExactJob (G, j\') let _ = runDelayed () in j\'\' let rec reconWithCtx (G, j)  = (queryMode := false; reconWithCtx\' (G, j)) let rec reconQueryWithCtx (G, j)  = (queryMode := true; reconWithCtx\' (G, j)) let rec internalInst x  = raise (Match) let rec externalInst x  = raise (Match)  (* open IntSyn *)  end\n(* functor ReconTerm *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* External Syntax and Type Reconstruction *) (* Author: Frank Pfenning *) (* signature EXTSYN\n   provides the interface for type reconstruction as seen\n   by the parser\n*) module type EXTSYN = sig (*! structure Paths : PATHS !*) type term(* term *) type dec(* variable declaration *) val lcid : string list * string * region -> term(* lower case id *) val ucid : string list * string * region -> term(* upper case id *) val quid : string list * string * region -> term(* quoted id, currently not parsed *) val scon : string * region -> term(* string constant *) (* unconditionally interpreted as such *) val evar : string * region -> termval fvar : string * region -> termval typ : region -> term(* type, region for "type" *) val arrow : term * term -> term(* tm -> tm *) val backarrow : term * term -> term(* tm <- tm *) val pi : dec * term -> term(* {d} tm *) val lam : dec * term -> term(* [d] tm *) val app : term * term -> term(* tm tm *) val hastype : term * term -> term(* tm : tm *) val omitted : region -> term(* _ as object, region for "_" *) (* region for "{dec}" "[dec]" etc. *) val dec : string option * term * region -> dec(* id : tm | _ : tm *) val dec0 : string option * region -> dec(* id | _  (type omitted) *)  end\n(* signature EXTSYN *) (* signature RECON_TERM\n   provides the interface to type reconstruction seen by Twelf \n*) module type RECON_TERM = sig (*! structure IntSyn : INTSYN !*) include EXTSYNexception Error of stringval resetErrors : string -> unit(* filename -fp *) val checkErrors : region -> unittype TraceModeProgressiveOmniscientval trace : bool refval traceMode : TraceMode ref(* Reconstruction jobs *) type jobval jnothing : jobval jand : job * job -> jobval jwithctx : dec Ctx * job -> jobval jterm : term -> jobval jclass : term -> jobval jof : term * term -> jobval jof\' : term * Exp -> jobtype JobJNothingJAndJob * JobJWithCtxDec Ctx * JobJTerm(Exp * occExp) * Exp * UniJClass(Exp * occExp) * UniJOf(Exp * occExp) * (Exp * occExp) * Unival recon : job -> Jobval reconQuery : job -> Jobval reconWithCtx : dctx * job -> Jobval reconQueryWithCtx : dctx * job -> Jobval termRegion : term -> regionval decRegion : dec -> regionval ctxRegion : dec Ctx -> region option(* unimplemented for the moment *) val internalInst : \'a -> \'bval externalInst : \'a -> \'b end\n(* signature RECON_TERM *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Lexer *) (* Author: Frank Pfenning *) module type LEXER = sig (* Stream is not memoizing for efficiency *) module Stream : STREAM(*! structure Paths : PATHS !*) type IdCaseUpperLowerQuoted(* '<id>', currently unused *) type TokenEOFDOTPATHSEPCOLONLPARENRPARENLBRACKETRBRACKETLBRACERBRACEBACKARROWARROWTYPEEQUALIDIdCase * stringUNDERSCOREINFIXPREFIXPOSTFIXNAMEDEFINESOLVEQUERYFQUERYCOMPILEQUERYTABLEDMODEUNIQUECOVERSTOTALTERMINATESBLOCKWORLDSREDUCESTABLEDKEEPTABLETHEOREMPROVEESTABLISHASSERTABBREVTRUSTMEFREEZETHAWSUBORDDETERMINISTICCLAUSESIGSTRUCTWHEREINCLUDEOPENUSESTRINGstring(* string constants *) exception Error of string(* lexer returns an infinite stream, terminated by EOF token *) val lexStream : instream -> Token * region streamval lexTerminal : string * string -> Token * region streamval toString : Token -> string(* Utilities *) exception NotDigit of charval stringToNat : string -> intval isUpper : string -> bool end\n(* signature LEXER *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Front End Interface *) (* Author: Frank Pfenning *) (* Presently, we do not memoize the token stream returned *) (* by the lexer.  Use Stream = MStream below if memoization becomes *) (* necessary. *) (* Now in lexer.fun *) (*\nstructure Lexer =\n  Lexer (structure Stream' = Stream\n\t structure Paths' = Paths);\n*) (* Now in parsing.fun *) (*\nstructure Parsing =\n  Parsing (structure Stream' = Stream\n\t   structure Lexer' = Lexer);\n*) module ReconTerm = ReconTerm(struct module Names = Names module Approx = Approx module Whnf = Whnf module Unify = UnifyTrail module Abstract = Abstract module Print = Print module StringTree = StringRedBlackTree module Msg = Msg end)\nmodule ReconConDec = ReconConDec(struct module Global = Global module Names = Names module Abstract = Abstract module ReconTerm' = ReconTerm module Constraints = Constraints module Strict = Strict module TypeCheck = TypeCheck module Timers = Timers module Print = Print module Msg = Msg end)\nmodule ReconQuery = ReconQuery(struct module Global = Global module Names = Names module Abstract = Abstract module ReconTerm' = ReconTerm module TypeCheck = TypeCheck module Strict = Strict module Timers = Timers module Print = Print end)\nmodule ReconMode = ReconMode(struct module Global = Global module Whnf = Whnf module Names = Names module ModePrint = ModePrint module ModeDec = ModeDec module ReconTerm' = ReconTerm end)\nmodule ReconThm = ReconThm(struct module Global = Global module IntSyn = IntSyn module Abstract = Abstract module Constraints = Constraints module Names = Names module ThmSyn' = ThmSyn module ReconTerm' = ReconTerm module Print = Print end)\nmodule ReconModule = ReconModule(struct module Global = Global module IntSyn = IntSyn module Names = Names module ReconTerm' = ReconTerm module ModSyn' = ModSyn module IntTree = IntRedBlackTree end)\nmodule ParseTerm = ParseTerm(struct module ExtSyn' = ReconTerm module Names = Names end)\nmodule ParseConDec = ParseConDec(struct module ExtConDec' = ReconConDec module ParseTerm = ParseTerm end)\nmodule ParseQuery = ParseQuery(struct module ExtQuery' = ReconQuery module ParseTerm = ParseTerm end)\nmodule ParseFixity = ParseFixity(module Names' = Names)\nmodule ParseMode = ParseMode(struct module ExtModes' = ReconMode module ParseTerm = ParseTerm end)\nmodule ParseThm = ParseThm(struct module ThmExtSyn' = ReconThm module ParseTerm = ParseTerm end)\nmodule ParseModule = ParseModule(struct module ModExtSyn' = ReconModule module ParseTerm = ParseTerm end)\nmodule Parser = Parser(struct module Stream' = Stream module ExtSyn' = ReconTerm module Names' = Names module ExtConDec' = ReconConDec module ExtQuery' = ReconQuery module ExtModes' = ReconMode module ThmExtSyn' = ReconThm module ModExtSyn' = ReconModule module ParseConDec = ParseConDec module ParseQuery = ParseQuery module ParseFixity = ParseFixity module ParseMode = ParseMode module ParseThm = ParseThm module ParseModule = ParseModule module ParseTerm = ParseTerm end)\nmodule Solve = Solve(struct module Global = Global module Names = Names module Parser = Parser module ReconQuery = ReconQuery module Timers = Timers module Compile = Compile module CPrint = CPrint module AbsMachine = SwMachine module PtRecon = PtRecon module AbsMachineSbt = AbsMachineSbt module PtRecon = PtRecon module Tabled = Tabled module Print = Print module Msg = Msg end)\nmodule Fquery = Fquery(struct module Global = Global module Names = Names module ReconQuery = ReconQuery module Timers = Timers module Print = Print end)\nmodule Twelf = Twelf(struct module Global = Global module Timers = Timers module Whnf = Whnf module Print = Print module Names = Names module Origins = Origins module Lexer = Lexer module Parser = Parser module TypeCheck = TypeCheck module Strict = Strict module Constraints = Constraints module Abstract = Abstract module ReconTerm = ReconTerm module ReconConDec = ReconConDec module ReconQuery = ReconQuery module ModeTable = ModeTable module ModeCheck = ModeCheck module ModeDec = ModeDec module ReconMode = ReconMode module ModePrint = ModePrint module Unique = Unique module UniqueTable = UniqueTable module Cover = Cover module Converter = Converter module TomegaPrint = TomegaPrint module TomegaCoverage = TomegaCoverage module TomegaTypeCheck = TomegaTypeCheck module Total = Total module Reduces = Reduces module Index = Index module IndexSkolem = IndexSkolem module Subordinate = Subordinate module Compile = Compile module CPrint = CPrint module AbsMachine = SwMachine module Tabled = Tabled module Solve = Solve module Fquery = Fquery module StyleCheck = StyleCheck module ThmSyn = ThmSyn module Thm = Thm module ReconThm = ReconThm module ThmPrint = ThmPrint module TabledSyn = TabledSyn module WorldSyn = WorldSyn module Worldify = Worldify module ModSyn = ModSyn module ReconModule = ReconModule module MetaGlobal = MetaGlobal module Skolem = Skolem module Prover = CombiProver module ClausePrint = ClausePrint module Trace = Trace module PrintTeX = PrintTeX module ClausePrintTeX = ClausePrintTeX module CSManager = CSManager module CSInstaller = CSInstaller module Compat = Compat module UnknownExn = UnknownExn module Msg = Msg end)\n", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* fquery: Executing logic programs via functional interpretation *) (* Author: Carsten Schuermann *) module type FQUERY = sig module ExtQuery : EXTQUERYexception AbortQuery of stringval run : query * location -> unit(* may raise AbortQuery(msg) *)  end\n(* signature SOLVE *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Reconstructing Mode Declarations *) (* Author: Carsten Schuermann *) module ReconMode (module Global : GLOBAL(*! structure ModeSyn\' : MODESYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = ModeSyn\'.IntSyn !*) (*! structure Paths\' : PATHS !*) module Names : NAMES(*! sharing Names.IntSyn = ModeSyn\'.IntSyn !*) module ModePrint : MODEPRINT(*! sharing ModePrint.ModeSyn = ModeSyn\' !*) module ModeDec : MODEDECmodule ReconTerm\' : RECON_TERM(*! sharing ReconTerm\'.IntSyn = ModeSyn\'.IntSyn !*) (*! sharing ReconTerm\'.Paths = Paths\' !*) ) : RECON_MODE = struct (*! structure ModeSyn = ModeSyn\' !*)  module ExtSyn = ReconTerm\' (*! structure Paths = Paths\' !*)  exception Error of string let rec error (r, msg)  = raise (Error (wrap (r, msg))) module M = ModeSynmodule I = IntSynmodule T = ExtSynmodule P = Pathstype mode = Mode * region let rec plus r  = (Plus, r) let rec star r  = (Star, r) let rec minus r  = (Minus, r) let rec minus1 r  = (Minus1, r) type modedec = (cid * ModeSpine) * region module Short = struct type mterm = (cid * ModeSpine) * region type mspine = ModeSpine * region let rec mnil r  = (Mnil, r) let rec mapp (((m, r1), name), (mS, r2))  = (Mapp (Marg (m, name), mS), join (r1, r2)) let rec mroot (ids, id, r1, (mS, r2))  = let r = join (r1, r2) let qid = Qid (ids, id) in match constLookup qid with NONE -> error (r, "Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in mode declaration") | SOME cid -> ((cid, shortToFull (cid, mS, r)), r) let rec toModedec nmS  = nmS end(* structure Short *) module Full = struct type mterm = dec Ctx * Mode Ctx -> (cid * ModeSpine) * region let rec mpi ((m, _), d, t) (g, D)  = t (Decl (g, d), Decl (D, m)) let rec mroot (tm, r) (g, D)  = (* convert term spine to mode spine *) (* Each argument must be contractible to variable *) (* convert root expression to head constant and mode spine *) (* convertExp (I.Root (I.Skonst _, S)) can\'t occur *) let JWithCtx (G, JOf ((V, _), _, _)) = recon (jwithctx (g, jof (tm, typ (r)))) let _ = checkErrors (r) let rec convertSpine (Nil)  = Mnil | convertSpine (App (U, S))  = (* print U? -fp *) (* yes, print U. -gaw *) let k = try  with  let Dec (name, _) = ctxLookup (G, k) let mode = ctxLookup (D, k) in Mapp (Marg (mode, name), convertSpine S) let rec convertExp (Root (Const (a), S))  = (a, convertSpine S) | convertExp (Root (Def (d), S))  = (* error is signalled later in ModeDec.checkFull *)  (d, convertSpine S) | convertExp _  = error (r, "Call pattern not an atomic type") let (a, mS) = convertExp (normalize (V, id)) in (checkFull (a, mS, r); ((a, mS), r)) let rec toModedec t  = let _ = varReset Null let t\' = t (Null, Null) in t\' end(* structure Full *) let rec modeToMode (m, r)  = (m, r) type mode = mode let plus = plus let star = star let minus = minus let minus1 = minus1 type modedec = modedec module Short = Shortmodule Full = Fulllet modeToMode = modeToMode  (* local ... *)  end\n(* functor ReconMode *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Parsing Fixity and Name Preference Declarations *) (* Author: Frank Pfenning *) module ParseFixity ((*! structure Parsing\' : PARSING !*) module Names\' : NAMES) : PARSE_FIXITY = struct (*! structure Parsing = Parsing\' !*)  module Names = Names\' (* some shorthands *) module L = Lexermodule LS = LexerStreammodule FX = NamesFixitylet rec fixToString (Strength (p))  = toString p (* idToPrec (region, (idCase, name)) = n\n       where n is the precedence indicated by name, which should consists\n       of all digits.  Raises error otherwise, or if precedence it too large\n    *) let rec idToPrec (r, (_, name))  = let prec = try  with  in if less (prec, minPrec) || less (maxPrec, prec) then error (r, "Precedence out of range [" ^ fixToString minPrec ^ "," ^ fixToString maxPrec ^ "]") else prec (*-----------------------------*) (* Parsing fixity declarations *) (*-----------------------------*) (* parseFixCon "id" *) let rec parseFixCon (fixity, Cons ((ID (_, name), r), s\'))  = (((Qid (nil, name), r), fixity), expose s\') | parseFixCon (fixity, Cons ((t, r), s\'))  = error (r, "Expected identifier to assign fixity, found " ^ toString t) (* parseFixPrec "n id" where n is precedence *) let rec parseFixPrec (fixity, Cons ((ID id, r), s\'))  = parseFixCon (fixity (idToPrec (r, id)), expose s\') | parseFixPrec (fixity, Cons ((t, r), s\'))  = error (r, "Expected precedence, found " ^ toString t) (* parseInfix "none|left|right n id" where n is precedence *) let rec parseInfix (Cons ((ID (Lower, "none"), r), s\'))  = parseFixPrec ((fun p -> Infix (p, None)), expose s\') | parseInfix (Cons ((ID (Lower, "left"), r), s\'))  = parseFixPrec ((fun p -> Infix (p, Left)), expose s\') | parseInfix (Cons ((ID (Lower, "right"), r), s\'))  = parseFixPrec ((fun p -> Infix (p, Right)), expose s\') | parseInfix (Cons ((t, r), s\'))  = error (r, "Expected associatitivy `left\', `right\', or `none\', found " ^ toString t) (* parsePrefix "n id" where n is precedence *) let rec parsePrefix (f)  = parseFixPrec (Prefix, f) (* parsePostfix "n id" where n is precedence *) let rec parsePostfix (f)  = parseFixPrec (Postfix, f) (* parseFixity\' : lexResult stream -> (name,fixity) * lexResult stream\n       Invariant: token stream starts with %infix, %prefix or %postfix\n    *) let rec parseFixity\' (Cons ((INFIX, r), s\'))  = parseInfix (expose s\') | parseFixity\' (Cons ((PREFIX, r), s\'))  = parsePrefix (expose s\') | parseFixity\' (Cons ((POSTFIX, r), s\'))  = parsePostfix (expose s\') (* anything else should be impossible *) let rec parseFixity (s)  = parseFixity\' (expose (s)) (*------------------------------------*) (* Parsing name preferences %name ... *) (*------------------------------------*) (* parseName5 "string ... )" or ")" *) let rec parseName5 (name, r0, prefENames, prefUNames, Cons ((ID (_, prefUName), r), s\'))  = (* prefUName should be lower case---not enforced *)  parseName5 (name, r0, prefENames, prefUNames @ [prefUName], expose s\') | parseName5 (name, r0, prefENames, prefUNames, Cons ((RPAREN, r), s\'))  = (((Qid (nil, name), r0), (prefENames, prefUNames)), expose s\') | parseName5 (name, r0, prefENames, prefUNames, Cons ((t, r), s\'))  = error (r, "Expected name preference or \')\', found " ^ toString t) (* parseName3 "string" or "" *) let rec parseName3 (name, r0, prefEName, Cons ((ID (_, prefUName), r), s\'))  = (* prefUName should be lower case---not enforced *)  (((Qid (nil, name), r0), (prefEName, [prefUName])), expose s\') | parseName3 (name, r0, prefEName, Cons ((LPAREN, r), s\'))  = parseName5 (name, r0, prefEName, nil, expose s\') | parseName3 (name, r0, prefEName, f)  = (((Qid (nil, name), r0), (prefEName, nil)), f) (* parseName4 "string ... )" or ")" *) let rec parseName4 (name, r0, prefENames, Cons ((ID (_, prefEName), r), s\'))  = if isUpper prefEName then parseName4 (name, r0, prefENames @ [prefEName], expose s\') else error (r, "Expected uppercase identifer, found " ^ prefEName) | parseName4 (name, r0, prefENames, Cons ((RPAREN, r), s\'))  = parseName3 (name, r0, prefENames, expose s\') | parseName4 (name, r0, prefENames, Cons ((t, r), s\'))  = error (r, "Expected name preference or \')\', found " ^ toString t) (* parseName2 "string" or "string string"\n              or "(string ... ) string"  or " string (string ...)"\n              or "(string ... ) (string ...)" *) let rec parseName2 (name, r0, Cons ((ID (_, prefEName), r), s\'))  = if isUpper prefEName then parseName3 (name, r0, [prefEName], expose s\') else error (r, "Expected uppercase identifer, found " ^ prefEName) | parseName2 (name, r0, Cons ((LPAREN, r), s\'))  = parseName4 (name, r0, nil, expose s\') | parseName2 (name, r0, Cons ((t, r), s\'))  = error (r, "Expected name preference, found " ^ toString t) (* parseName1 "id string" or "id string string" *) let rec parseName1 (Cons ((ID (_, name), r), s\'))  = parseName2 (name, r, expose s\') | parseName1 (Cons ((t, r), s\'))  = error (r, "Expected identifer to assign name preference, found " ^ toString t) (* parseNamePref\' "%name id string" or "%name id string string"\n       Invariant: token stream starts with %name\n    *) let rec parseNamePref\' (Cons ((NAME, r), s\'))  = parseName1 (expose s\') let rec parseNamePref (s)  = parseNamePref\' (expose s) let parseFixity\' = parseFixity\' let parseNamePref\' = parseNamePref\'  (* local ... in *)  end\n(* functor ParseFixity *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', 'module Version = struct let current_version = "1.7.1" let current_version_revision = "1813" let rec maybe true x  = x | maybe false x  = "" let official = revision = current_version_revision let external = revision = "exported" let version_string = "Twelf " ^ current_version ^ maybe (not official) "+" ^ " (" ^ maybe (not external && not official) ("r" ^ revision ^ ", ") ^ "built " ^ date ^ " on " ^ hostname ^ ")" end', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* External Syntax for queries *) (* Author: Frank Pfenning *) module type EXTQUERY = sig module ExtSyn : EXTSYN(*! structure Paths : PATHS !*) type query(* query *) val query : string option * term -> query(* ucid : tm | tm *) type defineval define : string option * term * term option -> definetype solveval solve : string option * term * region -> solve(* id : tm | _ : tm *)  end(* signature EXTQUERY *) module type RECON_QUERY = sig (*! structure IntSyn : INTSYN !*) include EXTQUERYexception Error of stringval queryToQuery : query * location -> Exp * string option * Exp * string list(* (A, SOME("X"), [(Y1, "Y1"),...] *) (* where A is query type, X the optional proof term variable name *) (* Yi the EVars in the query and "Yi" their names *) val solveToSolve : define list * solve * location -> Exp * (Exp -> ConDec * occConDec option list) end(* signature RECON_QUERY *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* External Syntax for meta theorems *) (* Author: Carsten Schuermann *) module type THMEXTSYN = sig module ExtSyn : EXTSYN(*! structure Paths : PATHS  !*) type orderval varg : (region * string list) -> orderval lex : (region * order list) -> orderval simul : (region * order list) -> ordertype callpatsval callpats : string * string option list * region list -> callpatstype tdeclval tdecl : order * callpats -> tdecl(* -bp *) type predicateval predicate : (string * region) -> predicate(* -bp *) type rdeclval rdecl : predicate * order * order * callpats -> rdecltype tableddeclval tableddecl : (string * region) -> tableddecltype keepTabledeclval keepTabledecl : (string * region) -> keepTabledecltype proveval prove : int * tdecl -> provetype establishval establish : int * tdecl -> establishtype assertval assert : callpats -> asserttype decstype theoremtype theoremdecval null : decsval decl : (decs * dec) -> decsval top : theoremval exists : decs * theorem -> theoremval forall : decs * theorem -> theoremval forallStar : decs * theorem -> theoremval forallG : decs * decs list * theorem -> theoremval dec : (string * theorem) -> theoremdec(* world checker *) type wdeclval wdecl : string list * string list * callpats -> wdecl(*  val wdecl : (decs * decs) list * callpats -> wdecl *)  end\n(* signature THMEXTSYN *) module type RECON_THM = sig module ThmSyn : THMSYNinclude THMEXTSYNexception Error of stringval tdeclTotDecl : tdecl -> (TDecl * (region * region list))val rdeclTorDecl : rdecl -> (RDecl * (region * region list))val tableddeclTotabledDecl : tableddecl -> (TabledDecl * region)val keepTabledeclToktDecl : keepTabledecl -> (KeepTableDecl * region)val theoremToTheorem : theorem -> ThDeclval theoremDecToTheoremDec : theoremdec -> string * ThDeclval proveToProve : prove -> (PDecl * (region * region list))val establishToEstablish : establish -> (PDecl * (region * region list))val assertToAssert : assert -> (Callpats * region list)val wdeclTowDecl : wdecl -> (WDecl * region list) end\n(* signature RECON_THM *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* External Syntax of Mode Declarations *) (* Author: Carsten Schuermann *) module type EXTMODES = sig module ExtSyn : EXTSYN(*! structure Paths : PATHS  !*) type modeval plus : region -> modeval star : region -> modeval minus : region -> modeval minus1 : region -> modetype modedecmodule Short : sig type mtermtype mspineval mnil : region -> mspineval mapp : (mode * string option) * mspine -> mspineval mroot : string list * string * region * mspine -> mtermval toModedec : mterm -> modedec endmodule Full : sig type mtermval mroot : term * region -> mtermval mpi : mode * dec * mterm -> mtermval toModedec : mterm -> modedec end end\n(* signature EXTMODES *) module type RECON_MODE = sig (*! structure ModeSyn : MODESYN !*) include EXTMODESexception Error of stringval modeToMode : modedec -> (cid * ModeSpine) * region end\n(* signature RECON_MODE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* External Syntax for signature entries *) (* Author: Frank Pfenning *) module type EXTCONDEC = sig module ExtSyn : EXTSYN(*! structure Paths : PATHS !*) type condec(* constant declaration *) val condec : string * term -> condec(* id : tm *) val blockdec : string * dec list * dec list -> condecval blockdef : string * string list * string list -> condecval condef : string option * term * term option -> condec(* id : tm = tm | _ : tm = tm *)  end(* signature EXTCONDEC *) module type RECON_CONDEC = sig (*! structure IntSyn : INTSYN !*) include EXTCONDECexception Error of stringval condecToConDec : condec * location * bool -> ConDec option * occConDec option(* optional ConDec is absent for anonymous definitions *) (* bool = true means that condec is an abbreviation *) val internalInst : ConDec * ConDec * region -> ConDecval externalInst : ConDec * term * region -> ConDec end(* signature RECON_CONDEC *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* fquery: Executing logic programs via functional interpretation *) (* Author: Carsten Schuermann *) module Fquery (module Global : GLOBALmodule Names : NAMESmodule ReconQuery : RECON_QUERYmodule Timers : TIMERSmodule Print : PRINT) : FQUERY = struct module ExtQuery = ReconQuery exception AbortQuery of string module I = IntSyn module T = Tomega module W = WorldSyn module P = Paths (* evarInstToString Xs = msg\n     formats instantiated EVars as a substitution.\n     Abbreviate as empty string if chatter level is < 3.\n  *)  let rec evarInstToString (Xs)  = if ! chatter >= 3 then evarInstToString (Xs) else "" (* expToString (G, U) = msg\n     formats expression as a string.\n     Abbreviate as empty string if chatter level is < 3.\n  *)  let rec expToString GU  = if ! chatter >= 3 then expToString GU else "" let rec lower (0, G, V)  = (G, V) | lower (n, G, Pi ((D, _), V))  = lower (n - 1, Decl (G, D), V) let rec run (quy, Loc (fileName, r))  = (* optName = SOME(X) or NONE, Xs = free variables in query excluding X *) (* times itself *) (* G |- V\'\' : type *) let (V, optName, Xs) = queryToQuery (quy, Loc (fileName, r)) let _ = if ! chatter >= 3 then print ("%fquery") else () let _ = if ! chatter >= 3 then print (" ") else () let _ = if ! chatter >= 3 then print ((time printing expToString) (Null, V) ^ ".\\n") else () let (k, V1) = abstractDecImp V let (G, V2) = lower (k, Null, V1) let a = targetFam V2 let W = lookup a let V3 = worldifyGoal (G, V2) let _ = typeCheck (G, (V3, Uni Type)) let P = convertGoal (embedCtx G, V3) let V = (time delphin evalPrg) P in print ("Delphin: " ^ prgToString (Null, V) ^ "\\n") end\n(* functor Solve *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Parsing modules *) (* Author: Kevin Watkins *) module ParseModule ((*! structure Paths : PATHS !*) (*! structure Parsing\' : PARSING !*) (*! sharing Parsing\'.Lexer.Paths = Paths !*) module ModExtSyn\' : MODEXTSYN(*! sharing ModExtSyn\'.Paths = Paths !*) module ParseTerm : PARSE_TERM(*! sharing ParseTerm.Lexer = Parsing\'.Lexer !*) ParseTermExtSynModExtSyn\'ExtSyn) : PARSE_MODULE = struct (*! structure Parsing = Parsing\' !*)  module ModExtSyn = ModExtSyn\' module L = Lexer module LS = LexerStream module E = ModExtSyn let rec parseStructExp\' (f as Cons ((ID _, r0), _))  = let ((ids, (ID (_, id), r1)), f\') = parseQualId\' f in (strexp (ids, id, join (r0, r1)), f\') | parseStructExp\' (Cons ((t, r), s\'))  = error (r, "Expected structure identifier, found token " ^ toString t) let rec parseColonEqual\' (Cons ((COLON, r1), s\'))  = (match expose s\' with Cons ((EQUAL, _), s\'\') -> ((), expose s\'\') | Cons ((t, r2), s\'\') -> error (r2, "Expected `=\', found token " ^ toString t)) | parseColonEqual\' (Cons ((t, r), s\'))  = error (r, "Expected `:=\', found token " ^ toString t) let rec parseDot\' (Cons ((DOT, r), s\'))  = (r, expose s\') | parseDot\' (Cons ((t, r), s\'))  = error (r, "Expected `.\', found token " ^ toString t) let rec parseConInst\' (f as Cons ((ID _, r0), _))  = let ((ids, (ID (_, id), r1)), f1) = parseQualId\' (f) let (_, f2) = parseColonEqual\' (f1) let (tm, f3) = parseTerm\' (f2) let (r2, f4) = parseDot\' (f3) in (coninst ((ids, id, join (r0, r1)), tm, join (r0, r2)), f4) | parseConInst\' (Cons ((t, r), s\'))  = error (r, "Expected identifier, found token " ^ toString t) let rec parseStrInst2\' (r0, f as Cons ((ID _, r1), _))  = let ((ids, (ID (_, id), r2)), f1) = parseQualId\' (f) let (_, f2) = parseColonEqual\' (f1) let (strexp, f3) = parseStructExp\' (f2) let (r3, f4) = parseDot\' (f3) in (strinst ((ids, id, join (r1, r2)), strexp, join (r0, r3)), f4) | parseStrInst2\' (r0, Cons ((t, r), s\'))  = error (r, "Expected structure identifier, found token " ^ toString t) let rec parseStrInst\' (Cons ((STRUCT, r), s\'))  = parseStrInst2\' (r, expose s\') | parseStrInst\' (Cons ((t, r), s\'))  = error (r, "Expected `%struct\', found token " ^ toString t) let rec parseInsts\' (f as Cons ((ID _, _), _))  = let (inst, f\') = parseConInst\' (f) let (insts, f\'\') = parseInsts\' (f\') in (inst :: insts, f\'\') | parseInsts\' (f as Cons ((STRUCT, _), _))  = let (inst, f\') = parseStrInst\' (f) let (insts, f\'\') = parseInsts\' (f\') in (inst :: insts, f\'\') | parseInsts\' (Cons ((RBRACE, _), s\'))  = (nil, expose s\') | parseInsts\' (Cons ((t, r), s\'))  = error (r, "Expected identifier or `%struct\', found token " ^ toString t) let rec parseInstantiate\' (f as Cons ((LBRACE, _), s\'))  = parseInsts\' (expose s\') | parseInstantiate\' (Cons ((t, r), s\'))  = error (r, "Expected `{\', found token " ^ toString t) let rec parseWhereClauses\' (f as Cons ((WHERE, _), s\'), sigexp)  = let (insts, f\') = parseInstantiate\' (expose s\') in parseWhereClauses\' (f\', wheresig (sigexp, insts)) | parseWhereClauses\' (f, sigexp)  = (sigexp, f) let rec parseSigExp\' (Cons ((ID (_, id), r), s))  = let (sigexp, f\') = parseWhereClauses\' (expose s, sigid (id, r)) in (Done (sigexp), f\') | parseSigExp\' (f as Cons ((LBRACE, r), _))  = (Continuation (fun f\' -> let (sigexp, f\'\') = parseWhereClauses\' (f\', thesig) in (Done (sigexp), f\'\')), f) | parseSigExp\' (Cons ((t, r), _))  = error (r, "Expected signature name or expression, found token " ^ toString t) let rec parseSgEqual\' (idOpt, Cons ((EQUAL, r), s\'))  = recwith (parseSigExp\', fun sigexp -> sigdef (idOpt, sigexp)) (expose s\') | parseSgEqual\' (idOpt, Cons ((t, r), s\'))  = error (r, "Expected `=\', found token " ^ toString t) let rec parseSgDef\' (Cons ((ID (_, id), r), s\'))  = parseSgEqual\' (SOME (id), expose s\') | parseSgDef\' (Cons ((UNDERSCORE, r), s\'))  = parseSgEqual\' (NONE, expose s\') | parseSgDef\' (Cons ((t, r), s\'))  = error (r, "Expected signature identifier, found token " ^ toString t) let rec parseSigDef\' (Cons ((SIG, r), s\'))  = parseSgDef\' (expose s\') let rec parseStrDec2\' (idOpt, Cons ((COLON, r), s\'))  = recwith (parseSigExp\', fun sigexp -> structdec (idOpt, sigexp)) (expose s\') | parseStrDec2\' (idOpt, Cons ((EQUAL, r), s\'))  = let (strexp, f\') = parseStructExp\' (expose s\') in (Done (structdef (idOpt, strexp)), f\') | parseStrDec2\' (idOpt, Cons ((t, r), s\'))  = error (r, "Expected `:\' or `=\', found token " ^ toString t) let rec parseStrDec\' (Cons ((ID (_, id), r), s\'))  = parseStrDec2\' (SOME id, expose s\') | parseStrDec\' (Cons ((UNDERSCORE, r), s\'))  = parseStrDec2\' (NONE, expose s\') | parseStrDec\' (Cons ((t, r), s\'))  = error (r, "Expected structure identifier, found token " ^ toString t) let rec parseStructDec\' (Cons ((STRUCT, r), s\'))  = parseStrDec\' (expose s\') let rec parseInclude\' (Cons ((INCLUDE, r), s\'))  = parseSigExp\' (expose s\') let rec parseOpen\' (Cons ((OPEN, r), s\'))  = parseStructExp\' (expose s\') end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Parsing Queries *) (* Author: Frank Pfenning *) module type PARSE_QUERY = sig (*! structure Parsing : PARSING !*) module ExtQuery : EXTQUERYval parseQuery' : query parserval parseSolve' : define list * solve parser end\n(* signature PARSE_QUERY *) ", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Solve and query declarations, interactive top level *) (* Author: Frank Pfenning *) module type SOLVE = sig (*! structure IntSyn : INTSYN !*) (*! structure Paths : PATHS !*) module ExtQuery : EXTQUERYexception AbortQuery of stringval solve : define list * solve * location -> ConDec * occConDec option listval query : (int option * int option * query) * location -> unit(* may raise AbortQuery(msg) *) val querytabled : (int option * int option * query) * location -> unit(* may raise AbortQuery(msg) *) val qLoop : unit -> bool(* true means normal exit *) val qLoopT : unit -> bool(* true means normal exit *)  end\n(* signature SOLVE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Front End Interface *) (* Author: Frank Pfenning *) (* Modified: Carsten Schuermann, Jeff Polakow, Roberto Virga *) module Solve (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Parser : PARSERParserNamesNamesmodule ReconQuery : RECON_QUERY(*! sharing ReconQuery.IntSyn = IntSyn\' !*) queryquerysolvesolvedefinedefine(* sharing type ReconQuery.Paths.occConDec = Origins.Paths.occConDec *) module Timers : TIMERS(*! structure CompSyn : COMPSYN !*) (*! sharing CompSyn.IntSyn = IntSyn\' !*) module Compile : COMPILE(*! sharing Compile.IntSyn = IntSyn\' !*) (*! sharing Compile.CompSyn = CompSyn !*) module CPrint : CPRINT(*! sharing CPrint.IntSyn = IntSyn\' !*) (*! sharing CPrint.CompSyn = CompSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) module AbsMachine : ABSMACHINE(*! sharing AbsMachine.IntSyn = IntSyn\' !*) (*! sharing AbsMachine.CompSyn = CompSyn !*) module AbsMachineSbt : ABSMACHINESBT(*! sharing AbsMachineSbt.IntSyn = IntSyn\' !*) (*! sharing AbsMachineSbt.CompSyn = CompSyn!*) module PtRecon : PTRECON(*! sharing PtRecon.IntSyn = IntSyn\' !*) (*! sharing PtRecon.CompSyn = CompSyn !*) (*! structure TableParam : TABLEPARAM !*) module Tabled : TABLED(*! sharing Tabled.IntSyn = IntSyn\' !*) (*! sharing Tabled.CompSyn = CompSyn !*) (*! structure MemoTable : MEMOTABLE !*) (*! sharing MemoTable.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module Msg : MSG) : SOLVE = struct (*! structure IntSyn = IntSyn\' !*)  module ExtQuery = ReconQuery (*! structure Paths = ReconQuery.Paths !*)  module S = ParserStream (* evarInstToString Xs = msg\n     formats instantiated EVars as a substitution.\n     Abbreviate as empty string if chatter level is < 3.\n  *)  let rec evarInstToString (Xs)  = if ! chatter >= 3 then evarInstToString (Xs) else "" (* expToString (G, U) = msg\n     formats expression as a string.\n     Abbreviate as empty string if chatter level is < 3.\n  *)  let rec expToString GU  = if ! chatter >= 3 then expToString GU else "" (* exception AbortQuery\n     is raised when a %query declaration has an unexpected number of solutions\n     or of %solve has no solution.\n  *)  exception AbortQuery of string (* Bounds SOME(n) for n >= 0, NONE represents positive infinity *)  (* Concrete syntax: 0, 1, 2, ..., * *)  type bound = int option (* exceeds : bound * bound -> bool *)  let rec exceeds (SOME (n), SOME (m))  = (n >= m) | exceeds (SOME (n), NONE)  = false | exceeds (NONE, _)  = true (* boundEq : bound * bound -> bool *)  let rec boundEq (SOME (n), SOME (m))  = (n = m) | boundEq (NONE, NONE)  = true | boundEq _  = false (* boundToString : bound -> string *)  let rec boundToString (SOME (n))  = toString (n) | boundToString (NONE)  = "*" (* boundMin : bound * bound -> bound *)  let rec boundMin (SOME (n), SOME (m))  = SOME (min (n, m)) | boundMin (b, NONE)  = b | boundMin (NONE, b)  = b (* checkSolutions : bound * bound * int -> unit *)  (* raises AbortQuery(msg) if the actual solutions do not match *)  (* the expected number, given the bound on the number of tries *)  let rec checkSolutions (expected, try, solutions)  = if boundEq (boundMin (expected, try), SOME (solutions)) then () else raise (AbortQuery ("Query error -- wrong number of solutions: expected " ^ boundToString expected ^ " in " ^ boundToString try ^ " tries, but found " ^ toString solutions)) (* checkStages : bound * int -> unit *)  (* raises AbortQuery(msg) if the actual #stages do not match *)  (* the expected number, given the bound on the number of tries *)  let rec checkStages (try, stages)  = if boundEq (try, SOME (stages)) then () else raise (AbortQuery ("Query error -- wrong number of stages: " ^ boundToString try ^ " tries, but terminated after  " ^ toString stages)) (* moreSolutions () = b  iff  the user requests more solutions\n     Effects: inputs one line from standard input,\n              raises exception AbortQuery(msg) is first character is "q" or "Q"\n  *)  let rec moreSolutions ()  = (print ("More? "); match sub (inputLine97 (stdIn), 0) with \'y\' -> true | \'Y\' -> true | \';\' -> true | \'q\' -> raise (AbortQuery ("Query error -- explicit quit")) | \'Q\' -> raise (AbortQuery ("Query error -- explicit quit")) | _ -> false) (* exception Done is raised by the initial success continuation\n     when no further solutions are requested.\n  *)  exception Done (* exception Completed raised by tabled computation when table is saturated *)  exception Completed (* exception Solution (imp, (M, A))\n     is raised when M : A is the generalized form of a solution to the\n     query A\', where imp is the number of implicitly quantified arguments.\n  *)  exception Solution of Exp exception SolutionSkel of pskeleton (* readfile (fileName) = status\n     reads and processes declarations from fileName in order, issuing\n     error messages and finally returning the status (either OK or\n     ABORT).\n  *)  let rec solve\' (defines, solve, Loc (fileName, r))  = (* echo declaration, according to chatter level *) let (A, finish) = (* self timing *) solveToSolve (defines, solve, Loc (fileName, r)) let _ = if ! chatter >= 3 then message ("%solve ") else () let _ = if ! chatter >= 3 then message ("\\n" ^ (time printing expToString) (Null, A) ^ ".\\n") else () let g = (time compiling compileGoal) (Null, A) let rec search ()  = solve ((g, id), DProg (Null, Null), fun M -> raise (Solution M)) in reset (); try  with (* Using substitution tree indexing for clauses in signature\n   The logic programming interpreter then creates a proof skeleton\n  and reconstructs the actual proof term which can be checked\n  -- this version can be used to produce oracles, however no user\n  directive is added yet.\n*)  let rec solveSbt (defines, solve, Loc (fileName, r))  = (* echo declaration, according to chatter level *) let (A, finish) = (* self timing *) solveToSolve (defines, solve, Loc (fileName, r)) let _ = if ! chatter >= 3 then message ("%solve ") else () let _ = if ! chatter >= 3 then message ("\\n" ^ (time printing expToString) (Null, A) ^ ".\\n") else () let g = (time compiling compileGoal) (Null, A) in reset (); try  with let rec solve args  = match (! optimize) with (* solves A where program clauses are indexed using substitution trees\n         and reconstructs the proof term X afterwards - bp\n       *) Indexing -> solveSbt args | LinearHeads -> solve\' args | _ -> solve\' args (* %query <expected> <try> A or %query <expected> <try> X : A *)  let rec query\' ((expected, try, quy), Loc (fileName, r))  = (* optName = SOME(X) or NONE, Xs = free variables in query excluding X *) (* times itself *) (* Problem: we cannot give an answer substitution for the variables\n         in the printed query, since the new variables in this query\n         may not necessarily have global scope.\n\n         For the moment, we print only the answer substitution for the\n         original variables encountered during parsing.\n       *) (* val Xs\' = if !Global.chatter >= 3 then Names.namedEVars () else Xs\n       *) (* solutions = ref <n> counts the number of solutions found *) (* Initial success continuation prints substitution (according to chatter level)\n         and raises exception Done if bound has been reached, otherwise it returns\n         to search for further solutions\n       *) let (A, optName, Xs) = queryToQuery (quy, Loc (fileName, r)) let _ = if ! chatter >= 3 then message ("%query " ^ boundToString expected ^ " " ^ boundToString try ^ "\\n") else () let _ = if ! chatter >= 4 then message (" ") else () let _ = if ! chatter >= 3 then message ("\\n" ^ (time printing expToString) (Null, A) ^ ".\\n") else () let g = (time compiling compileGoal) (Null, A) let solutions = ref 0 let rec scInit M  = (solutions := ! solutions + 1; if ! chatter >= 3 then (message ("---------- Solution " ^ toString (! solutions) ^ " ----------\\n"); message ((time printing evarInstToString) Xs ^ "\\n")) else if ! chatter >= 3 then message "." else (); match optName with NONE -> () | SOME (name) -> if ! chatter >= 3 then message ((time printing evarInstToString) [(M, name)] ^ "\\n") else (); if ! chatter >= 3(* Question: should we collect constraints in M? *)  then match (time printing evarCnstrsToStringOpt) Xs with NONE -> () | SOME (str) -> message ("Remaining constraints:\\n" ^ str ^ "\\n") else (); if exceeds (SOME (! solutions), try) then raise (Done) else ()) let rec search ()  = solve ((g, id), DProg (Null, Null), scInit) in if not (boundEq (try, SOME (0))) then (reset (); (* solve query if bound > 0 *) try  with ; reset (); (* in case Done was raised *) (* check if number of solutions is correct *) checkSolutions (expected, try, ! solutions)) else if ! chatter >= 3 then message ("Skipping query (bound = 0)\\n") else if ! chatter >= 4 then message ("skipping") else (); if ! chatter >= 3 then message "____________________________________________\\n\\n" else if ! chatter >= 4 then message (" OK\\n") else () (* %query <expected> <try> A or %query <expected> <try> X : A *)  let rec querySbt ((expected, try, quy), Loc (fileName, r))  = (* optName = SOME(X) or NONE, Xs = free variables in query excluding X *) (* times itself *) (* Problem: we cannot give an answer substitution for the variables\n               in the printed query, since the new variables in this query\n               may not necessarily have global scope.\n\n               For the moment, we print only the answer substitution for the\n               original variables encountered during parsing.\n             *) (*\n                val Xs\' = if !Global.chatter >= 3 then Names.namedEVars () else Xs\n             *) (* solutions = ref <n> counts the number of solutions found *) (* Initial success continuation prints substitution (according to chatter level)\n         and raises exception Done if bound has been reached, otherwise it returns\n         to search for further solutions\n       *) let (A, optName, Xs) = queryToQuery (quy, Loc (fileName, r)) let _ = if ! chatter >= 3 then message ("%query " ^ boundToString expected ^ " " ^ boundToString try ^ "\\n") else () let _ = if ! chatter >= 4 then message (" ") else () let _ = if ! chatter >= 3 then message ("\\n" ^ (time printing expToString) (Null, A) ^ ".\\n") else () let g = (time compiling compileGoal) (Null, A) let solutions = ref 0 let rec scInit M  = (solutions := ! solutions + 1; if ! chatter >= 3 then (message ("---------- Solution " ^ toString (! solutions) ^ " ----------\\n"); message ((time printing evarInstToString) Xs ^ "\\n")) else if ! chatter >= 3 then message "." else (); match optName with NONE -> () | SOME (name) -> (if ! chatter > 3 then (message ("\\n pskeleton \\n"); message ((pskeletonToString M) ^ "\\n")) else (); (time ptrecon solve) (M, (g, id), DProg (Null, Null), (fun (pskel, M) -> (if ! chatter >= 3 then message ((time printing evarInstToString) [(M, name)] ^ "\\n") else ())))); if ! chatter >= 3(* Question: should we collect constraints in M? *)  then match (time printing evarCnstrsToStringOpt) Xs with NONE -> () | SOME (str) -> message ("Remaining constraints:\\n" ^ str ^ "\\n") else (); if exceeds (SOME (! solutions), try) then raise (Done) else ()) let rec search ()  = solve ((g, id), DProg (Null, Null), scInit) in if not (boundEq (try, SOME (0))) then (reset (); (* solve query if bound > 0 *) try  with ; (* printing is timed into solving! *) reset (); (* in case Done was raised *) (* check if number of solutions is correct *) checkSolutions (expected, try, ! solutions)) else if ! chatter >= 3 then message ("Skipping query (bound = 0)\\n") else if ! chatter >= 4 then message ("skipping") else (); if ! chatter >= 3 then message "____________________________________________\\n\\n" else if ! chatter >= 4 then message (" OK\\n") else () (* %query <expected> <try> A or %query <expected> <try> X : A  *)  let rec query args  = match (! optimize) with (* Execute query where program clauses are\n            indexed using substitution trees -- if we require the proof term X\n            it will be reconstructed after the query A has succeeded - bp\n          *) Indexing -> querySbt args | LinearHeads -> query\' args | _ -> query\' args (* %querytabled <expected solutions> <max stages tried>  A\nor  %querytabled <expected solutions> <max stages tried>  X : A\n  note : %querytabled terminates if we have found the expected number of\n  solutions or if we have reached the maximal number of stages *)  let rec querytabled ((numSol, try, quy), Loc (fileName, r))  = (* optName = SOME(X) or NONE, Xs = free variables in query excluding X *) (* times itself *) (* Problem: we cannot give an answer substitution for the variables\n        in the printed query, since the new variables in this query\n        may not necessarily have global scope.\n\n        For the moment, we print only the answer substitution for the\n        original variables encountered during parsing.\n     *) (* val Xs\' = if !Global.chatter >= 3 then Names.namedEVars () else Xs *) (* solutions = ref <n> counts the number of solutions found *) (* stage = ref <n> counts the number of stages found *) (* Initial success continuation prints substitution (according to chatter level)\n         and raises exception Done if bound has been reached, otherwise it returns\n         to search for further solutions\n       *) (* loops -- scinit will raise exception Done *) let _ = if ! chatter >= 3 then message ("%querytabled " ^ boundToString numSol ^ " " ^ boundToString try) else () let (A, optName, Xs) = queryToQuery (quy, Loc (fileName, r)) let _ = if ! chatter >= 4 then message (" ") else () let _ = if ! chatter >= 3 then message ("\\n" ^ (time printing expToString) (Null, A) ^ ".\\n") else () let g = (time compiling compileGoal) (Null, A) let solutions = ref 0 let status = ref false let solExists = ref false let stages = ref 1 let rec scInit O  = (solutions := ! solutions + 1; solExists := true; if ! chatter >= 3 then (message ("\\n---------- Solutions " ^ toString (! solutions) ^ " ----------\\n"); message ((time printing evarInstToString) Xs ^ " \\n")) else if ! chatter >= 1 then message "." else (); (match optName with NONE -> () | SOME (name) -> (message (pskeletonToString O ^ "\\n"); (time ptrecon solve) (O, (g, id), DProg (Null, Null), (fun (O, M) -> if ! chatter >= 3 then message ((time printing evarInstToString) [(M, name)] ^ "\\n") else ())))); (if ! chatter >= 3 then (* Question: should we collect constraints in M? *) match (time printing evarCnstrsToStringOpt) Xs with NONE -> () | SOME (str) -> message ("Remaining constraints:\\n" ^ str ^ "\\n") else ()); (if ! chatter >= 1 then message "More solutions?\\n" else ()); match numSol with NONE -> () | SOME n -> (if (! solutions = n) then ((if ! chatter >= 1 then message "Found enough solutions\\n" else ()); raise (Done)) else ())) let rec loop ()  = (if exceeds (SOME (! stages - 1), try) then ((if ! chatter >= 1 then message ("\\n ================= " ^ " Number of tries exceeds stages " ^ " ======================= \\n") else ()); status := false; raise (Done)) else (); (if ! chatter >= 1 then message ("\\n ====================== Stage " ^ toString (! stages) ^ " finished =================== \\n") else ()); if exceeds (SOME (! stages), try) then (message ("\\n ================= " ^ " Number of tries exceeds stages " ^ " ======================= \\n"); status := false; raise (Done)) else (); if nextStage () then (stages := (! stages) + 1; loop ()) else (* table did not change,\n                         * i.e. all solutions have been found\n                         * we check for *all* solutions\n                         *) status := true; raise (Done)) let _ = reset () let _ = fillTable () let rec tabledSearch ()  = (solve ((g, id), DProg (Null, Null), scInit); reset (); (* in case Done was raised *) (* next stage until table doesn\'t change *) loop (); checkStages (try, ! stages)) in if not (boundEq (try, SOME (0))) then try  with  else if ! chatter >= 3 then message ("Skipping query (bound = 0)\\n") else if ! chatter >= 2 then message ("skipping") else (); if ! chatter >= 3 then (message "\\n____________________________________________\\n\\n"; message ("number of stages: tried " ^ boundToString try ^ " \\n" ^ "terminated after " ^ toString (! stages) ^ " stages \\n \\n"); if (! solExists) then () else message "\\nNO solution exists to query \\n\\n"; if (! status) then message "Tabled evaluation COMPLETE \\n \\n" else message "Tabled evaluation NOT COMPLETE \\n \\n"; message "\\n____________________________________________\\n\\n"; message "\\n Table Indexing parameters: \\n"; match (! strategy) with Variant -> message "\\n       Table Strategy := Variant \\n" | Subsumption -> message "\\n       Table Strategy := Subsumption \\n"; if (! strengthen) then message "\\n       Strengthening := true \\n" else message "\\n       Strengthening := false \\n"; message ("\\nNumber of table indices : " ^ toString (tableSize ()) ^ "\\n"); message ("Number of suspended goals : " ^ toString (suspGoalNo ()) ^ "\\n"); message "\\n____________________________________________\\n\\n") else (if ! chatter >= 3 then message (" OK\\n") else ()); updateGlobalTable (g, ! status) (* Interactive Query Top Level *)  let rec qLoop ()  = qLoops (reset (); parseTerminalQ ("?- ", "   "))(* primary, secondary prompt *) qLoops (s)  = qLoops\' ((time parsing expose) s)qLoops\' (Empty)  = true | qLoops\' (Cons (query, s\'))  = (* times itself *) let (A, optName, Xs) = queryToQuery (query, Loc ("stdIn", Reg (0, 0))) let g = (time compiling compileGoal) (Null, A) let rec scInit M  = ((if ! chatter >= 1 then message ((time printing evarInstToString) Xs ^ "\\n") else ()); match optName with NONE -> () | SOME (name) -> if ! chatter >= 3 then message ((time printing evarInstToString) [(M, name)] ^ "\\n") else (); if ! chatter >= 3(* Question: should we collect constraints from M *)  then match (time printing evarCnstrsToStringOpt) Xs with NONE -> () | SOME (str) -> message ("Remaining constraints:\\n" ^ str ^ "\\n") else (); if moreSolutions () then () else raise (Done)) let _ = if ! chatter >= 3 then message "Solving...\\n" else () in try  with ; (* Ignore s\': parse one query at a time *) qLoop () (* querytabled interactive top loop *)  let rec qLoopT ()  = qLoopsT (reset (); parseTerminalQ ("?- ", "   "))(* primary, secondary prompt *) qLoopsT (s)  = qLoopsT\' ((time parsing expose) s)qLoopsT\' (Empty)  = true | qLoopsT\' (Cons (query, s\'))  = (* times itself *) (* loops -- scinit will raise exception Done *) let solExists = ref false let (A, optName, Xs) = queryToQuery (query, Loc ("stdIn", Reg (0, 0))) let g = (time compiling compileGoal) (Null, A) let _ = reset () let rec scInit O  = ((if ! chatter >= 1 then message ((time printing evarInstToString) Xs ^ "\\n") else ()); match optName with NONE -> () | SOME (name) -> if ! chatter >= 3 then message (" Sorry cannot reconstruct pskeleton proof terms yet \\n") else (); if ! chatter >= 3(* Question: should we collect constraints from M? *)  then match (time printing evarCnstrsToStringOpt) Xs with NONE -> () | SOME (str) -> message ("Remaining constraints:\\n" ^ str ^ "\\n") else (); solExists := true; if moreSolutions () then () else raise (Done)) let rec loop ()  = (if nextStage () then loop () else (* table did not change,\n                         * i.e. all solutions have been found\n                         * we check for *all* solutions\n                         *) raise (Completed)) let _ = if ! chatter >= 3 then message "Solving...\\n" else () in try  with ; (* Ignore s\': parse one query at a time *) qLoopT () end\n(* functor Solve *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Front End Interface *) (* Author: Frank Pfenning *) module type TWELF = sig module Print : sig val implicit : bool ref(* false, print implicit args *) val printInfix : bool ref(* false, print fully explicit form infix when possible *) val depth : int option ref(* NONE, limit print depth *) val length : int option ref(* NONE, limit argument length *) val indent : int ref(* 3, indentation of subterms *) val width : int ref(* 80, line width *) val noShadow : bool ref(* if true, don\'t print shadowed constants as "%const%" *) val sgn : unit -> unit(* print signature *) val prog : unit -> unit(* print signature as program *) val subord : unit -> unit(* print subordination relation *) val def : unit -> unit(* print information about definitions *) val domains : unit -> unit(* print available constraint domains *) module TeX : (* print in TeX format *) sig val sgn : unit -> unit(* print signature *) val prog : unit -> unit(* print signature as program *)  end endmodule Trace : sig type \'aSpecNoneSome\'a listAll(* trace all clauses and families *) val trace : string Spec -> unit(* trace clauses and families *) val break : string Spec -> unit(* break at clauses and families *) val detail : int ref(* 0 = none, 1 = default, 2 = unify *) val show : unit -> unit(* show trace, break, and detail *) val reset : unit -> unit(* reset trace, break, and detail *)  endmodule Table : sig type StrategyVariantSubsumption(* Variant | Subsumption *) val strategy : Strategy ref(* strategy used for %querytabled *) val strengthen : bool ref(* strengthenng used %querytabled *) val resetGlobalTable : unit -> unit(* reset global table           *) val top : unit -> unit(* top-level for interactive tabled queries *)  endmodule Timers : sig val show : unit -> unit(* show and reset timers *) val reset : unit -> unit(* reset timers *) val check : unit -> unit(* display, but not no reset *)  endmodule OS : sig val chDir : string -> unit(* change working directory *) val getDir : unit -> string(* get working directory *) val exit : unit -> unit(* exit Twelf and ML *)  endmodule Compile : sig type OptNoLinearHeadsIndexingval optimize : Opt ref endmodule Recon : sig type TraceModeProgressiveOmniscientval trace : bool refval traceMode : TraceMode ref endmodule Prover : sig type StrategyRFSFRS(* F=Filling, R=Recursion, S=Splitting *) val strategy : Strategy ref(* FRS, strategy used for %prove *) val maxSplit : int ref(* 2, bound on splitting  *) val maxRecurse : int ref(* 10, bound on recursion *)  endval chatter : int ref(* 3, chatter level *) val doubleCheck : bool ref(* false, check after reconstruction *) val unsafe : bool ref(* false, allows %assert *) val autoFreeze : bool ref(* false, freezes families in meta-theorems *) val timeLimit : time option ref(* NONEe, allows timeLimit in seconds *) type StatusOKABORT(* return status *) val reset : unit -> unit(* reset global signature *) val loadFile : string -> Status(* load file *) val loadString : string -> Status(* load string *) val readDecl : unit -> Status(* read declaration interactively *) val decl : string -> Status(* print declaration of constant *) val top : unit -> unit(* top-level for interactive queries *) module Config : sig type config(* configuration *) val suffix : string ref(* suffix of configuration files *) val read : string -> config(* read config file *) val readWithout : string * config -> config(* read config file, minus contents of another *) val load : config -> Status(* reset and load configuration *) val append : config -> Status(* load configuration (w/o reset) *) val define : string list -> config(* explicitly define configuration *)  endval make : string -> Status(* read and load configuration *) val version : string(* Twelf version *)  end\n(* signature TWELF *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Parsing Signature Entries *) (* Author: Frank Pfenning *) module type PARSE_CONDEC = sig (*! structure Parsing : PARSING !*) module ExtConDec : EXTCONDECval parseConDec' : condec parserval parseAbbrev' : condec parserval parseClause' : condec parser end\n(* signature PARSE_CONDEC *) ", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Parsing Mode Declarations *) (* Author: Carsten Schuermann *) module type PARSE_MODE = sig (*! structure Parsing : PARSING !*) module ExtModes : EXTMODESval parseMode' : modedec list parser end\n(* signature PARSE_MODE *) ", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Parsing Queries *) (* Author: Frank Pfenning *) module ParseQuery ((*! structure Parsing\' : PARSING !*) module ExtQuery\' : EXTQUERY(*! sharing ExtQuery\'.Paths = Parsing\'.Lexer.Paths !*) module ParseTerm : PARSE_TERM(*! sharing ParseTerm.Lexer = Parsing\'.Lexer !*) ParseTermExtSynExtQuery\'ExtSyn) : PARSE_QUERY = struct (*! structure Parsing = Parsing\' !*)  module ExtQuery = ExtQuery\' module L = Lexermodule LS = LexerStreammodule P = Pathslet rec returnQuery (optName, (tm, f))  = (query (optName, tm), f) (* parseQuery1 (name, f, f\')   ": A" from f\' or "V" from f. *) let rec parseQuery1 (name, f, Cons ((COLON, r), s\'))  = returnQuery (SOME (name), parseTerm\' (expose s\')) | parseQuery1 (name, f, _)  = returnQuery (NONE, parseTerm\' f) (* parseQuery\' : lexResult front -> ExtQuery.query * lexResult front *) (* parseQuery\'  "X : A" | "A" *) (* Query parsing is ambiguous, since a term "V" might have the form "U\' : V\'" *) (* We look for an uppercase variable X followed by a `:\'.\n       If we find this, we parse a query of the form "X : A".\n       Otherwise we parse a query of the form "A".\n    *) let rec parseQuery\' (f as Cons ((ID (Upper, name), r), s\'))  = parseQuery1 (name, f, expose s\') | parseQuery\' (f)  = returnQuery (NONE, parseTerm\' f) (* parseQuery --- currently not exported *) let rec parseQuery (s)  = parseQuery\' (expose s) (* parseDefine4 parses the definition body *) (* "U" *) let rec parseDefine4 (optName, optT, s)  = let (tm\', f\') = parseTerm\' (expose s) in (define (optName, tm\', optT), f\') (* parseDefine3 parses the equal sign in a long form define *) (* "= U" *) let rec parseDefine3 (optName, (tm, Cons ((EQUAL, r), s\')))  = parseDefine4 (optName, SOME (tm), s\') | parseDefine3 (_, (tm, Cons ((t, r), _)))  = error (r, "Expected `=\', found " ^ toString t) (* parseDefine2 switches between short and long form *) (* ": V = U" | "= U" *) let rec parseDefine2 (optName, Cons ((COLON, r), s\'))  = parseDefine3 (optName, parseTerm\' (expose s\')) | parseDefine2 (optName, Cons ((EQUAL, r), s\'))  = parseDefine4 (optName, NONE, s\') | parseDefine2 (_, Cons ((t, r), _))  = error (r, "Expected `:\' or `=\', found " ^ toString t) (* parseDefine1 parses the name of the constant to be defined *) (* "c : V = U" | "_ : V = U" | "c = U" | "_ = U" *) let rec parseDefine1 (Cons ((ID (idCase, name), r), s\'))  = parseDefine2 (SOME (name), expose s\') | parseDefine1 (Cons ((UNDERSCORE, r), s\'))  = parseDefine2 (NONE, expose s\') | parseDefine1 (Cons ((t, r), _))  = error (r, "Expected identifier or `_\', found " ^ toString t) let rec parseSolve3 (defns, nameOpt, Cons ((COLON, r), s\'), r0)  = let (tm, f\' as Cons ((_, r), _)) = parseTerm\' (expose s\') in ((rev defns, solve (nameOpt, tm, join (r0, r))), f\') | parseSolve3 (_, _, Cons ((t, r), s\'), r0)  = error (r, "Expected `:\', found " ^ toString t) let rec parseSolve2 (defns, Cons ((UNDERSCORE, r), s\'), r0)  = parseSolve3 (defns, NONE, expose s\', r0) | parseSolve2 (defns, Cons ((ID (_, name), r), s\'), r0)  = parseSolve3 (defns, SOME name, expose s\', r0) | parseSolve2 (_, Cons ((t, r), s\'), r0)  = error (r, "Expected identifier or `_\', found " ^ toString t)parseSolve1 (defns, Cons ((SOLVE, r0), s\'))  = parseSolve2 (defns, expose s\', r0) | parseSolve1 (defns, Cons ((DEFINE, r0), s\'))  = let (defn, f\') = parseDefine1 (expose s\') in parseSolve1 (defn :: defns, f\') | parseSolve1 (defns, Cons ((t, r), s))  = error (r, "Expected %define or %solve, found " ^ toString t)parseSolve\' (f)  = parseSolve1 (nil, f) let parseQuery\' = parseQuery\' let parseSolve\' = parseSolve\'  (* local ... in *)  end\n(* functor ParseQuery *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: (* Print exception trace in unknownExn.  Both SML/NJ and MLton have
   SMLofNJ.exnHistory.
*) module UnknownExn = UnknownExn()

('Error parsing code:', '(* Unification *) (* Author: Frank Pfenning, Carsten Schuermann *) (* Modified: Roberto Virga *) module Unify ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Trail : TRAIL) : UNIFY = struct (*! structure IntSyn = IntSyn\' !*)  exception Unify of string exception NotInvertible open IntSyn type Action = Instantiate of Exp option ref | InstantiateBlock of Block option ref | Add of cnstr list ref | Solve of cnstr * Cnstr type CAction = BindCnstr of Cnstr ref * Cnstr type FAction = BindExp of Exp option ref * Exp option | BindBlock of Block option ref * Block option | BindAdd of cnstr list ref * CAction list | FSolve of Cnstr ref * Cnstr * Cnstr (* ? *) type unifTrail = FAction trail let globalTrail = trail () : Action trail let rec copyCnstr []  = [] | copyCnstr (refC :: clist)  = (BindCnstr (refC, ! refC) :: copyCnstr clist) let rec copy (Instantiate refU)  = (BindExp (refU, ! refU)) | copy (InstantiateBlock refB)  = (BindBlock (refB, ! refB)) | copy (Add (cnstrs as ref Cnstrs))  = (BindAdd (cnstrs, copyCnstr (! cnstrs))) | copy (Solve (cnstr, Cnstr))  = (FSolve (cnstr, Cnstr, ! cnstr)) let rec resetCnstr []  = [] | resetCnstr (BindCnstr (refC, Cnstr) :: L)  = (refC := Cnstr; (refC :: (resetCnstr L))) let rec reset (BindExp (refU, U))  = (refU := U; Instantiate refU) | reset (BindBlock (refB, B))  = (refB := B; InstantiateBlock refB) | reset (BindAdd (cnstrs, CActions))  = (cnstrs := resetCnstr CActions; Add cnstrs) | reset (FSolve (refCnstr, Cnstr, Cnstr\'))  = (refCnstr := Cnstr\'; Solve (refCnstr, Cnstr)) let rec suspend ()  = suspend (globalTrail, copy) let rec resume trail  = resume (trail, globalTrail, reset) let rec undo (Instantiate refU)  = (refU := NONE) | undo (InstantiateBlock refB)  = (refB := NONE) | undo (Add (cnstrs as ref (cnstr :: cnstrL)))  = (cnstrs := cnstrL) | undo (Solve (cnstr, Cnstr))  = (cnstr := Cnstr) let rec reset ()  = reset globalTrail let rec mark ()  = mark globalTrail let rec unwind ()  = unwind (globalTrail, undo) let rec addConstraint (cnstrs, cnstr)  = (cnstrs := cnstr :: (! cnstrs); log (globalTrail, Add (cnstrs))) let rec solveConstraint (cnstr as ref (Cnstr))  = (cnstr := Solved; log (globalTrail, Solve (cnstr, Cnstr))) (* Associate a constraint to an expression *) (* delayExpW ((U, s), cnstr) = ()\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V    (U,s)  in whnf\n       then\n       the constraint cnstr is added to all the rigid EVar occurrences in U[s]\n    *) let rec delayExpW ((U as Uni (L), s1), _)  = () | delayExpW ((Pi ((D, P), U), s), cnstr)  = (delayDec ((D, s), cnstr); delayExp ((U, dot1 s), cnstr)) | delayExpW ((Root (H, S), s), cnstr)  = (delayHead (H, cnstr); delaySpine ((S, s), cnstr)) | delayExpW ((Lam (D, U), s), cnstr)  = (delayDec ((D, s), cnstr); delayExp ((U, dot1 s), cnstr)) | delayExpW ((EVar (G, r, V, cnstrs), s), cnstr)  = addConstraint (cnstrs, cnstr) | delayExpW ((FgnExp csfe, s), cnstr)  = (* s = id *)  apply csfe (fun U -> delayExp ((U, s), cnstr))(* no other cases by invariant *) (* delayExp ((U, s), cnstr) = ()\n       as in delayExpCW, except that the argument may not be in whnf\n    *) delayExp (Us, cnstr)  = delayExpW (whnf Us, cnstr)(* delayHead (H, s, rOccur) = ()\n\n       Invariant:\n       If   G\' |- H : V\n       and  G\' |- s : G         s is a pattern substitution\n       then\n       the constraint cnstr is added to a total of n rigid EVar occurrences in H[s]\n    *) delayHead (FVar (x, V, s\'), cnstr)  = delayExp ((V, id), cnstr) | delayHead (H, _)  = ()(* delaySpine ((S, s), cnstr) = ()\n\n       Invariant:\n       If   G\' |- s : G    G |- S : V > W\n       then      G  |- S\' : V\' > W\'\n       the constraint cnstr is added to all the rigid EVar occurrences in S[s]\n    *) delaySpine ((Nil, s), cnstr)  = () | delaySpine ((App (U, S), s), cnstr)  = (delayExp ((U, s), cnstr); delaySpine ((S, s), cnstr)) | delaySpine ((SClo (S, s\'), s), cnstr)  = delaySpine ((S, comp (s\', s)), cnstr)(* delayDec see delayExp *) delayDec ((Dec (name, V), s), cnstr)  = delayExp ((V, s), cnstr) let awakenCnstrs = ref nil : cnstr list ref let rec resetAwakenCnstrs ()  = (awakenCnstrs := nil) let rec nextCnstr ()  = match ! awakenCnstrs with nil -> NONE | (cnstr :: cnstrL) -> (awakenCnstrs := cnstrL; SOME (cnstr)) (* Instantiating EVars  *) let rec instantiateEVar (refU, V, cnstrL)  = (refU := SOME (V); log (globalTrail, Instantiate (refU)); awakenCnstrs := cnstrL @ ! awakenCnstrs) (* Instantiating LVars  *) let rec instantiateLVar (refB, B)  = (refB := SOME (B); log (globalTrail, InstantiateBlock (refB))) (* local *) (* intersection (s1, s2) = s\'\n       s\' = s1 /\\ s2 (see JICSLP\'96)\n\n       Invariant:\n       If   G |- s1 : G\'    s1 patsub\n       and  G |- s2 : G\'    s2 patsub\n       then G |- s\' : G\'\' for some G\'\'\n       and  s\' patsub\n    *) let rec intersection (Dot (Idx (k1), s1), Dot (Idx (k2), s2))  = if (k1 = k2) then dot1 (intersection (s1, s2)) else comp (intersection (s1, s2), shift) | intersection (s1 as Dot _, Shift (n2))  = intersection (s1, Dot (Idx (n2 + 1), Shift (n2 + 1))) | intersection (Shift (n1), s2 as Dot _)  = intersection (Dot (Idx (n1 + 1), Shift (n1 + 1)), s2) | intersection (Shift _, Shift _)  = id (* both substitutions are the same number of shifts by invariant *) (* all other cases impossible for pattern substitutions *) (* weakenSub (G1, s, ss) = w\'\n\n       Invariant:\n       If    G |- s : G1       (* s patsub *)\n       and   G2 |- ss : G      (* ss strsub *)\n       then  G1 |- w\' : G1\'    (* w\' weaksub *)\n\n       and   G2 |- w\' o s o ss : G1\'  is fully defined\n       and   G1\' is maximal such\n    *) let rec weakenSub (G, Shift n, ss)  = if n < ctxLength G then weakenSub (G, Dot (Idx (n + 1), Shift (n + 1)), ss) else id | weakenSub (G, Dot (Idx n, s\'), ss)  = (match bvarSub (n, ss) with Undef -> comp (weakenSub (G, s\', ss), shift) | Idx _ -> dot1 (weakenSub (G, s\', ss))) | weakenSub (G, Dot (Undef, s\'), ss)  = comp (weakenSub (G, s\', ss), shift) (* invert (G, (U, s), ss, rOccur) = U[s][ss]\n\n       G |- s : G\'   G\' |- U : V  (G |- U[s] : V[s])\n       G\'\' |- ss : G\n\n       Effect: raises NotInvertible if U[s][ss] does not exist\n               or rOccurs occurs in U[s]\n               does NOT prune EVars in U[s] according to ss; fails instead\n    *) let rec invertExp (G, Us, ss, rOccur)  = invertExpW (G, whnf Us, ss, rOccur)invertExpW (G, (U as Uni _, s), _, _)  = U | invertExpW (G, (Pi ((D, P), V), s), ss, rOccur)  = Pi ((invertDec (G, (D, s), ss, rOccur), P), invertExp (Decl (G, decSub (D, s)), (V, dot1 s), dot1 ss, rOccur)) | invertExpW (G, (Lam (D, V), s), ss, rOccur)  = Lam (invertDec (G, (D, s), ss, rOccur), invertExp (Decl (G, decSub (D, s)), (V, dot1 s), dot1 ss, rOccur)) | invertExpW (G, (Root (H, S), s, (* = id *) ), ss, rOccur)  = Root (invertHead (G, H, ss, rOccur), invertSpine (G, (S, s), ss, rOccur)) | invertExpW (G, (X as EVar (r, GX, V, cnstrs), s), ss, rOccur)  = if (rOccur = r) then raise (NotInvertible) else if isPatSub (s) then let w = weakenSub (G, s, ss) in if isId w then EClo (X, comp (s, ss)) else raise (NotInvertible) else (* s not patsub *) (* invertExp may raise NotInvertible *) EClo (X, invertSub (G, s, ss, rOccur)) | invertExpW (G, (FgnExp csfe, s), ss, rOccur)  = apply csfe (fun U -> invertExp (G, (U, s), ss, rOccur))(* other cases impossible since (U,s1) whnf *) invertDec (G, (Dec (name, V), s), ss, rOccur)  = Dec (name, invertExp (G, (V, s), ss, rOccur))invertSpine (G, (Nil, s), ss, rOccur)  = Nil | invertSpine (G, (App (U, S), s), ss, rOccur)  = App (invertExp (G, (U, s), ss, rOccur), invertSpine (G, (S, s), ss, rOccur)) | invertSpine (G, (SClo (S, s\'), s), ss, rOccur)  = invertSpine (G, (S, comp (s\', s)), ss, rOccur)invertHead (G, BVar k, ss, rOccur)  = (match (bvarSub (k, ss)) with Undef -> raise (NotInvertible) | Idx k\' -> BVar k\') | invertHead (G, H as Const _, ss, rOccur)  = H | invertHead (G, Proj (B as Bidx k, i), ss, rOccur)  = (* blockSub (B, ss) should always be defined *)  (* Fri Dec 28 10:03:12 2001 -fp !!! *)  (match blockSub (B, ss) with Bidx (k\') -> Proj (Bidx (k\'), i)) | invertHead (G, H as Proj (LVar (r, sk, (l, t)), i), ss, rOccur)  = (* claim: LVar does not need to be pruned since . |- t : Gsome *)  (* so we perform only the occurs-check here as for FVars *)  (* Sat Dec  8 13:39:41 2001 -fp !!! *)  (* this is not true any more, Sun Dec  1 11:28:47 2002 -cs  *)  (* Changed from Null to G Sat Dec  7 21:58:00 2002 -fp *)  (invertSub (G, t, id, rOccur); H) | invertHead (G, H as Skonst _, ss, rOccur)  = H | invertHead (G, H as Def _, ss, rOccur)  = H | invertHead (G, FVar (x, V, s\'), ss, rOccur)  = (* V does not to be pruned, since . |- V : type and s\' = ^k *)  (* perform occurs-check for r only *)  (invertExp (G, (V, id), id, rOccur); (* why G here? -fp !!! *) FVar (x, V, comp (s\', ss))) | invertHead (G, H as FgnConst _, ss, rOccur)  = H(* pruneSub never allows pruning OUTDATED *) (* in the presence of block variables, this invariant\n       doesn\'t hold any more, because substitutions do not\n       only occur in EVars any more but also in LVars!\n       and there pruning is allowed!   Tue May 29 21:50:17 EDT 2001 -cs *) invertSub (G, s as Shift (n), ss, rOccur)  = if n < ctxLength (G) then invertSub (G, Dot (Idx (n + 1), Shift (n + 1)), ss, rOccur) else comp (s, ss) | invertSub (G, Dot (Idx (n), s\'), ss, rOccur)  = (match bvarSub (n, ss) with Undef -> raise (NotInvertible) | Ft -> Dot (Ft, invertSub (G, s\', ss, rOccur))) | invertSub (G, Dot (Exp (U), s\'), ss, rOccur)  = (* below my raise NotInvertible *)  Dot (Exp (invertExp (G, (U, id), ss, rOccur)), invertSub (G, s\', ss, rOccur)) (* pruneSub (G, Dot (Undef, s), ss, rOccur) is impossible *) (* By invariant, all EVars X[s] are such that s is defined everywhere *) (* Pruning establishes and maintains this invariant *) (* invertCtx does not appear to be necessary *) (*\n    and invertCtx (Shift n, Null, rOccur) = Null\n      | invertCtx (Dot (Idx k, t), Decl (G, D), rOccur) =\n        let\n          val t\' = comp (t, invShift)\n          val D\' = invertDec (G, (D, id), t\', rOccur)\n        in\n          Decl (invertCtx (t\', G, rOccur), D\')\n        end\n      | invertCtx (Dot (Undef, t), Decl (G, d), rOccur) =\n          invertCtx (t, G, rOccur)\n      | invertCtx (Shift n, G, rOccur) =\n          invertCtx (Dot (Idx (n+1), Shift (n+1)), G, rOccur)\n    *) (* prune (G, (U, s), ss, rOccur) = U[s][ss]\n\n       !!! looks wrong to me -kw\n       G |- U : V    G\' |- s : G  (G\' |- U[s] : V[s])\n       G\'\' |- ss : G\'\n       !!! i would say\n       G |- s : G\'   G\' |- U : V  (G  |- U[s] : V[s])\n       G\'\' |- ss : G\n\n       Effect: prunes EVars in U[s] according to ss\n               raises Unify if U[s][ss] does not exist, or rOccur occurs in U[s]\n    *) let rec pruneExp (G, Us, ss, rOccur)  = pruneExpW (G, whnf Us, ss, rOccur)pruneExpW (G, (U as Uni _, s), _, _)  = U | pruneExpW (G, (Pi ((D, P), V), s), ss, rOccur)  = Pi ((pruneDec (G, (D, s), ss, rOccur), P), pruneExp (Decl (G, decSub (D, s)), (V, dot1 s), dot1 ss, rOccur)) | pruneExpW (G, (Lam (D, V), s), ss, rOccur)  = Lam (pruneDec (G, (D, s), ss, rOccur), pruneExp (Decl (G, decSub (D, s)), (V, dot1 s), dot1 ss, rOccur)) | pruneExpW (G, (Root (H, S), s, (* = id *) ), ss, rOccur)  = Root (pruneHead (G, H, ss, rOccur), pruneSpine (G, (S, s), ss, rOccur)) | pruneExpW (G, (X as EVar (r, GX, V, cnstrs), s), ss, rOccur)  = if (rOccur = r) then raise (Unify "Variable occurrence") else if isPatSub (s) then let w = weakenSub (G, s, ss) in if isId w then EClo (X, comp (s, ss)) else (* val V\' = EClo (V, wi) *) (* val GY = Whnf.strengthen (wi, GX) *) (* shortcut on GY possible by invariant on GX and V[s]? -fp *) (* could optimize by checking for identity subst *) let wi = invert w let V\' = pruneExp (GX, (V, id), wi, rOccur) let GY = pruneCtx (wi, GX, rOccur) let Y = newEVar (GY, V\') let Yw = EClo (Y, w) let _ = instantiateEVar (r, Yw, ! cnstrs) in EClo (Yw, comp (s, ss)) else (* s not patsub *) (try  with ) | pruneExpW (G, (FgnExp csfe, s), ss, rOccur)  = apply csfe (fun U -> pruneExp (G, (U, s), ss, rOccur)) | pruneExpW (G, ((X as AVar _), s), ss, rOccur)  = (* this case should never happen! *)  raise (Unify "Left-over AVar")(* other cases impossible since (U,s1) whnf *) pruneDec (G, (Dec (name, V), s), ss, rOccur)  = Dec (name, pruneExp (G, (V, s), ss, rOccur)) | pruneDec (G, (NDec x, _), _, _)  = NDec x(* Added for the meta level -cs Tue Aug 17 17:09:27 2004 *) pruneSpine (G, (Nil, s), ss, rOccur)  = Nil | pruneSpine (G, (App (U, S), s), ss, rOccur)  = App (pruneExp (G, (U, s), ss, rOccur), pruneSpine (G, (S, s), ss, rOccur)) | pruneSpine (G, (SClo (S, s\'), s), ss, rOccur)  = pruneSpine (G, (S, comp (s\', s)), ss, rOccur)pruneHead (G, BVar k, ss, rOccur)  = (match (bvarSub (k, ss)) with Undef -> raise (Unify "Parameter dependency") | Idx k\' -> BVar k\') | pruneHead (G, H as Const _, ss, rOccur)  = H | pruneHead (G, Proj (B as Bidx k, i), ss, rOccur)  = (* blockSub (B, ss) should always be defined *)  (* Fri Dec 28 10:03:12 2001 -fp !!! *)  (match blockSub (B, ss) with Bidx (k\') -> Proj (Bidx (k\'), i)) | pruneHead (G, H as Proj (LVar (r, sk, (l, t)), i), ss, rOccur)  = (* claim: LVar does not need to be pruned since . |- t : Gsome *)  (* so we perform only the occurs-check here as for FVars *)  (* Sat Dec  8 13:39:41 2001 -fp !!! *)  (* this is not true any more, Sun Dec  1 11:28:47 2002 -cs  *)  (* Changed from Null to G Sat Dec  7 21:58:00 2002 -fp *)  (pruneSub (G, t, id, rOccur); H) | pruneHead (G, H as Skonst _, ss, rOccur)  = H | pruneHead (G, H as Def _, ss, rOccur)  = H | pruneHead (G, FVar (x, V, s\'), ss, rOccur)  = (* V does not to be pruned, since . |- V : type and s\' = ^k *)  (* perform occurs-check for r only *)  (pruneExp (G, (V, id), id, rOccur); (* why G here? -fp !!! *) FVar (x, V, comp (s\', ss))) | pruneHead (G, H as FgnConst _, ss, rOccur)  = H(* pruneSub never allows pruning OUTDATED *) (* in the presence of block variables, this invariant\n       doesn\'t hold any more, because substitutions do not\n       only occur in EVars any more but also in LVars!\n       and there pruning is allowed!   Tue May 29 21:50:17 EDT 2001 -cs *) pruneSub (G, s as Shift (n), ss, rOccur)  = if n < ctxLength (G) then pruneSub (G, Dot (Idx (n + 1), Shift (n + 1)), ss, rOccur) else comp (s, ss) | pruneSub (G, Dot (Idx (n), s\'), ss, rOccur)  = (match bvarSub (n, ss) with Undef -> raise (Unify "Not prunable") | Ft -> Dot (Ft, pruneSub (G, s\', ss, rOccur))) | pruneSub (G, Dot (Exp (U), s\'), ss, rOccur)  = (* below my raise Unify *)  Dot (Exp (pruneExp (G, (U, id), ss, rOccur)), pruneSub (G, s\', ss, rOccur))(* pruneSub (G, Dot (Undef, s), ss, rOccur) is impossible *) (* By invariant, all EVars X[s] are such that s is defined everywhere *) (* Pruning establishes and maintains this invariant *) pruneCtx (Shift n, Null, rOccur)  = Null | pruneCtx (Dot (Idx k, t), Decl (G, D), rOccur)  = let t\' = comp (t, invShift) let D\' = pruneDec (G, (D, id), t\', rOccur) in Decl (pruneCtx (t\', G, rOccur), D\') | pruneCtx (Dot (Undef, t), Decl (G, d), rOccur)  = pruneCtx (t, G, rOccur) | pruneCtx (Shift n, G, rOccur)  = pruneCtx (Dot (Idx (n + 1), Shift (n + 1)), G, rOccur) (* unifyExpW (G, (U1, s1), (U2, s2)) = ()\n\n       Invariant:\n       If   G |- s1 : G1   G1 |- U1 : V1    (U1,s1) in whnf\n       and  G |- s2 : G2   G2 |- U2 : V2    (U2,s2) in whnf\n       and  G |- V1 [s1] = V2 [s2]  : L    (for some level L)\n        ***** or V1 = V2 = kind  (needed to check type definitions)\n        ***** added by kw Apr 5 2002\n       and  s1, U1, s2, U2 do not contain any blockvariable indices Bidx\n       then if   there is an instantiation I :\n                 s.t. G |- U1 [s1] <I> == U2 [s2] <I>\n            then instantiation is applied as effect, () returned\n            else exception Unify is raised\n       Other effects: EVars may be lowered\n                      constraints may be added for non-patterns\n    *) let rec unifyExpW (G, Us1 as (FgnExp csfe1, _), Us2)  = (match (apply csfe1 (G, EClo Us2)) with (Succeed residualL) -> let rec execResidual (Assign (G, EVar (r, _, _, cnstrs), W, ss))  = let W\' = pruneExp (G, (W, id), ss, r) in instantiateEVar (r, W\', ! cnstrs) | execResidual (Delay (U, cnstr))  = delayExp ((U, id), cnstr) in app execResidual residualL | Fail -> raise (Unify "Foreign Expression Mismatch")) | unifyExpW (G, Us1, Us2 as (FgnExp csfe2, _))  = (match (apply csfe2 (G, EClo Us1)) with (Succeed opL) -> let rec execOp (Assign (G, EVar (r, _, _, cnstrs), W, ss))  = let W\' = pruneExp (G, (W, id), ss, r) in instantiateEVar (r, W\', ! cnstrs) | execOp (Delay (U, cnstr))  = delayExp ((U, id), cnstr) in app execOp opL | Fail -> raise (Unify "Foreign Expression Mismatch")) | unifyExpW (G, (Uni (L1), _), (Uni (L2), _))  = (* L1 = L2 = type, by invariant *)  (* unifyUni (L1, L2) - removed Mon Aug 24 12:18:24 1998 -fp *)  () | unifyExpW (G, Us1 as (Root (H1, S1), s1), Us2 as (Root (H2, S2), s2))  = (* s1 = s2 = id by whnf *)  (* order of calls critical to establish unifySpine invariant *)  (match (H1, H2) with (BVar (k1), BVar (k2)) -> if (k1 = k2) then unifySpine (G, (S1, s1), (S2, s2)) else raise (Unify "Bound variable clash") | (Const (c1), Const (c2)) -> if (c1 = c2) then unifySpine (G, (S1, s1), (S2, s2)) else raise (Unify "Constant clash") | (Proj (b1, i1), Proj (b2, i2)) -> if (i1 = i2) then (unifyBlock (G, b1, b2); unifySpine (G, (S1, s1), (S2, s2))) else raise (Unify "Global parameter clash") | (Skonst (c1), Skonst (c2)) -> if (c1 = c2) then unifySpine (G, (S1, s1), (S2, s2)) else raise (Unify "Skolem constant clash") | (FVar (n1, _, _), FVar (n2, _, _)) -> if (n1 = n2) then unifySpine (G, (S1, s1), (S2, s2)) else raise (Unify "Free variable clash") | (Def (d1), Def (d2)) -> if (d1 = d2) then (* because of strict *) unifySpine (G, (S1, s1), (S2, s2)) else (*  unifyExpW (G, Whnf.expandDef (Us1), Whnf.expandDef (Us2)) *) unifyDefDefW (G, Us1, Us2)(* four new cases for defined constants *)  | (Def (d1), Const (c2)) -> (match defAncestor d1 with Anc (_, _, NONE) -> (* conservative *) unifyExpW (G, expandDef Us1, Us2) | Anc (_, _, SOME (c1)) -> if (c1 = c2) then unifyExpW (G, expandDef Us1, Us2) else raise (Unify "Constant clash")) | (Const (c1), Def (d2)) -> (match defAncestor d2 with Anc (_, _, NONE) -> (* conservative *) unifyExpW (G, Us1, expandDef Us2) | Anc (_, _, SOME (c2)) -> if (c1 = c2) then unifyExpW (G, Us1, expandDef Us2) else raise (Unify "Constant clash")) | (Def (d1), BVar (k2)) -> raise (Unify "Head mismatch")(* due to strictness! *)  | (BVar (k1), Def (d2)) -> raise (Unify "Head mismatch")(* due to strictness! *) (* next two cases for def/fgn, fgn/def *)  | (Def (d1), _) -> unifyExpW (G, expandDef Us1, Us2) | (_, Def (d2)) -> unifyExpW (G, Us1, expandDef Us2) | (FgnConst (cs1, ConDec (n1, _, _, _, _, _)), FgnConst (cs2, ConDec (n2, _, _, _, _, _))) -> (* we require unique string representation of external constants *) if (cs1 = cs2) && (n1 = n2) then () else raise (Unify "Foreign Constant clash") | (FgnConst (cs1, ConDef (n1, _, _, W1, _, _, _)), FgnConst (cs2, ConDef (n2, _, _, V, W2, _, _))) -> if (cs1 = cs2) && (n1 = n2) then () else unifyExp (G, (W1, s1), (W2, s2)) | (FgnConst (_, ConDef (_, _, _, W1, _, _, _)), _) -> unifyExp (G, (W1, s1), Us2) | (_, FgnConst (_, ConDef (_, _, _, W2, _, _, _))) -> unifyExp (G, Us1, (W2, s2)) | _ -> raise (Unify "Head mismatch")) | unifyExpW (G, (Pi ((D1, _), U1), s1), (Pi ((D2, _), U2), s2))  = (unifyDec (G, (D1, s1), (D2, s2)); unifyExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (U2, dot1 s2))) | unifyExpW (G, Us1 as (Pi (_, _), _), Us2 as (Root (Def _, _), _))  = unifyExpW (G, Us1, expandDef (Us2)) | unifyExpW (G, Us1 as (Root (Def _, _), _), Us2 as (Pi (_, _), _))  = unifyExpW (G, expandDef (Us1), Us2) | unifyExpW (G, (Lam (D1, U1), s1), (Lam (D2, U2), s2))  = (* D1[s1] = D2[s2]  by invariant *)  unifyExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (U2, dot1 s2)) | unifyExpW (G, (Lam (D1, U1), s1), (U2, s2))  = (* ETA: can\'t occur if eta expanded *)  unifyExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (Redex (EClo (U2, shift), App (Root (BVar (1), Nil), Nil)), dot1 s2)) | unifyExpW (G, (U1, s1), (Lam (D2, U2), s2))  = (* Cannot occur if expressions are eta expanded *)  unifyExp (Decl (G, decSub (D2, s2)), (Redex (EClo (U1, shift), App (Root (BVar (1), Nil), Nil)), dot1 s1), (U2, dot1 s2)) | unifyExpW (G, Us1 as (U1 as EVar (r1, G1, V1, cnstrs1), s1), Us2 as (U2 as EVar (r2, G2, V2, cnstrs2), s2))  = (* postpone, if s1 or s2 are not patsub *)  if r1 = r2 then if isPatSub (s1) then if isPatSub (s2) then (* compute ss\' directly? *) let s\' = intersection (s1, s2) in (* without the next optimization, bugs/hangs/sources.cfg\n                     would gets into an apparent infinite loop\n                     Fri Sep  5 20:23:27 2003 -fp\n                  *) if isId s\'(* added for definitions Mon Sep  1 19:53:13 2003 -fp *)  then ()(* X[s] = X[s] *)  else (* invertExp ((V1, id), s\', ref NONE) *) let ss\' = invert s\' let V1\' = EClo (V1, ss\') let G1\' = strengthen (ss\', G1) in instantiateEVar (r1, EClo (newEVar (G1\', V1\'), s\'), ! cnstrs1) else addConstraint (cnstrs2, ref (Eqn (G, EClo Us2, EClo Us1))) else addConstraint (cnstrs1, ref (Eqn (G, EClo Us1, EClo Us2))) else if isPatSub (s1) then let ss1 = invert s1 let U2\' = pruneExp (G, Us2, ss1, r1) in (* instantiateEVar (r1, EClo (U2, comp(s2, ss1)), !cnstrs1) *) (* invertExpW (Us2, s1, ref NONE) *) instantiateEVar (r1, U2\', ! cnstrs1) else if isPatSub (s2) then let ss2 = invert s2 let U1\' = pruneExp (G, Us1, ss2, r2) in (* instantiateEVar (r2, EClo (U1, comp(s1, ss2)), !cnstr2) *) (* invertExpW (Us1, s2, ref NONE) *) instantiateEVar (r2, U1\', ! cnstrs2) else let cnstr = ref (Eqn (G, EClo Us1, EClo Us2)) in addConstraint (cnstrs1, cnstr) | unifyExpW (G, Us1 as (EVar (r, GX, V, cnstrs), s), Us2 as (U2, s2))  = if isPatSub (s) then let ss = invert s let U2\' = pruneExp (G, Us2, ss, r) in (* instantiateEVar (r, EClo (U2, comp(s2, ss)), !cnstrs) *) (* invertExpW (Us2, s, r) *) instantiateEVar (r, U2\', ! cnstrs) else addConstraint (cnstrs, ref (Eqn (G, EClo Us1, EClo Us2))) | unifyExpW (G, Us1 as (U1, s1), Us2 as (EVar (r, GX, V, cnstrs), s))  = if isPatSub (s) then let ss = invert s let U1\' = pruneExp (G, Us1, ss, r) in (* instantiateEVar (r, EClo (U1, comp(s1, ss)), !cnstrs) *) (* invertExpW (Us1, s, r) *) instantiateEVar (r, U1\', ! cnstrs) else addConstraint (cnstrs, ref (Eqn (G, EClo Us1, EClo Us2))) | unifyExpW (G, Us1, Us2)  = raise (Unify ("Expression clash"))(* covers most remaining cases *) (* the cases for EClo or Redex should not occur because of whnf invariant *) (* unifyExp (G, (U1, s1), (U2, s2)) = ()\n       as in unifyExpW, except that arguments may not be in whnf\n    *) unifyExp (G, Us1 as (E1, s1), Us2 as (E2, s2))  = unifyExpW (G, whnf Us1, whnf Us2)unifyDefDefW (G, Us1 as (Root (Def (d1), S1), s1), Us2 as (Root (Def (d2), S2), s2))  = (*  unifyExpW (G, Whnf.expandDef (Us1), Whnf.expandDef (Us2)) *)  (* conservative *) let Anc (_, h1, c1Opt) = defAncestor d1 let Anc (_, h2, c2Opt) = defAncestor d2 let _ = match (c1Opt, c2Opt) with (SOME (c1), SOME (c2)) -> if c1 <> c2 then raise (Unify ("Irreconcilable defined constant clash")) else () | _ -> () in match compare (h1, h2) with EQUAL -> unifyExpW (G, expandDef (Us1), expandDef (Us2)) | LESS -> unifyExpW (G, Us1, expandDef (Us2)) | GREATER -> unifyExpW (G, expandDef (Us1), Us2)(* unifySpine (G, (S1, s1), (S2, s2)) = ()\n\n       Invariant:\n       If   G |- s1 : G1   G1 |- S1 : V1 > W1\n       and  G |- s2 : G2   G2 |- S2 : V2 > W2\n       and  G |- V1 [s1] = V2 [s2]  : L    (for some level L)\n       and  G |- W1 [s1] = W2 [s2]\n       then if   there is an instantiation I :\n                 s.t. G |- S1 [s1] <I> == S2 [s2] <I>\n            then instantiation is applied as effect, () returned\n            else exception Unify is raised\n       Other effects: EVars may be lowered,\n                      constraints may be added for non-patterns\n    *) unifySpine (G, (Nil, _), (Nil, _))  = () | unifySpine (G, (SClo (S1, s1\'), s1), Ss)  = unifySpine (G, (S1, comp (s1\', s1)), Ss) | unifySpine (G, Ss, (SClo (S2, s2\'), s2))  = unifySpine (G, Ss, (S2, comp (s2\', s2))) | unifySpine (G, (App (U1, S1), s1), (App (U2, S2), s2))  = (unifyExp (G, (U1, s1), (U2, s2)); unifySpine (G, (S1, s1), (S2, s2)))(* Nil/App or App/Nil cannot occur by typing invariants *) unifyDec (G, (Dec (_, V1), s1), (Dec (_, V2), s2))  = unifyExp (G, (V1, s1), (V2, s2))(* unifySub (G, s1, s2) = ()\n\n       Invariant:\n       If   G |- s1 : G\'\n       and  G |- s2 : G\'\n       then unifySub (G, s1, s2) terminates with ()\n            iff there exists an instantiation I, such that\n            s1 [I] = s2 [I]\n\n       Remark:  unifySub is used only to unify the instantiation of SOME variables\n    *) (* conjecture: G == Null at all times *) (* Thu Dec  6 21:01:09 2001 -fp *) unifySub (G, Shift (n1), Shift (n2))  = () | unifySub (G, Shift (n), s2 as Dot _)  = unifySub (G, Dot (Idx (n + 1), Shift (n + 1)), s2) | unifySub (G, s1 as Dot _, Shift (m))  = unifySub (G, s1, Dot (Idx (m + 1), Shift (m + 1))) | unifySub (G, Dot (Ft1, s1), Dot (Ft2, s2))  = ((match (Ft1, Ft2) with (Idx (n1), Idx (n2)) -> if n1 <> n2 then raise (Error "SOME variables mismatch") else () | (Exp (U1), Exp (U2)) -> unifyExp (G, (U1, id), (U2, id)) | (Exp (U1), Idx (n2)) -> unifyExp (G, (U1, id), (Root (BVar (n2), Nil), id)) | (Idx (n1), Exp (U2)) -> unifyExp (G, (Root (BVar (n1), Nil), id), (U2, id))); (*         | (Undef, Undef) =>\n           | _ => false *) (* not possible because of invariant? -cs *) unifySub (G, s1, s2))(* substitutions s1 and s2 were redundant here --- removed *) (* Sat Dec  8 11:47:12 2001 -fp !!! *) unifyBlock (G, LVar (ref (SOME (B1)), s, _), B2)  = unifyBlock (G, blockSub (B1, s), B2) | unifyBlock (G, B1, LVar (ref (SOME (B2)), s, _))  = unifyBlock (G, B1, blockSub (B2, s)) | unifyBlock (G, B1, B2)  = unifyBlockW (G, B1, B2)unifyBlockW (G, LVar (r1, s1 as Shift (k1), (l1, t1)), LVar (r2, s2 as Shift (k2), (l2, t2)))  = if l1 <> l2 then raise (Unify "Label clash") else if r1 = r2 then () else (unifySub (G, comp (t1, s1), comp (t2, s2)); (* Sat Dec  7 22:04:31 2002 -fp *) (* was: unifySub (G, t1, t2)  Jul 22 2010 *) if k1 < k2 then instantiateLVar (r1, LVar (r2, Shift (k2 - k1), (l2, t2))) else instantiateLVar (r2, LVar (r1, Shift (k1 - k2), (l1, t1)))) | unifyBlockW (G, LVar (r1, s1, (l1, t1)), B2)  = instantiateLVar (r1, blockSub (B2, invert s1)) | unifyBlockW (G, B1, LVar (r2, s2, (l2, t2)))  = instantiateLVar (r2, blockSub (B1, invert s2)) | unifyBlockW (G, Bidx (n1), (Bidx (n2)))  = if n1 <> n2 then raise (Unify "Block index clash") else () (*\n      | unifyBlock (LVar (r1, _, _), B as Bidx _) = instantiate (r1, B)\n      | unifyBlock (B as Bidx _, LVar (r2, _, _)) =\n\n      This is still difficult --- B must make sense in the context of the LVar\n      Shall we use the inverse of a pattern substitution? Or postpone as\n      a constraint if pattern substitution does not exist?\n      Sun Dec  1 11:33:13 2002 -cs\n\n*) let rec unify1W (G, Us1, Us2)  = (unifyExpW (G, Us1, Us2); awakeCnstr (nextCnstr ()))unify1 (G, Us1, Us2)  = (unifyExp (G, Us1, Us2); awakeCnstr (nextCnstr ()))awakeCnstr (NONE)  = () | awakeCnstr (SOME (ref Solved))  = awakeCnstr (nextCnstr ()) | awakeCnstr (SOME (cnstr as ref (Eqn (G, U1, U2))))  = (solveConstraint cnstr; unify1 (G, (U1, id), (U2, id))) | awakeCnstr (SOME (ref (FgnCnstr csfc)))  = if (apply csfc ()) then () else raise (Unify "Foreign constraint violated") let rec unifyW (G, Us1, Us2)  = (resetAwakenCnstrs (); unify1W (G, Us1, Us2)) let rec unify (G, Us1, Us2)  = (resetAwakenCnstrs (); unify1 (G, Us1, Us2)) type unifTrail = unifTrail let reset = reset let mark = mark let unwind = unwind let suspend = suspend let resume = resume let delay = delayExp let instantiateEVar = instantiateEVar let instantiateLVar = instantiateLVar let resetAwakenCnstrs = resetAwakenCnstrs let nextCnstr = nextCnstr let addConstraint = addConstraint let solveConstraint = solveConstraint let intersection = intersection let unifyW = unifyW let unify = unify let unifySub = unifySub let unifyBlock = unifyBlock let rec invertible (G, Us, ss, rOccur)  = try  with let invertSub = invertSub let rec unifiable (G, Us1, Us2)  = try  with let rec unifiable\' (G, Us1, Us2)  = try  with  end\n(* functor Unify *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Normalizer for Delphin meta level *) (* Author: Carsten Schuermann *) module type NORMALIZE = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) (*  val normalizeFor : (Tomega.For * Tomega.Sub) -> Tomega.For *) (*  val normalizePrg : (Tomega.Prg * Tomega.Sub) -> Tomega.Prg 
  val normalizeSub : Tomega.Sub -> Tomega.Sub  *) (*  val whnfFor : Tomega.For * Tomega.Sub -> Tomega.For * Tomega.Sub *)  end
('Error parsing code:', '(* Convertibility Modulo Beta and Eta *) (* Author: Frank Pfenning, Carsten Schuermann *) module type CONV = sig (*! structure IntSyn : INTSYN !*) val conv : eclo * eclo -> boolval convDec : (Dec * Sub) * (Dec * Sub) -> boolval convSub : Sub * Sub -> bool end\n(* signature CONV *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Now in intsyn.fun *) (*\nstructure IntSyn =\n  IntSyn (structure Global = Global);\n*) (* Now in tomega.sml *) (*\nstructure Whnf =\n  Whnf ((*! structure IntSyn' = IntSyn !*));\n\nstructure Conv =\n  Conv ((*! structure IntSyn' = IntSyn !*)\n\tstructure Whnf = Whnf);\n\nstructure Tomega : TOMEGA =\n   Tomega (structure IntSyn' = IntSyn\n\t   structure Whnf = Whnf\n\t   structure Conv = Conv)\n*) module Constraints = Constraints(module Conv = Conv)\nmodule UnifyNoTrail = Unify(struct module Whnf = Whnf module Trail = NoTrail end)\nmodule UnifyTrail = Unify(struct module Whnf = Whnf module Trail = Trail end)\n(* structure Normalize : NORMALIZE =  \n  Normalize ((*! structure IntSyn' = IntSyn !*)\n             (*! structure Tomega' = Tomega !*)\n             structure Whnf = Whnf)\n *) module Match = Match(struct module Whnf = Whnf module Unify = UnifyTrail module Trail = Trail end)\nmodule Abstract = Abstract(struct module Whnf = Whnf module Constraints = Constraints module Unify = UnifyNoTrail end)\nmodule Approx = Approx(module Whnf = Whnf)\n", 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Matching *) (* Unification modified to Matching *) (* Author: Frank Pfenning, Carsten Schuermann *) (* Modified: Roberto Virga, Brigitte Pientka *) module Match ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFYmodule Trail : TRAIL) : MATCH = struct (*! structure IntSyn = IntSyn\' !*)  exception Match of string exception NotInvertible open IntSyn let delayExp = delay (* weakenSub (G1, s, ss) = w\'\n\n       Invariant:\n       If    G |- s : G1       (* s patsub *)\n       and   G2 |- ss : G      (* ss strsub *)\n       then  G1 |- w\' : G1\'    (* w\' weaksub *)\n\n       and   G2 |- w\' o s o ss : G1\'  is fully defined\n       and   G1\' is maximal such\n    *) let rec weakenSub (G, Shift n, ss)  = if n < ctxLength G then weakenSub (G, Dot (Idx (n + 1), Shift (n + 1)), ss) else id | weakenSub (G, Dot (Idx n, s\'), ss)  = (match bvarSub (n, ss) with Undef -> comp (weakenSub (G, s\', ss), shift) | Idx _ -> dot1 (weakenSub (G, s\', ss))) | weakenSub (G, Dot (Undef, s\'), ss)  = comp (weakenSub (G, s\', ss), shift) (* prune (G, (U, s), ss, rOccur) = U[s][ss]\n\n       !!! looks wrong to me -kw\n       G |- U : V    G\' |- s : G  (G\' |- U[s] : V[s])\n       G\'\' |- ss : G\'\n\n       !!! i would say\n       G |- s : G\'   G\' |- U : V  (G  |- U[s] : V[s])\n       G\'\' |- ss : G\n\n       Effect: prunes EVars in U[s] according to ss\n               raises Match if U[s][ss] does not exist, or rOccur occurs in U[s]\n    *) let rec pruneExp (G, Us, ss, rOccur)  = pruneExpW (G, whnf Us, ss, rOccur)pruneExpW (G, (U as Uni _, s), _, _)  = U | pruneExpW (G, (Pi ((D, P), V), s), ss, rOccur)  = Pi ((pruneDec (G, (D, s), ss, rOccur), P), pruneExp (Decl (G, decSub (D, s)), (V, dot1 s), dot1 ss, rOccur)) | pruneExpW (G, (Lam (D, V), s), ss, rOccur)  = Lam (pruneDec (G, (D, s), ss, rOccur), pruneExp (Decl (G, decSub (D, s)), (V, dot1 s), dot1 ss, rOccur)) | pruneExpW (G, (Root (H, S), s, (* = id *) ), ss, rOccur)  = Root (pruneHead (G, H, ss, rOccur), pruneSpine (G, (S, s), ss, rOccur)) | pruneExpW (G, (X as EVar (r, GX, V, cnstrs), s), ss, rOccur)  = if (rOccur = r) then raise (Match "Variable occurrence") else if isPatSub (s) then let w = weakenSub (G, s, ss) in if isId w then EClo (X, comp (s, ss)) else raise (Match "Invertible Substitution does not necessarily exist\\n")(* let\n                     val wi = Whnf.invert w\n                     (* val V\' = EClo (V, wi) *)\n                     val V\' = pruneExp (GX, (V, id), wi, rOccur)\n                     (* val GY = Whnf.strengthen (wi, GX) *)\n                     val GY = pruneCtx (wi, GX, rOccur)\n                     (* shortcut on GY possible by invariant on GX and V[s]? -fp *)\n                     (* could optimize by checking for identity subst *)\n                     val Y = newEVar (GY, V\')\n                     val Yw = EClo (Y, w)\n                     val _ = Unify.instantiateEVar (r, Yw, !cnstrs)\n                   in\n                     EClo (Yw, comp (s, ss))\n                   end*)  else (* s not patsub *) (* -bp not sure what to do in the non-pattern case *) (try  with ) | pruneExpW (G, (FgnExp csfe, s), ss, rOccur)  = apply csfe (fun U -> pruneExp (G, (U, s), ss, rOccur)) | pruneExpW (G, ((X as AVar _), s), ss, rOccur)  = (* this case should never happen! *)  raise (Match "Left-over AVar")(* other cases impossible since (U,s1) whnf *) pruneDec (G, (Dec (name, V), s), ss, rOccur)  = Dec (name, pruneExp (G, (V, s), ss, rOccur)) | pruneDec (G, (NDec x, _), _, _)  = NDec x(* Added for the meta level -cs Tue Aug 17 17:09:27 2004 *) pruneSpine (G, (Nil, s), ss, rOccur)  = Nil | pruneSpine (G, (App (U, S), s), ss, rOccur)  = App (pruneExp (G, (U, s), ss, rOccur), pruneSpine (G, (S, s), ss, rOccur)) | pruneSpine (G, (SClo (S, s\'), s), ss, rOccur)  = pruneSpine (G, (S, comp (s\', s)), ss, rOccur)pruneHead (G, BVar k, ss, rOccur)  = (match (bvarSub (k, ss)) with Undef -> raise (Match "Parameter dependency") | Idx k\' -> BVar k\') | pruneHead (G, H as Const _, ss, rOccur)  = H | pruneHead (G, Proj (B as Bidx k, i), ss, rOccur)  = (* blockSub (B, ss) should always be defined *)  (* Fri Dec 28 10:03:12 2001 -fp !!! *)  (match blockSub (B, ss) with Bidx (k\') -> Proj (Bidx (k\'), i)) | pruneHead (G, H as Proj (LVar (r, sk, (l, t)), i), ss, rOccur)  = (* claim: LVar does not need to be pruned since . |- t : Gsome *)  (* so we perform only the occurs-check here as for FVars *)  (* Sat Dec  8 13:39:41 2001 -fp !!! *)  (* this is not true any more, Sun Dec  1 11:28:47 2002 -cs  *)  (* Changed from Null to G Sat Dec  7 21:58:00 2002 -fp *)  (pruneSub (G, t, id, rOccur); H) | pruneHead (G, H as Skonst _, ss, rOccur)  = H | pruneHead (G, H as Def _, ss, rOccur)  = H | pruneHead (G, FVar (x, V, s\'), ss, rOccur)  = (* V does not to be pruned, since . |- V : type and s\' = ^k *)  (* perform occurs-check for r only *)  (pruneExp (G, (V, id), id, rOccur); (* why G here? -fp !!! *) FVar (x, V, comp (s\', ss))) | pruneHead (G, H as FgnConst _, ss, rOccur)  = H(* pruneSub never allows pruning OUTDATED *) (* in the presence of block variables, this invariant\n       doesn\'t hold any more, because substitutions do not\n       only occur in EVars any more but also in LVars!\n       and there pruning is allowed!   Tue May 29 21:50:17 EDT 2001 -cs *) pruneSub (G, s as Shift (n), ss, rOccur)  = if n < ctxLength (G) then pruneSub (G, Dot (Idx (n + 1), Shift (n + 1)), ss, rOccur) else comp (s, ss) | pruneSub (G, Dot (Idx (n), s\'), ss, rOccur)  = (match bvarSub (n, ss) with Undef -> raise (Match "Not prunable") | Ft -> Dot (Ft, pruneSub (G, s\', ss, rOccur))) | pruneSub (G, Dot (Exp (U), s\'), ss, rOccur)  = (* below my raise Match *)  Dot (Exp (pruneExp (G, (U, id), ss, rOccur)), pruneSub (G, s\', ss, rOccur))(* pruneSub (G, Dot (Undef, s), ss, rOccur) is impossible *) (* By invariant, all EVars X[s] are such that s is defined everywhere *) (* Pruning establishes and maintains this invariant *) pruneCtx (Shift n, Null, rOccur)  = Null | pruneCtx (Dot (Idx k, t), Decl (G, D), rOccur)  = let t\' = comp (t, invShift) let D\' = pruneDec (G, (D, id), t\', rOccur) in Decl (pruneCtx (t\', G, rOccur), D\') | pruneCtx (Dot (Undef, t), Decl (G, d), rOccur)  = pruneCtx (t, G, rOccur) | pruneCtx (Shift n, G, rOccur)  = pruneCtx (Dot (Idx (n + 1), Shift (n + 1)), G, rOccur) (* matchExpW (G, (U1, s1), (U2, s2)) = ()\n\n       Invariant:\n       If   G |- s1 : G1   G1 |- U1 : V1    (U1,s1) in whnf\n       and  G |- s2 : G2   G2 |- U2 : V2    (U2,s2) in whnf\n       and  G |- V1 [s1] = V2 [s2]  : L    (for some level L)\n        ***** or V1 = V2 = kind  (needed to check type definitions)\n        ***** added by kw Apr 5 2002\n       and  s1, U1, s2, U2 do not contain any blockvariable indices Bidx\n       then if   there is an instantiation I :\n                 s.t. G |- U1 [s1] <I> == U2 [s2] <I>\n            then instantiation is applied as effect, () returned\n            else exception Match is raised\n       Other effects: EVars may be lowered\n                      constraints may be added for non-patterns\n    *) let rec matchExpW (G, Us1 as (FgnExp csfe1, _), Us2)  = (match (apply csfe1 (G, EClo Us2)) with (Succeed residualL) -> let rec execResidual (Assign (G, EVar (r, _, _, cnstrs), W, ss))  = let W\' = pruneExp (G, (W, id), ss, r) in instantiateEVar (r, W\', ! cnstrs) | execResidual (Delay (U, cnstr))  = delayExp ((U, id), cnstr) in app execResidual residualL | Fail -> raise (Match "Foreign Expression Mismatch")) | matchExpW (G, Us1, Us2 as (FgnExp csfe2, _))  = (match (apply csfe2 (G, EClo Us1)) with (Succeed opL) -> let rec execOp (Assign (G, EVar (r, _, _, cnstrs), W, ss))  = let W\' = pruneExp (G, (W, id), ss, r) in instantiateEVar (r, W\', ! cnstrs) | execOp (Delay (U, cnstr))  = delayExp ((U, id), cnstr) in app execOp opL | Fail -> raise (Match "Foreign Expression Mismatch")) | matchExpW (G, (Uni (L1), _), (Uni (L2), _))  = (* L1 = L2 = type, by invariant *)  (* matchUni (L1, L2) - removed Mon Aug 24 12:18:24 1998 -fp *)  () | matchExpW (G, Us1 as (Root (H1, S1), s1), Us2 as (Root (H2, S2), s2))  = (* s1 = s2 = id by whnf *)  (* order of calls critical to establish matchSpine invariant *)  (match (H1, H2) with (BVar (k1), BVar (k2)) -> if (k1 = k2) then matchSpine (G, (S1, s1), (S2, s2)) else raise (Match "Bound variable clash") | (Const (c1), Const (c2)) -> if (c1 = c2) then matchSpine (G, (S1, s1), (S2, s2)) else raise (Match "Constant clash") | (Proj (b1, i1), Proj (b2, i2)) -> if (i1 = i2) then (matchBlock (G, b1, b2); matchSpine (G, (S1, s1), (S2, s2))) else raise (Match "Global parameter clash") | (Skonst (c1), Skonst (c2)) -> if (c1 = c2) then matchSpine (G, (S1, s1), (S2, s2)) else raise (Match "Skolem constant clash") | (FVar (n1, _, _), FVar (n2, _, _)) -> if (n1 = n2) then matchSpine (G, (S1, s1), (S2, s2)) else raise (Match "Free variable clash") | (Def (d1), Def (d2)) -> if (d1 = d2) then (* because of strict *) matchSpine (G, (S1, s1), (S2, s2)) else (*  matchExpW (G, Whnf.expandDef (Us1), Whnf.expandDef (Us2)) *) matchDefDefW (G, Us1, Us2)(* four new cases for defined constants *)  | (Def (d1), Const (c2)) -> (match defAncestor d1 with Anc (_, _, NONE) -> (* conservative *) matchExpW (G, expandDef Us1, Us2) | Anc (_, _, SOME (c1)) -> if (c1 = c2) then matchExpW (G, expandDef Us1, Us2) else raise (Match "Constant clash")) | (Const (c1), Def (d2)) -> (match defAncestor d2 with Anc (_, _, NONE) -> (* conservative *) matchExpW (G, Us1, expandDef Us2) | Anc (_, _, SOME (c2)) -> if (c1 = c2) then matchExpW (G, Us1, expandDef Us2) else raise (Match "Constant clash")) | (Def (d1), BVar (k2)) -> raise (Match "Head mismatch")(* due to strictness! *)  | (BVar (k1), Def (d2)) -> raise (Match "Head mismatch")(* due to strictness! *) (* next two cases for def/fgn, fgn/def *)  | (Def (d1), _) -> matchExpW (G, expandDef Us1, Us2) | (_, Def (d2)) -> matchExpW (G, Us1, expandDef Us2) | (FgnConst (cs1, ConDec (n1, _, _, _, _, _)), FgnConst (cs2, ConDec (n2, _, _, _, _, _))) -> (* we require unique string representation of external constants *) if (cs1 = cs2) && (n1 = n2) then () else raise (Match "Foreign Constant clash") | (FgnConst (cs1, ConDef (n1, _, _, W1, _, _, _)), FgnConst (cs2, ConDef (n2, _, _, V, W2, _, _))) -> if (cs1 = cs2) && (n1 = n2) then () else matchExp (G, (W1, s1), (W2, s2)) | (FgnConst (_, ConDef (_, _, _, W1, _, _, _)), _) -> matchExp (G, (W1, s1), Us2) | (_, FgnConst (_, ConDef (_, _, _, W2, _, _, _))) -> matchExp (G, Us1, (W2, s2)) | _ -> raise (Match "Head mismatch")) | matchExpW (G, (Pi ((D1, _), U1), s1), (Pi ((D2, _), U2), s2))  = (matchDec (G, (D1, s1), (D2, s2)); matchExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (U2, dot1 s2))) | matchExpW (G, Us1 as (Pi (_, _), _), Us2 as (Root (Def _, _), _))  = matchExpW (G, Us1, expandDef (Us2)) | matchExpW (G, Us1 as (Root (Def _, _), _), Us2 as (Pi (_, _), _))  = matchExpW (G, expandDef (Us1), Us2) | matchExpW (G, (Lam (D1, U1), s1), (Lam (D2, U2), s2))  = (* D1[s1] = D2[s2]  by invariant *)  matchExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (U2, dot1 s2)) | matchExpW (G, (Lam (D1, U1), s1), (U2, s2))  = (* ETA: can\'t occur if eta expanded *)  matchExp (Decl (G, decSub (D1, s1)), (U1, dot1 s1), (Redex (EClo (U2, shift), App (Root (BVar (1), Nil), Nil)), dot1 s2)) | matchExpW (G, (U1, s1), (Lam (D2, U2), s2))  = (* Cannot occur if expressions are eta expanded *)  matchExp (Decl (G, decSub (D2, s2)), (Redex (EClo (U1, shift), App (Root (BVar (1), Nil), Nil)), dot1 s1), (U2, dot1 s2)) | matchExpW (G, Us1 as (EVar (r, GX, V, cnstrs), s), Us2 as (U2, s2))  = if isPatSub (s) then let ss = invert s let U2\' = pruneExp (G, Us2, ss, r) in (* instantiateEVar (r, EClo (U2, comp(s2, ss)), !cnstrs) *) (* invertExpW (Us2, s, r) *) instantiateEVar (r, U2\', ! cnstrs) else addConstraint (cnstrs, ref (Eqn (G, EClo Us1, EClo Us2))) | matchExpW (G, Us1, Us2)  = raise (Match ("Expression clash"))(* covers most remaining cases *) (* the cases for EClo or Redex should not occur because of whnf invariant *) (* matchExp (G, (U1, s1), (U2, s2)) = ()\n       as in matchExpW, except that arguments may not be in whnf\n    *) matchExp (G, Us1 as (E1, s1), Us2 as (E2, s2))  = matchExpW (G, whnf Us1, whnf Us2)matchDefDefW (G, Us1 as (Root (Def (d1), S1), s1), Us2 as (Root (Def (d2), S2), s2))  = (*  matchExpW (G, Whnf.expandDef (Us1), Whnf.expandDef (Us2)) *)  (* conservative *) let Anc (_, h1, c1Opt) = defAncestor d1 let Anc (_, h2, c2Opt) = defAncestor d2 let _ = match (c1Opt, c2Opt) with (SOME (c1), SOME (c2)) -> if c1 <> c2 then raise (Match ("Irreconcilable defined constant clash")) else () | _ -> () in match compare (h1, h2) with EQUAL -> matchExpW (G, expandDef (Us1), expandDef (Us2)) | LESS -> matchExpW (G, Us1, expandDef (Us2)) | GREATER -> matchExpW (G, expandDef (Us1), Us2)(* matchSpine (G, (S1, s1), (S2, s2)) = ()\n\n       Invariant:\n       If   G |- s1 : G1   G1 |- S1 : V1 > W1\n       and  G |- s2 : G2   G2 |- S2 : V2 > W2\n       and  G |- V1 [s1] = V2 [s2]  : L    (for some level L)\n       and  G |- W1 [s1] = W2 [s2]\n       then if   there is an instantiation I :\n                 s.t. G |- S1 [s1] <I> == S2 [s2] <I>\n            then instantiation is applied as effect, () returned\n            else exception Match is raised\n       Other effects: EVars may be lowered,\n                      constraints may be added for non-patterns\n    *) matchSpine (G, (Nil, _), (Nil, _))  = () | matchSpine (G, (SClo (S1, s1\'), s1), Ss)  = matchSpine (G, (S1, comp (s1\', s1)), Ss) | matchSpine (G, Ss, (SClo (S2, s2\'), s2))  = matchSpine (G, Ss, (S2, comp (s2\', s2))) | matchSpine (G, (App (U1, S1), s1), (App (U2, S2), s2))  = (matchExp (G, (U1, s1), (U2, s2)); matchSpine (G, (S1, s1), (S2, s2)))(* Nil/App or App/Nil cannot occur by typing invariants *) matchDec (G, (Dec (_, V1), s1), (Dec (_, V2), s2))  = matchExp (G, (V1, s1), (V2, s2))(* matchSub (G, s1, s2) = ()\n\n       Invariant:\n       If   G |- s1 : G\'\n       and  G |- s2 : G\'\n       then matchSub (G, s1, s2) terminates with ()\n            iff there exists an instantiation I, such that\n            s1 [I] = s2 [I]\n\n       Remark:  matchSub is used only to match the instantiation of SOME variables\n    *) (* conjecture: G == Null at all times *) (* Thu Dec  6 21:01:09 2001 -fp *) matchSub (G, Shift (n1), Shift (n2))  = () | matchSub (G, Shift (n), s2 as Dot _)  = matchSub (G, Dot (Idx (n + 1), Shift (n + 1)), s2) | matchSub (G, s1 as Dot _, Shift (m))  = matchSub (G, s1, Dot (Idx (m + 1), Shift (m + 1))) | matchSub (G, Dot (Ft1, s1), Dot (Ft2, s2))  = ((match (Ft1, Ft2) with (Idx (n1), Idx (n2)) -> if n1 <> n2 then raise (Error "SOME variables mismatch") else () | (Exp (U1), Exp (U2)) -> matchExp (G, (U1, id), (U2, id)) | (Exp (U1), Idx (n2)) -> matchExp (G, (U1, id), (Root (BVar (n2), Nil), id)) | (Idx (n1), Exp (U2)) -> matchExp (G, (Root (BVar (n1), Nil), id), (U2, id))); (*         | (Undef, Undef) =>\n           | _ => false *) (* not possible because of invariant? -cs *) matchSub (G, s1, s2))(* substitutions s1 and s2 were redundant here --- removed *) (* Sat Dec  8 11:47:12 2001 -fp !!! *) matchBlock (G, LVar (ref (SOME (B1)), s, _), B2)  = matchBlock (G, blockSub (B1, s), B2) | matchBlock (G, B1, LVar (ref (SOME (B2)), s, _))  = matchBlock (G, B1, blockSub (B2, s)) | matchBlock (G, B1, B2)  = matchBlockW (G, B1, B2)matchBlockW (G, LVar (r1, Shift (k1), (l1, t1)), LVar (r2, Shift (k2), (l2, t2)))  = if l1 <> l2 then raise (Match "Label clash") else if r1 = r2 then () else (matchSub (G, t1, t2); (* Sat Dec  7 22:04:31 2002 -fp *) (* invariant? always k1 = k2? *) (* prune t2? Sat Dec  7 22:09:53 2002 *) if k1 <> k2 then raise (Bind) else (); (*\n              if k1 < k2 then instantiateLVar (r1, LVar(r2, Shift(k2-k1), (l2, t2)))\n                else Unify.instantiateLVar (r2, LVar(r1, Shift (k1-k2), (l1, t1)))\n              *) (* hack! *) let ss = invert (Shift (k1)) let t2\' = pruneSub (G, t2, ss, ref NONE) in instantiateLVar (r1, LVar (r2, Shift (0), (l2, t2\')))(* 0 = k2-k1 *) ) | matchBlockW (G, LVar (r1, s1, (l1, t1)), B2)  = (r1 := SOME (blockSub (B2, invert s1)); ()) | matchBlockW (G, B1, LVar (r2, s2, (l2, t2)))  = (r2 := SOME (blockSub (B1, invert s2)); ()) | matchBlockW (G, Bidx (n1), (Bidx (n2)))  = if n1 <> n2 then raise (Match "Block index clash") else () (*\n      | matchBlock (LVar (r1, _, _), B as Bidx _) = instantiate (r1, B)\n      | matchBlock (B as Bidx _, LVar (r2, _, _)) =\n\n      This is still difficult --- B must make sense in the context of the LVar\n      Shall we use the inverse of a pattern substitution? Or postpone as\n      a constraint if pattern substitution does not exist?\n      Sun Dec  1 11:33:13 2002 -cs\n\n*) let rec match1W (G, Us1, Us2)  = (matchExpW (G, Us1, Us2); awakeCnstr (nextCnstr ()))match1 (G, Us1, Us2)  = (matchExp (G, Us1, Us2); awakeCnstr (nextCnstr ()))awakeCnstr (NONE)  = () | awakeCnstr (SOME (ref Solved))  = awakeCnstr (nextCnstr ()) | awakeCnstr (SOME (cnstr as ref (Eqn (G, U1, U2))))  = (solveConstraint cnstr; match1 (G, (U1, id), (U2, id))) | awakeCnstr (SOME (ref (FgnCnstr csfc)))  = if (apply csfc ()) then () else raise (Match "Foreign constraint violated") let rec matchW (G, Us1, Us2)  = (resetAwakenCnstrs (); match1W (G, Us1, Us2)) let rec match (G, Us1, Us2)  = (resetAwakenCnstrs (); match1 (G, Us1, Us2)) let matchW = matchW let match = match let matchSub = matchSub let matchBlock = matchBlock let rec instance (G, Us1, Us2)  = try  with let rec instance\' (G, Us1, Us2)  = try  with  end\n(* functor Match *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Approximate language for term reconstruction *) (* Author: Kevin Watkins *) module Approx ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) ) : APPROX = struct (*! structure IntSyn = IntSyn\' !*)  module I = IntSyn let rec headConDec (Const c)  = sgnLookup c | headConDec (Skonst c)  = sgnLookup c | headConDec (Def d)  = sgnLookup d | headConDec (NSDef d)  = sgnLookup d | headConDec (FgnConst (_, cd))  = cd (* others impossible by invariant *)  (* The approximate language is based on the idea of erasure.  The\n     erasure of a term is defined as follows:\n\n       c- = c\n       d- = d\n       type- = type\n       kind- = kind\n       ({x:A} B)- = A- -> B-\n       ([x:A] M)- = M-    \n       (M N)- = M-\n\n       x- undefined\n       X- undefined\n\n     Note that erasure is always defined on well-typed terms at type\n     family or kind level.  Also, if G |- U1 = U2 : V and U1,U2 are at\n     type family or kind level, then U1- and U2- are defined and\n     equal.  We can define the approximate typing judgment\n             \n       G |- U ~:~ V\n                  \n     by replacing appeals to equality in the usual presentation of the\n     LF type theory with appeals to\n\n       G |- U1 = U2 ~:~ V,\n\n     which is defined to mean\n           G |- U1 ~:~ V  and  G |- U2 ~:~ V  and  U1- = U2-\n                                                         \n     This is a mutual recursion between the two judgments, just as for\n     the standard LF type theory.\n\n     There is also a typing judgment on approximate terms\n\n       |- u : v\n\n     defined in the obvious way.  If |- u : v : l then for any\n     well-formed G there are most general U, V such that G |- U : V\n     and U- = u and V- = v.  *)  (* The approximate language *)  type Uni = Level of int | Next of Uni | LVar of Uni option ref type Exp = Uni of Uni | Arrow of Exp * Exp | Const of Head | CVar of Exp option ref | Undefined (* Because approximate type reconstruction uses the pattern G |- U\n     ~:~ V ~:~ L and universe unification on L, if U is to be an\n     arbitrary input expression, there must be an internal universe\n     Hyperkind such that |- Type ~:~ Kind ~:~ Hyperkind.  The\n     Hyperkind universe is used only during the approximate phase of\n     reconstruction.  The invariants established by\n     ReconTerm.filterLevel ensure that Hyperkind will never appear\n     elsewhere. *)  let Type = Level 1 let Kind = Level 2 let Hyperkind = Level 3 let rec newLVar ()  = LVar (ref NONE) let rec newCVar ()  = CVar (ref NONE) (* whnfUni (l) = l\'\n       where l = l\' and l\' is in whnf *)  let rec whnfUni (Next L)  = (match whnfUni L with Level i -> Level (i + 1) | L\' -> Next L\') | whnfUni (LVar (ref (SOME L)))  = whnfUni L | whnfUni L  = L (* whnf (u) = u\'\n       where u = u\' and u\' is in whnf *)  let rec whnf (CVar (ref (SOME V)))  = whnf V | whnf V  = V (* just a little list since these are only for printing errors *) type varEntry = (Exp * Exp * Uni) * string let varList : varEntry list ref = ref nil let rec varReset ()  = (varList := nil) let rec varLookupRef r  = find (fun ((CVar r\', _, _), _) -> r = r\') (! varList) let rec varLookupName name  = find (fun (_, name\') -> name = name\') (! varList) let rec varInsert ((U, V, L), name)  = (varList := ((U, V, L), name) :: (! varList)) exception Ambiguous (* getReplacementName (u, v, l, allowed) = name\n         if u : v : l\n         and u is a CVar at type family or kind level *) let rec getReplacementName (U as CVar r, V, L, allowed)  = (match varLookupRef r with SOME (_, name) -> name | NONE -> (* others impossible by invariant *) let _ = if allowed then () else raise (Ambiguous) let pref = match whnfUni L with Level 2 -> "A" | Level 3 -> "K" let rec try i  = let name = "%" ^ pref ^ toString i ^ "%" in match varLookupName name with NONE -> (varInsert ((U, V, L), name); name) | SOME _ -> try (i + 1) in try 1) (* findByReplacementName (name) = (u, v, l)\n         if getReplacementName (u, v, l, allowed) = name was already called\n         then u : v : l *) let rec findByReplacementName name  = (match varLookupName name with SOME (UVL, _) -> UVL(* must be in list by invariant *) )  (* converting exact terms to approximate terms *)  (* uniToApx (L) = L- *)  let rec uniToApx (Type)  = Type | uniToApx (Kind)  = Kind (* expToApx (U) = (U-, V-)\n     if G |- U : V\n     or G |- U ":" V = "hyperkind" *)  let rec expToApx (Uni L)  = let L\' = uniToApx L in (Uni L\', Uni (whnfUni (Next L\'))) | expToApx (Pi ((Dec (_, V1), _), V2))  = let (V1\', _, (* Type *) ) = expToApx (V1) let (V2\', L\') = expToApx (V2) in (Arrow (V1\', V2\'), L\') | expToApx (Root (FVar (name, _, _), _))  = (* must have been created to represent a CVar *)  let (U, V, L) = findByReplacementName (name) in (U, V) | expToApx (Root (H, (* Const/Def/NSDef *) , _))  = (* are we sure Skonst/FgnConst are never types or kinds? *)  (Const H, Uni Type) | expToApx (Redex (U, _))  = expToApx U | expToApx (Lam (_, U))  = expToApx U | expToApx (EClo (U, _))  = expToApx U (* classToApx (V) = (V-, L-)\n     if G |- V : L\n     or G |- V ":" L = "hyperkind" *)  let rec classToApx (V)  = let (V\', L\') = expToApx (V) let Uni L\'\' = whnf L\' in (V\', L\'\') (* exactToApx (U, V) = (U-, V-)\n     if G |- U : V *)  let rec exactToApx (U, V)  = let (V\', L\') = classToApx (V) in match whnfUni L\' with Level 1(* Type *)  -> (Undefined, V\', L\') | _(* Kind/Hyperkind *)  -> let (U\', _, (* V\' *) ) = expToApx (U) in (U\', V\', L\') (* constDefApx (d) = V-\n     if |- d = V : type *)  let rec constDefApx d  = (match sgnLookup d with ConDef (_, _, _, U, _, _, _) -> let (V\', _, (* Uni Type *) ) = expToApx U in V\' | AbbrevDef (_, _, _, U, _, _) -> let (V\', _, (* Uni Type *) ) = expToApx U in V\') (* converting approximate terms to exact terms *)  (* apxToUni (L-) = L *)  let rec apxToUniW (Level 1)  = Type | apxToUniW (Level 2)  = Kind (* others impossible by invariant *)  let rec apxToUni L  = apxToUniW (whnfUni L) (* apxToClass (G, v, L-, allowed) = V\n     pre: L is ground and <= Hyperkind,\n          and if L is Hyperkind then the target classifier\n          of v is ground\n          v : L-\n     post: V is most general such that V- = v and G |- V : L *)  let rec apxToClassW (G, Uni L, _, (* Next L *) , allowed)  = Uni (apxToUni L) | apxToClassW (G, Arrow (V1, V2), L, allowed)  = (* this is probably very bad -- it should be possible to infer\n         more accurately which pis can be dependent *)  (* also, does the name of the bound variable here matter? *)  let V1\' = apxToClass (G, V1, Type, allowed) let D = Dec (NONE, V1\') let V2\' = apxToClass (Decl (G, D), V2, L, allowed) in Pi ((D, Maybe), V2\') | apxToClassW (G, V as CVar r, L, (* Type or Kind *) , allowed)  = (* convert undetermined CVars to FVars *)  let name = getReplacementName (V, Uni L, Next L, allowed) let s = Shift (ctxLength (G)) in Root (FVar (name, Uni (apxToUni L), s), Nil) | apxToClassW (G, Const H, L, (* Type *) , allowed)  = Root (H, newSpineVar (G, (conDecType (headConDec H), id)))(* Undefined case impossible *) apxToClass (G, V, L, allowed)  = apxToClassW (G, whnf V, L, allowed) (* apxToExact (G, u, (V, s), allowed) = U\n     if u : V-\n     and G\' |- V : L and G |- s : G\'\n     then U- = u and G |- U : V[s] and U is the most general such *)  let rec apxToExactW (G, U, (Pi ((D, _), V), s), allowed)  = let D\' = decSub (D, s) in Lam (D\', apxToExact (Decl (G, D\'), U, (V, dot1 s), allowed)) | apxToExactW (G, U, (Uni L, s), allowed)  = apxToClass (G, U, uniToApx L, allowed) | apxToExactW (G, U, Vs as (Root (FVar (name, _, _), _), s), allowed)  = let (V, L, _, (* Next L *) ) = findByReplacementName (name) let Uni L = whnf L in match whnfUni L with Level 1 -> newEVar (G, EClo Vs) | Level 2 -> (* U must be a CVar *) (* NOTE: V\' differs from Vs by a Shift *) (* probably could avoid the following call by removing the\n                  substitutions in Vs instead *) let name\' = getReplacementName (whnf U, V, Level 2, allowed) let V\' = apxToClass (Null, V, Level 2, allowed) let s\' = Shift (ctxLength (G)) in Root (FVar (name\', V\', s\'), Nil) | apxToExactW (G, U, Vs, (* an atomic type, not Def *) , allowed)  = newEVar (G, EClo Vs)apxToExact (G, U, Vs, allowed)  = apxToExactW (G, U, whnfExpandDef Vs, allowed) (* matching for the approximate language *)  exception Unify of string (* occurUni (r, l) = ()\n       iff r does not occur in l,\n       otherwise raises Unify *)  let rec occurUniW (r, Next L)  = occurUniW (r, L) | occurUniW (r, LVar r\')  = if r = r\' then raise (Unify "Level circularity") else () | occurUniW (r, _)  = () let rec occurUni (r, L)  = occurUniW (r, whnfUni L) (* matchUni (l1, l2) = ()\n       iff l1<I> = l2<I> for some most general instantiation I\n       effect: applies I\n       otherwise raises Unify *)  let rec matchUniW (Level i1, Level i2)  = if i1 = i2 then () else raise (Unify "Level clash") | matchUniW (Level i1, Next L2)  = if i1 > 1 then matchUniW (Level (i1 - 1), L2) else raise (Unify "Level clash") | matchUniW (Next L1, Level i2)  = if i2 > 1 then matchUniW (L1, Level (i2 - 1)) else raise (Unify "Level clash") | matchUniW (Next L1, Next L2)  = matchUniW (L1, L2) | matchUniW (LVar r1, L2 as LVar r2)  = if r1 = r2 then () else r1 := SOME L2 | matchUniW (LVar r1, L2)  = (occurUniW (r1, L2); r1 := SOME L2) | matchUniW (L1, LVar r2)  = (occurUniW (r2, L1); r2 := SOME L1) let rec matchUni (L1, L2)  = matchUniW (whnfUni L1, whnfUni L2) (* occur (r, u) = ()\n       iff r does not occur in u,\n       otherwise raises Unify *)  let rec occurW (r, Arrow (V1, V2))  = (occur (r, V1); occur (r, V2)) | occurW (r, CVar r\')  = if r = r\' then raise (Unify "Type/kind variable occurrence") else () | occurW (r, _)  = ()occur (r, U)  = occurW (r, whnf U) (* match (u1, u2) = ()\n       iff u1<I> = u2<I> : v for some most general instantiation I\n       effect: applies I\n       otherwise raises Unify *)  let rec matchW (Uni L1, Uni L2)  = matchUni (L1, L2) | matchW (V1 as Const H1, V2 as Const H2)  = (match (H1, H2) with (Const (c1), Const (c2)) -> if c1 = c2 then () else raise (Unify "Type/kind constant clash") | (Def (d1), Def (d2)) -> if d1 = d2 then () else match (constDefApx d1, constDefApx d2) | (Def (d1), _) -> match (constDefApx d1, V2) | (_, Def (d2)) -> match (V1, constDefApx d2)(* strictness is irrelevant to matching on approximate types *)  | (NSDef (d1), NSDef (d2)) -> if d1 = d2 then () else match (constDefApx d1, constDefApx d2) | (NSDef (d1), _) -> match (constDefApx d1, V2) | (_, NSDef (d2)) -> match (V1, constDefApx d2)(* others cannot occur by invariant *) ) | matchW (Arrow (V1, V2), Arrow (V3, V4))  = (try  with ; match (V2, V4)) | matchW (V1 as Arrow _, Const (Def (d2)))  = match (V1, constDefApx d2) | matchW (Const (Def (d1)), V2 as Arrow _)  = match (constDefApx d1, V2) | matchW (V1 as Arrow _, Const (NSDef (d2)))  = match (V1, constDefApx d2) | matchW (Const (NSDef (d1)), V2 as Arrow _)  = match (constDefApx d1, V2) | matchW (CVar r1, U2 as CVar r2)  = if r1 = r2 then () else r1 := SOME U2 | matchW (CVar r1, U2)  = (occurW (r1, U2); r1 := SOME U2) | matchW (U1, CVar r2)  = (occurW (r2, U1); r2 := SOME U1) | matchW _  = raise (Unify "Type/kind expression clash")match (U1, U2)  = matchW (whnf U1, whnf U2) let rec matchable (U1, U2)  = try  with let rec makeGroundUni (Level _)  = false | makeGroundUni (Next L)  = makeGroundUni L | makeGroundUni (LVar (ref (SOME L)))  = makeGroundUni L | makeGroundUni (LVar (r as ref NONE))  = (r := SOME (Level 1); true) end(* structure Apx *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Termination Order *) (* Author: Carsten Schuermann *) module type ORDER = sig (*! structure IntSyn : INTSYN !*) exception Error of stringtype 'aOrderArg'aLex'a Order listSimul'a Order list(*     | [O1 .. On]           *) type PredicateLessint Order * int OrderLeqint Order * int OrderEqint Order * int Order(* O = O'                     *) type MutualEmptyLEcid * MutualLTcid * Mutual(*     | lex order for  -     *) type TDecTDecint Order * Mutualtype RDecRDecPredicate * Mutualval reset : unit -> unitval resetROrder : unit -> unitval install : cid * TDec -> unitval uninstall : cid -> boolval installROrder : cid * RDec -> unitval uninstallROrder : cid -> boolval selLookup : cid -> int Orderval selLookupROrder : cid -> Predicateval mutLookup : cid -> Mutualval closure : cid -> cid list end\n(* signature ORDER *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Whnf = Whnf()\nmodule Conv = Conv(module Whnf = Whnf)\nmodule TomegaTOMEGA = Tomega(struct module Whnf = Whnf module Conv = Conv end)\n', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Manipulating Constraints *) (* Author: Jeff Polakow, Frank Pfenning *) (* Modified: Roberto Virga *) module type CONSTRAINTS = sig (*! structure IntSyn : INTSYN !*) exception Error of cnstr listval simplify : cnstr list -> cnstr listval warnConstraints : string list -> unit end\n(* signature CONSTRAINTS *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Weak Head-Normal Forms *) (* Author: Frank Pfenning, Carsten Schuermann *) (* Modified: Roberto Virga *) module Whnf ((*! structure IntSyn\' : INTSYN !*) ) : WHNF = struct (*! structure IntSyn = IntSyn\' !*)  (*\n     Weak Head-Normal Form (whnf)\n\n     whnf ::= (L, s) | (Pi DP. U, s) | (Root (#k(b), S))\n            | (Root(n,S), id) | (Root(c,S), id) | (Root(d,S), id) | (Root(F[s\'], S), id)\n            | (Root(fgnC,S), id) where fgnC is a foreign constant\n            | (Lam D. U, s) | (X, s) where X is uninstantiated, X of base type\n                                     during type reconstruction, X might have variable type\n            | (FgnExp, id) where FgnExp is a foreign expression\n\n     Normal Form (nf)\n\n        UA ::= L | Pi (DA,P). UA\n             | Root(n,SA) | Root(c,SA) | Root(d,SA) | Root(fgnC,SA) | Root (#k(b), S)\n             | Lam DA. UA | FgnExp\n        DA ::= x:UA\n        SA ::= Nil | App (UA, SA)\n\n     Existential Normal Form (enf)\n\n     Existential normal forms are like normal forms, but also allows\n     X[s] where X is uninstantiated with no particular restriction on s\n     or type of X.\n\n     An existential normal form is a hereditary weak head-normal form.\n  *)  open IntSyn (* exception Undefined *) exception Eta (* etaContract (U, s, n) = k\'\n\n       Invariant:\n       if   G, V1, .., Vn |- s : G1  and  G1 |- U : V\n       then if   lam V1...lam Vn. U[s] =eta*=> k\n            then k\' = k\n            and  G |- k\' : Pi V1...Pi Vn. V [s]\n            else Eta is raised\n              (even if U[s] might be eta-reducible to some other expressions).\n    *) (* optimization(?): quick check w/o substitution first *) let rec etaContract (Root (BVar (k), S), s, n)  = (match bvarSub (k, s) with Idx (k\') -> if k\' > n then (etaContract\' (S, s, n); k\' - n) else raise (Eta) | _ -> raise (Eta)) | etaContract (Lam (D, U), s, n)  = etaContract (U, dot1 s, n + 1) | etaContract (EClo (U, s\'), s, n)  = etaContract (U, comp (s\', s), n) | etaContract (EVar (ref (SOME (U)), _, _, _), s, n)  = etaContract (U, s, n) | etaContract (AVar (ref (SOME (U))), s, n)  = etaContract (U, s, n) | etaContract _  = raise (Eta)(* Should fail: (c@S), (d@S), (F@S), X *) (* Not treated (fails): U@S *) (* Could weak head-normalize for more thorough checks *) (* Impossible: L, Pi D.V *) (* etaContract\' (S, s, n) = R\'\n\n       Invariant:\n       If  G |- s : G1    and  G1 |- S : V > W\n       then if   S[s] =eta*=> n ; n-1 ; ... ; 1 ; Nil\n            then ()\n       else Eta is raised\n    *) etaContract\' (Nil, s, 0)  = () | etaContract\' (App (U, S), s, n)  = if etaContract (U, s, 0) = n then etaContract\' (S, s, n - 1) else raise (Eta) | etaContract\' (SClo (S, s\'), s, n)  = etaContract\' (S, comp (s\', s), n) | etaContract\' _  = raise (Eta) (* dotEta (Ft, s) = s\'\n\n       Invariant:\n       If   G |- s : G1, V  and G |- Ft : V [s]\n       then Ft  =eta*=>  Ft1\n       and  s\' = Ft1 . s\n       and  G |- s\' : G1, V\n    *) let rec dotEta (Ft as Idx _, s)  = Dot (Ft, s) | dotEta (Ft as Exp (U), s)  = let Ft\' = try  with  in Dot (Ft\', s) | dotEta (Ft as Undef, s)  = Dot (Ft, s) (* appendSpine ((S1, s1), (S2, s2)) = S\'\n\n       Invariant:\n       If    G |- s1 : G1   G1 |- S1 : V1\' > V1\n       and   G |- s2 : G2   G2 |- S2 : V2  > V2\'\n       and   G |- V1 [s1] == V2 [s2]\n       then  G |- S\' : V1\' [s1] > V2\' [s2]\n    *) let rec appendSpine ((Nil, s1), Ss2)  = SClo Ss2 | appendSpine ((App (U1, S1), s1), Ss2)  = App (EClo (U1, s1), appendSpine ((S1, s1), Ss2)) | appendSpine ((SClo (S1, s1\'), s1), Ss2)  = appendSpine ((S1, comp (s1\', s1)), Ss2) (* whnfRedex ((U, s1), (S, s2)) = (U\', s\')\n\n       Invariant:\n       If    G |- s1 : G1   G1 |- U : V1,   (U,s1) whnf\n             G |- s2 : G2   G2 |- S : V2 > W2\n             G |- V1 [s1] == V2 [s2] == V : L\n       then  G |- s\' : G\',  G\' |- U\' : W\'\n       and   G |- W\'[s\'] == W2[s2] == W : L\n       and   G |- U\'[s\'] == (U[s1] @ S[s2]) : W\n       and   (U\',s\') whnf\n\n       Effects: EVars may be lowered to base type.\n    *) let rec whnfRedex (Us, (SClo (S, s2\'), s2))  = whnfRedex (Us, (S, comp (s2\', s2))) | whnfRedex (Us as (Root R, s1), (Nil, s2))  = Us | whnfRedex ((Root (H1, S1), s1), (S2, s2))  = (* S2 = App _, only possible if term is not eta-expanded *)  (Root (H1, appendSpine ((S1, s1), (S2, s2))), id) | whnfRedex ((Lam (_, U1), s1), (App (U2, S), s2))  = whnfRedex (whnf (U1, dotEta (frontSub (Exp (U2), s2), s1)), (S, s2)) | whnfRedex (Us as (Lam _, s1), _)  = Us | whnfRedex (Us as (EVar _, s1), (Nil, s2))  = Us | whnfRedex (Us as (X as EVar _, s1), Ss2)  = (* Ss2 must be App, since prior cases do not apply *)  (* lowerEVar X results in redex, optimize by unfolding call to whnfRedex *)  (lowerEVar X; whnfRedex (whnf Us, Ss2)) | whnfRedex (Us as (AVar (ref (SOME U)), s1), Ss2)  = whnfRedex ((U, s1), Ss2) | whnfRedex (Us as (AVar (ref NONE), s1), Ss2)  = Us | whnfRedex (Us as (FgnExp _, _), _)  = Us | whnfRedex (Us as (Uni _, s1), _)  = Us | whnfRedex (Us as (Pi _, s1), _)  = Us(* S2[s2] = Nil *) (* Other cases impossible since (U,s1) whnf *) (* lowerEVar\' (G, V[s]) = (X\', U), see lowerEVar *) lowerEVar\' (G, (Pi ((D\', _), V\'), s\'))  = let D\'\' = decSub (D\', s\') let (X\', U) = lowerEVar\' (Decl (G, D\'\'), whnfExpandDef (V\', dot1 s\')) in (X\', Lam (D\'\', U)) | lowerEVar\' (G, Vs\')  = let X\' = newEVar (G, EClo Vs\') in (X\', X\')(* lowerEVar1 (X, V[s]), V[s] in whnf, see lowerEVar *) lowerEVar1 (EVar (r, G, _, _), Vs as (Pi _, _))  = let (X\', U) = lowerEVar\' (G, Vs) let _ = r := SOME (U) in X\' | lowerEVar1 (X, _)  = X(* lowerEVar (X) = X\'\n\n       Invariant:\n       If   G |- X : {{G\'}} P\n            X not subject to any constraints\n       then G, G\' |- X\' : P\n\n       Effect: X is instantiated to [[G\']] X\' if G\' is empty\n               otherwise X = X\' and no effect occurs.\n    *) lowerEVar (X as EVar (r, G, V, ref nil))  = lowerEVar1 (X, whnfExpandDef (V, id)) | lowerEVar (EVar _)  = (* It is not clear if this case can happen *)  (* pre-Twelf 1.2 code walk, Fri May  8 11:05:08 1998 *)  raise (Error "Typing ambiguous -- constraint of functional type cannot be simplified")(* whnfRoot ((H, S), s) = (U\', s\')\n\n       Invariant:\n       If    G |- s : G1      G1 |- H : V\n                              G1 |- S : V > W\n       then  G |- s\' : G\'     G\' |- U\' : W\'\n       and   G |- W [s] = W\' [s\'] : L\n\n       Effects: EVars may be instantiated when lowered\n    *) whnfRoot ((BVar (k), S), s)  = (match bvarSub (k, s) with Idx (k) -> (Root (BVar (k), SClo (S, s)), id) | Exp (U) -> whnfRedex (whnf (U, id), (S, s))) | whnfRoot ((Proj (B as Bidx _, i), S), s)  = (* could blockSub (B, s) return instantiated LVar ? *)  (* Sat Dec  8 13:43:17 2001 -fp !!! *)  (* yes Thu Dec 13 21:48:10 2001 -fp !!! *)  (* was: (Root (Proj (blockSub (B, s), i), SClo (S, s)), id) *)  (match blockSub (B, s) with B\' as Bidx (k) -> (Root (Proj (B\', i), SClo (S, s)), id) | B\' as LVar _ -> whnfRoot ((Proj (B\', i), SClo (S, s)), id) | Inst L -> whnfRedex (whnf (nth (L, i - 1), id), (S, s))) | whnfRoot ((Proj (LVar (ref (SOME B), sk, (l, t)), i), S), s)  = whnfRoot ((Proj (blockSub (B, comp (sk, s)), i), SClo (S, s)), id) | whnfRoot ((Proj (L as LVar (r, sk, (l, t)), i), S), s)  = (* r = ref NONE *)  (Root (Proj (LVar (r, comp (sk, s), (l, t)), i), SClo (S, s)), id) | whnfRoot ((FVar (name, V, s\'), S), s)  = (Root (FVar (name, V, comp (s\', s)), SClo (S, s)), id) | whnfRoot ((NSDef (d), S), s)  = whnfRedex (whnf (constDef d, id), (S, s)) | whnfRoot ((H, S), s)  = (Root (H, SClo (S, s)), id)(* whnf (U, s) = (U\', s\')\n\n       Invariant:\n       If    G |- s : G\'    G\' |- U : V\n       then  G |- s\': G\'\'   G\'\'|- U\' : V\'\n       and   G |- V [s] == V\' [s\'] == V\'\' : L\n       and   G |- U [s] == U\' [s\'] : V\'\'\n       and   (U\', s\') whnf\n    *) (*\n       Possible optimization :\n         Define whnf of Root as (Root (n , S [s]), id)\n         Fails currently because appendSpine does not necessairly return a closure  -cs\n         Advantage: in unify, abstract... the spine needn\'t be treated under id, but under s\n    *) whnf (U as Uni _, s)  = (U, s) | whnf (U as Pi _, s)  = (U, s) | whnf (Root R, s)  = whnfRoot (R, s) | whnf (Redex (U, S), s)  = whnfRedex (whnf (U, s), (S, s)) | whnf (Us as (Lam _, s))  = Us | whnf (AVar (ref (SOME U)), s)  = whnf (U, s) | whnf (Us as (AVar _, s))  = Us | whnf (EVar (ref (SOME U), _, _, _), s)  = whnf (U, s) | whnf (Us as (EVar (r, _, Root _, _), s))  = Us | whnf (Us as (EVar (r, _, Uni _, _), s))  = Us | whnf (Us as (X as EVar (r, _, V, _), s))  = (match whnf (V, id) with (Pi _, _) -> (lowerEVar X; whnf Us)(* possible opt: call lowerEVar1 *)  | _ -> Us) | whnf (EClo (U, s\'), s)  = whnf (U, comp (s\', s)) | whnf (Us as (FgnExp _, Shift (0)))  = Us | whnf (Us as (FgnExp csfe, s))  = (apply csfe (fun U -> EClo (U, s)), id)(* expandDef (Root (Def (d), S), s) = (U\' ,s\')\n\n       Invariant:\n       If    G |- s : G1     G1 |- S : V > W            ((d @ S), s) in whnf\n                             .  |- d = U : V\'\n       then  G |- s\' : G\'    G\' |- U\' : W\'\n       and   G |- V\' == V [s] : L\n       and   G |- W\' [s\'] == W [s] == W\'\' : L\n       and   G |- (U @ S) [s] == U\' [s\'] : W\'\n       and   (U\', s\') in whnf\n    *) expandDef (Root (Def (d), S), s)  = (* why the call to whnf?  isn\'t constDef (d) in nf? -kw *)  whnfRedex (whnf (constDef (d), id), (S, s))whnfExpandDefW (Us as (Root (Def _, _), _))  = whnfExpandDefW (expandDef Us) | whnfExpandDefW Us  = UswhnfExpandDef Us  = whnfExpandDefW (whnf Us) let rec newLoweredEVarW (G, (Pi ((D, _), V), s))  = let D\' = decSub (D, s) in Lam (D\', newLoweredEVar (Decl (G, D\'), (V, dot1 s))) | newLoweredEVarW (G, Vs)  = newEVar (G, EClo Vs)newLoweredEVar (G, Vs)  = newLoweredEVarW (G, whnfExpandDef Vs) let rec newSpineVarW (G, (Pi ((Dec (_, Va), _), Vr), s))  = let X = newLoweredEVar (G, (Va, s)) in App (X, newSpineVar (G, (Vr, dotEta (Exp (X), s)))) | newSpineVarW (G, _)  = NilnewSpineVar (G, Vs)  = newSpineVarW (G, whnfExpandDef Vs) let rec spineToSub (Nil, s)  = s | spineToSub (App (U, S), s)  = spineToSub (S, dotEta (Exp (U), s)) (* inferSpine ((S, s1), (V, s2)) = (V\', s\')\n\n       Invariant:\n       If  G |- s1 : G1  and  G1 |- S : V1 > V1\'\n       and G |- s2 : G2  and  G2 |- V : L,  (V, s2) in whnf\n       and G |- S[s1] : V[s2] > W  (so V1[s1] == V[s2] and V1[s1] == W)\n       then G |- V\'[s\'] = W\n    *) (* FIX: this is almost certainly mis-design -kw *) let rec inferSpine ((Nil, _), Vs)  = Vs | inferSpine ((SClo (S, s\'), s), Vs)  = inferSpine ((S, comp (s\', s)), Vs) | inferSpine ((App (U, S), s1), (Pi (_, V2), s2))  = inferSpine ((S, s1), whnfExpandDef (V2, Dot (Exp (EClo (U, s1)), s2))) (* inferCon (C) = V  if C = c or C = d or C = sk and |- C : V *) (* FIX: this is almost certainly mis-design -kw *) let rec inferCon (Const (cid))  = constType (cid) | inferCon (Skonst (cid))  = constType (cid) | inferCon (Def (cid))  = constType (cid) (* etaExpand\' (U, (V,s)) = U\'\n\n       Invariant :\n       If    G |- U : V [s]   (V,s) in whnf\n       then  G |- U\' : V [s]\n       and   G |- U == U\' : V[s]\n       and   (U\', id) in whnf and U\' in head-eta-long form\n    *) (* quite inefficient -cs *) (* FIX: this is almost certainly mis-design -kw *) let rec etaExpand\' (U, (Root _, s))  = U | etaExpand\' (U, (Pi ((D, _), V), s))  = Lam (decSub (D, s), etaExpand\' (Redex (EClo (U, shift), App (Root (BVar (1), Nil), Nil)), whnfExpandDef (V, dot1 s))) (* etaExpandRoot (Root(H, S)) = U\' where H = c or H = d\n\n       Invariant:\n       If   G |- H @ S : V  where H = c or H = d\n       then G |- U\' : V\n       and  G |- H @ S == U\'\n       and (U\',id) in whnf and U\' in head-eta-long form\n    *) (* FIX: this is almost certainly mis-design -kw *) let rec etaExpandRoot (U as Root (H, S))  = etaExpand\' (U, inferSpine ((S, id), (inferCon (H), id))) (* whnfEta ((U, s1), (V, s2)) = ((U\', s1\'), (V\', s2)\')\n\n       Invariant:\n       If   G |- s1 : G1  G1 |- U : V1\n       and  G |- s2 : G2  G2 |- V : L\n       and  G |- V1[s1] == V[s2] : L\n\n       then G |- s1\' : G1\'  G1\' |- U\' : V1\'\n       and  G |- s2\' : G2\'  G2\' |- V\' : L\'\n       and  G |- V1\'[s1\'] == V\'[s2\'] : L\n       and (U\', s1\') is in whnf\n       and (V\', s2\') is in whnf\n       and (U\', s1\') == Lam x.U\'\' if V[s2] == Pi x.V\'\'\n\n       Similar to etaExpand\', but without recursive expansion\n    *) (* FIX: this is almost certainly mis-design -kw *) let rec whnfEta (Us, Vs)  = whnfEtaW (whnf Us, whnf Vs)whnfEtaW (UsVs as (_, (Root _, _)))  = UsVs | whnfEtaW (UsVs as ((Lam _, _), (Pi _, _)))  = UsVs | whnfEtaW ((U, s1), Vs2 as (Pi ((D, P), V), s2))  = ((Lam (decSub (D, s2), Redex (EClo (U, comp (s1, shift)), App (Root (BVar (1), Nil), Nil))), id), Vs2) (* Invariant:\n\n       normalizeExp (U, s) = U\'\n       If   G |- s : G\' and G\' |- U : V\n       then U [s] = U\'\n       and  U\' in existential normal form\n\n       If (U, s) contain no existential variables,\n       then U\' in normal formal\n    *) let rec normalizeExp Us  = normalizeExpW (whnf Us)normalizeExpW (U as Uni (L), s)  = U | normalizeExpW (Pi (DP, U), s)  = Pi (normalizeDecP (DP, s), normalizeExp (U, dot1 s)) | normalizeExpW (U as Root (H, S), s)  = (* s = id *)  Root (H, normalizeSpine (S, s)) | normalizeExpW (Lam (D, U), s)  = Lam (normalizeDec (D, s), normalizeExp (U, dot1 s)) | normalizeExpW (Us as (EVar _, s))  = EClo Us | normalizeExpW (FgnExp csfe, s)  = apply csfe (fun U -> normalizeExp (U, s)) | normalizeExpW (Us as (AVar (ref (SOME (U))), s))  = normalizeExpW (U, s) | normalizeExpW (Us as (AVar _, s))  = (print "Normalize  AVAR\\n"; raise (Error ""))normalizeSpine (Nil, s)  = Nil | normalizeSpine (App (U, S), s)  = App (normalizeExp (U, s), normalizeSpine (S, s)) | normalizeSpine (SClo (S, s\'), s)  = normalizeSpine (S, comp (s\', s))normalizeDec (Dec (xOpt, V), s)  = Dec (xOpt, normalizeExp (V, s)) | normalizeDec (BDec (xOpt, (c, t)), s)  = BDec (xOpt, (c, normalizeSub (comp (t, s))))normalizeDecP ((D, P), s)  = (normalizeDec (D, s), P)(* dead code -fp *) (* pre-Twelf 1.2 code walk Fri May  8 11:37:18 1998 *) (* not any more --cs Wed Jun 19 13:59:56 EDT 2002 *) normalizeSub (s as Shift _)  = s | normalizeSub (Dot (Ft as Idx _, s))  = Dot (Ft, normalizeSub (s)) | normalizeSub (Dot (Exp U, s))  = (* changed to obtain pattern substitution if possible *)  (* Sat Dec  7 16:58:09 2002 -fp *)  (* Dot (Exp (normalizeExp (U, id)), normalizeSub s) *)  dotEta (Exp (normalizeExp (U, id)), normalizeSub s) let rec normalizeCtx Null  = Null | normalizeCtx (Decl (G, D))  = Decl (normalizeCtx G, normalizeDec (D, id)) (* invert s = s\'\n\n       Invariant:\n       If   G |- s : G\'    (and s patsub)\n       then G\' |- s\' : G\n       s.t. s o s\' = id\n    *) let rec invert s  = let rec lookup (n, Shift _, p)  = NONE | lookup (n, Dot (Undef, s\'), p)  = lookup (n + 1, s\', p) | lookup (n, Dot (Idx k, s\'), p)  = if k = p then SOME n else lookup (n + 1, s\', p) let rec invert\'\' (0, si)  = si | invert\'\' (p, si)  = (match (lookup (1, s, p)) with SOME k -> invert\'\' (p - 1, Dot (Idx k, si)) | NONE -> invert\'\' (p - 1, Dot (Undef, si))) let rec invert\' (n, Shift p)  = invert\'\' (p, Shift n) | invert\' (n, Dot (_, s\'))  = invert\' (n + 1, s\') in invert\' (0, s) (* strengthen (t, G) = G\'\n\n       Invariant:\n       If   G\'\' |- t : G    (* and t strsub *)\n       then G\' |- t : G  and G\' subcontext of G\n    *) let rec strengthen (Shift n, (* = 0 *) , Null)  = Null | strengthen (Dot (Idx k, (* k = 1 *) , t), Decl (G, D))  = let t\' = comp (t, invShift) in (* G |- D dec *) (* G\' |- t\' : G *) (* G\' |- D[t\'] dec *) Decl (strengthen (t\', G), decSub (D, t\')) | strengthen (Dot (Undef, t), Decl (G, D))  = strengthen (t, G) | strengthen (Shift n, G)  = strengthen (Dot (Idx (n + 1), Shift (n + 1)), G) (* isId s = B\n\n       Invariant:\n       If   G |- s: G\', s weakensub\n       then B holds\n            iff s = id, G\' = G\n    *) let rec isId\' (Shift (k), k\')  = (k = k\') | isId\' (Dot (Idx (n), s\'), k\')  = n = k\' && isId\' (s\', k\' + 1) | isId\' _  = false let rec isId s  = isId\' (s, 0) (* cloInv (U, w) = U[w^-1]\n\n       Invariant:\n       If G |- U : V\n          G |- w : G\'  w weakening subst\n          U[w^-1] defined (without pruning or constraints)\n\n       then G\' |- U[w^-1] : V[w^-1]\n       Effects: None\n    *) let rec cloInv (U, w)  = EClo (U, invert w) (* cloInv (s, w) = s o w^-1\n\n       Invariant:\n       If G |- s : G1\n          G |- w : G2  s weakening subst\n          s o w^-1 defined (without pruning or constraints)\n\n       then G2 |- s o w^-1 : G1\n       Effects: None\n    *) let rec compInv (s, w)  = comp (s, invert w) (* functions previously in the Pattern functor *) (* eventually, they may need to be mutually recursive with whnf *) (* isPatSub s = B\n\n       Invariant:\n       If    G |- s : G\'\n       and   s = n1 .. nm ^k\n       then  B iff  n1, .., nm pairwise distinct\n               and  ni <= k or ni = _ for all 1 <= i <= m\n    *) let rec isPatSub (Shift (k))  = true | isPatSub (Dot (Idx (n), s))  = let rec checkBVar (Shift (k))  = (n <= k) | checkBVar (Dot (Idx (n\'), s))  = n <> n\' && checkBVar (s) | checkBVar (Dot (Undef, s))  = checkBVar (s) | checkBVar _  = false in checkBVar s && isPatSub s | isPatSub (Dot (Undef, s))  = isPatSub s | isPatSub _  = false (* Try harder, due to bug somewhere *) (* Sat Dec  7 17:05:02 2002 -fp *) (* false *) (* below does not work, because the patSub is lost *) (*\n          let val (U\', s\') = whnf (U, id)\n          in\n            isPatSub (Dot (Idx (etaContract (U\', s\', 0)), s))\n            handle Eta => false\n          end\n      | isPatSub _ = false\n      *) (* makePatSub s = SOME(s\') if s is convertible to a patSub\n                      NONE otherwise\n\n       Invariant:\n       If    G |- s : G\'\n       and   s = n1 .. nm ^k\n       then  B iff  n1, .., nm pairwise distinct\n               and  ni <= k or ni = _ for all 1 <= i <= m\n    *) let rec mkPatSub (s as Shift (k))  = s | mkPatSub (Dot (Idx (n), s))  = let s\' = mkPatSub s let rec checkBVar (Shift (k))  = (n <= k) | checkBVar (Dot (Idx (n\'), s\'))  = n <> n\' && checkBVar (s\') | checkBVar (Dot (Undef, s\'))  = checkBVar (s\') let _ = checkBVar s\' in Dot (Idx (n), s\') | mkPatSub (Dot (Undef, s))  = Dot (Undef, mkPatSub s) | mkPatSub (Dot (Exp (U), s))  = (* may raise Eta *) let (U\', t\') = whnf (U, id) let k = (etaContract (U\', t\', 0)) in Dot (Idx (k), mkPatSub s) | mkPatSub _  = raise (Eta) let rec makePatSub (s)  = try  with let isPatSub = isPatSub let makePatSub = makePatSub let dotEta = dotEta exception EtaEta let etaContract = (fun U -> etaContract (U, id, 0)) let whnf = whnf let expandDef = expandDef let whnfExpandDef = whnfExpandDef let etaExpandRoot = etaExpandRoot let whnfEta = whnfEta let lowerEVar = lowerEVar let newLoweredEVar = newLoweredEVar let newSpineVar = newSpineVar let spineToSub = spineToSub let normalize = normalizeExp let normalizeDec = normalizeDec let normalizeCtx = normalizeCtx let invert = invert let strengthen = strengthen let isId = isId let cloInv = cloInv let compInv = compInv  end\n(* functor Whnf *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Unification *) (* Author: Frank Pfenning, Carsten Schuermann *) module type UNIFY = sig (*! structure IntSyn : INTSYN !*) type unifTrail(* suspending and resuming trailing *) val suspend : unit -> unifTrailval resume : unifTrail -> unit(* trailing of variable instantiation *) val reset : unit -> unitval mark : unit -> unitval unwind : unit -> unitval instantiateEVar : Exp option ref * Exp * cnstr list -> unitval instantiateLVar : Block option ref * Block -> unitval resetAwakenCnstrs : unit -> unitval nextCnstr : unit -> cnstr optionval addConstraint : cnstr list ref * cnstr -> unitval solveConstraint : cnstr -> unitval delay : eclo * cnstr -> unit(* unification *) val intersection : Sub * Sub -> Subexception Unify of stringval unify : dctx * eclo * eclo -> unit(* raises Unify *) val unifyW : dctx * eclo * eclo -> unit(* raises Unify *) val unifyBlock : dctx * Block * Block -> unit(* raises Unify *) val unifySub : dctx * Sub * Sub -> unit(* raises Unify *) val invertible : dctx * eclo * Sub * Exp option ref -> boolval invertSub : dctx * Sub * Sub * Exp option ref -> Sub(* unifiable (G, Us,Us') will instantiate EVars as an effect *) val unifiable : dctx * eclo * eclo -> bool(* unifiable' (G, Us,Us') is like unifiable, but returns NONE for\n     success and SOME(msg) for failure *) val unifiable' : dctx * eclo * eclo -> string option end\n(* signature UNIFY *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module Order = Order(module Table = IntRedBlackTree)\n(* -bp *) (*\nstructure RedOrder = \n    RedOrder ((*! structure IntSyn' = IntSyn !*)\n\t      structure Table = IntRedBlackTree); \n*) ", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module Order = Order(module Table = IntRedBlackTree)\n(* -bp *) (*\nstructure RedOrder = \n    RedOrder ((*! structure IntSyn' = IntSyn !*)\n\t      structure Table = IntRedBlackTree); \n*) ", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Whnf = Whnf()\nmodule Conv = Conv(module Whnf = Whnf)\nmodule TomegaTOMEGA = Tomega(struct module Whnf = Whnf module Conv = Conv end)\n', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Manipulating Constraints *) (* Author: Jeff Polakow, Frank Pfenning *) (* Modified: Roberto Virga *) module Constraints ((*! structure IntSyn\' : INTSYN !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn\' !*) ) : CONSTRAINTS = struct (*! structure IntSyn = IntSyn\' !*)  exception Error of cnstr list (*\n     Constraints cnstr are of the form (X<I>[s] = U).\n     Invariants:\n       G |- s : G\'  G\' |- X<I> : V\n       G |- U : W\n       G |- V[s] == W : L\n       (X<>,s) is whnf, but X<>[s] is not a pattern\n     If X<I> is uninstantiated, the constraint is inactive.\n     If X<I> is instantiated, the constraint is active.\n\n     Constraints are attached directly to the EVar X\n     or to a descendent  -fp?\n  *)  module I = IntSyn(* simplify cnstrs = cnstrs\'\n       Effects: simplifies the constraints in cnstrs by removing constraints\n         of the form U = U\' where G |- U == U\' : V (mod beta/eta)\n         Neither U nor U\' needs to be a pattern\n         *) let rec simplify nil  = nil | simplify ((ref Solved) :: cnstrs)  = simplify cnstrs | simplify ((Eqn as ref (Eqn (G, U1, U2))) :: cnstrs)  = if conv ((U1, id), (U2, id)) then simplify cnstrs else Eqn :: (simplify cnstrs) | simplify ((FgnCnstr as ref (FgnCnstr csfc)) :: cnstrs)  = if apply csfc () then simplify cnstrs else FgnCnstr :: (simplify cnstrs) let rec namesToString (name :: nil)  = name ^ "." | namesToString (name :: names)  = name ^ ", " ^ namesToString names let rec warnConstraints (nil)  = () | warnConstraints (names)  = print ("Constraints remain on " ^ namesToString names ^ "\\n") let simplify = simplify let namesToString = namesToString let warnConstraints = warnConstraints  end\n(* functor Constraints *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Internal Syntax *) (* Author: Frank Pfenning, Carsten Schuermann *) (* Modified: Roberto Virga *) module IntSyn (module Global : GLOBAL)INTSYN = struct type cid = int (* Constant identifier        *)  type name = string (* Variable name              *)  type mid = int (* Structure identifier       *)  type csid = int (* CS module identifier       *)  (* Contexts *)  type Ctx = Null | Decl of \'a Ctx * \'a (*     | G, D                 *)  (* ctxPop (G) => G\'\n     Invariant: G = G\',D\n  *)  let rec ctxPop (Decl (G, D))  = G exception Error of string (* raised if out of space     *)  (* ctxLookup (G, k) = D, kth declaration in G from right to left\n     Invariant: 1 <= k <= |G|, where |G| is length of G\n  *)  let rec ctxLookup (Decl (G\', D), 1)  = D | ctxLookup (Decl (G\', _), k\')  = ctxLookup (G\', k\' - 1) (*    | ctxLookup (Null, k\') = (print ("Looking up k\' = " ^ Int.toString k\' ^ "\\n"); raise Error "Out of Bounce\\n")*)  (* ctxLookup (Null, k\')  should not occur by invariant *)  (* ctxLength G = |G|, the number of declarations in G *)  let rec ctxLength G  = let rec ctxLength\' (Null, n)  = n | ctxLength\' (Decl (G, _), n)  = ctxLength\' (G, n + 1) in ctxLength\' (G, 0) type FgnExp = exn (* foreign expression representation *)  exception UnexpectedFgnExp of FgnExp (* raised by a constraint solver\n                                           if passed an incorrect arg *)  type FgnCnstr = exn (* foreign unification constraint\n                                           representation *)  exception UnexpectedFgnCnstr of FgnCnstr (* raised by a constraint solver\n                                           if passed an incorrect arg *)  type Depend = No | Maybe | Meta (*     | Meta                 *)  (* Expressions *)  type Uni = Kind | Type (*     | Type                 *)  type Exp = Uni of Uni | Pi of (Dec * Depend) * Exp | Root of Head * Spine | Redex of Exp * Spine | Lam of Dec * Exp | EVar of Exp option ref * Dec Ctx * Exp * Cnstr ref list ref | EClo of Exp * Sub | AVar of Exp option ref | NVar of int | FgnExp of csid * FgnExp and Head = BVar of int | Const of cid | Proj of Block * int | Skonst of cid | Def of cid | NSDef of cid | FVar of name * Exp * Sub | FgnConst of csid * ConDec and Spine = Nil | App of Exp * Spine | SClo of Spine * Sub and Sub = Shift of int | Dot of Front * Sub and Front = Idx of int | Exp of Exp | Axp of Exp | Block of Block | Undef and Dec = Dec of name option * Exp | BDec of name option * (cid * Sub) | ADec of name option * int | NDec of name option and Block = Bidx of int | LVar of Block option ref * Sub * (cid * Sub) | Inst of Exp list and Cnstr = Solved | Eqn of Dec Ctx * Exp * Exp | FgnCnstr of csid * FgnCnstr and Status = Normal | Constraint of csid * (Dec Ctx * Spine * int -> Exp option) | Foreign of csid * (Spine -> Exp) and FgnUnify = Succeed of FgnUnifyResidual list | Fail and FgnUnifyResidual = Assign of Dec Ctx * Exp * Exp * Sub | Delay of Exp * Cnstr ref and ConDec = ConDec of string * mid option * int * Status(* a : K : kind  or           *)  * Exp * Uni | ConDef of string * mid option * int(* a = A : K : kind  or       *)  * Exp * Exp * Uni(* d = M : A : type           *)  * Ancestor | AbbrevDef of string * mid option * int(* a = A : K : kind  or       *)  * Exp * Exp * Uni | BlockDec of string * mid option(* %block l : SOME G1 PI G2   *)  * Dec Ctx * Dec list | BlockDef of string * mid option * cid list | SkoDec of string * mid option * int(* sa: K : kind  or           *)  * Exp * Uni and Ancestor = Anc of cid option * int * cid option (* head(expand(d)), height, head(expand[height](d)) *)  (* NONE means expands to {x:A}B *)  type StrDec = StrDec of string * mid option (* Form of constant declaration *)  type ConDecForm = FromCS | Ordinary | Clause (* %clause declaration *)  (* Type abbreviations *)  type dctx = Dec Ctx (* G = . | G,D                *)  type eclo = Exp * Sub (* Us = U[s]                  *)  type bclo = Block * Sub (* Bs = B[s]                  *)  type cnstr = Cnstr ref (*  exception Error of string             (* raised if out of space     *) *)  module FgnExpStd = struct module ToInternal = FgnOpnTable() module Map = FgnOpnTable() module App = FgnOpnTable() module EqualTo = FgnOpnTable() module UnifyWith = FgnOpnTable() let rec fold csfe f b  = let r = ref b let rec g U  = r := f (U, ! r) in apply csfe g; ! r end module FgnCnstrStd = struct module ToInternal = FgnOpnTable() module Awake = FgnOpnTable() module Simplify = FgnOpnTable() end let rec conDecName (ConDec (name, _, _, _, _, _))  = name | conDecName (ConDef (name, _, _, _, _, _, _))  = name | conDecName (AbbrevDef (name, _, _, _, _, _))  = name | conDecName (SkoDec (name, _, _, _, _))  = name | conDecName (BlockDec (name, _, _, _))  = name | conDecName (BlockDef (name, _, _))  = name let rec conDecParent (ConDec (_, parent, _, _, _, _))  = parent | conDecParent (ConDef (_, parent, _, _, _, _, _))  = parent | conDecParent (AbbrevDef (_, parent, _, _, _, _))  = parent | conDecParent (SkoDec (_, parent, _, _, _))  = parent | conDecParent (BlockDec (_, parent, _, _))  = parent | conDecParent (BlockDef (_, parent, _))  = parent (* conDecImp (CD) = k\n\n     Invariant:\n     If   CD is either a declaration, definition, abbreviation, or\n          a Skolem constant\n     then k stands for the number of implicit elements.\n  *)  let rec conDecImp (ConDec (_, _, i, _, _, _))  = i | conDecImp (ConDef (_, _, i, _, _, _, _))  = i | conDecImp (AbbrevDef (_, _, i, _, _, _))  = i | conDecImp (SkoDec (_, _, i, _, _))  = i | conDecImp (BlockDec (_, _, _, _))  = 0 (* watch out -- carsten *)  let rec conDecStatus (ConDec (_, _, _, status, _, _))  = status | conDecStatus _  = Normal (* conDecType (CD) =  V\n\n     Invariant:\n     If   CD is either a declaration, definition, abbreviation, or\n          a Skolem constant\n     then V is the respective type\n  *)  let rec conDecType (ConDec (_, _, _, _, V, _))  = V | conDecType (ConDef (_, _, _, _, V, _, _))  = V | conDecType (AbbrevDef (_, _, _, _, V, _))  = V | conDecType (SkoDec (_, _, _, V, _))  = V (* conDecBlock (CD) =  (Gsome, Lpi)\n\n     Invariant:\n     If   CD is block definition\n     then Gsome is the context of some variables\n     and  Lpi is the list of pi variables\n  *)  let rec conDecBlock (BlockDec (_, _, Gsome, Lpi))  = (Gsome, Lpi) (* conDecUni (CD) =  L\n\n     Invariant:\n     If   CD is either a declaration, definition, abbreviation, or\n          a Skolem constant\n     then L is the respective universe\n  *)  let rec conDecUni (ConDec (_, _, _, _, _, L))  = L | conDecUni (ConDef (_, _, _, _, _, L, _))  = L | conDecUni (AbbrevDef (_, _, _, _, _, L))  = L | conDecUni (SkoDec (_, _, _, _, L))  = L let rec strDecName (StrDec (name, _))  = name let rec strDecParent (StrDec (_, parent))  = parent let maxCid = maxCid let dummyEntry = ConDec ("", NONE, 0, Normal, Uni (Kind), Kind) let sgnArray = array (maxCid + 1, dummyEntry) : ConDec array let nextCid = ref (0) let maxMid = maxMid let sgnStructArray = array (maxMid + 1, StrDec ("", NONE)) : StrDec array let nextMid = ref (0) (* Invariants *) (* Constant declarations are all well-typed *) (* Constant declarations are stored in beta-normal form *) (* All definitions are strict in all their arguments *) (* If Const(cid) is valid, then sgnArray(cid) = ConDec _ *) (* If Def(cid) is valid, then sgnArray(cid) = ConDef _ *) let rec sgnClean (i)  = if i >= ! nextCid then () else (update (sgnArray, i, dummyEntry); sgnClean (i + 1)) let rec sgnReset ()  = ((* Fri Dec 20 12:04:24 2002 -fp *) (* this circumvents a space leak *) sgnClean (0); nextCid := 0; nextMid := 0) let rec sgnSize ()  = (! nextCid, ! nextMid) let rec sgnAdd (conDec)  = let cid = ! nextCid in if cid > maxCid then raise (Error ("Global signature size " ^ toString (maxCid + 1) ^ " exceeded")) else (update (sgnArray, cid, conDec); nextCid := cid + 1; cid) (* 0 <= cid < !nextCid *) let rec sgnLookup (cid)  = sub (sgnArray, cid) let rec sgnApp (f)  = let rec sgnApp\' (cid)  = if cid = ! nextCid then () else (f cid; sgnApp\' (cid + 1)) in sgnApp\' (0) let rec sgnStructAdd (strDec)  = let mid = ! nextMid in if mid > maxMid then raise (Error ("Global signature size " ^ toString (maxMid + 1) ^ " exceeded")) else (update (sgnStructArray, mid, strDec); nextMid := mid + 1; mid) (* 0 <= mid < !nextMid *) let rec sgnStructLookup (mid)  = sub (sgnStructArray, mid) (* A hack used in Flit - jcreed 6/05 *) let rec rename (cid, new)  = let newConDec = match sgnLookup cid with ConDec (n, m, i, s, e, u) -> ConDec (new, m, i, s, e, u) | ConDef (n, m, i, e, e\', u, a) -> ConDef (new, m, i, e, e\', u, a) | AbbrevDef (n, m, i, e, e\', u) -> AbbrevDef (new, m, i, e, e\', u) | BlockDec (n, m, d, d\') -> BlockDec (new, m, d, d\') | SkoDec (n, m, i, e, u) -> SkoDec (new, m, i, e, u) in update (sgnArray, cid, newConDec)  let rec constDef (d)  = (match sgnLookup (d) with ConDef (_, _, _, U, _, _, _) -> U | AbbrevDef (_, _, _, U, _, _) -> U) let rec constType (c)  = conDecType (sgnLookup c) let rec constImp (c)  = conDecImp (sgnLookup c) let rec constUni (c)  = conDecUni (sgnLookup c) let rec constBlock (c)  = conDecBlock (sgnLookup c) let rec constStatus (c)  = (match sgnLookup (c) with ConDec (_, _, _, status, _, _) -> status | _ -> Normal) (* Explicit Substitutions *)  (* id = ^0\n\n     Invariant:\n     G |- id : G        id is patsub\n  *)  let id = Shift (0) (* shift = ^1\n\n     Invariant:\n     G, V |- ^ : G       ^ is patsub\n  *)  let shift = Shift (1) (* invShift = ^-1 = _.^0\n     Invariant:\n     G |- ^-1 : G, V     ^-1 is patsub\n  *)  let invShift = Dot (Undef, id) (* comp (s1, s2) = s\'\n\n     Invariant:\n     If   G\'  |- s1 : G\n     and  G\'\' |- s2 : G\'\n     then s\'  = s1 o s2\n     and  G\'\' |- s1 o s2 : G\n\n     If  s1, s2 patsub\n     then s\' patsub\n   *)  let rec comp (Shift (0), s)  = s | comp (s, Shift (0))  = s | comp (Shift (n), Dot (Ft, s))  = comp (Shift (n - 1), s) | comp (Shift (n), Shift (m))  = Shift (n + m) | comp (Dot (Ft, s), s\')  = Dot (frontSub (Ft, s\'), comp (s, s\'))(* bvarSub (n, s) = Ft\'\n\n      Invariant:\n     If    G |- s : G\'    G\' |- n : V\n     then  Ft\' = Ftn         if  s = Ft1 .. Ftn .. ^k\n       or  Ft\' = ^(n+k)     if  s = Ft1 .. Ftm ^k   and m<n\n     and   G |- Ft\' : V [s]\n  *) bvarSub (1, Dot (Ft, s))  = Ft | bvarSub (n, Dot (Ft, s))  = bvarSub (n - 1, s) | bvarSub (n, Shift (k))  = Idx (n + k)(* blockSub (B, s) = B\'\n\n     Invariant:\n     If   G |- s : G\'\n     and  G\' |- B block\n     then G |- B\' block\n     and  B [s] == B\'\n  *) (* in front of substitutions, first case is irrelevant *) (* Sun Dec  2 11:56:41 2001 -fp *) blockSub (Bidx k, s)  = (match bvarSub (k, s) with Idx k\' -> Bidx k\' | Block B -> B) | blockSub (LVar (ref (SOME B), sk, _), s)  = blockSub (B, comp (sk, s)) | blockSub (LVar (r as ref NONE, sk, (l, t)), s)  = LVar (r, comp (sk, s), (l, t)) | blockSub (L as Inst ULs, s\')  = Inst (map (fun U -> EClo (U, s\')) ULs)(* this should be right but somebody should verify *) (* frontSub (Ft, s) = Ft\'\n\n     Invariant:\n     If   G |- s : G\'     G\' |- Ft : V\n     then Ft\' = Ft [s]\n     and  G |- Ft\' : V [s]\n\n     NOTE: EClo (U, s) might be undefined, so if this is ever\n     computed eagerly, we must introduce an "Undefined" exception,\n     raise it in whnf and handle it here so Exp (EClo (U, s)) => Undef\n  *) frontSub (Idx (n), s)  = bvarSub (n, s) | frontSub (Exp (U), s)  = Exp (EClo (U, s)) | frontSub (Undef, s)  = Undef | frontSub (Block (B), s)  = Block (blockSub (B, s)) (* decSub (x:V, s) = D\'\n\n     Invariant:\n     If   G  |- s : G\'    G\' |- V : L\n     then D\' = x:V[s]\n     and  G  |- V[s] : L\n  *)  (* First line is an optimization suggested by cs *)  (* D[id] = D *)  (* Sat Feb 14 18:37:44 1998 -fp *)  (* seems to have no statistically significant effect *)  (* undo for now Sat Feb 14 20:22:29 1998 -fp *)  (*\n  fun decSub (D, Shift(0)) = D\n    | decSub (Dec (x, V), s) = Dec (x, EClo (V, s))\n  *)  let rec decSub (Dec (x, V), s)  = Dec (x, EClo (V, s)) | decSub (NDec x, s)  = NDec x | decSub (BDec (n, (l, t)), s)  = BDec (n, (l, comp (t, s))) (* dot1 (s) = s\'\n\n     Invariant:\n     If   G |- s : G\'\n     then s\' = 1. (s o ^)\n     and  for all V s.t.  G\' |- V : L\n          G, V[s] |- s\' : G\', V\n\n     If s patsub then s\' patsub\n  *)  (* first line is an optimization *)  (* roughly 15% on standard suite for Twelf 1.1 *)  (* Sat Feb 14 10:16:16 1998 -fp *)  let rec dot1 (s as Shift (0))  = s | dot1 s  = Dot (Idx (1), comp (s, shift)) (* invDot1 (s) = s\'\n     invDot1 (1. s\' o ^) = s\'\n\n     Invariant:\n     s = 1 . s\' o ^\n     If G\' |- s\' : G\n     (so G\',V[s] |- s : G,V)\n  *)  let rec invDot1 (s)  = comp (comp (shift, s), invShift) (* Declaration Contexts *)  (* ctxDec (G, k) = x:V\n     Invariant:\n     If      |G| >= k, where |G| is size of G,\n     then    G |- k : V  and  G |- V : L\n  *)  let rec ctxDec (G, k)  = (* ctxDec\' (G\'\', k\') = x:V\n             where G |- ^(k-k\') : G\'\', 1 <= k\' <= k\n           *) (* ctxDec\' (Null, k\')  should not occur by invariant *) let rec ctxDec\' (Decl (G\', Dec (x, V\')), 1)  = Dec (x, EClo (V\', Shift (k))) | ctxDec\' (Decl (G\', BDec (n, (l, s))), 1)  = BDec (n, (l, comp (s, Shift (k)))) | ctxDec\' (Decl (G\', _), k\')  = ctxDec\' (G\', k\' - 1) in ctxDec\' (G, k) (* blockDec (G, v, i) = V\n\n     Invariant:\n     If   G (v) = l[s]\n     and  Sigma (l) = SOME Gsome BLOCK Lblock\n     and  G |- s : Gsome\n     then G |- pi (v, i) : V\n  *)  let rec blockDec (G, v as (Bidx k), i)  = (* G |- s : Gsome *) let BDec (_, (l, s)) = ctxDec (G, k) let (Gsome, Lblock) = conDecBlock (sgnLookup l) let rec blockDec\' (t, D :: L, 1, j)  = decSub (D, t) | blockDec\' (t, _ :: L, n, j)  = blockDec\' (Dot (Exp (Root (Proj (v, j), Nil)), t), L, n - 1, j + 1) in blockDec\' (s, Lblock, i, 1) (* EVar related functions *)  (* newEVar (G, V) = newEVarCnstr (G, V, nil) *)  let rec newEVar (G, V)  = EVar (ref NONE, G, V, ref nil) (* newAVar G = new AVar (assignable variable) *)  (* AVars carry no type, ctx, or cnstr *)  let rec newAVar ()  = AVar (ref NONE) (* newTypeVar (G) = X, X new\n     where G |- X : type\n  *)  let rec newTypeVar (G)  = EVar (ref NONE, G, Uni (Type), ref nil) (* newLVar (l, s) = (l[s]) *)  let rec newLVar (sk, (cid, t))  = LVar (ref NONE, sk, (cid, t)) (* Definition related functions *)  (* headOpt (U) = SOME(H) or NONE, U should be strict, normal *)  let rec headOpt (Root (H, _))  = SOME (H) | headOpt (Lam (_, U))  = headOpt U | headOpt _  = NONE let rec ancestor\' (NONE)  = Anc (NONE, 0, NONE) | ancestor\' (SOME (Const (c)))  = Anc (SOME (c), 1, SOME (c)) | ancestor\' (SOME (Def (d)))  = (match sgnLookup (d) with ConDef (_, _, _, _, _, _, Anc (_, height, cOpt)) -> Anc (SOME (d), height + 1, cOpt)) | ancestor\' (SOME _)  = (* FgnConst possible, BVar impossible by strictness *)  Anc (NONE, 0, NONE) (* ancestor(U) = ancestor info for d = U *)  let rec ancestor (U)  = ancestor\' (headOpt U) (* defAncestor(d) = ancestor of d, d must be defined *)  let rec defAncestor (d)  = (match sgnLookup (d) with ConDef (_, _, _, _, _, _, anc) -> anc) (* Type related functions *)  (* targetHeadOpt (V) = SOME(H) or NONE\n     where H is the head of the atomic target type of V,\n     NONE if V is a kind or object or have variable type.\n     Does not expand type definitions.\n  *)  (* should there possibly be a FgnConst case? also targetFamOpt -kw *)  let rec targetHeadOpt (Root (H, _))  = SOME (H) | targetHeadOpt (Pi (_, V))  = targetHeadOpt V | targetHeadOpt (Redex (V, S))  = targetHeadOpt V | targetHeadOpt (Lam (_, V))  = targetHeadOpt V | targetHeadOpt (EVar (ref (SOME (V)), _, _, _))  = targetHeadOpt V | targetHeadOpt (EClo (V, s))  = targetHeadOpt V | targetHeadOpt _  = NONE (* Root(Bvar _, _), Root(FVar _, _), Root(FgnConst _, _),\n         EVar(ref NONE,..), Uni, FgnExp _\n      *)  (* Root(Skonst _, _) can\'t occur *)  (* targetHead (A) = a\n     as in targetHeadOpt, except V must be a valid type\n  *)  let rec targetHead (A)  = valOf (targetHeadOpt A) (* targetFamOpt (V) = SOME(cid) or NONE\n     where cid is the type family of the atomic target type of V,\n     NONE if V is a kind or object or have variable type.\n     Does expand type definitions.\n  *)  let rec targetFamOpt (Root (Const (cid), _))  = SOME (cid) | targetFamOpt (Pi (_, V))  = targetFamOpt V | targetFamOpt (Root (Def (cid), _))  = targetFamOpt (constDef cid) | targetFamOpt (Redex (V, S))  = targetFamOpt V | targetFamOpt (Lam (_, V))  = targetFamOpt V | targetFamOpt (EVar (ref (SOME (V)), _, _, _))  = targetFamOpt V | targetFamOpt (EClo (V, s))  = targetFamOpt V | targetFamOpt _  = NONE (* Root(Bvar _, _), Root(FVar _, _), Root(FgnConst _, _),\n         EVar(ref NONE,..), Uni, FgnExp _\n      *)  (* Root(Skonst _, _) can\'t occur *)  (* targetFam (A) = a\n     as in targetFamOpt, except V must be a valid type\n  *)  let rec targetFam (A)  = valOf (targetFamOpt A) end\n(* functor IntSyn *) module IntSynINTSYN = IntSyn(module Global = Global)\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Extensible operation on foreign matter *) (* Author: Aleksey Kliger *) module type FGN_OPN = sig type csid = inttype rep = exntype argtype resulttype func = rep -> arg -> resultval install : csid * func -> unitval apply : csid * rep -> arg -> result end', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Convertibility Modulo Beta and Eta *) (* Author: Frank Pfenning, Carsten Schuermann *) module Conv ((*! structure IntSyn' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn' !*) ) : CONV = struct (*! structure IntSyn = IntSyn' !*)  open IntSyn (* eqUni (L1, L2) = B iff L1 = L2 *) let rec eqUni (Type, Type)  = true | eqUni (Kind, Kind)  = true | eqUni _  = false (* convExpW ((U1, s1), (U2, s2)) = B\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1    (U1,s1) in whnf\n            G |- s2 : G2    G2 |- U2 : V2    (U2,s2) in whnf\n            G |- V1[s1] == V2[s2] == V : L\n       then B iff G |- U1[s1] == U2[s2] : V\n\n       Effects: EVars may be lowered\n    *) let rec convExpW ((Uni (L1), _), (Uni (L2), _))  = eqUni (L1, L2) | convExpW (Us1 as (Root (H1, S1), s1), Us2 as (Root (H2, S2), s2))  = (* s1 = s2 = id by whnf invariant *)  (* order of calls critical to establish convSpine invariant *)  (match (H1, H2) with (BVar (k1), BVar (k2)) -> (k1 = k2) && convSpine ((S1, s1), (S2, s2)) | (Const (c1), Const (c2)) -> (c1 = c2) && convSpine ((S1, s1), (S2, s2)) | (Skonst c1, Skonst c2) -> (c1 = c2) && convSpine ((S1, s1), (S2, s2)) | (Proj (Bidx v1, i1), Proj (Bidx v2, i2)) -> (v1 = v2) && (i1 = i2) && convSpine ((S1, s1), (S2, s2)) | (FVar (n1, _, s1'), FVar (n2, _, s2')) -> (* s1' = s2' = ^|G| *) (n1 = n2) && convSpine ((S1, s1), (S2, s2)) | (FgnConst (cs1, cD1), FgnConst (cs2, cD2)) -> (* they must have the same string representation *) (cs1 = cs2) && (conDecName (cD1) = conDecName (cD2)) && convSpine ((S1, s1), (S2, s2)) | (Def (d1), Def (d2)) -> (* because of strict *) ((d1 = d2) && convSpine ((S1, s1), (S2, s2))) || convExpW (expandDef (Us1), expandDef (Us2)) | (Def (d1), _) -> convExpW (expandDef Us1, Us2) | (_, Def (d2)) -> convExpW (Us1, expandDef Us2) | _ -> false) | convExpW ((Pi (DP1, V1), s1), (Pi (DP2, V2), s2))  = convDecP ((DP1, s1), (DP2, s2)) && convExp ((V1, dot1 s1), (V2, dot1 s2)) | convExpW (Us1 as (Pi _, _), Us2 as (Root (Def _, _), _))  = convExpW (Us1, expandDef Us2) | convExpW (Us1 as (Root (Def _, _), _), Us2 as (Pi _, _))  = convExpW (expandDef Us1, Us2) | convExpW ((Lam (D1, U1), s1), (Lam (D2, U2), s2))  = (* G |- D1[s1] = D2[s2] by typing invariant *)  convExp ((U1, dot1 s1), (U2, dot1 s2)) | convExpW ((Lam (D1, U1), s1), (U2, s2))  = convExp ((U1, dot1 s1), (Redex (EClo (U2, shift), App (Root (BVar (1), Nil), Nil)), dot1 s2)) | convExpW ((U1, s1), (Lam (D2, U2), s2))  = convExp ((Redex (EClo (U1, shift), App (Root (BVar (1), Nil), Nil)), dot1 s1), (U2, dot1 s2)) | convExpW ((FgnExp csfe1, s1), Us2)  = (* s1 = id *)  apply csfe1 (EClo Us2) | convExpW (Us1, (FgnExp csfe2, s2))  = (* s2 = id *)  apply csfe2 (EClo Us1) | convExpW ((EVar (r1, _, _, _), s1), (EVar (r2, _, _, _), s2))  = (r1 = r2) && convSub (s1, s2) | convExpW _  = false(* Possible are:\n           L <> Pi D. V   Pi D. V <> L\n           X <> U         U <> X\n        *) (* convExp ((U1, s1), (U2, s2)) = B\n\n       Invariant:\n       as above, but (U1, s1), (U2, s2) need not to be in whnf\n       Effects: EVars may be lowered\n    *) convExp (Us1, Us2)  = convExpW (whnf Us1, whnf Us2)(* convSpine ((S1, s1), (S2, s2)) = B\n\n       Invariant:\n       If   G |- s1 : G1     G1 |- S1 : V1 > W1\n            G |- s2 : G2    G2 |- S2 : V2 > W2\n            G |- V1[s1] = V2[s2] = V : L\n            G |- W1[s1] = W2[s2] = W : L\n       then B iff G |- S1 [s1] = S2 [s2] : V > W\n\n       Effects: EVars may be lowered\n    *) convSpine ((Nil, _), (Nil, _))  = true | convSpine ((App (U1, S1), s1), (App (U2, S2), s2))  = convExp ((U1, s1), (U2, s2)) && convSpine ((S1, s1), (S2, s2)) | convSpine ((SClo (S1, s1'), s1), Ss2)  = convSpine ((S1, comp (s1', s1)), Ss2) | convSpine (Ss1, (SClo (S2, s2'), s2))  = convSpine (Ss1, (S2, comp (s2', s2))) | convSpine (_, _)  = false(* bp*) (* no others are possible due to typing invariants *) (* convSub (s1, s2) = B\n\n     Invariant:\n     If  G |- s1 : G'\n         G |- s2 : G'\n     then B iff G |- s1 = s2 : G'\n     Effects: EVars may be lowered\n    *) convSub (Shift (n), Shift (m))  = true | convSub (Shift (n), s2 as Dot _)  = convSub (Dot (Idx (n + 1), Shift (n + 1)), s2) | convSub (s1 as Dot _, Shift (m))  = convSub (s1, Dot (Idx (m + 1), Shift (m + 1))) | convSub (Dot (Ft1, s1), Dot (Ft2, s2))  = (match (Ft1, Ft2) with (Idx (n1), Idx (n2)) -> (n1 = n2) | (Exp (U1), Exp (U2)) -> convExp ((U1, id), (U2, id)) | (Block (Bidx k1), Block (Bidx k2)) -> (k1 = k2)(* other block cases don't matter -cs 2/18/03 *)  | (Exp (U1), Idx (n2)) -> convExp ((U1, id), (Root (BVar (n2), Nil), id)) | (Idx (n1), Exp (U2)) -> convExp ((Root (BVar (n1), Nil), id), (U2, id)) | (Undef, Undef) -> true | _ -> false) && convSub (s1, s2)(* convDec ((x1:V1, s1), (x2:V2, s2)) = B\n\n       Invariant:\n       If   G |- s1 : G'     G'  |- V1 : L\n            G |- s2 : G''    G'' |- V2 : L\n       then B iff G |- V1 [s1]  = V2 [s2] : L\n       Effects: EVars may be lowered\n    *) convDec ((Dec (_, V1), s1), (Dec (_, V2), s2))  = convExp ((V1, s1), (V2, s2)) | convDec ((BDec (_, (c1, s1)), t1), (BDec (_, (c2, s2)), t2))  = c1 = c2 && convSub (comp (s1, t1), comp (s2, t2))(* convDecP see convDec *) convDecP (((D1, P1), s1), ((D2, P2), s2))  = convDec ((D1, s1), (D2, s2)) let conv = convExp let convDec = convDec let convSub = convSub  (* local *)  end\n(* functor Conv *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Abstraction *) (* Author: Frank Pfenning, Carsten Schuermann *) (* Modified: Roberto Virga *) module Abstract ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Constraints : CONSTRAINTS) : ABSTRACT = struct exception Error of string module I = IntSynmodule T = Tomegamodule C = Constraintsmodule O = Order(* Intermediate Data Structure *) type EFLVar = EV of Exp | FV of string * Exp | LV of Block | PV of Prg (*     | P                            *) (*\n       We write {{K}} for the context of K, where EVars, FVars, LVars have\n       been translated to declarations and their occurrences to BVars.\n       We write {{U}}_K, {{S}}_K for the corresponding translation of an\n       expression or spine.\n\n       Just like contexts G, any K is implicitly assumed to be\n       well-formed and in dependency order.\n\n       We write  K ||- U  if all EVars and FVars in U are collected in K.\n       In particular, . ||- U means U contains no EVars or FVars.  Similarly,\n       for spines K ||- S and other syntactic categories.\n\n       Collection and abstraction raise Error if there are unresolved\n       constraints after simplification.\n    *) (* collectConstraints K = cnstrs\n       where cnstrs collects all constraints attached to EVars in K\n    *) let rec collectConstraints (Null)  = nil | collectConstraints (Decl (G, FV _))  = collectConstraints G | collectConstraints (Decl (G, EV (EVar (_, _, _, ref nil))))  = collectConstraints G | collectConstraints (Decl (G, EV (EVar (_, _, _, ref cnstrL))))  = (simplify cnstrL) @ collectConstraints G | collectConstraints (Decl (G, LV _))  = collectConstraints G (* checkConstraints (K) = ()\n       Effect: raises Constraints.Error(C) if K contains unresolved constraints\n    *) let rec checkConstraints (K)  = let constraints = collectConstraints K let _ = match constraints with nil -> () | _ -> raise (Error (constraints)) in () (* checkEmpty Cnstr = ()\n       raises Error exception if constraints Cnstr cannot be simplified\n       to the empty constraint\n    *) (*\n    fun checkEmpty (nil) = ()\n      | checkEmpty (Cnstr) =\n        (case C.simplify Cnstr\n           of nil => ()\n            | _ => raise Error "Typing ambiguous -- unresolved constraints")\n    *) (* eqEVar X Y = B\n       where B iff X and Y represent same variable\n    *) let rec eqEVar (EVar (r1, _, _, _)) (EV (EVar (r2, _, _, _)))  = (r1 = r2) | eqEVar _ _  = false (* eqFVar F Y = B\n       where B iff X and Y represent same variable\n    *) let rec eqFVar (FVar (n1, _, _)) (FV (n2, _))  = (n1 = n2) | eqFVar _ _  = false (* eqLVar L Y = B\n       where B iff X and Y represent same variable\n    *) let rec eqLVar (LVar ((r1, _, _))) (LV (LVar ((r2, _, _))))  = (r1 = r2) | eqLVar _ _  = false (* exists P K = B\n       where B iff K = K1, Y, K2  s.t. P Y  holds\n    *) let rec exists P K  = let rec exists\' (Null)  = false | exists\' (Decl (K\', Y))  = P (Y) || exists\' (K\') in exists\' K (* this should be non-strict *) (* perhaps the whole repeated traversal are now a performance\n       bottleneck in PCC applications where logic programming search\n       followed by abstraction creates certificates.  such certificates\n       are large, so the quadratic algorithm is not really acceptable.\n       possible improvement, collect, abstract, then traverse one more\n       time to determine status of all variables.\n    *) (* Wed Aug  6 16:37:57 2003 -fp *) (* !!! *) let rec or (Maybe, _)  = Maybe | or (_, Maybe)  = Maybe | or (Meta, _)  = Meta | or (_, Meta)  = Meta | or (No, No)  = No (* occursInExp (k, U) = DP,\n\n       Invariant:\n       If    U in nf\n       then  DP = No      iff k does not occur in U\n             DP = Maybe   iff k occurs in U some place not as an argument to a Skonst\n             DP = Meta    iff k occurs in U and only as arguments to Skonsts\n    *) let rec occursInExp (k, Uni _)  = No | occursInExp (k, Pi (DP, V))  = or (occursInDecP (k, DP), occursInExp (k + 1, V)) | occursInExp (k, Root (H, S))  = occursInHead (k, H, occursInSpine (k, S)) | occursInExp (k, Lam (D, V))  = or (occursInDec (k, D), occursInExp (k + 1, V)) | occursInExp (k, FgnExp csfe)  = fold csfe (fun (U, DP) -> or (DP, (occursInExp (k, normalize (U, id))))) No(* no case for Redex, EVar, EClo *) occursInHead (k, BVar (k\'), DP)  = if (k = k\') then Maybe else DP | occursInHead (k, Const _, DP)  = DP | occursInHead (k, Def _, DP)  = DP | occursInHead (k, Proj _, DP)  = DP | occursInHead (k, FgnConst _, DP)  = DP | occursInHead (k, Skonst _, No)  = No | occursInHead (k, Skonst _, Meta)  = Meta | occursInHead (k, Skonst _, Maybe)  = Meta(* no case for FVar *) occursInSpine (_, Nil)  = No | occursInSpine (k, App (U, S))  = or (occursInExp (k, U), occursInSpine (k, S))(* no case for SClo *) occursInDec (k, Dec (_, V))  = occursInExp (k, V)occursInDecP (k, (D, _))  = occursInDec (k, D) (* piDepend ((D,P), V) = Pi ((D,P\'), V)\n       where P\' = Maybe if D occurs in V, P\' = No otherwise\n    *) (* optimize to have fewer traversals? -cs *) (* pre-Twelf 1.2 code walk Fri May  8 11:17:10 1998 *) let rec piDepend (DPV as ((D, No), V))  = Pi DPV | piDepend (DPV as ((D, Meta), V))  = Pi DPV | piDepend ((D, Maybe), V)  = Pi ((D, occursInExp (1, V)), V) (* raiseType (G, V) = {{G}} V\n\n       Invariant:\n       If G |- V : L\n       then  . |- {{G}} V : L\n\n       All abstractions are potentially dependent.\n    *) let rec raiseType (Null, V)  = V | raiseType (Decl (G, D), V)  = raiseType (G, Pi ((D, Maybe), V)) (* raiseTerm (G, U) = [[G]] U\n\n       Invariant:\n       If G |- U : V\n       then  . |- [[G]] U : {{G}} V\n\n       All abstractions are potentially dependent.\n    *) let rec raiseTerm (Null, U)  = U | raiseTerm (Decl (G, D), U)  = raiseTerm (G, Lam (D, U)) (* collectExpW (G, (U, s), K) = K\'\n\n       Invariant:\n       If    G |- s : G1     G1 |- U : V      (U,s) in whnf\n       No circularities in U\n             (enforced by extended occurs-check for FVars in Unify)\n       and   K\' = K, K\'\'\n             where K\'\' contains all EVars and FVars in (U,s)\n    *) (* Possible optimization: Calculate also the normal form of the term *) let rec collectExpW (G, (Uni L, s), K)  = K | collectExpW (G, (Pi ((D, _), V), s), K)  = collectExp (Decl (G, decSub (D, s)), (V, dot1 s), collectDec (G, (D, s), K)) | collectExpW (G, (Root (F as FVar (name, V, s\'), S), s), K)  = if exists (eqFVar F) K then collectSpine (G, (S, s), K) else (* s\' = ^|G| *) collectSpine (G, (S, s), Decl (collectExp (Null, (V, id), K), FV (name, V))) | collectExpW (G, (Root (Proj (L as LVar (ref NONE, sk, (l, t)), i), S), s), K)  = collectSpine (G, (S, s), collectBlock (G, blockSub (L, s), K)) | collectExpW (G, (Root (_, S), s), K)  = collectSpine (G, (S, s), K) | collectExpW (G, (Lam (D, U), s), K)  = collectExp (Decl (G, decSub (D, s)), (U, dot1 s), collectDec (G, (D, s), K)) | collectExpW (G, (X as EVar (r, GX, V, cnstrs), s), K)  = if exists (eqEVar X) K then collectSub (G, s, K) else (* val _ = checkEmpty !cnstrs *) (* inefficient *) let V\' = raiseType (GX, V) let K\' = collectExp (Null, (V\', id), K) in collectSub (G, s, Decl (K\', EV (X))) | collectExpW (G, (FgnExp csfe, s), K)  = fold csfe (fun (U, K) -> collectExp (G, (U, s), K)) K(* No other cases can occur due to whnf invariant *) (* collectExp (G, (U, s), K) = K\'\n\n       same as collectExpW  but  (U,s) need not to be in whnf\n    *) collectExp (G, Us, K)  = collectExpW (G, whnf Us, K)(* collectSpine (G, (S, s), K) = K\'\n\n       Invariant:\n       If    G |- s : G1     G1 |- S : V > P\n       then  K\' = K, K\'\'\n       where K\'\' contains all EVars and FVars in (S, s)\n     *) collectSpine (G, (Nil, _), K)  = K | collectSpine (G, (SClo (S, s\'), s), K)  = collectSpine (G, (S, comp (s\', s)), K) | collectSpine (G, (App (U, S), s), K)  = collectSpine (G, (S, s), collectExp (G, (U, s), K))(* collectDec (G, (x:V, s), K) = K\'\n\n       Invariant:\n       If    G |- s : G1     G1 |- V : L\n       then  K\' = K, K\'\'\n       where K\'\' contains all EVars and FVars in (V, s)\n    *) collectDec (G, (Dec (_, V), s), K)  = collectExp (G, (V, s), K) | collectDec (G, (BDec (_, (_, t)), s), K)  = (* . |- t : Gsome, so do not compose with s *)  (* Sat Dec  8 13:28:15 2001 -fp *)  (* was: collectSub (I.Null, t, K) *)  collectSub (G, comp (t, s), K) | collectDec (G, (NDec _, s), K)  = K(* collectSub (G, s, K) = K\'\n\n       Invariant:\n       If    G |- s : G1\n       then  K\' = K, K\'\'\n       where K\'\' contains all EVars and FVars in s\n    *) collectSub (G, Shift _, K)  = K | collectSub (G, Dot (Idx _, s), K)  = collectSub (G, s, K) | collectSub (G, Dot (Exp (U), s), K)  = collectSub (G, s, collectExp (G, (U, id), K)) | collectSub (G, Dot (Block B, s), K)  = collectSub (G, s, collectBlock (G, B, K))(* next case should be impossible *) (*\n      | collectSub (G, I.Dot (I.Undef, s), K) =\n          collectSub (G, s, K)\n    *) (* collectBlock (G, B, K) where G |- B block *) collectBlock (G, LVar (ref (SOME B), sk, _), K)  = collectBlock (G, blockSub (B, sk), K) | collectBlock (G, L as LVar (_, sk, (l, t)), K)  = if exists (eqLVar L) K then collectSub (G, comp (t, sk), K) else Decl (collectSub (G, comp (t, sk), K), LV L) (* was: t in the two lines above, July 22, 2010, -fp -cs *) (* | collectBlock (G, I.Bidx _, K) = K *) (* should be impossible: Fronts of substitutions are never Bidx *) (* Sat Dec  8 13:30:43 2001 -fp *) (* collectCtx (G0, G, K) = (G0\', K\')\n       Invariant:\n       If G0 |- G ctx,\n       then G0\' = G0,G\n       and K\' = K, K\'\' where K\'\' contains all EVars and FVars in G\n    *) let rec collectCtx (G0, Null, K)  = (G0, K) | collectCtx (G0, Decl (G, D), K)  = let (G0\', K\') = collectCtx (G0, G, K) let K\'\' = collectDec (G0\', (D, id), K\') in (Decl (G0, D), K\'\') (* collectCtxs (G0, Gs, K) = K\'\n       Invariant: G0 |- G1,...,Gn ctx where Gs = [G1,...,Gn]\n       and K\' = K, K\'\' where K\'\' contains all EVars and FVars in G1,...,Gn\n    *) let rec collectCtxs (G0, nil, K)  = K | collectCtxs (G0, G :: Gs, K)  = let (G0\', K\') = collectCtx (G0, G, K) in collectCtxs (G0\', Gs, K\') (* abstractEVar (K, depth, X) = C\'\n\n       Invariant:\n       If   G |- X : V\n       and  |G| = depth\n       and  X occurs in K  at kth position (starting at 1)\n       then C\' = BVar (depth + k)\n       and  {{K}}, G |- C\' : V\n    *) let rec abstractEVar (Decl (K\', EV (EVar (r\', _, _, _))), depth, X as EVar (r, _, _, _))  = if r = r\' then BVar (depth + 1) else abstractEVar (K\', depth + 1, X) | abstractEVar (Decl (K\', _), depth, X)  = abstractEVar (K\', depth + 1, X) (* abstractFVar (K, depth, F) = C\'\n\n       Invariant:\n       If   G |- F : V\n       and  |G| = depth\n       and  F occurs in K  at kth position (starting at 1)\n       then C\' = BVar (depth + k)\n       and  {{K}}, G |- C\' : V\n    *) let rec abstractFVar (Decl (K\', FV (n\', _)), depth, F as FVar (n, _, _))  = if n = n\' then BVar (depth + 1) else abstractFVar (K\', depth + 1, F) | abstractFVar (Decl (K\', _), depth, F)  = abstractFVar (K\', depth + 1, F) (* abstractLVar (K, depth, L) = C\'\n\n       Invariant:\n       If   G |- L : V\n       and  |G| = depth\n       and  L occurs in K  at kth position (starting at 1)\n       then C\' = Bidx (depth + k)\n       and  {{K}}, G |- C\' : V\n    *) let rec abstractLVar (Decl (K\', LV (LVar (r\', _, _))), depth, L as LVar (r, _, _))  = if r = r\' then Bidx (depth + 1) else abstractLVar (K\', depth + 1, L) | abstractLVar (Decl (K\', _), depth, L)  = abstractLVar (K\', depth + 1, L) (* abstractExpW (K, depth, (U, s)) = U\'\n       U\' = {{U[s]}}_K\n\n       Invariant:\n       If    G |- s : G1     G1 |- U : V    (U,s) is in whnf\n       and   K is internal context in dependency order\n       and   |G| = depth\n       and   K ||- U and K ||- V\n       then  {{K}}, G |- U\' : V\'\n       and   . ||- U\' and . ||- V\'\n       and   U\' is in nf\n    *) let rec abstractExpW (K, depth, (U as Uni (L), s))  = U | abstractExpW (K, depth, (Pi ((D, P), V), s))  = piDepend ((abstractDec (K, depth, (D, s)), P), abstractExp (K, depth + 1, (V, dot1 s))) | abstractExpW (K, depth, (Root (F as FVar _, S), s))  = Root (abstractFVar (K, depth, F), abstractSpine (K, depth, (S, s))) | abstractExpW (K, depth, (Root (Proj (L as LVar _, i), S), s))  = Root (Proj (abstractLVar (K, depth, L), i), abstractSpine (K, depth, (S, s))) | abstractExpW (K, depth, (Root (H, S), s))  = Root (H, abstractSpine (K, depth, (S, s))) | abstractExpW (K, depth, (Lam (D, U), s))  = Lam (abstractDec (K, depth, (D, s)), abstractExp (K, depth + 1, (U, dot1 s))) | abstractExpW (K, depth, (X as EVar _, s))  = Root (abstractEVar (K, depth, X), abstractSub (K, depth, s, Nil)) | abstractExpW (K, depth, (FgnExp csfe, s))  = apply csfe (fun U -> abstractExp (K, depth, (U, s)))(* abstractExp (K, depth, (U, s)) = U\'\n\n       same as abstractExpW, but (U,s) need not to be in whnf\n    *) abstractExp (K, depth, Us)  = abstractExpW (K, depth, whnf Us)(* abstractSub (K, depth, s, S) = S\'      (implicit raising)\n       S\' = {{s}}_K @@ S\n\n       Invariant:\n       If   G |- s : G1\n       and  |G| = depth\n       and  K ||- s\n       then {{K}}, G |- S\' : {G1}.W > W   (for some W)\n       and  . ||- S\'\n    *) abstractSub (K, depth, Shift (k), S)  = if k < depth then abstractSub (K, depth, Dot (Idx (k + 1), Shift (k + 1)), S) else (* k = depth *) S | abstractSub (K, depth, Dot (Idx (k), s), S)  = abstractSub (K, depth, s, App (Root (BVar (k), Nil), S)) | abstractSub (K, depth, Dot (Exp (U), s), S)  = abstractSub (K, depth, s, App (abstractExp (K, depth, (U, id)), S))(* abstractSpine (K, depth, (S, s)) = S\'\n       where S\' = {{S[s]}}_K\n\n       Invariant:\n       If   G |- s : G1     G1 |- S : V > P\n       and  K ||- S\n       and  |G| = depth\n\n       then {{K}}, G |- S\' : V\' > P\'\n       and  . ||- S\'\n    *) abstractSpine (K, depth, (Nil, _))  = Nil | abstractSpine (K, depth, (SClo (S, s\'), s))  = abstractSpine (K, depth, (S, comp (s\', s))) | abstractSpine (K, depth, (App (U, S), s))  = App (abstractExp (K, depth, (U, s)), abstractSpine (K, depth, (S, s)))(* abstractDec (K, depth, (x:V, s)) = x:V\'\n       where V = {{V[s]}}_K\n\n       Invariant:\n       If   G |- s : G1     G1 |- V : L\n       and  K ||- V\n       and  |G| = depth\n\n       then {{K}}, G |- V\' : L\n       and  . ||- V\'\n    *) abstractDec (K, depth, (Dec (x, V), s))  = Dec (x, abstractExp (K, depth, (V, s))) (* abstractSOME (K, s) = s\'\n       s\' = {{s}}_K\n\n       Invariant:\n       If    . |- s : Gsome\n       and   K is internal context in dependency order\n       and   K ||- s\n       then  {{K}} |- s\' : Gsome  --- not changing domain of s\'\n\n       Update: modified for globality invariant of . |- t : Gsome\n       Sat Dec  8 13:35:55 2001 -fp\n       Above is now incorrect\n       Sun Dec  1 22:36:50 2002 -fp\n    *) let rec abstractSOME (K, Shift 0)  = (* n = 0 by invariant, check for now *)  Shift (ctxLength (K)) | abstractSOME (K, Shift (n))  = (* n > 0 *)  Shift (ctxLength (K)) | abstractSOME (K, Dot (Idx k, s))  = Dot (Idx k, abstractSOME (K, s)) | abstractSOME (K, Dot (Exp U, s))  = Dot (Exp (abstractExp (K, 0, (U, id))), abstractSOME (K, s)) | abstractSOME (K, Dot (Block (L as LVar _), s))  = Dot (Block (abstractLVar (K, 0, L)), abstractSOME (K, s)) (* I.Block (I.Bidx _) should be impossible as head of substitutions *) (* abstractCtx (K, depth, G) = (G\', depth\')\n       where G\' = {{G}}_K\n\n       Invariants:\n       If G0 |- G ctx\n       and K ||- G\n       and |G0| = depth\n       then {{K}}, G0 |- G\' ctx\n       and . ||- G\'\n       and |G0,G| = depth\'\n    *) let rec abstractCtx (K, depth, Null)  = (Null, depth) | abstractCtx (K, depth, Decl (G, D))  = let (G\', depth\') = abstractCtx (K, depth, G) let D\' = abstractDec (K, depth\', (D, id)) in (Decl (G\', D\'), depth\' + 1) (* abstractCtxlist (K, depth, [G1,...,Gn]) = [G1\',...,Gn\']\n       where Gi\' = {{Gi}}_K\n\n       Invariants:\n       if G0 |- G1,...,Gn ctx\n       and K ||- G1,...,Gn\n       and |G0| = depth\n       then {{K}}, G0 |- G1\',...,Gn\' ctx\n       and . ||- G1\',...,Gn\'\n    *) let rec abstractCtxlist (K, depth, nil)  = nil | abstractCtxlist (K, depth, G :: Gs)  = let (G\', depth\') = abstractCtx (K, depth, G) let Gs\' = abstractCtxlist (K, depth\', Gs) in G\' :: Gs\' (* dead code under new reconstruction -kw\n    (* getlevel (V) = L if G |- V : L\n\n       Invariant: G |- V : L\' for some L\'\n    *)\n    fun getLevel (I.Uni _) = I.Kind\n      | getLevel (I.Pi (_, U)) = getLevel U\n      | getLevel (I.Root _)  = I.Type\n      | getLevel (I.Redex (U, _)) = getLevel U\n      | getLevel (I.Lam (_, U)) = getLevel U\n      | getLevel (I.EClo (U,_)) = getLevel U\n\n    (* checkType (V) = () if G |- V : type\n\n       Invariant: G |- V : L\' for some L\'\n    *)\n    fun checkType V =\n        (case getLevel V\n           of I.Type => ()\n            | _ => raise Error "Typing ambiguous -- free type variable")\n    *) (* abstractKPi (K, V) = V\'\n       where V\' = {{K}} V\n\n       Invariant:\n       If   {{K}} |- V : L\n       and  . ||- V\n\n       then V\' = {{K}} V\n       and  . |- V\' : L\n       and  . ||- V\'\n    *) let rec abstractKPi (Null, V)  = V | abstractKPi (Decl (K\', EV (EVar (_, GX, VX, _))), V)  = (* enforced by reconstruction -kw\n          val _ = checkType V\'\' *) let V\' = raiseType (GX, VX) let V\'\' = abstractExp (K\', 0, (V\', id)) in abstractKPi (K\', Pi ((Dec (NONE, V\'\'), Maybe), V)) | abstractKPi (Decl (K\', FV (name, V\')), V)  = (* enforced by reconstruction -kw\n          val _ = checkType V\'\' *) let V\'\' = abstractExp (K\', 0, (V\', id)) in abstractKPi (K\', Pi ((Dec (SOME (name), V\'\'), Maybe), V)) | abstractKPi (Decl (K\', LV (LVar (r, _, (l, t)))), V)  = let t\' = abstractSOME (K\', t) in abstractKPi (K\', Pi ((BDec (NONE, (l, t\')), Maybe), V)) (* abstractKLam (K, U) = U\'\n       where U\' = [[K]] U\n\n       Invariant:\n       If   {{K}} |- U : V\n       and  . ||- U\n       and  . ||- V\n\n       then U\' = [[K]] U\n       and  . |- U\' : {{K}} V\n       and  . ||- U\'\n    *) let rec abstractKLam (Null, U)  = U | abstractKLam (Decl (K\', EV (EVar (_, GX, VX, _))), U)  = let V\' = raiseType (GX, VX) in abstractKLam (K\', Lam (Dec (NONE, abstractExp (K\', 0, (V\', id))), U)) | abstractKLam (Decl (K\', FV (name, V\')), U)  = abstractKLam (K\', Lam (Dec (SOME (name), abstractExp (K\', 0, (V\', id))), U)) let rec abstractKCtx (Null)  = Null | abstractKCtx (Decl (K\', EV (EVar (_, GX, VX, _))))  = (* enforced by reconstruction -kw\n          val _ = checkType V\'\' *) let V\' = raiseType (GX, VX) let V\'\' = abstractExp (K\', 0, (V\', id)) in Decl (abstractKCtx K\', Dec (NONE, V\'\')) | abstractKCtx (Decl (K\', FV (name, V\')))  = (* enforced by reconstruction -kw\n          val _ = checkType V\'\' *) let V\'\' = abstractExp (K\', 0, (V\', id)) in Decl (abstractKCtx K\', Dec (SOME (name), V\'\')) | abstractKCtx (Decl (K\', LV (LVar (r, _, (l, t)))))  = let t\' = abstractSOME (K\', t) in Decl (abstractKCtx K\', BDec (NONE, (l, t\'))) (* abstractDecImp V = (k\', V\')   (* rename --cs  (see above) *)\n\n       Invariant:\n       If    . |- V : L\n       and   K ||- V\n\n       then  . |- V\' : L\n       and   V\' = {{K}} V\n       and   . ||- V\'\n       and   k\' = |K|\n    *) let rec abstractDecImp V  = let K = collectExp (Null, (V, id), Null) let _ = checkConstraints (K) in (ctxLength K, abstractKPi (K, abstractExp (K, 0, (V, id)))) (* abstractDef  (U, V) = (k\', (U\', V\'))\n\n       Invariant:\n       If    . |- V : L\n       and   . |- U : V\n       and   K1 ||- V\n       and   K2 ||- U\n       and   K = K1, K2\n\n       then  . |- V\' : L\n       and   V\' = {{K}} V\n       and   . |- U\' : V\'\n       and   U\' = [[K]] U\n       and   . ||- V\'\n       and   . ||- U\'\n       and   k\' = |K|\n    *) let rec abstractDef (U, V)  = let K = collectExp (Null, (U, id), collectExp (Null, (V, id), Null)) let _ = checkConstraints K in (ctxLength K, (abstractKLam (K, abstractExp (K, 0, (U, id))), abstractKPi (K, abstractExp (K, 0, (V, id))))) let rec abstractSpineExt (S, s)  = let K = collectSpine (Null, (S, s), Null) let _ = checkConstraints (K) let G = abstractKCtx (K) let S = abstractSpine (K, 0, (S, s)) in (G, S) (* abstractCtxs [G1,...,Gn] = G0, [G1\',...,Gn\']\n       Invariants:\n       If . |- G1,...,Gn ctx\n          K ||- G1,...,Gn for some K\n       then G0 |- G1\',...,Gn\' ctx for G0 = {{K}}\n       and G1\',...,Gn\' nf\n       and . ||- G1\',...,Gn\' ctx\n    *) let rec abstractCtxs (Gs)  = let K = collectCtxs (Null, Gs, Null) let _ = checkConstraints K in (abstractKCtx (K), abstractCtxlist (K, 0, Gs)) (* closedDec (G, D) = true iff D contains no EVar or FVar *) let rec closedDec (G, (Dec (_, V), s))  = match collectExp (G, (V, s), Null) with Null -> true | _ -> false let rec closedSub (G, Shift _)  = true | closedSub (G, Dot (Idx _, s))  = closedSub (G, s) | closedSub (G, Dot (Exp U, s))  = (match collectExp (G, (U, id), Null) with Null -> closedSub (G, s) | _ -> false) let rec closedExp (G, (U, s))  = match collectExp (G, (U, id), Null) with Null -> true | _ -> false let rec closedCtx Null  = true | closedCtx (Decl (G, D))  = closedCtx G && closedDec (G, (D, id)) let rec closedFor (Psi, True)  = true | closedFor (Psi, All ((D, _), F))  = closedDEC (Psi, D) && closedFor (Decl (Psi, D), F) | closedFor (Psi, Ex ((D, _), F))  = closedDec (coerceCtx Psi, (D, id)) && closedFor (Decl (Psi, UDec D), F)closedDEC (Psi, UDec D)  = closedDec (coerceCtx Psi, (D, id)) | closedDEC (Psi, PDec (_, F, _, _))  = closedFor (Psi, F) let rec closedCTX Null  = true | closedCTX (Decl (Psi, D))  = closedCTX Psi && closedDEC (Psi, D) let rec evarsToK (nil)  = Null | evarsToK (X :: Xs)  = Decl (evarsToK (Xs), EV (X)) let rec KToEVars (Null)  = nil | KToEVars (Decl (K, EV (X)))  = X :: KToEVars (K) | KToEVars (Decl (K, _))  = KToEVars (K) (* collectEVars (G, U[s], Xs) = Xs\'\n       Invariants:\n         G |- U[s] : V\n         Xs\' extends Xs by new EVars in U[s]\n    *) let rec collectEVars (G, Us, Xs)  = KToEVars (collectExp (G, Us, evarsToK (Xs))) let rec collectEVarsSpine (G, (S, s), Xs)  = KToEVars (collectSpine (G, (S, s), evarsToK (Xs))) (* for the theorem prover:\n       collect and abstract in subsitutions  including residual lemmas\n       pending approval of Frank.\n    *) let rec collectPrg (_, P as EVar (Psi, r, F, _, _, _), K)  = Decl (K, PV P) | collectPrg (Psi, Unit, K)  = K | collectPrg (Psi, PairExp (U, P), K)  = collectPrg (Psi, P, collectExp (coerceCtx Psi, (U, id), K)) (* abstractPVar (K, depth, L) = C\'\n\n       Invariant:\n       If   G |- L : V\n       and  |G| = depth\n       and  L occurs in K  at kth position (starting at 1)\n       then C\' = Bidx (depth + k)\n       and  {{K}}, G |- C\' : V\n    *) let rec abstractPVar (Decl (K\', PV (EVar (_, r\', _, _, _, _))), depth, P as EVar (_, r, _, _, _, _))  = if r = r\' then Var (depth + 1) else abstractPVar (K\', depth + 1, P) | abstractPVar (Decl (K\', _), depth, P)  = abstractPVar (K\', depth + 1, P) let rec abstractPrg (K, depth, X as EVar _)  = abstractPVar (K, depth, X) | abstractPrg (K, depth, Unit)  = Unit | abstractPrg (K, depth, PairExp (U, P))  = PairExp (abstractExp (K, depth, (U, id)), abstractPrg (K, depth, P)) let rec collectTomegaSub (Shift 0)  = Null | collectTomegaSub (Dot (Exp U, t))  = collectExp (Null, (U, id), collectTomegaSub t) | collectTomegaSub (Dot (Block B, t))  = collectBlock (Null, B, collectTomegaSub t) | collectTomegaSub (Dot (Prg P, t))  = collectPrg (Null, P, collectTomegaSub t) let rec abstractOrder (K, depth, Arg (Us1, Us2))  = Arg ((abstractExp (K, depth, Us1), id), (abstractExp (K, depth, Us2), id)) | abstractOrder (K, depth, Simul (Os))  = Simul (map (fun O -> abstractOrder (K, depth, O)) Os) | abstractOrder (K, depth, Lex (Os))  = Lex (map (fun O -> abstractOrder (K, depth, O)) Os) let rec abstractTC (K, depth, Abs (D, TC))  = Abs (abstractDec (K, depth, (D, id)), abstractTC (K, depth, TC)) | abstractTC (K, depth, Conj (TC1, TC2))  = Conj (abstractTC (K, depth, TC1), abstractTC (K, depth, TC2)) | abstractTC (K, depth, Base (O))  = Base (abstractOrder (K, depth, O)) let rec abstractTCOpt (K, depth, NONE)  = NONE | abstractTCOpt (K, depth, SOME TC)  = SOME (abstractTC (K, depth, TC)) let rec abstractMetaDec (K, depth, UDec D)  = UDec (abstractDec (K, depth, (D, id))) | abstractMetaDec (K, depth, PDec (xx, F, TC1, TC2))  = PDec (xx, abstractFor (K, depth, F), TC1, TC2)(* TC cannot contain free FVAR\'s or EVars\'\n            --cs  Fri Apr 30 13:45:50 2004 *) (* Argument must be in normal form *) abstractFor (K, depth, True)  = True | abstractFor (K, depth, All ((MD, Q), F))  = All ((abstractMetaDec (K, depth, MD), Q), abstractFor (K, depth, F)) | abstractFor (K, depth, Ex ((D, Q), F))  = Ex ((abstractDec (K, depth, (D, id)), Q), abstractFor (K, depth, F)) | abstractFor (K, depth, And (F1, F2))  = And (abstractFor (K, depth, F1), abstractFor (K, depth, F2)) | abstractFor (K, depth, World (W, F))  = World (W, abstractFor (K, depth, F)) let rec abstractPsi (Null)  = Null | abstractPsi (Decl (K\', EV (EVar (_, GX, VX, _))))  = (* enforced by reconstruction -kw\n          val _ = checkType V\'\' *) let V\' = raiseType (GX, VX) let V\'\' = abstractExp (K\', 0, (V\', id)) in Decl (abstractPsi K\', UDec (Dec (NONE, V\'\'))) | abstractPsi (Decl (K\', FV (name, V\')))  = (* enforced by reconstruction -kw\n          val _ = checkType V\'\' *) let V\'\' = abstractExp (K\', 0, (V\', id)) in Decl (abstractPsi K\', UDec (Dec (SOME (name), V\'\'))) | abstractPsi (Decl (K\', LV (LVar (r, _, (l, t)))))  = let t\' = abstractSOME (K\', t) in Decl (abstractPsi K\', UDec (BDec (NONE, (l, t\')))) | abstractPsi (Decl (K\', PV (EVar (GX, _, FX, TC1, TC2, _))))  = (* What\'s happening with GX? *)  (* What\'s happening with TCs? *)  let F\' = abstractFor (K\', 0, forSub (FX, id)) let TC1\' = abstractTCOpt (K\', 0, TC1) let TC2\' = abstractTCOpt (K\', 0, TC2) in Decl (abstractPsi K\', PDec (NONE, F\', TC1, TC2)) let rec abstractTomegaSub t  = let K = collectTomegaSub t let t\' = abstractTomegaSub\' (K, 0, t) let Psi = abstractPsi K in (Psi, t\')abstractTomegaSub\' (K, depth, Shift 0)  = Shift depth | abstractTomegaSub\' (K, depth, Dot (Exp U, t))  = (Dot (Exp (abstractExp (K, depth, (U, id))), abstractTomegaSub\' (K, depth, t))) | abstractTomegaSub\' (K, depth, Dot (Block B, t))  = (Dot (Block (abstractLVar (K, depth, B)), abstractTomegaSub\' (K, depth, t))) | abstractTomegaSub\' (K, depth, Dot (Prg P, t))  = (Dot (Prg (abstractPrg (K, depth, P)), abstractTomegaSub\' (K, depth, t))) let rec abstractTomegaPrg P  = let K = collectPrg (Null, P, Null) let P\' = abstractPrg (K, 0, P) let Psi = abstractPsi K in (Psi, P\') (* just added to abstract over residual lemmas  -cs *) (* Tomorrow: Make collection in program values a priority *) (* Then just traverse the Tomega by abstraction to get to the types of those\n       variables. *) let raiseType = raiseType let raiseTerm = raiseTerm let piDepend = piDepend let closedDec = closedDec let closedSub = closedSub let closedExp = closedExp let abstractDecImp = abstractDecImp let abstractDef = abstractDef let abstractCtxs = abstractCtxs let abstractTomegaSub = abstractTomegaSub let abstractTomegaPrg = abstractTomegaPrg let abstractSpine = abstractSpineExt let collectEVars = collectEVars let collectEVarsSpine = collectEVarsSpine let closedCtx = closedCtx let closedCTX = closedCTX  end\n(* functor Abstract *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Approximate language for term reconstruction *) (* Author: Kevin Watkins *) module type APPROX = sig (*! structure IntSyn : INTSYN !*) type UniLevelintNextUniLVarUni option reftype ExpUniUniArrowExp * ExpConstHeadCVarExp option refUndefinedval Type : Unival Kind : Unival Hyperkind : Uni(* resets names of undetermined type/kind variables chosen for printing *) val varReset : unit -> unitval newLVar : unit -> Unival newCVar : unit -> Expval whnfUni : Uni -> Unival whnf : Exp -> Expval uniToApx : Uni -> Unival classToApx : Exp -> Exp * Unival exactToApx : Exp * Exp -> Exp * Exp * Uniexception Ambiguousval apxToUni : Uni -> Unival apxToClass : dctx * Exp * Uni * bool -> Expval apxToExact : dctx * Exp * eclo * bool -> Expexception Unify of stringval matchUni : Uni * Uni -> unitval match : Exp * Exp -> unitval makeGroundUni : Uni -> bool end', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Internal syntax for functional proof term calculus *) (* Author: Carsten Schuermann *) module Normalize ((*! structure IntSyn' : INTSYN !*) (*! structure Tomega' : TOMEGA !*) (*! sharing Tomega'.IntSyn = IntSyn' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn' !*) ) : NORMALIZE = struct (*! structure IntSyn = IntSyn' !*)  (*! structure Tomega = Tomega' !*)  exception Error of string module I = IntSynmodule T = Tomegalet rec normalizeFor (All ((D, Q), F), t)  = All ((decSub (D, t), Q), normalizeFor (F, dot1 t)) | normalizeFor (Ex ((D, Q), F), t)  = Ex ((decSub (D, coerceSub t), Q), normalizeFor (F, dot1 t)) | normalizeFor (And (F1, F2), t)  = And (normalizeFor (F1, t), normalizeFor (F2, t)) | normalizeFor (FClo (F, t1), t2)  = normalizeFor (F, comp (t1, t2)) | normalizeFor (World (W, F), t)  = World (W, normalizeFor (F, t)) | normalizeFor (True, _)  = True let rec whnfFor (Ft as (All (D, _), t))  = Ft | whnfFor (Ft as (Ex (D, F), t))  = Ft | whnfFor (Ft as (And (F1, F2), t))  = Ft | whnfFor (FClo (F, t1), t2)  = whnfFor (F, comp (t1, t2)) | whnfFor (Ft as (World (W, F), t))  = Ft | whnfFor (Ft as (True, _))  = Ft (* normalizePrg (P, t) = (P', t')\n\n       Invariant:\n       If   Psi' |- P :: F\n       and  Psi  |- t :: Psi'\n       and  P doesn't contain free EVars\n       then there exists a Psi'', F'\n       s.t. Psi'' |- F' for\n       and  Psi'' |- P' :: F'\n       and  Psi |- t' : Psi''\n       and  Psi |- F [t] == F' [t']\n       and  Psi |- P [t] == P' [t'] : F [t]\n       and  Psi |- P' [t'] :nf: F [t]\n    *) let rec normalizePrg (Var n, t)  = (* ABP -- 1/20/03 *)  (match varSub (n, t) with (Prg P) -> P | (Idx _) -> raise (Domain) | (Exp _) -> raise (Domain) | (Block _) -> raise (Domain) | (Undef) -> raise (Domain)) | normalizePrg (PairExp (U, P'), t)  = PairExp (normalize (U, coerceSub t), normalizePrg (P', t)) | normalizePrg (PairBlock (B, P'), t)  = PairBlock (blockSub (B, coerceSub t), normalizePrg (P', t)) | normalizePrg (PairPrg (P1, P2), t)  = PairPrg (normalizePrg (P1, t), normalizePrg (P2, t)) | normalizePrg (Unit, _)  = Unit | normalizePrg (EVar (_, ref (SOME P), _), t)  = PClo (P, t) | normalizePrg (P as EVar _, t)  = PClo (P, t) | normalizePrg (PClo (P, t), t')  = normalizePrg (P, comp (t, t'))normalizeSpine (Nil, t)  = Nil | normalizeSpine (AppExp (U, S), t)  = AppExp (normalize (U, coerceSub t), normalizeSpine (S, t)) | normalizeSpine (AppPrg (P, S), t)  = AppPrg (normalizePrg (P, t), normalizeSpine (S, t)) | normalizeSpine (AppBlock (B, S), t)  = AppBlock (blockSub (B, coerceSub t), normalizeSpine (S, t)) | normalizeSpine (SClo (S, t1), t2)  = normalizeSpine (S, comp (t1, t2)) (*\n    and normalizeDec (T.UDec D, t) = T.UDec (I.decSub (D, T.coerceSub t))\n(*      | normalizeDec (T.BDec (k, t1), t2) = *)\n      | normalizeDec (T.PDec (n, F), t) = T.PDec (n, (normalizeFor (F, t)))\n*) let rec normalizeSub (s as Shift n)  = s | normalizeSub (Dot (Prg P, s))  = Dot (Prg (normalizePrg (P, id)), normalizeSub s) | normalizeSub (Dot (Exp E, s))  = Dot (Exp (normalize (E, id)), normalizeSub s) | normalizeSub (Dot (Block k, s))  = Dot (Block k, normalizeSub s) | normalizeSub (Dot (Idx k, s))  = Dot (Idx k, normalizeSub s) let normalizeFor = normalizeFor let normalizePrg = normalizePrg let normalizeSub = normalizeSub let whnfFor = whnfFor  end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Matching *) (* Author: Frank Pfenning, Carsten Schuermann *) module type MATCH = sig (*! structure IntSyn : INTSYN !*) (* matching *) exception Match of stringval match : dctx * eclo * eclo -> unit(* raises Unify *) val matchW : dctx * eclo * eclo -> unit(* raises Unify *) val matchBlock : dctx * Block * Block -> unit(* raises Unify *) val matchSub : dctx * Sub * Sub -> unit(* raises Unify *) (* instance (G, Us,Us') will instantiate EVars as an effect \n     checks if Us' is an instance of Us *) val instance : dctx * eclo * eclo -> bool(* instance' (G, Us,Us') is like instance, but returns NONE for\n     success and SOME(msg) for failure *) val instance' : dctx * eclo * eclo -> string option end\n(* signature MATCH *) ", 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Abstraction *) (* Author: Frank Pfenning, Carsten Schuermann *) module type ABSTRACT = sig exception Error of stringval piDepend : (Dec * Depend) * Exp -> Expval closedDec : Dec Ctx * (Dec * Sub) -> boolval closedSub : Dec Ctx * Sub -> boolval closedExp : Dec Ctx * (Exp * Sub) -> boolval closedCtx : Dec Ctx -> boolval closedCTX : Dec Ctx -> boolval abstractDecImp : Exp -> (int * Exp)val abstractDef : (Exp * Exp) -> (int * (Exp * Exp))val abstractCtxs : Dec Ctx list -> (Dec Ctx) * Dec Ctx listval abstractTomegaSub : Sub -> (Dec Ctx * Sub)val abstractTomegaPrg : Prg -> (Dec Ctx * Prg)val abstractSpine : Spine * Sub -> (dctx * Spine)val collectEVars : dctx * eclo * Exp list -> Exp listval collectEVarsSpine : dctx * (Spine * Sub) * Exp list -> Exp listval raiseTerm : dctx * Exp -> Expval raiseType : dctx * Exp -> Exp end\n(* signature ABSTRACT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Internal Syntax *) (* Author: Frank Pfenning, Carsten Schuermann *) (* Modified: Roberto Virga *) module type INTSYN = sig type cid = int(* Constant identifier        *) type mid = int(* Structure identifier       *) type csid = int(* CS module identifier       *) type FgnExp = exn(* foreign expression representation *) exception UnexpectedFgnExp of FgnExp(* raised by a constraint solver\n\t\t\t\t\t   if passed an incorrect arg *) type FgnCnstr = exn(* foreign constraint representation *) exception UnexpectedFgnCnstr of FgnCnstr(* raised by a constraint solver\n                                           if passed an incorrect arg *) (* Contexts *) type 'aCtxNullDecl'a Ctx * 'a(*     | G, D                 *) val ctxPop : 'a Ctx -> 'a Ctxval ctxLookup : 'a Ctx * int -> 'aval ctxLength : 'a Ctx -> inttype DependNoMaybeMeta(*     | Meta                 *) (* expressions *) type UniKindType(*     | Type                 *) type ExpUniUniPi(Dec * Depend) * ExpRootHead * SpineRedexExp * SpineLamDec * ExpEVarExp option ref * Dec Ctx * Exp * Cnstr ref list refECloExp * SubAVarExp option refFgnExpcsid * FgnExpNVarint and HeadBVarintConstcidProjBlock * intSkonstcidDefcidNSDefcidFVarstring * Exp * SubFgnConstcsid * ConDec and SpineNilAppExp * SpineSCloSpine * Sub and SubShiftintDotFront * Sub and FrontIdxintExpExpAxpExpBlockBlockUndef and DecDecstring option * ExpBDecstring option * (cid * Sub)ADecstring option * intNDecstring option and BlockBidxintLVarBlock option ref * Sub * (cid * Sub)InstExp list and CnstrSolvedEqnDec Ctx * Exp * ExpFgnCnstrcsid * FgnCnstr and StatusNormalConstraintcsid * (Dec Ctx * Spine * int -> Exp option)Foreigncsid * (Spine -> Exp) and FgnUnifySucceedFgnUnifyResidual listFail and FgnUnifyResidualAssignDec Ctx * Exp * Exp * SubDelayExp * Cnstr ref and ConDecConDecstring * mid option * int * Status(* a : K : kind  or           *)  * Exp * UniConDefstring * mid option * int(* a = A : K : kind  or       *)  * Exp * Exp * Uni(* d = M : A : type           *)  * AncestorAbbrevDefstring * mid option * int(* a = A : K : kind  or       *)  * Exp * Exp * UniBlockDecstring * mid option(* %block l : SOME G1 PI G2   *)  * Dec Ctx * Dec listBlockDefstring * mid option * cid listSkoDecstring * mid option * int(* sa: K : kind  or           *)  * Exp * Uni and AncestorAnccid option * int * cid option(* head(expand(d)), height, head(expand[height](d)) *) (* NONE means expands to {x:A}B *) type StrDecStrDecstring * mid option(* Form of constant declaration *) type ConDecFormFromCSOrdinaryClause(* %clause declaration *) (* Type abbreviations *) type dctx = Dec Ctx(* G = . | G,D                *) type eclo = Exp * Sub(* Us = U[s]                  *) type bclo = Block * Sub(* Bs = B[s]                  *) type cnstr = Cnstr refexception Error of string(* raised if out of space     *) (* standard operations on foreign expressions *) module FgnExpStd : sig (* convert to internal syntax *) module ToInternal : FGN_OPN where argunit where resultExp(* apply function to subterms *) module Map : FGN_OPN where argExp -> Exp where resultExp(* apply function to subterms, for effect *) module App : FGN_OPN where argExp -> unit where resultunit(* test for equality *) module EqualTo : FGN_OPN where argExp where resultbool(* unify with another term *) module UnifyWith : FGN_OPN where argDec Ctx * Exp where resultFgnUnify(* fold a function over the subterms *) val fold : (csid * FgnExp) -> (Exp * 'a -> 'a) -> 'a -> 'a end(* standard operations on foreign constraints *) module FgnCnstrStd : sig (* convert to internal syntax *) module ToInternal : FGN_OPN where argunit where resultDec Ctx * Exp list(* awake *) module Awake : FGN_OPN where argunit where resultbool(* simplify *) module Simplify : FGN_OPN where argunit where resultbool endval conDecName : ConDec -> stringval conDecParent : ConDec -> mid optionval conDecImp : ConDec -> intval conDecStatus : ConDec -> Statusval conDecType : ConDec -> Expval conDecBlock : ConDec -> dctx * Dec listval conDecUni : ConDec -> Unival strDecName : StrDec -> stringval strDecParent : StrDec -> mid optionval sgnReset : unit -> unitval sgnSize : unit -> cid * midval sgnAdd : ConDec -> cidval sgnLookup : cid -> ConDecval sgnApp : (cid -> unit) -> unitval sgnStructAdd : StrDec -> midval sgnStructLookup : mid -> StrDecval constType : cid -> Exp(* type of c or d             *) val constDef : cid -> Exp(* definition of d            *) val constImp : cid -> intval constStatus : cid -> Statusval constUni : cid -> Unival constBlock : cid -> dctx * Dec list(* Declaration Contexts *) val ctxDec : dctx * int -> Dec(* get variable declaration   *) val blockDec : dctx * Block * int -> Dec(* Explicit substitutions *) val id : Sub(* id                         *) val shift : Sub(* ^                          *) val invShift : Sub(* ^-1                        *) val bvarSub : int * Sub -> Front(* k[s]                       *) val frontSub : Front * Sub -> Front(* H[s]                       *) val decSub : Dec * Sub -> Dec(* x:V[s]                     *) val blockSub : Block * Sub -> Block(* B[s]                       *) val comp : Sub * Sub -> Sub(* s o s'                     *) val dot1 : Sub -> Sub(* 1 . (s o ^)                *) val invDot1 : Sub -> Sub(* (^ o s) o ^-1)             *) (* EVar related functions *) val newEVar : dctx * Exp -> Exp(* creates X:G|-V, []         *) val newAVar : unit -> Exp(* creates A (bare)           *) val newTypeVar : dctx -> Exp(* creates X:G|-type, []      *) val newLVar : Sub * (cid * Sub) -> Block(* creates B:(l[^k],t)        *) (* Definition related functions *) val headOpt : Exp -> Head optionval ancestor : Exp -> Ancestorval defAncestor : cid -> Ancestor(* Type related functions *) (* Not expanding type definitions *) val targetHeadOpt : Exp -> Head option(* target type family or NONE *) val targetHead : Exp -> Head(* target type family         *) (* Expanding type definitions *) val targetFamOpt : Exp -> cid option(* target type family or NONE *) val targetFam : Exp -> cid(* target type family         *) (* Used in Flit *) val rename : cid * string -> unit end\n(* signature INTSYN *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Extensible operation on foreign matter *) (* Author: Aleksey Kliger *) module FgnOpnTable (type argtype result)FGN_OPN where argarg where resultresult = struct type csid = int type rep = exn type arg = arg type result = result type func = (rep -> arg -> result) type table = func array let rec initializeTable tbl  = exception CSfunNotInstalled of csid let maxCSid = (*Global.maxCSid*) 50 let rec unimplemented csid  = fun _ -> raise ((CSfunNotInstalled csid)) in tabulate (maxCSid + 1, unimplemented) let table : table = initializeTable () let rec install (csid, f)  = update (table, csid, f) let rec apply (csid, rep)  = sub (table, csid) rep end', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Weak Head-Normal Forms *) (* Authors: Frank Pfenning, Carsten Schuermann *) module type WHNF = sig (*! structure IntSyn : INTSYN !*) (* Patterns *) val isPatSub : Sub -> boolval makePatSub : Sub -> Sub optionval dotEta : Front * Sub -> Subexception Etaval etaContract : Exp -> int(* can raise Eta *) (* Weak head normalization *) val whnf : eclo -> ecloval expandDef : eclo -> ecloval whnfExpandDef : eclo -> ecloval etaExpandRoot : Exp -> Expval whnfEta : (eclo * eclo) -> (eclo * eclo)val lowerEVar : Exp -> Expval newLoweredEVar : dctx * eclo -> Expval newSpineVar : dctx * eclo -> Spineval spineToSub : Spine * Sub -> Sub(* Full normalization *) val normalize : eclo -> Expval normalizeDec : Dec * Sub -> Decval normalizeCtx : dctx -> dctx(* Inverting substitutions *) val invert : Sub -> Subval strengthen : Sub * dctx -> dctxval isId : Sub -> boolval cloInv : Exp * Sub -> Expval compInv : Sub * Sub -> Sub end\n(* signature WHNF *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Internal syntax for Delphin *) (* Author: Carsten Schuermann *) module type TOMEGA = sig (*! structure IntSyn : INTSYN !*) (* make abstract *) type label = inttype lemma = inttype WorldsWorldscid listtype QuantifierImplicitExplicittype TCAbsDec * TCConjTC * TCBase(Exp * Sub) * (Exp * Sub) Ordertype ForWorldWorlds * ForAll(Dec * Quantifier) * ForEx(Dec * Quantifier) * ForTrueAndFor * ForFCloFor * SubFVar(Dec Ctx * For option ref) and DecUDecDecPDecstring option * For * TC option * TC option and PrgBoxWorlds * PrgLamDec * PrgNewPrgChoosePrgPairExpExp * PrgPairBlockBlock * PrgPairPrgPrg * PrgUnitRedexPrg * SpineRecDec * PrgCaseCasesPCloPrg * SubLetDec * Prg * PrgEVarDec Ctx * Prg option ref * For * TC option * TC option * ExpConstlemmaVarintLetPairExpDec * Dec * Prg * PrgLetUnitPrg * Prg and SpineNilAppExpExp * SpineAppBlockBlock * SpineAppPrgPrg * SpineSCloSpine * Sub and SubShiftintDotFront * Sub and FrontIdxintPrgPrgExpExpBlockBlockUndef and CasesCasesDec Ctx * Sub * Prg list(* C ::= (Psi' |> s |-> P)    *) type ConDecForDecstring * ForValDecstring * Prg * For(*      | f == P              *) exception NoMatchval coerceSub : Sub -> Subval embedSub : Sub -> Subval coerceCtx : Dec Ctx -> Dec Ctxval strengthenCtx : Dec Ctx -> (Dec Ctx * Sub * Sub)val embedCtx : Dec Ctx -> Dec Ctxval weakenSub : Dec Ctx -> Subval invertSub : Sub -> Subval id : Subval shift : Subval dot1 : Sub -> Subval dotEta : Front * Sub -> Subval comp : Sub * Sub -> Subval varSub : int * Sub -> Frontval decSub : Dec * Sub -> Decval forSub : For * Sub -> Forval whnfFor : For * Sub -> For * Subval normalizePrg : Prg * Sub -> Prgval normalizeSub : Sub -> Subval derefPrg : Prg -> Prgval lemmaLookup : lemma -> ConDecval lemmaName : string -> lemmaval lemmaAdd : ConDec -> lemmaval lemmaSize : unit -> intval lemmaDef : lemma -> Prgval lemmaFor : lemma -> Forval eqWorlds : Worlds * Worlds -> boolval convFor : (For * Sub) * (For * Sub) -> boolval newEVar : Dec Ctx * For -> Prgval newEVarTC : Dec Ctx * For * TC option * TC option -> Prg(* Below are added by Yu Liao *) val ctxDec : Dec Ctx * int -> Decval revCoerceSub : Sub -> Subval revCoerceCtx : Dec Ctx -> Dec Ctx(* Added references by ABP *) val coerceFront : Front -> Frontval revCoerceFront : Front -> Frontval deblockify : Dec Ctx -> Dec Ctx * Sub(* Stuff that has to do with termination conditions *) val TCSub : TC * Sub -> TCval normalizeTC : TC -> TCval convTC : TC * TC -> boolval transformTC : Dec Ctx * For * int Order list -> TC end(* Signature TOMEGA *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* World Checking *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning *) module WorldSyn (module Global : GLOBALmodule Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn !*) module Table : TABLE where keyint(*! structure Paths : PATHS !*) module Origins : ORIGINS(*! sharing Origins.Paths = Paths !*) (*! sharing Origins.IntSyn = IntSyn !*) module Timers : TIMERS) : WORLDSYN = struct module I = IntSyn module T = Tomega module P = Paths module F = PrintFormatter exception Error of string exception Error\' of occ * string (* copied from terminates/reduces.fun *)  let rec wrapMsg (c, occ, msg)  = (match originLookup c with (fileName, NONE) -> (fileName ^ ":" ^ msg) | (fileName, SOME occDec) -> (wrapLoc\' (Loc (fileName, occToRegionDec occDec occ), linesInfoLookup (fileName), "While checking constant " ^ qidToString (constQid c) ^ ":\\n" ^ msg))) type dlist = Dec list let worldsTable : Worlds Table = new (0) let rec reset ()  = clear worldsTable let rec insert (cid, W)  = insert worldsTable (cid, W) let rec getWorlds (b)  = (match lookup worldsTable b with NONE -> raise (Error ("Family " ^ qidToString (constQid b) ^ " has no worlds declaration")) | SOME (Wb) -> Wb) (* subsumedTable\n       For each family a that is world-checked, this\n       contains the subordinate families b whose worlds\n       subsume that of a modulo subordination\n    *) let subsumedTable : unit Table = new (0) let rec subsumedReset ()  = clear subsumedTable let rec subsumedInsert (cid)  = insert subsumedTable (cid, ()) let rec subsumedLookup (cid)  = (match lookup subsumedTable cid with NONE -> false | SOME _ -> true) (* Regular world expressions R\n       Invariants:\n       If R = (D1,...,Dn)[s] then G |- s : G\' and G\' |- D1,...,Dn ctx\n       If R = r* then r = 1 or r does not accept the empty world\n    *) type Reg = Block of dctx * dlist | Seq of dlist * Sub | Star of Reg | Plus of Reg * Reg | One (*     | 1                    *) exception Success (* signals worldcheck success *) (* Format a regular world *) let rec formatReg r  = (match r with Block (G, dl) -> formatDecList (G, dl)(* Is this correct? - gaw *) (* Fixed June 3, 2009 -fp,cs *)  | Seq (dl, s) -> formatDecList\' (Null, (dl, s)) | Star r -> Hbox ([String "("; formatReg r; String ")*"]) | Plus (r1, r2) -> HVbox ([String "("; formatReg r1; String ")"; Break; String "|"; Space; String "("; formatReg r2; String ")"]) | One -> String "1") (* Format a subsumption failure judgment\n       msg: Prefix for the message\n       dl : declaration list\n       Rb : regular world\n       b : family\n       Displays:\n\n         msg for family b:\n         G |- dl </: Rb\n     *) let rec formatSubsump msg (G, dl, Rb, b)  = (*\n            F.HVbox ([F.String ((Names.qidToString (Names.constQid b)) ^ ":")])\n        *)  HVbox ([String msg; Space; String "for family"; Space; String ((qidToString (constQid b)) ^ ":"); Break; (* F.Newline (), *) (* Do not print some-variables; reenable if necessary *) (* June 3, 2009 -fp,cs *) (* Print.formatCtx(I.Null, G), F.Break, F.String "|-", F.Space, *) formatDecList (G, dl); Break; String ("</:"); Space; formatReg Rb]) (* createEVarSub G G\' = s\n\n       Invariant:\n       If   G is a context\n       and  G\' is a context\n       then G |- s : G\'\n    *) let rec createEVarSub (G, Null)  = Shift (ctxLength G) | createEVarSub (G, Decl (G\', D as Dec (_, V)))  = let s = createEVarSub (G, G\') let V\' = EClo (V, s) let X = newEVar (G, V\') in Dot (Exp X, s) (* from cover.fun *) (* collectConstraints (Xs) = constrs\n       collect all the constraints that may be attached to EVars in Xs\n\n       try simplifying away the constraints in case they are "hard"\n    *) let rec collectConstraints (nil)  = nil | collectConstraints (EVar (_, _, _, ref nil) :: Xs)  = collectConstraints Xs | collectConstraints (EVar (_, _, _, ref constrs) :: Xs)  = (* constrs <> nil *)  simplify constrs @ collectConstraints Xs (* collectEVars (G, s, Xs) = Xs\'\n       adds all uninstantiated EVars from s to Xs to obtain Xs\'\n       Invariant: s is EVar substitutions\n    *) let rec collectEVars (G, Dot (Exp X, s), Xs)  = collectEVars (G, s, collectEVars (G, (X, id), Xs)) | collectEVars (G, Shift _, Xs)  = Xs (* other cases impossible by invariants since s is EVarSubst *) (* noConstraints (G, s) = true iff there are no remaining constraints in s\n       Invariants: s is an EVar substitution X1...Xn.^k\n    *) let rec noConstraints (G, s)  = (match collectConstraints (collectEVars (G, s, nil)) with nil -> true | _ -> false) (* end from cover.fun *) (************) (* Printing *) (************) (* Declarations *) let rec formatD (G, D)  = Hbox (String "{" :: formatDec (G, D) :: String "}" :: nil) (* Declaration lists *) let rec formatDList (G, nil, t)  = nil | formatDList (G, D :: nil, t)  = let D\' = decSub (D, t) in formatD (G, D\') :: nil(* Names.decUName (G, I.decSub(D, t)) *) | formatDList (G, D :: L, t)  = (* Names.decUName (G, I.decSub (D, t)) *) let D\' = decSub (D, t) in formatD (G, D\') :: Break :: formatDList (Decl (G, D\'), L, dot1 t) (*\n    fun hypsToDList (I.Root _) = nil\n      | hypsToDList (I.Pi ((D, _), V)) =\n          D::hypsToDList V\n    *) (* Hypotheses and declaration lists *) let rec wGoalToString ((G, L), Seq (piDecs, t))  = makestring_fmt (HVbox [HVbox (formatDList (G, L, id)); Break; String "<|"; Break; HVbox (formatDList (G, piDecs, t))]) (* Declaration list *) let rec worldToString (G, Seq (piDecs, t))  = makestring_fmt (HVbox (formatDList (G, piDecs, t))) (* Hypotheses *) let rec hypsToString (G, L)  = makestring_fmt (HVbox (formatDList (G, L, id))) (* Mismatch between hypothesis and world declaration *) let rec mismatchToString (G, (V1, s1), (V2, s2))  = makestring_fmt (HVbox [formatExp (G, EClo (V1, s1)); Break; String "<>"; Break; formatExp (G, EClo (V2, s2))]) (***********) (* Tracing *) (***********) module Tracesig val clause : cid -> unitval constraintsRemain : unit -> unitval matchBlock : (dctx * dlist) * Reg -> unitval unmatched : dctx * dlist -> unitval missing : dctx * Reg -> unitval mismatch : dctx * eclo * eclo -> unitval success : unit -> unit end = struct let rec clause (c)  = print ("World checking clause " ^ qidToString (constQid c) ^ "\\n") let rec constraintsRemain ()  = if ! chatter > 7 then print ("Constraints remain after matching hypotheses against context block\\n") else () let rec matchBlock (GL, R)  = (* R = (D1,...,Dn)[t] *)  if ! chatter > 7 then print ("Matching:\\n" ^ wGoalToString (GL, R) ^ "\\n") else () let rec unmatched GL  = if ! chatter > 7 then print ("Unmatched hypotheses:\\n" ^ hypsToString GL ^ "\\n") else () let rec missing (G, R)  = (* R = (D1,...,Dn)[t] *)  if ! chatter > 7 then print ("Missing hypotheses:\\n" ^ worldToString (G, R) ^ "\\n") else () let rec mismatch (G, Vs1, Vs2)  = if ! chatter > 7 then print ("Mismatch:\\n" ^ mismatchToString (G, Vs1, Vs2) ^ "\\n") else () let rec success ()  = if ! chatter > 7 then print ("Success\\n") else () endlet rec decUName (G, D)  = Decl (G, decUName (G, D)) let rec decEName (G, D)  = Decl (G, decEName (G, D)) (**************************************) (* Matching hypotheses against worlds *) (**************************************) let rec subGoalToDList (Pi ((D, _), V))  = D :: subGoalToDList (V) | subGoalToDList (Root _)  = nil (* worldsToReg (Worlds [c1,...,cn]) = R\n       W = R, except that R is a regular expression\n       with non-empty contextblocks as leaves\n    *) let rec worldsToReg (Worlds nil)  = One | worldsToReg (Worlds cids)  = Star (worldsToReg\' cids)worldsToReg\' (cid :: nil)  = Block (constBlock cid) | worldsToReg\' (cid :: cids)  = Plus (Block (constBlock cid), worldsToReg\' cids) (* init b (G, L) raises Success iff V is empty\n       or none of the remaining declarations are relevant to b\n       otherwise fails by returning ()\n       Initial continuation for world checker\n\n       Invariant: G |- L dlist, L nf\n    *) let rec init b (_, nil)  = (success (); raise (Success)) | init b (G, L as (D1 as Dec (_, V1)) :: L2)  = if belowEq (targetFam V1, b) then (unmatched (G, L); ()) else init b (decUName (G, D1), L2) (* accR ((G, L), R, k)   raises Success\n       iff L = L1,L2 such that R accepts L1\n           and k ((G, L1), L2) succeeds\n       otherwise fails by returning ()\n       Invariant: G |- L dlist, L nf\n                  R regular world expression\n       trails at choice points to undo EVar instantiations during matching\n    *) let rec accR (GL, One, b, k)  = k GL | accR (GL as (G, L), Block (someDecs, piDecs), b, k)  = (* G |- t : someDecs *) (* if block matches, check for remaining constraints *) let t = createEVarSub (G, someDecs) let _ = matchBlock (GL, Seq (piDecs, t)) let k\' = (fun GL\' -> if noConstraints (G, t) then k GL\' else (constraintsRemain (); ())) in accR (GL, Seq (piDecs, t), b, k\') | accR ((G, L as (D as Dec (_, V1)) :: L2), L\' as Seq (B\' as Dec (_, V1\') :: L2\', t), b, k)  = if unifiable (G, (V1, id), (V1\', t)) then accR ((decUName (G, D), L2), Seq (L2\', dot1 t), b, k) else if belowEq (targetFam V1, b) then (* relevant to family b, fail *) (mismatch (G, (V1, id), (V1\', t)); ()) else (* not relevant to family b, skip in L *) accR ((decUName (G, D), L2), Seq (B\', comp (t, shift)), b, k) | accR (GL, Seq (nil, t), b, k)  = k GL | accR (GL as (G, nil), R as Seq (L\', t), b, k)  = (missing (G, R); ()) | accR (GL, Plus (r1, r2), b, k)  = (trail (fun () -> accR (GL, r1, b, k)); accR (GL, r2, b, k)) | accR (GL, Star (One), b, k)  = k GL | accR (GL, r as Star (r\'), b, k)  = (* r\' does not accept empty declaration list *)  (trail (fun () -> k GL); accR (GL, r\', b, fun GL\' -> accR (GL\', r, b, k))) (* checkSubsumedBlock (G, someDecs, piDecs, Rb, b) = ()\n       iff block SOME someDecs. PI piDecs is subsumed by Rb\n       Effect: raises Error (msg) otherwise\n\n       Invariants: Rb = reg (worlds (b))\n    *) let rec checkSubsumedBlock (G, L\', Rb, b)  = (try  with ) (* checkSubsumedWorlds (Wa, Rb, b) = ()\n       iff Wa is subsumed by Rb\n       Effect: raises Error (msg) otherwise\n\n       Invariants: Rb = reg (worlds (b))\n    *) let rec checkSubsumedWorlds (nil, Rb, b)  = () | checkSubsumedWorlds (cid :: cids, Rb, b)  = let (someDecs, piDecs) = constBlock cid in checkSubsumedBlock (ctxName (someDecs), piDecs, Rb, b); checkSubsumedWorlds (cids, Rb, b) (* checkBlocks W (G, V, occ) = ()\n       iff V = {{G\'}} a @ S and G\' satisfies worlds W\n       Effect: raises Error\'(occ, msg) otherwise\n\n       Invariants: G |- V : type, V nf\n    *) let rec checkBlocks (Worlds cids) (G, V, occ)  = try  with (******************************) (* Checking clauses and goals *) (******************************) (* checkClause (G, V, W, occ) = ()\n       iff all subgoals in V satisfy world spec W\n       Effect: raises Error\' (occ\', msg) otherwise\n\n       Invariant: G |- V : type, V nf\n       occ is occurrence of V in current clause\n     *) let rec checkClause (G, Root (a, S), W, occ)  = () | checkClause (G, Pi ((D as Dec (_, V1), Maybe), V2), W, occ)  = (checkClause (decEName (G, D), V2, W, body occ); checkGoal (G, V1, W, label occ)) | checkClause (G, Pi ((D as Dec (_, V1), No), V2), W, occ)  = (checkBlocks W (G, V1, label occ); checkClause (decEName (G, D), V2, W, body occ); checkGoal (G, V1, W, label occ))(* checkGoal (G, V, W, occ) = ()\n        iff all (embedded) subgoals in V satisfy world spec W\n        Effect: raises Error\' (occ\', msg) otherwise\n\n        Invariant: G |- V : type, V nf\n     *) (* Question: should dependent Pi\'s really be checked recursively? *) (* Thu Mar 29 09:38:20 2001 -fp *) checkGoal (G, Root (a, S), W, occ)  = () | checkGoal (G, Pi ((D as Dec (_, V1), _), V2), W, occ)  = (checkGoal (decUName (G, D), V2, W, body occ); checkClause (G, V1, W, label occ)) (* worldcheck W a = ()\n       iff all subgoals in all clauses defining a satisfy world spec W\n       Effect: raises Error(msg) otherwise, where msg includes location\n    *) let rec worldcheck W a  = (* initialize table of subsumed families *) let _ = if ! chatter > 3 then print ("World checking family " ^ qidToString (constQid a) ^ ":\\n") else () let _ = subsumedReset () let rec checkAll nil  = () | checkAll (Const (c) :: clist)  = (if ! chatter = 4 then print (qidToString (constQid c) ^ " ") else (); if ! chatter > 4 then clause c else (); try  with ; checkAll clist) | checkAll (Def (d) :: clist)  = (if ! chatter = 4 then print (qidToString (constQid d) ^ " ") else (); if ! chatter > 4 then clause d else (); try  with ; checkAll clist) let _ = checkAll (lookup a) let _ = if ! chatter = 4 then print "\\n" else () in () (**************************) (* Checking Subordination *) (**************************) (*\n       At present, worlds declarations must respect the\n       current subordination relation in order to guarantee\n       soundness.\n    *) let rec ctxAppend (G, Null)  = G | ctxAppend (G, Decl (G\', D))  = Decl (ctxAppend (G, G\'), D) (* checkSubordBlock (G, G\', L\') = ()\n       Effect: raises Error(msg) if subordination is not respected\n               in context block SOME G\'. PI L\'\n       Invariants: G |- SOME G\'. PI L\' block\n    *) let rec checkSubordBlock (G, G\', L)  = checkSubordBlock\' (ctxAppend (G, G\'), L)checkSubordBlock\' (G, (D as Dec (_, V)) :: L\')  = (respectsN (G, V); (* is V nf?  Assume here: yes! *) checkSubordBlock\' (Decl (G, D), L\')) | checkSubordBlock\' (G, nil)  = () (* conDecBlock (condec) = (Gsome, Lpi)\n       if condec is a block declaration\n       raise Error (msg) otherwise\n    *) let rec conDecBlock (BlockDec (_, _, Gsome, Lpi))  = (Gsome, Lpi) | conDecBlock condec  = raise (Error ("Identifier " ^ conDecName condec ^ " is not a block label")) (* constBlock cid = (someDecs, piDecs)\n       if cid is defined as a context block\n       Effect: raise Error (msg) otherwise\n    *) let rec constBlock (cid)  = conDecBlock (sgnLookup cid) (* checkSubordWorlds (W) = ()\n       Effect: raises Error(msg) if subordination is not respected\n               in some context block in W\n    *) let rec checkSubordWorlds (nil)  = () | checkSubordWorlds (cid :: cids)  = let (someDecs, piDecs) = constBlock cid in checkSubordBlock (Null, someDecs, piDecs); checkSubordWorlds cids (* install (a, W) = ()\n       install worlds declaration W for family a\n\n       Effect: raises Error if W does not respect subordination\n    *) let rec install (a, W as Worlds (cids))  = (try  with ; insert (a, W)) let rec uninstall a  = match lookup worldsTable a with NONE -> false | SOME _ -> (delete worldsTable a; true) (* lookup (a) = SOME W if worlds declared for a, NONE otherwise *) let rec lookup a  = getWorlds a (* ctxToList G = L\n\n       Invariant:\n       G = L  (G is left associative, L is right associative)\n    *) let rec ctxToList (Gin)  = let rec ctxToList\' (Null, G)  = G | ctxToList\' (Decl (G, D), G\')  = ctxToList\' (G, D :: G\') in ctxToList\' (Gin, nil) (* isSubsumed (W, b) = ()\n       holds if the worlds associated with b are subsumed by W\n       Effect: raises Error\'(occ, msg) otherwise\n\n       Invariants: G |- V : type, V nf\n    *) let rec isSubsumed (Worlds cids) b  = let Wb = getWorlds b let Rb = worldsToReg Wb in if subsumedLookup b then () else (checkSubsumedWorlds (cids, Rb, b); subsumedInsert (b)) let reset = reset let install = install let lookup = lookup let uninstall = uninstall let worldcheck = worldcheck let ctxToList = ctxToList let isSubsumed = isSubsumed let getWorlds = getWorlds  end\n(* functor WorldSyn *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Worldification and World-checking *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning *) module Worldify (module Global : GLOBAL(*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) (*! sharing Tomega.IntSyn = IntSyn !*) module WorldSyn : WORLDSYN(*! sharing WorldSyn.IntSyn = IntSyn !*) (*! sharing WorldSyn.Tomega = Tomega !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn !*) module CSManager : CS_MANAGER(*! sharing CSManager.IntSyn = IntSyn !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn !*) module Table : TABLE where keyintmodule MemoTable : TABLE where keyint * intmodule IntSet : INTSET(*! structure Paths : PATHS !*) module Origins : ORIGINS(*! sharing Origins.Paths = Paths !*) (*! sharing Origins.IntSyn = IntSyn !*) ) : WORLDIFY = struct (*! structure IntSyn = IntSyn !*)  (*! structure Tomega = Tomega !*)  module I = IntSyn module T = Tomega module P = Paths module F = PrintFormatter exception Error of string exception Error\' of occ * string (* copied from terminates/reduces.fun *)  let rec wrapMsg (c, occ, msg)  = (match originLookup c with (fileName, NONE) -> (fileName ^ ":" ^ msg) | (fileName, SOME occDec) -> (wrapLoc\' (Loc (fileName, occToRegionDec occDec occ), linesInfoLookup (fileName), "Constant " ^ qidToString (constQid c) ^ ":" ^ msg))) let rec wrapMsgBlock (c, occ, msg)  = (match originLookup c with (fileName, NONE) -> (fileName ^ ":" ^ msg) | (fileName, SOME occDec) -> (wrapLoc\' (Loc (fileName, occToRegionDec occDec occ), linesInfoLookup (fileName), "Block " ^ qidToString (constQid c) ^ ":" ^ msg))) type dlist = Dec list module W = WorldSyn(* Regular world expressions R\n       Invariants:\n       If R = (D1,...,Dn)[s] then G |- s : G\' and G\' |- D1,...,Dn ctx\n       If R = r* then r = 1 or r does not accept the empty world\n    *) type Reg = Block of cid * (dctx * dlist) | Seq of int * dlist * Sub | Star of Reg | Plus of Reg * Reg | One (*     | 1                    *) exception Success of Exp (* signals worldcheck success *) (* createEVarSub G G\' = s\n\n       Invariant:\n       If   G is a context\n       and  G\' is a context\n       then G |- s : G\'\n    *) let rec createEVarSub (G, Null)  = Shift (ctxLength G) | createEVarSub (G, Decl (G\', D as Dec (_, V)))  = let s = createEVarSub (G, G\') let V\' = EClo (V, s) let X = newEVar (G, V\') in Dot (Exp X, s) (* from cover.fun *) (* collectConstraints (Xs) = constrs\n       collect all the constraints that may be attached to EVars in Xs\n\n       try simplifying away the constraints in case they are "hard"\n    *) let rec collectConstraints (nil)  = nil | collectConstraints (EVar (_, _, _, ref nil) :: Xs)  = collectConstraints Xs | collectConstraints (EVar (_, _, _, ref constrs) :: Xs)  = (* constrs <> nil *)  simplify constrs @ collectConstraints Xs (* collectEVars (G, s, Xs) = Xs\'\n       adds all uninstantiated EVars from s to Xs to obtain Xs\'\n       Invariant: s is EVar substitutions\n    *) let rec collectEVars (G, Dot (Exp X, s), Xs)  = collectEVars (G, s, collectEVars (G, (X, id), Xs)) | collectEVars (G, Shift _, Xs)  = Xs (* other cases impossible by invariants since s is EVarSubst *) (* noConstraints (G, s) = true iff there are no remaining constraints in s\n       Invariants: s is an EVar substitution X1...Xn.^k\n    *) let rec noConstraints (G, s)  = (match collectConstraints (collectEVars (G, s, nil)) with nil -> true | _ -> false) (************) (* Printing *) (************) (* Declarations *) let rec formatD (G, D)  = Hbox (String "{" :: formatDec (G, D) :: String "}" :: nil) (* Declaration lists *) let rec formatDList (G, nil, t)  = nil | formatDList (G, D :: nil, t)  = let D\' = decSub (D, t) in formatD (G, D\') :: nil(* Names.decUName (G, I.decSub(D, t)) *) | formatDList (G, D :: L, t)  = (* Names.decUName (G, I.decSub (D, t)) *) let D\' = decSub (D, t) in formatD (G, D\') :: Break :: formatDList (Decl (G, D\'), L, dot1 t) (*\n    fun hypsToDList (I.Root _) = nil\n      | hypsToDList (I.Pi ((D, _), V)) =\n          D::hypsToDList V\n    *) (* Hypotheses and declaration lists *) let rec wGoalToString ((G, L), Seq (_, piDecs, t))  = makestring_fmt (HVbox [HVbox (formatDList (G, L, id)); Break; String "<|"; Break; HVbox (formatDList (G, piDecs, t))]) (* Declaration list *) let rec worldToString (G, Seq (_, piDecs, t))  = makestring_fmt (HVbox (formatDList (G, piDecs, t))) (* Hypotheses *) let rec hypsToString (G, L)  = makestring_fmt (HVbox (formatDList (G, L, id))) (* Mismatch between hypothesis and world declaration *) let rec mismatchToString (G, (V1, s1), (V2, s2))  = makestring_fmt (HVbox [formatExp (G, EClo (V1, s1)); Break; String "<>"; Break; formatExp (G, EClo (V2, s2))]) (***********) (* Tracing *) (***********) module Tracesig val clause : cid -> unitval constraintsRemain : unit -> unitval matchBlock : (dctx * dlist) * Reg -> unitval unmatched : dctx * dlist -> unitval missing : dctx * Reg -> unitval mismatch : dctx * eclo * eclo -> unitval success : unit -> unit end = struct let rec clause (c)  = print ("World checking clause " ^ qidToString (constQid c) ^ "\\n") let rec constraintsRemain ()  = if ! chatter > 7 then print ("Constraints remain after matching hypotheses against context block\\n") else () let rec matchBlock (GL, R)  = (* R = (D1,...,Dn)[t] *)  if ! chatter > 7 then print ("Matching:\\n" ^ wGoalToString (GL, R) ^ "\\n") else () let rec unmatched GL  = if ! chatter > 7 then print ("Unmatched hypotheses:\\n" ^ hypsToString GL ^ "\\n") else () let rec missing (G, R)  = (* R = (D1,...,Dn)[t] *)  if ! chatter > 7 then print ("Missing hypotheses:\\n" ^ worldToString (G, R) ^ "\\n") else () let rec mismatch (G, Vs1, Vs2)  = if ! chatter > 7 then print ("Mismatch:\\n" ^ mismatchToString (G, Vs1, Vs2) ^ "\\n") else () let rec success ()  = if ! chatter > 7 then print ("Success\\n") else () endlet rec decUName (G, D)  = Decl (G, decUName (G, D)) let rec decEName (G, D)  = Decl (G, decEName (G, D)) (* ******************** *) (* World Subsumption    *) (* The STATIC part      *) (* ******************** *) (* equivList (G, (t, L), L\')\n\n        Invariant:\n        If  . |- t : G\n        and G |- L block\n        then  B = true if  L [t] unifies with L\'\n              B = false otherwise\n     *) let rec equivList (G, (_, nil), nil)  = true | equivList (G, (t, Dec (_, V1) :: L1), Dec (_, V2) :: L2)  = (try  with ) | equivList _  = false (* equivBlock ((G, L), L\') = B\n\n        Invariant:\n        If   G |- L block\n        then B = true if there exists a substitution . |- t : G, s.t. L[t] = L\'\n             B = false otherwise\n     *) let rec equivBlock ((G, L), L\')  = let t = createEVarSub (Null, G) in equivList (Null, (t, L), L\') (* equivBlocks W L = B\n\n        Invariant:\n        Let W be a world and L be a block.\n        B = true if exists L\' in W such that L = L\'\n        B = false otherwise\n     *) let rec equivBlocks W1 nil  = true | equivBlocks nil L\'  = false | equivBlocks (b :: W1) L\'  = equivBlock (constBlock b, L\') || equivBlocks W1 L\' (* strengthen a (t, L) = L\'\n\n        Invariant:\n        If   a is a type family,\n        and  . |- t : G\n        and  G |- L block\n        then . |- L\' block\n        where V \\in L and not V < a then V \\in L\'\n        and   V \\in L and V < a then not V \\in L\'\n     *) let rec strengthen a (t, nil)  = nil | strengthen a (t, (D as Dec (_, V)) :: L)  = if below (targetFam V, a) then (decSub (D, t) :: strengthen a (dot1 t, L)) else strengthen a (Dot (Undef, t), L) (* subsumedBlock a W1 (G, L) = ()\n\n        Invariant:\n        If   a is a type family\n        and  W1 the world in which the callee is defined\n        and (G, L) one block in the world of the caller\n        Then the function returns () if (G, L) is subsumed by W1\n        otherwise Error is raised\n     *) let rec subsumedBlock a W1 (G, L)  = (* G |- t : someDecs *) let t = createEVarSub (Null, G) let L\' = strengthen a (t, L) in if equivBlocks W1 L\' then () else raise (Error "Static world subsumption failed") (* subsumedBlocks a W1 W2 = ()\n\n        Invariant:\n        Let W1 be the world in which the callee is defined\n        Let W2 be the world in which the caller is defined\n        Then the function returns () if W2 is subsumed by W1\n        otherwise Error is raised\n     *) let rec subsumedBlocks a W1 nil  = () | subsumedBlocks a W1 (b :: W2)  = (subsumedBlock a W1 (constBlock b); subsumedBlocks a W1 W2) (* subsumedWorld a W1 W2 = ()\n\n        Invariant:\n        Let W1 be the world in which the callee is defined\n        Let W2 be the world in which the caller is defined\n        Then the function returns () if W2 is subsumed by W1\n        otherwise Error is raised\n     *) let rec subsumedWorld a (Worlds W1) (Worlds W2)  = subsumedBlocks a W1 W2 (* ******************** *) (* World Subsumption    *) (* The DYNAMIC part     *) (* ******************** *) (* eqCtx (G1, G2) = B\n\n        Invariant:\n        Let  G1, G2 constexts of declarations (as the occur in the some part\n                    of a block).\n        B = true if G1 and G2 are equal (modulo renaming of variables)\n        B = false otherwise\n     *) let rec eqCtx (Null, Null)  = true | eqCtx (Decl (G1, D1), Decl (G2, D2))  = eqCtx (G1, G2) && convDec ((D1, id), (D2, id)) | eqCtx _  = false (* eqList (L1, L2) = B\n\n        Invariant:\n        Let  L1, L2 lists of declarations (as the occur in a block).\n        B = true if L1 and L2 are equal (modulo renaming of variables)\n        B = false otherwise\n     *) let rec eqList (nil, nil)  = true | eqList (D1 :: L1, D2 :: L2)  = convDec ((D1, id), (D2, id)) && eqList (L1, L2) | eqList _  = false (* eqBlock (b1, b2) = B\n\n        Invariant:\n        Let  b1, b2 blocks.\n        B = true if b1 and b2 are equal (modulo renaming of variables)\n        B = false otherwise\n     *) let rec eqBlock (b1, b2)  = let (G1, L1) = constBlock b1 let (G2, L2) = constBlock b2 in eqCtx (G1, G2) && eqList (L1, L2) (* sumbsumedCtx (G, W) = ()\n\n        Invariant:\n        Let G be a context of blocks\n        and W a world\n        Then the function returns () if every block in G\n        is listed in W\n        otherwise Error is raised\n     *) let rec subsumedCtx (Null, W)  = () | subsumedCtx (Decl (G, BDec (_, (b, _))), W as Worlds Bs)  = (if exists (fun b\' -> eqBlock (b, b\')) Bs then () else raise (Error "Dynamic world subsumption failed"); subsumedCtx (G, W)) | subsumedCtx (Decl (G, _), W as Worlds Bs)  = subsumedCtx (G, W) (******************************) (* Checking clauses and goals *) (******************************) (* checkGoal W (G, V, occ) = ()\n        iff all (embedded) subgoals in V satisfy world spec W\n        Effect: raises Error\' (occ\', msg) otherwise\n\n        Invariant: G |- V : type, V nf\n     *) let rec checkGoal W (G, Root (Const a, S), occ)  = let W\' = getWorlds a in (subsumedWorld a W\' W; subsumedCtx (G, W)) | checkGoal W (G, Pi ((D, _), V2), occ)  = checkGoal W (decUName (G, D), V2, body occ) (* checkClause (G, V, W, occ) = ()\n       iff all subgoals in V satisfy world spec W\n       Effect: raises Error\' (occ\', msg) otherwise\n\n       Invariant: G |- V : type, V nf\n       occ is occurrence of V in current clause\n     *) let rec checkClause W (G, Root (a, S), occ)  = () | checkClause W (G, Pi ((D as Dec (_, V1), Maybe), V2), occ)  = checkClause W (decEName (G, D), V2, body occ) | checkClause W (G, Pi ((D as Dec (_, V1), No), V2), occ)  = (checkClause W (decEName (G, D), V2, body occ); checkGoal W (G, V1, label occ)) let rec checkConDec W (ConDec (s, m, k, status, V, L))  = checkClause W (Null, V, top) (**************************************) (* Matching hypotheses against worlds *) (**************************************) let rec subGoalToDList (Pi ((D, _), V))  = D :: subGoalToDList (V) | subGoalToDList (Root _)  = nil (* worldsToReg (Worlds [c1,...,cn]) = R\n       W = R, except that R is a regular expression\n       with non-empty contextblocks as leaves\n    *) let rec worldsToReg (Worlds nil)  = One | worldsToReg (Worlds cids)  = Star (worldsToReg\' cids)worldsToReg\' (cid :: nil)  = Block (cid, constBlock cid) | worldsToReg\' (cid :: cids)  = Plus (Block (cid, constBlock cid), worldsToReg\' cids) (* init b (G, L) raises Success iff V is empty\n       or none of the remaining declarations are relevant to b\n       otherwise fails by returning ()\n       Initial continuation for world checker\n\n       Invariant: G |- L dlist, L nf\n    *) let rec init (_, Vs as (Root _, s))  = (success (); raise (Success (normalize Vs))) | init (G, (V as Pi ((D1 as Dec (_, V1), _), V2), s))  = (unmatched (G, subGoalToDList (normalize (V, s))); ()) (* accR ((G, (V, s)), R, k)   raises Success\n       iff V[s] = {L1}{L2} P  such that R accepts L1\n           and k ((G, L1), L2) succeeds\n       otherwise fails by returning ()\n       Invariant: G |- (V s) type, L nf\n                  R regular world expression\n       trails at choice points to undo EVar instantiations during matching\n    *) let rec accR (GVs, One, k)  = k GVs | accR (GVs as (G, (V, s)), Block (c, (someDecs, piDecs)), k)  = (* G |- t : someDecs *) let t = createEVarSub (G, someDecs) let _ = matchBlock ((G, subGoalToDList (normalize (V, s))), Seq (1, piDecs, t)) let k\' = (fun (G\', Vs\') -> if noConstraints (G, t) then k (G\', Vs\') else (constraintsRemain (); ())) in try  with | accR ((G, (V as Pi ((D as Dec (_, V1), _), V2), s)), L\' as Seq (j, Dec (_, V1\') :: L2\', t), k)  = if unifiable (G, (V1, s), (V1\', t)) then accR ((G, (V2, Dot (Exp (Root (Proj (Bidx 1, j), Nil)), s))), Seq (j + 1, L2\', Dot (Exp (Root (Proj (Bidx 1, j), Nil)), t)), k) else (mismatch (G, (V1, id), (V1\', t)); ()) | accR (GVs, Seq (_, nil, t), k)  = k GVs | accR (GVs as (G, (Root _, s)), R as Seq (_, L\', t), k)  = (missing (G, R); ()) | accR (GVs, Plus (r1, r2), k)  = (trail (fun () -> accR (GVs, r1, k)); accR (GVs, r2, k)) | accR (GVs, Star (One), k)  = k GVs | accR (GVs, r as Star (r\'), k)  = (* r\' does not accept empty declaration list *)  (trail (fun () -> k GVs); accR (GVs, r\', fun GVs\' -> accR (GVs\', r, k))) (******************************) (* Worldifying clauses and goals *) (******************************) (* worldifyGoal (G, V, W, occ) = ()\n       iff V = {{G\'}} a @ S and G\' satisfies worlds W\n       Effect: raises Error\' (occ\', msg) otherwise\n\n       Invariant: G |- V : type, V nf\n    *) let rec worldifyGoal (G, V, W as Worlds cids, occ)  = try  with (* worldifyClause (G, V, W, occ) = ()\n       iff all subgoals in V satisfy world spec W\n       Effect: raises Error\' (occ\', msg) otherwise\n\n       Invariant: G |- V : type, V nf\n       occ is occurrence of V in current clause\n     *) let rec worldifyClause (G, V as Root (a, S), W, occ)  = V | worldifyClause (G, Pi ((D as Dec (x, V1), Maybe), V2), W, occ)  = (*         val W1 = worldifyGoal (G, V1, W, P.label occ) *) let _ = print "{" let W2 = worldifyClause (decEName (G, D), V2, W, body occ) let _ = print "}" in Pi ((Dec (x, V1, (* W1*) ), Maybe), W2) | worldifyClause (G, Pi ((D as Dec (x, V1), No), V2), W, occ)  = let W1 = worldifyGoal (G, V1, W, label occ) let W2 = worldifyClause (decEName (G, D), V2, W, body occ) in Pi ((Dec (x, W1), No), W2) (* worldcheck W a = ()\n       iff all subgoals in all clauses defining a satisfy world spec W\n       Effect: raises Error(msg) otherwise, where msg includes location\n     *) let rec worldifyConDec W (c, ConDec (s, m, k, status, V, L))  = (if ! chatter = 4 then print (qidToString (constQid c) ^ " ") else (); if ! chatter > 4 then clause c else (); try  with ) (* by invariant, other cases cannot apply *) let rec worldifyBlock (G, nil)  = () | worldifyBlock (G, (D as (Dec (_, V))) :: L)  = let a = targetFam V let W\' = getWorlds a in (checkClause W\' (G, worldifyClause (Null, V, W\', top), top); worldifyBlock (decUName (G, D), L)) let rec worldifyBlocks nil  = () | worldifyBlocks (b :: Bs)  = let _ = worldifyBlocks Bs let (Gsome, Lblock) = constBlock b let _ = print "|" in try  with let rec worldifyWorld (Worlds Bs)  = worldifyBlocks Bs let rec worldify a  = let W = getWorlds a let _ = print "[?" let W\' = worldifyWorld W let _ = print ";" let _ = if ! chatter > 3 then print ("World checking family " ^ qidToString (constQid a) ^ ":\\n") else () let condecs = map (fun (Const c) -> try  with ) (lookup a) let _ = map (fun condec -> (print "#"; checkConDec W condec)) condecs let _ = print "]" let _ = if ! chatter = 4 then print "\\n" else () in condecs let worldify = worldify let worldifyGoal = fun (G, V) -> worldifyGoal (G, V, getWorlds (targetFam V), top)  end\n(* functor Worldify *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module MemoTable = HashTable()
module WorldSyn = WorldSyn(struct module Global = Global module Whnf = Whnf module Names = Names module Unify = UnifyTrail module Abstract = Abstract module Constraints = Constraints module Index = Index module Subordinate = Subordinate module Print = Print module Table = IntRedBlackTree module Paths = Paths module Origins = Origins module Timers = Timers end)
module Worldify = Worldify(struct module Global = Global module WorldSyn = WorldSyn module Whnf = Whnf module Names = Names module Unify = UnifyTrail module Abstract = Abstract module Constraints = Constraints module Index = Index module CSManager = CSManager module Subordinate = Subordinate module Print = Print module Table = IntRedBlackTree module MemoTable = MemoTable module IntSet = IntSet module Origins = Origins end)

('Error parsing code:', '(* World Checking *) (* Author: Carsten Schuermann *) module type WORLDSYN = sig exception Error of stringval reset : unit -> unitval install : cid * Worlds -> unitval lookup : cid -> Worlds(* raises Error if undeclared *) val uninstall : cid -> bool(* true if declared *) val worldcheck : Worlds -> cid -> unitval ctxToList : Dec Ctx -> Dec listval isSubsumed : Worlds -> cid -> unitval getWorlds : cid -> Worlds end\n(* signature WORLDSYN *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Worldify *) (* Author: Carsten Schuermann *) module type WORLDIFY = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) exception Error of stringval worldify : cid -> ConDec listval worldifyGoal : Dec Ctx * Exp -> Exp(*  val check : Tomega.Worlds -> IntSyn.cid list -> unit\n  val closure : Tomega.Worlds -> Tomega.Worlds *)  end\n(* signature WORLDIFY *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Compatibility shim from Basis-current to Poly/ML Basis as of 4.1.3 *) (* Author: Christopher Richards *) module CompatCOMPAT = Compat(struct module Array = CompatArray97 module Vector = CompatVector97 module Path = OSPath module Substring = CompatSubstring97 module TextIO = CompatTextIO97 module Timer = Timer end)

('Error parsing code:', "(* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type COMPAT_VECTOR = sig val appi : (int * 'a -> unit) -> 'a vector -> unitval mapi : (int * 'a -> 'b) -> 'a vector -> 'b vector end\n", 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: (* Compatibility shim from Basis-current TextIO to Basis-97 TextIO *) (* Author: Christopher Richards *) module CompatTextIO97COMPAT_TEXT_IO = struct let rec inputLine instream  = let line = inputLine instream in match line with "" -> NONE | str -> SOME str end

('Error parsing code:', "(* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type VECTOR_SLICE = sig type 'asliceval slice : 'a vector * int * int option -> 'a sliceval appi : (int * 'a -> unit) -> 'a slice -> unitval mapi : (int * 'a -> 'b) -> 'a slice -> 'b vector end\n", 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: (* Default implementation of timeLimit *) (* Ignores time limit *) module TimeLimitTIME_LIMIT = struct exception TimeOut let timeLimit = fun t -> fun f -> fun x -> f (x) end

Code parsed successfully: (* Compatibility shim from Basis-current Socket to Basis-97 Socket *) (* Author: Christopher Richards *) module CompatSocketIO97COMPAT_SOCKET_IO = struct let rec sendVec (sock, vs)  = sendVec (sock, {buf = vs; i = 0; sz = NONE}) end
Code parsed successfully: (* Compatibility shim from Basis-current Socket to Basis-97 Socket *) (* Author: Christopher Richards *) module CompatSocketIOCOMPAT_SOCKET_IO = struct let rec sendVec (sock, vs)  = sendVec (sock, full vs) end
('Error parsing code:', "(* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type ARRAY_SLICE = sig type 'asliceval slice : 'a array * int * int option -> 'a sliceval appi : (int * 'a -> unit) -> 'a slice -> unit end\n", 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: (* Compatibility shim from Basis-current OS.Path to Basis-97 OS.Path *) (* Author: Christopher Richards *) module CompatPath97COMPAT_PATH = struct let rec mkAbsolute {path = path; relativeTo = relativeTo}  = mkAbsolute (path, relativeTo) end

('Error parsing code:', '(* Compatibility shim from Basis-02 Word8VectorSlice to Basis-97 Word8Vector *) (* Author: Christopher Richards *) module type MONO_VECTOR_SLICE = sig type slicetype vectorval slice : vector * int * int option -> sliceval vector : slice -> vectorval full : vector -> slice end\nmodule Word8VectorSliceMONO_VECTOR_SLICE where vectorvector = struct type vector = vector type slice = vector * int * int option let rec slice s  = s let vector = extract let rec full v  = (v, 0, NONE) end\nmodule type COMPAT_WORD8_VECTOR_SLICE = sig val full : vector -> slice end\nmodule Word8VectorSlice97COMPAT_WORD8_VECTOR_SLICE = struct type vector = vector type slice = slice let full = full end\n', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type COMPAT_TIMER = sig val checkCPUTimer : cpu_timer -> {usr: time; sys: time}val checkGCTime : cpu_timer -> time end\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Compatibility shim from Basis-02 Word8ArraySlice to Basis-97 Word8Array *) (* Author: Christopher Richards *) module Word8ArraySliceMONO_ARRAY_SLICE where arrayarray where vectorvector = struct type array = array type slice = array * int * int option type vector = vector let rec slice s  = s let vector = extract end\n', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* SML/NJ implementation of timeLimit *) (* Other implementations possible via ALRM signal? *) module TimeLimitTIME_LIMIT = struct exception TimeOut let rec timeLimit NONE f x  = f x | timeLimit (SOME t) f x  = let _ = print ("TIME LIMIT : " ^ toString t ^ "sec \\n") let setitimer = setIntTimer let rec timerOn ()  = ignore (setitimer (SOME t)) let rec timerOff ()  = ignore (setitimer NONE) let escapeCont = callcc (fun k -> (callcc (fun k\' -> (throw k k\')); timerOff (); raise (TimeOut))) let rec handler _  = escapeCont in setHandler (sigALRM, HANDLER handler); timerOn (); (try  with ) before timerOff () end\n(* TimeLimit *) ', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Compatibility shim from Basis-current Substring to Basis-97 Substring *) (* Author: Christopher Richards *) module CompatSubstring97COMPAT_SUBSTRING = struct let full = all end

Code parsed successfully: (* Compatibility shim from Basis-current Array to Basis-97 Array *) (* Author: Christopher Richards *) module CompatArray97COMPAT_ARRAY = struct let rec appi f arr  = appi f (arr, 0, NONE) end

('Error parsing code:', "(* Compatibility shim from Basis-current ArraySlice to Basis-97 Array *) (* Author: Christopher Richards *) module ArraySliceARRAY_SLICE = struct type 'aslice = 'a array * int * int option let rec slice s  = s let appi = appi end\n", 'Error matches:', [(0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: (* Compatibility shim from Basis-current to Basis-97 *) (* Author: Christopher Richards *) module CompatCOMPAT = Compat(struct module Array = CompatArray97 module Vector = CompatVector97 module Path = CompatPath97 module Substring = CompatSubstring97 module TextIO = CompatTextIO97 module Timer = CompatTimer97 module SocketIO = CompatSocketIO97 end)

Code parsed successfully: (* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type COMPAT_ARRAY = sig val appi : (int * 'a -> unit) -> 'a array -> unit end

Code parsed successfully: (* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type COMPAT_SUBSTRING = sig val full : string -> substring end

Code parsed successfully: (* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) 
('Error parsing code:', "module type TIME_LIMIT = sig exception TimeOutval timeLimit : time option -> ('a -> 'b) -> 'a -> 'b end\n", 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Compatibility shim from Basis-current to itself *) (* Author: Christopher Richards *) module CompatCOMPAT = Compat(struct module Array = Array module Vector = Vector module Path = OSPath module Substring = Substring module TextIO = TextIO module Timer = Timer module SocketIO = CompatSocketIO end)

('Error parsing code:', '(* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type MONO_ARRAY_SLICE = sig type arraytype slicetype vectorval slice : array * int * int option -> sliceval vector : slice -> vector end\n', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type COMPAT = sig val inputLine97 : instream -> stringmodule Array : COMPAT_ARRAYmodule Vector : COMPAT_VECTORmodule OS : sig module Path : COMPAT_PATH endmodule Substring : COMPAT_SUBSTRINGmodule TextIO : COMPAT_TEXT_IOmodule Timer : COMPAT_TIMERmodule SocketIO : COMPAT_SOCKET_IO end\n', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Compatibility shim from Basis-current to itself *) (* Author: Christopher Richards *) module CompatCOMPAT = Compat(struct module Array = Array module Vector = Vector module Path = OSPath module Substring = Substring module TextIO = TextIO module Timer = Timer module SocketIO = CompatSocketIO end)

('Error parsing code:', "(* Compatibility shim from Basis-current VectorSlice to Basis-97 Vector *) (* Author: Christopher Richards *) module VectorSliceVECTOR_SLICE = struct type 'aslice = 'a vector * int * int option let rec slice s  = s let appi = appi let mapi = mapi end\n", 'Error matches:', [(0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: (* Compatibility shim from Basis-current Timer to Basis-97 Timer *) (* Author: Christopher Richards *) module CompatTimer97COMPAT_TIMER = struct let rec checkCPUTimer timer  = let {usr = usr; sys = sys; gc = gc} = checkCPUTimer timer in {usr = usr; sys = sys} let rec checkGCTime timer  = let {gc = gc; _} = checkCPUTimer timer in gc end

Code parsed successfully: (* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type COMPAT_SOCKET_IO = sig val sendVec : 'aactive stream sock * vector -> int end

Code parsed successfully: (* Compatibility shim from Basis-current Vector to Basis-97 Vector *) (* Author: Christopher Richards *) module CompatVector97COMPAT_VECTOR = struct let rec appi f vec  = appi f (vec, 0, NONE) let rec mapi f vec  = mapi f (vec, 0, NONE) end

('Error parsing code:', '(* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type COMPAT_PATH = sig val mkAbsolute : {path: string; relativeTo: string} -> string end\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Compatibility shim to cope with Standard Basis version skew *) (* Author: Christopher Richards *) module type COMPAT_TEXT_IO = sig val inputLine : instream -> string option end

('Error parsing code:', 'module Convert = struct open Syntax exception Convert of string exception NotFound of string let sigma : string list ref = ref [] let sigmat : class list ref = ref [] let sigmap : bool list ref = ref [] let rec clear ()  = in sigma := []; sigmat := []; sigmap := [] let rec findn [] (v : string)  = raise (NotFound v) | findn (v :: tl) v\'  = if v = v\' then 0 else 1 + findn tl v\' let rec findid ctx v  = (try  with ) let rec modeconvert mMINUS  = MINUS | modeconvert mPLUS  = PLUS | modeconvert mOMIT  = OMIT let rec modesofclass (kclass (Type))  = [] | modesofclass (kclass (KPi (m, _, k)))  = m :: modesofclass (kclass k) | modesofclass (tclass (TRoot _))  = [] | modesofclass (tclass (TPi (m, _, a)))  = m :: modesofclass (tclass a) (* given a context and an external expression, returns the internal \'spine form\' as a 4-tuple\n   (h, mopt, p, s)\n   where h is the head (Var n or Const n)\n         mopt is a list of modes for the arguments (MINUS, PLUS, OMIT)\n         p is true iff the head is a synthesizing constant or a variable\n         s is the list of arugments\n*)  let rec spine_form (G, Id s)  = (match findid G s with Var n -> (Var n, NONE, true, []) | Const n -> (Const n, SOME (modesofclass (nth (! sigmat, n))), nth (! sigmap, n), [])) | spine_form (G, App (t, u))  = let (h, mopt, p, s) = spine_form (G, t) in (h, mopt, p, s @ [u]) | spine_form (G, Lam _)  = raise (Convert "illegal redex") | spine_form (G, _)  = raise (Convert "level mismatch") (* similar to spine_form for a type family applied to a list of arguments *)  let rec type_spine_form (G, Id s)  = let n = findn (! sigma) s in (n, modesofclass (nth (! sigmat, n)), []) | type_spine_form (G, App (t, u))  = let (n, m, s) = type_spine_form (G, t) in (n, m, s @ [u]) | type_spine_form (G, _)  = raise (Convert "level mismatch") let rec safezip (l1, l2)  = if length l1 = length l2 then zip (l1, l2) else raise (Convert "wrong spine length") (* given a context and an external expression and a mode, return a spine element or raise an exception*)  let rec eltconvert G (t, MINUS)  = Elt (convert (G, t)) | eltconvert G (Ascribe (t, a), PLUS)  = Ascribe (nconvert (G, t), typeconvert (G, a)) | eltconvert G (t, PLUS)  = AElt (aconvert (G, t)) | eltconvert G (Omit, OMIT)  = Omit | eltconvert G (_, OMIT)  = raise (Convert "found term expected to be omitted")(* given a context and an external expression, return an atomic term or raise an exception*) aconvert (G, t)  = (match convert (G, t) with ATerm t\' -> t\' | NTerm _ -> raise (Convert "required atomic, found normal"))(* given a context and an external expression, return a normal term or raise an exception*) nconvert (G, t)  = (match convert (G, t) with NTerm t\' -> t\' | ATerm _ -> raise (Convert "required normal, found atomic"))(* given a context and an external expression, return a term or raise an exception *) convert (G, Lam ((v, _), t))  = NTerm (Lam (convert (v :: G, t))) | convert (G, t)  = let (h, mopt, p, s) = spine_form (G, t) let s\' = map (eltconvert G) (match mopt with NONE -> map (fun elt -> (elt, MINUS)) s | SOME m -> (safezip (s, m))) in if p then ATerm (ARoot (h, s\')) else NTerm (NRoot (h, s\'))(* given a context and an external expression, return a type or raise an exception *) typeconvert (G, Pi (m, (v, SOME t), t\'))  = let ct = typeconvert (G, t) let ct\' = typeconvert (v :: G, t\') in TPi (modeconvert m, ct, ct\') | typeconvert (G, Pi (m, (_, NONE), _))  = raise (Convert "can\'t handle implicit pi") | typeconvert (G, Arrow (t, t\'))  = let ct = typeconvert (G, t) let ct\' = typeconvert ("" :: G, t\') in TPi (MINUS, ct, ct\') | typeconvert (G, PlusArrow (t, t\'))  = let ct = typeconvert (G, t) let ct\' = typeconvert ("" :: G, t\') in TPi (PLUS, ct, ct\') | typeconvert (G, a)  = let (n, m, s) = type_spine_form (G, a) let s\' = map (eltconvert G) (safezip (s, m)) in TRoot (n, s\')(* given a context and an external expression, return a kind or raise an exception *) kindconvert (G, Pi (m, (v, SOME t), t\'))  = let ct = typeconvert (G, t) let ct\' = kindconvert (v :: G, t\') in KPi (modeconvert m, ct, ct\') | kindconvert (G, Arrow (t, t\'))  = let ct = typeconvert (G, t) let ct\' = kindconvert ("" :: G, t\') in KPi (MINUS, ct, ct\') | kindconvert (G, PlusArrow (t, t\'))  = let ct = typeconvert (G, t) let ct\' = kindconvert ("" :: G, t\') in KPi (PLUS, ct, ct\') | kindconvert (G, Pi (m, (_, NONE), _))  = raise (Convert "can\'t handle implicit pi") | kindconvert (G, Type)  = Type | kindconvert _  = raise (Convert "level mismatch") end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module Strict = struct open Syntax exception EtaContract (* val eta_contract_var : spineelt -> int\n      if the spine element given is an ordinary spine element (i.e. an Elt)\n      that is an eta-expansion of the deBruijn index n,\n      then returns n. Otherwise raises EtaContract.\n    *)  let rec eta_contract_var (Elt t)  = eta_contract_var' 0 t | eta_contract_var _  = raise (EtaContract)eta_contract_var' n (ATerm (ARoot (Var n', s)))  = let s' = map eta_contract_var s let rec decreasing_list 0 []  = true | decreasing_list n (h :: tl)  = (n - 1 = h) && decreasing_list (n - 1) tl | decreasing_list _ _  = false in if decreasing_list n s' then n' - n else raise (EtaContract) | eta_contract_var' n (NTerm (Lam t))  = eta_contract_var' (n + 1) t | eta_contract_var' _ _  = raise (EtaContract) let rec pattern_spine' (D, [])  = true | pattern_spine' (D, n :: s)  = let rec isn x  = (x = n) let rec hasn s  = exists isn s in hasn D && not (hasn s) && pattern_spine' (D, s) let rec pattern_spine (D, s)  = (try  with ) let rec spine_occ n (D, nil)  = false | spine_occ n (D, (Elt t) :: s)  = term_occ n (D, t) || spine_occ n (D, s) | spine_occ n (D, (AElt t) :: s)  = aterm_occ n (D, t) || spine_occ n (D, s) | spine_occ n (D, (Ascribe (t, a)) :: s)  = nterm_occ n (D, t) || type_occ n (D, a) || spine_occ n (D, s) | spine_occ n (D, Omit :: s)  = false(* Omit invalidates all strict\n\t\t\t\t\t    occurrences to the right *) term_occ n (D, NTerm t)  = nterm_occ n (D, t) | term_occ n (D, ATerm t)  = aterm_occ n (D, t)(* PERF: suspend these context shifts, do them at the end *) nterm_occ n (D, Lam t)  = term_occ (n + 1) (0 :: (map (fun x -> x + 1) D), t) | nterm_occ n (D, NRoot (h, s))  = root_occ n (D, h, s)aterm_occ n (D, ARoot (h, s))  = root_occ n (D, h, s) | aterm_occ n (D, ERoot _)  = falseroot_occ n (D, Var n', s)  = if n = n'(* n = n' precludes n in D, right? *)  then pattern_spine (D, s) else exists (fun x -> x = n') D && spine_occ n (D, s) | root_occ n (D, Const n', s)  = spine_occ n (D, s)type_occ n (D, TRoot (_, s))  = spine_occ n (D, s) | type_occ n (D, TPi (_, a, b))  = type_occ n (D, a) || (* PERF: suspend these context shifts, do them at the end *)  || type_occ (n + 1) (0 :: (map (fun x -> x + 1) D), b) (* toplevel strictness judgments *)  let rec check_strict_type' n p (TRoot (n', s))  = if p then false else spine_occ n ([], s) | check_strict_type' n p (TPi (PLUS, a, b))  = type_occ n ([], a) || check_strict_type' (n + 1) p b | check_strict_type' n p (TPi (_, a, b))  = check_strict_type' (n + 1) p b let rec check_strict_kind' n Type  = false | check_strict_kind' n (KPi (PLUS, a, k))  = type_occ n ([], a) || check_strict_kind' (n + 1) k | check_strict_kind' n (KPi (_, a, k))  = check_strict_kind' (n + 1) k (* p is whether we should imagine we are checking a c+ (rather than c-) constant *)  let rec check_strict_type p b  = check_strict_type' 0 p b let rec check_strict_kind k  = check_strict_kind' 0 k end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Syntax = struct exception Syntax of string exception MissingVar type mode = MINUS | PLUS | OMIT type nterm = Lam of term | NRoot of head * spine and aterm = ARoot of head * spine | ERoot of evar * subst and head = Var of int | Const of int and tp = TRoot of int * spine | TPi of mode * tp * tp and knd = Type | KPi of mode * tp * knd and spinelt = Elt of term | AElt of aterm | Ascribe of nterm * tp | Omit and term = NTerm of nterm | ATerm of aterm and subst = Id | Shift of int * int | ZeroDotShift of subst | TermDot of term * tp * subst | EVarDot of evar * subst list * subst | VarOptDot of int option * subst | Compose of subst list (* special hack for type functions used only in tp_reduce *)  type tpfn = tpfnType of tp | tpfnLam of tpfn let rec EVarDotId ev  = EVarDot (ev, [], Id) (*\ttype decl = string * Parse.term *)  (*\ttype ctx = decl list *)  type class = kclass of knd | tclass of tp (* termof elm\n        returns the term part of the spine element elm *)  let rec termof (Elt t)  = t | termof (AElt t)  = ATerm t | termof (Ascribe (t, a))  = NTerm t | termof (Omit)  = raise (Syntax "invariant violated: arguments to variables cannot be omitted") type subst_result = srVar of int | srTerm of term * tp | srEVar of evar * subst list exception Debugs of subst_result * spinelt list let rec curryfoldr sf sl x  = foldr (fun (s, x\') -> sf s x\') x sl (* lower (a, sp)\n           supposing we have an evar of (potentially higher-order)\n           type a, applied to a spine sp, return the lowered type of\n           that evar and a substitution to apply it to *)  (* XXX: so we\'re not carrying out substitutions over the type\n                as we recurse down: is this right? I think it is. *)  let rec lower acc (a as TRoot _, [])  = (a, acc) | lower acc (TPi (m, a, b), elt :: sp)  = let newacc = TermDot (termof elt, subst_tp acc a, acc) in lower newacc (b, sp) | lower _ _  = raise (Syntax "type mismatch in lowering")(* substNth (subst, n)\n        returns the result of applying the substitution subst\n        to the index n *) substNth (Id, n)  = srVar n | substNth (ZeroDotShift s, n)  = if n = 0 then srVar 0 else (match substNth (s, n - 1) with srTerm (t, a) -> srTerm (shift t, shift_tp 0 a) | srVar n -> srVar (n + 1) | srEVar (ev, sl) -> srEVar (ev, (Shift (0, 1)) :: sl)) | substNth (TermDot (m, a, s), n)  = if n = 0 then srTerm (m, a) else substNth (s, n - 1) | substNth (EVarDot (ev, sl, s), n)  = if n = 0 then srEVar (ev, sl) else substNth (s, n - 1) | substNth (Shift (n, m), n\')  = if n\' >= n then srVar (n\' + m) else srVar n\' | substNth (VarOptDot (no, s), n\')  = if n\' = 0 then match no with SOME n -> srVar n | NONE -> raise (MissingVar) else substNth (s, n\' - 1) | substNth (Compose [], n)  = srVar n | substNth (Compose (h :: tl), n)  = subst_sr h (substNth (Compose tl, n))subst_sr s (srTerm (t, a))  = srTerm (subst_term s t, subst_tp s a) | subst_sr s (srVar n)  = substNth (s, n) | subst_sr s (srEVar (ev, sl))  = srEVar (ev, s :: sl)(* the type of the evar is understood to be\n\t\t\t\t\t\t\t        affected by the subst as well *) subst_spinelt Id x  = x | subst_spinelt s (Elt t)  = Elt (subst_term s t) | subst_spinelt s (AElt t)  = subst_aterm_plus s t | subst_spinelt s (Ascribe (t, a))  = Ascribe (subst_nterm s t, subst_tp s a) | subst_spinelt s Omit  = Omitsubst_spine s sp  = map (subst_spinelt s) spsubst_term s (ATerm t)  = subst_aterm s t | subst_term s (NTerm t)  = NTerm (subst_nterm s t)subst_nterm s (Lam t)  = Lam (subst_term (ZeroDotShift s) t) | subst_nterm s (NRoot (h, sp))  = NRoot (h, subst_spine s sp)subst_aterm s (ARoot (Const n, sp))  = ATerm (ARoot (Const n, subst_spine s sp)) | subst_aterm s (ARoot (Var n, sp))  = reduce (substNth (s, n), subst_spine s sp) | subst_aterm s (ERoot (ev as (ref NONE, _), sl))  = ATerm (ERoot (ev, subst_compose (s, sl))) | subst_aterm s (t as ERoot _)  = subst_term s (eroot_elim t)subst_aterm_plus s (ARoot (Const n, sp))  = AElt (ARoot (Const n, subst_spine s sp)) | subst_aterm_plus s (ARoot (Var n, sp))  = reduce_plus (substNth (s, n), subst_spine s sp) | subst_aterm_plus s (ERoot (ev as (ref NONE, _), sl))  = AElt (ERoot (ev, subst_compose (s, sl))) | subst_aterm_plus s (t as ERoot _)  = subst_spinelt s (eroot_elim_plus t)(* XXX right??? *) subst_tp s (TRoot (h, sp))  = TRoot (h, subst_spine s sp) | subst_tp s (TPi (m, b, b\'))  = TPi (m, subst_tp s b, subst_tp (ZeroDotShift s) b\')subst_knd s (Type)  = Type | subst_knd s (KPi (m, b, k))  = KPi (m, subst_tp s b, subst_knd (ZeroDotShift s) k)reduce (srVar n, sp)  = ATerm (ARoot (Var n, sp)) | reduce (srTerm (NTerm (Lam n), TPi (_, a, b)), h :: sp)  = let s = TermDot (termof h, a, Id) let n\' = subst_term s n let b\' = subst_tp s b in reduce (srTerm (n\', b\'), sp) | reduce (srTerm (t as NTerm (NRoot (h, sp)), a), [])  = t | reduce (srTerm (t as ATerm (ARoot (h, sp)), a), [])  = t | reduce (srTerm (ATerm (t as ERoot ((ref (SOME _), _), _)), a), [])  = reduce (srTerm (eroot_elim t, a), []) | reduce (srTerm (ATerm (t as ERoot ((ref NONE, _), _)), a), [])  = ATerm t | reduce (srEVar ((x, a), sl), sp)  = let (a\', subst) = lower (substs_comp sl) (a, sp) in ATerm (ERoot ((x, a\'), subst)) | reduce _  = raise (Syntax "simplified-type mismatch in reduction")reduce_plus (srVar n, sp)  = AElt (ARoot (Var n, sp)) | reduce_plus (srTerm (NTerm (Lam n), TPi (_, a, b)), h :: sp)  = let s = TermDot (termof h, a, Id) let n\' = subst_term s n let b\' = subst_tp s b in reduce_plus (srTerm (n\', b\'), sp) | reduce_plus (srTerm (NTerm (t as NRoot (h, sp)), a), [])  = Ascribe (t, a) | reduce_plus (srTerm (ATerm (t as ARoot (h, sp)), a), [])  = AElt t | reduce_plus (srTerm (ATerm (t as ERoot ((ref (SOME _), _), _)), a), [])  = reduce_plus (srTerm (eroot_elim t, a), []) | reduce_plus (srTerm (ATerm (t as ERoot ((ref NONE, _), _)), a), [])  = AElt t | reduce_plus (srEVar ((x, a), sl), sp)  = let (a\', subst) = lower (substs_comp sl) (a, sp) in AElt (ERoot ((x, a\'), subst)) | reduce_plus (x, y)  = (raise (Debugs (x, y)); raise (Syntax "simplified-type mismatch in reduction"))(* val tp_reduce : tp * knd * spine -> tp\n           tp_reduce (a, k, sp) computes the result\n           of reducing (.\\ .\\ ... .\\ a) . sp\n           assuming (.\\ .\\ ... .\\ a) : k\n           (where the number of lambdas is the number\n            of pis found in k) \n        *) tp_reduce (a, k, sp)  = let rec subst_tpfn s (tpfnLam a)  = tpfnLam (subst_tpfn (ZeroDotShift s) a) | subst_tpfn s (tpfnType a)  = tpfnType (subst_tp s a) let rec tp_reduce\' (tpfnLam (a), KPi (_, b, k), h :: sp)  = let s = TermDot (termof h, b, Id) let a\' = subst_tpfn s a let k\' = subst_knd s k in tp_reduce\' (a\', k\', sp) | tp_reduce\' (tpfnType a, Type, [])  = a | tp_reduce\' _  = raise (Syntax "simplified-kind mismatch in type reduction") let rec wrap (a, KPi (_, b, k))  = tpfnLam (wrap (a, k)) | wrap (a, Type)  = tpfnType a let aw = wrap (a, k) in tp_reduce\' (aw, k, sp)(* elt_eroot_elim e\n        returns a spine element equal to e but makes sure that it\'s not\n        an instatiated ERoot. That is, it carries out the instantiation\n        and substitutions involved therein. *) (* probably not the right way to do things considering I have Compose *) substs_term x  = curryfoldr subst_term xsubsts_tp x  = curryfoldr subst_tp xeroot_elim (ERoot ((ref (SOME t), a), subst))  = subst_term subst t | eroot_elim x  = ATerm xeroot_elim_plus (ERoot ((ref (SOME t), a), subst))  = let newt = subst_term subst t in match newt with ATerm t -> AElt t | NTerm t -> Ascribe (t, subst_tp subst a) | eroot_elim_plus x  = AElt x(* YYY: the following doesn\'t avoid incurring polyequal. why??? \n\n\tdatatype foo =\n\t        Foo of baralias\n\t     and bar =\n\t        Bar of foo \n\twithtype baralias = bar;\n\n        - fn (x : foo, y : foo) => x = y;\n        stdIn:376.28 Warning: calling polyEqual\n        val it = fn : foo * foo -> bool\n\n        doesn\'t really matter anymore to this code, (it used to)\n        but I\'m still curious.\n        *) (* compute [s]n . (s o s\') *) composeNth (s, n, s\')  = let s\'\' = subst_compose (s, s\') in match substNth (s, n) with srVar n\' -> VarOptDot (SOME n\', s\'\') | srTerm (t, a) -> TermDot (t, a, s\'\') | srEVar (ev, sl) -> EVarDot (ev, sl, s\'\')(* val subst_compose : subst * subst -> subst *) subst_compose (Id, s)  = s | subst_compose (s, Id)  = s | subst_compose (s, Shift (_, 0))  = s | subst_compose (Shift (_, 0), s)  = s | subst_compose (s, Compose [])  = s | subst_compose (Compose [], s)  = s | subst_compose (s, Compose (h :: tl))  = subst_compose (subst_compose (s, h), Compose tl) | subst_compose (Compose (h :: tl), s)  = subst_compose (h, subst_compose (Compose tl, s)) | subst_compose (ZeroDotShift s, Shift (0, m))  = subst_compose (subst_compose (Shift (0, 1), s), Shift (0, m - 1)) | subst_compose (TermDot (_, _, s), Shift (0, m))  = subst_compose (s, Shift (0, m - 1)) | subst_compose (EVarDot (_, _, s), Shift (0, m))  = subst_compose (s, Shift (0, m - 1)) | subst_compose (VarOptDot (_, s), Shift (0, m))  = subst_compose (s, Shift (0, m - 1)) | subst_compose (Shift (0, m), Shift (0, m\'))  = Shift (0, m + m\') | subst_compose (Shift (n, m\'), t as Shift (0, m))  = subst_compose (ZeroDotShift (Shift (n - 1, m\')), t) | subst_compose (s, Shift (n, m))  = subst_compose (s, ZeroDotShift (Shift (n - 1, m))) | subst_compose (s, ZeroDotShift s\')  = composeNth (s, 0, subst_compose (Shift (0, 1), s\')) | subst_compose (s, TermDot (t, a, s\'))  = TermDot (subst_term s t, subst_tp s a, subst_compose (s, s\')) | subst_compose (s, EVarDot (ev, sl, s\'))  = EVarDot (ev, s :: sl, subst_compose (s, s\')) | subst_compose (s, VarOptDot (no, s\'))  = (match no with NONE -> VarOptDot (NONE, subst_compose (s, s\')) | SOME n -> composeNth (s, n, s\'))(* shift_[...] n t\n        shifts all deBruijn indices in the object t by one, as long\n        as they refer to positions in the current context \n        greater than or equal to n. *) shift t  = shift_term 0 tshift_nterm n (Lam t)  = Lam (shift_term (n + 1) t) | shift_nterm n (NRoot (h, sp))  = NRoot (h, shift_spine n sp)shift_aterm n (ARoot (Const n\', sp))  = ARoot (Const n\', shift_spine n sp) | shift_aterm n (ERoot (ev, sl))  = ERoot (ev, subst_compose (Shift (n, 1), sl)) | shift_aterm n (ARoot (Var n\', sp))  = let sp\' = shift_spine n sp in if n\' >= n then ARoot (Var (n\' + 1), sp\') else ARoot (Var n\', sp\')shift_spinelt n (Elt (ATerm t))  = Elt (ATerm (shift_aterm n t)) | shift_spinelt n (Elt (NTerm t))  = Elt (NTerm (shift_nterm n t)) | shift_spinelt n (AElt t)  = AElt (shift_aterm n t) | shift_spinelt n (Ascribe (t, a))  = Ascribe (shift_nterm n t, shift_tp n a) | shift_spinelt n Omit  = Omitshift_spine n  = map (shift_spinelt n)shift_tp n (TPi (m, a, b))  = TPi (m, shift_tp n a, shift_tp (n + 1) b) | shift_tp n (TRoot (h, sp))  = TRoot (h, shift_spine n sp)shift_term n (NTerm t)  = NTerm (shift_nterm n t) | shift_term n (ATerm t)  = ATerm (shift_aterm n t)substs_comp sl  = foldr subst_compose Id sl let rec elt_eroot_elim (AElt (t))  = eroot_elim_plus t | elt_eroot_elim (Elt (ATerm (t)))  = Elt (eroot_elim t) | elt_eroot_elim x  = x let rec ntm_eroot_elim (Lam (ATerm (t)))  = Lam (eroot_elim t) | ntm_eroot_elim x  = x let rec ctxLookup (G, n)  = subst_tp (Shift (0, n + 1)) (nth (G, n)) let rec typeOf (tclass a)  = a let rec kindOf (kclass k)  = k let sum = foldl + 0 let rec size_term (NTerm (Lam t))  = 1 + (size_term t) | size_term (NTerm (NRoot (_, s)))  = 1 + size_spine s | size_term (ATerm (ARoot (_, s)))  = 1 + size_spine s | size_term (ATerm (ERoot _))  = 1size_spine s  = sum (map size_spinelt s)size_spinelt (Elt t)  = size_term t | size_spinelt (AElt t)  = size_term (ATerm t) | size_spinelt (Ascribe (t, a))  = size_term (NTerm t) + size_tp a | size_spinelt Omit  = 0size_tp (TRoot (_, s))  = 1 + size_spine s | size_tp (TPi (_, a, b))  = 1 + size_tp a + size_tp bsize_knd (Type)  = 1 | size_knd (KPi (_, a, b))  = 1 + size_tp a + size_knd b (* convert a kind to a context of all the pi-bound variables in it *)  let rec explodeKind (Type)  = [] | explodeKind (KPi (_, a, k))  = (explodeKind k) @ [a] end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Parse = struct open Parsing open Tok      let ` = literal type mode = mMINUS | mPLUS | mOMIT type term = Id of string | App of term * term | Lam of (string * term option) * term | Type | Pi of mode * (string * term option) * term | Arrow of term * term | PlusArrow of term * term | Ascribe of term * term | Omit let rec PiMinus ((s, to), t)  = Pi (mMINUS, (s, to), t) let rec PiPlus ((s, to), t)  = Pi (mPLUS, (s, to), t) let rec PiOmit ((s, to), t)  = Pi (mOMIT, (s, to), t) let rec modeToString mMINUS  = "" | modeToString mPLUS  = "+ " | modeToString mOMIT  = "* " let rec termToString (Id s)  = s | termToString (App (t, u))  = "(" ^ (termToString t) ^ " " ^ (termToString u) ^ ")" | termToString (Lam (vd, t))  = "[" ^ (vardecToString vd) ^ "] " ^ (termToString t) | termToString (Pi (m, vd, t))  = "{" ^ (modeToString m) ^ (vardecToString vd) ^ "} " ^ (termToString t) | termToString (Type)  = "type" | termToString (Arrow (t, u))  = "(" ^ (termToString t) ^ " -> " ^ (termToString u) ^ ")" | termToString (PlusArrow (t, u))  = "(" ^ (termToString t) ^ " +> " ^ (termToString u) ^ ")" | termToString (Ascribe (t, u))  = "(" ^ (termToString t) ^ " : " ^ (termToString u) ^ ")" | termToString (Omit)  = "*"vardecToString (v, SOME t)  = v ^ ":" ^ (termToString t) | vardecToString (v, NONE)  = v let id = maybe (fun (ID s) -> SOME s | _ -> NONE) let rec swap (x, y)  = (y, x) let rec vardec ()  = id << ` COLON && ($ term wth SOME) || id wth (fun s -> (s, NONE))term ()  = parsefixityadj (alt [id wth (Atm o Id); ` LPAREN >> $ term << ` RPAREN wth Atm; ` LPAREN >> $ term << ` COLON && $ term << ` RPAREN wth (Atm o Ascribe); ` LBRACKET >> $ vardec << ` RBRACKET && $ term wth (Atm o Lam); ` LBRACE >> ` STAR >> $ vardec << ` RBRACE && $ term wth (Atm o PiOmit); ` LBRACE >> ` PLUS >> $ vardec << ` RBRACE && $ term wth (Atm o PiPlus); ` LBRACE >> $ vardec << ` RBRACE && $ term wth (Atm o PiMinus); ` TYPE return (Atm Type); ` ARROW return Opr (Infix (Right, 5, Arrow)); ` PLUSARROW return Opr (Infix (Right, 5, PlusArrow)); ` BACKARROW return Opr (Infix (Left, 5, Arrow o swap)); ` STAR return (Atm Omit)]) Left App let condec = (opt (` MINUS) wth (not o isSome)) && id << ` COLON && $ term << ` DOT let rec parseof x  = toList (transform ($ term) (transform (!! tok) (markstream (stostream (x ^ "\\n%."))))) end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Reductio = struct exception Unimp exception Error of string exception Matching of string exception NonPattern exception NotFound of string open Syntax type kinding_constraint = CON_LF | CON_PLUS | CON_MINUS (* All Pis, and [Pi] can use strict occs in later args\n                              and in return type. *)  (* left side is open, (with respect to outer pi bindings)\n           and right side is closed *)  type eq_c = EltC of spinelt * spinelt | SpineC of spine * spine | TypeC of tp * tp type tp_c = term * tp (* equality checking *)  let rec tp_eq (TRoot (n, sp), TRoot (n\', sp\'))  = type_const_head_eq (n, n\', sp, sp\') | tp_eq (TPi (m, a, b), TPi (m\', a\', b\'))  = m = m\' && tp_eq (a, a\') && tp_eq (b, b\') | tp_eq _  = falsesp_eq ([], [])  = true | sp_eq (e :: sp, e\' :: sp\')  = elt_eq (e, e\') && sp_eq (sp, sp\') | sp_eq _  = falseelt_eq (t, t\')  = elt_eq\' (elt_eroot_elim t, elt_eroot_elim t\')elt_eq\' (Elt t, Elt t\')  = tm_eq (t, t\') | elt_eq\' (AElt t, AElt t\')  = atm_eq (t, t\') | elt_eq\' (Ascribe (t, a), Ascribe (t\', a\'))  = ntm_eq (t, t\') && tp_eq (a, a\') | elt_eq\' (Omit, Omit)  = true | elt_eq\' _  = falsetm_eq (NTerm t, NTerm t\')  = ntm_eq (t, t\') | tm_eq (ATerm t, ATerm t\')  = atm_eq (t, t\') | tm_eq _  = falseatm_eq (tm as ARoot (Const n, sp), tm\' as ARoot (Const n\', sp\'))  = const_head_eq (n, n\', sp, sp\', ATerm tm, ATerm tm\') | atm_eq (ARoot (Var n, sp), ARoot (Var n\', sp\'))  = n = n\' && sp_eq (sp, sp\') | atm_eq _  = false(* ERoots are taken care of at the spine element level *) ntm_eq (t, t\')  = ntm_eq\' (ntm_eroot_elim t, ntm_eroot_elim t\')ntm_eq\' (tm as NRoot (Const n, sp), tm\' as NRoot (Const n\', sp\'))  = const_head_eq (n, n\', sp, sp\', NTerm tm, NTerm tm\') | ntm_eq\' (Lam t, Lam t\')  = tm_eq (t, t\') | ntm_eq\' _  = false(* determine whether two roots are equal. n and n\' are the cids of the heads, whether the\n           roots happen to be nroots or aroots. sp and sp\' are the spines, and tm and tm\' are the\n           entire roots. *) const_head_eq (n, n\', sp, sp\', tm, tm\')  = let def = def n let def\' = def n\' let eq_and_strict = (n = n\' && (def = DEF_NONE || not (abbreviation n))) let rec redux t n sp  = reduce (srTerm (t, typeOf (classifier n)), sp) in match (eq_and_strict, def, def\') with (true, _, _) -> sp_eq (sp, sp\') | (false, DEF_NONE, DEF_NONE) -> false | (_, DEF_TERM t, DEF_TERM t\') -> tm_eq (redux t n sp, redux t\' n\' sp\') | (_, DEF_TERM t, DEF_NONE) -> tm_eq (redux t n sp, tm\') | (_, DEF_NONE, DEF_TERM t\') -> tm_eq (tm, redux t\' n\' sp\') | _ -> raise (Syntax "invariant violation")(* similar thing for atomic types. Here we need not include redundant arguments for the entire\n            TRoot since there is only one kind of TRoot (not both ARoot and NRoot in the case of terms)\n            so we just build it back up from scratch *) type_const_head_eq (n, n\', sp, sp\')  = let def = def n let def\' = def n\' let eq_and_strict = n = n\' && (def = DEF_NONE || not (abbreviation n)) let rec redux a n sp  = tp_reduce (a, kindOf (classifier n), sp) in match (eq_and_strict, def, def\') with (true, _, _) -> sp_eq (sp, sp\') | (false, DEF_NONE, DEF_NONE) -> false | (_, DEF_TYPE a, DEF_TYPE a\') -> tp_eq (redux a n sp, redux a\' n\' sp\') | (_, DEF_TYPE a, DEF_NONE) -> tp_eq (redux a n sp, TRoot (n\', sp\')) | (_, DEF_NONE, DEF_TYPE a\') -> tp_eq (TRoot (n, sp), redux a\' n\' sp\') | _ -> raise (Syntax "invariant violation") (* is an equality constraint satisfied? *)  let rec eq_c_true (EltC (e, e\'))  = elt_eq (e, e\') | eq_c_true (SpineC (s, s\'))  = sp_eq (s, s\') | eq_c_true (TypeC (a, a\'))  = tp_eq (a, a\') (* The type ppsubst is a compact way of representing a\n           class of substitutions that contains all of the pattern\n           substitutions. These are the "prepattern" substitutions,\n           the ones that are of the form \n           i1.i2. ... in . shift^m\n           where all the i1...in are variables. *)  (* ([i1, i2, ... , in], m) represents i1.i2. ... in . shift^m *)  type ppsubst = int list * int (* pp_shift pps m: compute pps o shift^m *)  let rec pp_shift (vs, shift) m  = let len = length vs in if m < len then (drop (vs, m), shift) else ([], m - len + shift) (* pp_nth: extract the result of applying a ppsubst to the nth variable *)  let rec pp_nth (vs, shift) n  = let len = length vs in if n < len then nth (vs, n) else n - len + shift (* pp_o: compose two ppsubsts *)  let rec pp_o (pps, (vs, shift))  = let (vs\', shift\') = pp_shift pps shift in ((map (pp_nth pps) vs) @ vs\', shift\') (* pp_comp: compose a list of ppsubsts *)  let rec pp_comp ppsl  = foldr pp_o ([], 0) ppsl (* pp_normalize s\n           if a substitution s is equal to a \'prepattern\'\n           i1.i2. ... in . shift^m (no restriction on the i\'s being distinct)\n           returns ([i1, i2, ... , in], m).\n           Otherwise raises Domain. *)  let rec pp_normalize s  = pp_normalize\' spp_normalize\' Id  = ([], 0) | pp_normalize\' (TermDot (t, a, s))  = (* if the term being consed on is not an eta-expansion of\n                    a variable, forget about it *) let v = try  with  let (vs, shift) = pp_normalize\' s in (v :: vs, shift) | pp_normalize\' (ZeroDotShift s)  = let (vs, shift) = pp_normalize\' s in (0 :: (map (fun x -> x + 1) vs), shift + 1) | pp_normalize\' (Shift (n, m))  = (* using the fact that Shift (n+1) m = ZeroDotShift (Shift n m) *)  (tabulate (n, (fun x -> x)), n + m) | pp_normalize\' (EVarDot _)  = raise (Domain) | pp_normalize\' (VarOptDot (no, s))  = let (vs, shift) = pp_normalize\' s in match no with SOME n -> (n :: vs, shift) | NONE -> raise (Error "??? I\'m not sure this is really wrong") | pp_normalize\' (Compose sl)  = prepattern (substs_comp sl)(* prepattern: convert a subst into a ppsubst *) (* raises Domain if it is not a prepattern *) prepattern (s : subst)  = pp_normalize s (* pp_ispat: is this ppsubst a pattern substitution? *)  let rec pp_ispat ([], shift)  = true | pp_ispat (n :: s, shift)  = let rec isn x  = (x = n) let rec hasn s  = exists isn s in n < shift && not (hasn s) && pp_ispat (s, shift) (* take a list of int options and a shift value and\n        produce an actual substitution. This is morally a one-sided\n        inverse to pp_normalize *)  let rec makesubst ([], 0)  = Id | makesubst ([], shift)  = Shift (0, shift) | makesubst (v :: vs, shift)  = VarOptDot (v, makesubst (vs, shift)) (* take in a ppsubst and return a substitution (which may involve VarOptDots) that is its inverse. *)  let rec pp_invert (vs, shift)  = let inds = tabulate (shift, (fun x -> x)) let rec search n [] (x : int)  = NONE | search n (h :: tl) x  = if x = h then SOME n else search (n + 1) tl x in makesubst (map (search 0 vs) inds, length vs) (* Here begins all the matching code.\n           flex_left takes an uninstantiated evar, a substitution, and a right-hand-side of an equation.\n           The equation is\n           E[sl] = RHS\n           If it can successfully instantiate E with RHS[sl^-1], then it does so\n           imperatively and returns ().\n\n           If sl is not pattern it raises NonPattern.\n           If RHS is not in the range of sl, then MissingVar is raised by substitution *)  let rec flex_left ((r as ref NONE, a), s : subst, rhs)  = let pps = try  with  let _ = if pp_ispat pps then () else raise (NonPattern) let ppsi = pp_invert pps let rhs\' = subst_term ppsi (termof rhs) let _ = r := SOME rhs\' in () | flex_left _  = raise (Error "evar invariant violated") (* match_one\' takes an equation (which by invariant does not\n           have an instantiated evar on the left, and is ground on the\n           right) and returns a list of smaller equations that are\n           equivalent to it, or else throws NonPattern in the event\n           that it finds a flex-rigid equation where the flex side is\n           not pattern. *)  (* XXX this just_one stuff is here for debugging: replace with match_one *)  let rec just_one c  = [c]just_one\' c  = [c]match_one\' (EltC (Elt (NTerm (Lam t)), Elt (NTerm (Lam t\'))))  = just_one (EltC (Elt t, Elt t\')) | match_one\' (EltC (elt as Elt (NTerm (NRoot (Const n, s))), elt\' as Elt (NTerm (NRoot (Const n\', s\')))))  = match_const_head (n, n\', s, s\', elt, elt\', "c- head mismatch") | match_one\' (EltC (elt as Elt (ATerm (ARoot (Const n, s))), elt\' as Elt (ATerm (ARoot (Const n\', s\')))))  = match_const_head (n, n\', s, s\', elt, elt\', "c+ head mismatch") | match_one\' (EltC (Elt (ATerm (ARoot (Var n, s))), Elt (ATerm (ARoot (Var n\', s\')))))  = if n = n\' then just_one\' (SpineC (s, s\')) else raise (Matching "var head mismatch") | match_one\' (EltC (AElt t, AElt t\'))  = just_one\' (EltC (Elt (ATerm t), Elt (ATerm t\'))) | match_one\' (EltC (Ascribe (m, a), Ascribe (m\', a\')))  = match_two (EltC (Elt (NTerm m), Elt (NTerm m\'))) (TypeC (a, a\')) | match_one\' (EltC (Omit, Omit))  = [] | match_one\' (TypeC (TPi (m, a, b), TPi (m\', a\', b\')))  = if m = MINUS && m\' = MINUS then match_two (TypeC (a, a\')) (TypeC (b, b\')) else raise (Matching "mode mismatch") | match_one\' (TypeC (TRoot (n, s), TRoot (n\', s\')))  = match_type_const_head (n, n\', s, s\', "type family mismatch") | match_one\' (SpineC ([], []))  = [] | match_one\' (SpineC (h :: s, h\' :: s\'))  = match_two (EltC (h, h\')) (SpineC (s, s\')) | match_one\' (EltC (Elt (ATerm (ERoot (ev, s : subst))), elt))  = (flex_left (ev, s, elt); []) | match_one\' x  = raise (Matching "doesn\'t match")(* PERF: this second elt_eroot_elim on elt\' seems like it ought to be unnecessary if\n\t     I eliminate all eroots at synth time *) match_one (EltC (elt, elt\'))  = match_one\' (EltC (elt_eroot_elim elt, elt_eroot_elim elt\')) | match_one e  = match_one\' ematch_two e1 e2  = [e1; e2]match_const_head (n, n\', s, s\', elt, elt\', err)  = let def = def n let def\' = def n\' let eq_and_strict = n = n\' && (def = DEF_NONE || not (abbreviation n)) let rec redux t n sp  = reduce (srTerm (t, typeOf (classifier n)), sp) let eq = match (eq_and_strict, def, def\') with (true, _, _) -> SpineC (s, s\') | (false, DEF_NONE, DEF_NONE) -> raise (Matching err) | (_, DEF_TERM t, DEF_TERM t\') -> EltC (Elt (redux t n s), Elt (redux t\' n\' s\')) | (_, DEF_TERM t, DEF_NONE) -> EltC (Elt (redux t n s), elt\') | (_, DEF_NONE, DEF_TERM t\') -> EltC (elt, Elt (redux t\' n\' s\')) | _ -> raise (Matching "invariant violation") in just_one\' eqmatch_type_const_head (n, n\', s, s\', err)  = let def = def n let def\' = def n\' let eq_and_strict = n = n\' && (def = DEF_NONE || not (abbreviation n)) let rec redux a n sp  = tp_reduce (a, kindOf (classifier n), sp) let eq = match (eq_and_strict, def, def\') with (true, _, _) -> SpineC (s, s\') | (false, DEF_NONE, DEF_NONE) -> raise (Matching err) | (_, DEF_TYPE a, DEF_TYPE a\') -> TypeC (redux a n s, redux a\' n\' s\') | (_, DEF_TYPE a, DEF_NONE) -> TypeC (redux a n s, TRoot (n\', s\')) | (_, DEF_NONE, DEF_TYPE a\') -> TypeC (TRoot (n, s), redux a\' n\' s\') | _ -> raise (Matching "invariant violation") in just_one\' eq let rec matching (p)  = let rec matching\' (c :: p, p\')  = (try  with ) | matching\' ([], p\')  = p\' in matching\' (p, []) (*\tfun ctxcons (a, G) = map (shift_tp 0) (a::G) *)  let rec ctxcons (a, G)  = a :: G type cg_mode = CG_SYNTH | CG_CHECK of tp (* \tval constraint_gen : tp list -> spine * tp * cg_mode -> eq_c list * tp_c list\n        fun constraint_gen G (s, z, c) = (p, q, aopt) *)  (* invariants: \n\t   s is ground\n\t   if c is CG_CHECK c\', then c\' is ground \n           right-hand sides of p,q are ground\n           left-hand sides of p,q and z may involve evars\n           \n           the returned aopt...\n           ... is SOME of a type if c was CG_SYNTH\n           ... is NONE           if c was CG_CHECK of something *)  let rec constraint_gen G (s, z, c)  = constraint_gen\' G (s, z, c)constraint_gen\' G ([], a as TRoot _, CG_CHECK (a\' as TRoot _))  = ([TypeC (a, a\')], [], NONE) | constraint_gen\' G ([], TRoot (n, s), CG_SYNTH)  = ([], [], SOME (TRoot (n, s))) | constraint_gen\' G (Omit :: s, TPi (OMIT, a, z), c)  = let ev : evar = (ref NONE, a) let z\' = subst_tp (EVarDotId ev) z let (p, q, aa) = constraint_gen\' G (s, z\', c) in (p, q, aa) | constraint_gen\' G ((Elt m) :: s, TPi (MINUS, a, z), c)  = let z\' = subst_tp (TermDot (m, a, Id)) z let (p, q, aa) = constraint_gen\' G (s, z\', c) in (p, (m, a) :: q, aa) | constraint_gen\' G ((AElt m) :: s, TPi (PLUS, a, z), c)  = let a\' = synth (G, m) let z\' = subst_tp (TermDot (ATerm m, a, Id)) z let (p, q, aa) = constraint_gen\' G (s, z\', c) in (* Same PERF comment here as above *) ((TypeC (a, a\')) :: p, q, aa) | constraint_gen\' G ((Ascribe (m, a\')) :: s, TPi (PLUS, a, z), c)  = let z\' = subst_tp (TermDot (NTerm m, a, Id)) z let (p, q, aa) = constraint_gen\' G (s, z\', c) in (* As well as here *) ((TypeC (a, a\')) :: p, q, aa) | constraint_gen\' _ _  = raise (Error "spine doesn\'t match type")(* similar to above but we just have a putative type and its kind, and return nothing but constraints *) tp_constraint_gen G ([], Type)  = ([], []) | tp_constraint_gen G (Omit :: s, KPi (OMIT, a, z))  = let ev : evar = (ref NONE, a) let z\' = subst_knd (EVarDotId ev) z let (p, q) = tp_constraint_gen G (s, z\') in (p, q) | tp_constraint_gen G ((Elt m) :: s, KPi (MINUS, a, z))  = let z\' = subst_knd (TermDot (m, a, Id)) z let (p, q) = tp_constraint_gen G (s, z\') in (p, (m, a) :: q) | tp_constraint_gen G ((AElt m) :: s, KPi (PLUS, a, z))  = let a\' = synth (G, m) let z\' = subst_knd (TermDot (ATerm m, a, Id)) z let (p, q) = tp_constraint_gen G (s, z\') in ((TypeC (a, a\')) :: p, q) | tp_constraint_gen G ((Ascribe (m, a\')) :: s, KPi (PLUS, a, z))  = let z\' = subst_knd (TermDot (NTerm m, a, Id)) z let (p, q) = tp_constraint_gen G (s, z\') in ((TypeC (a, a\')) :: p, q) | tp_constraint_gen _ _  = raise (Error "spine doesn\'t match type")check_equality_constraints p  = all eq_c_true pcheck_typing_constraints G q  = all (fun (m, a) -> check (G, m, a)) q(* returns true on success or raises Matching on failure *) matching_succeeds G (p, q)  = (* evar side-effects affect q, raises Matching if matching fails *) let p\' = matching p let _ = if check_equality_constraints p\' then () else raise (Matching "residual equality constraints failed") let _ = if check_typing_constraints G q then () else raise (Matching "residual typing constraints failed") in truecheck_spinelt (G, Elt t, a)  = check (G, t, a) | check_spinelt (G, AElt t, a)  = check (G, ATerm t, a) | check_spinelt (G, Ascribe (t, a), a\')  = (tp_eq (a, a\') && check (G, NTerm t, a)) | check_spinelt (G, Omit, _)  = raise (Error "cannot check omitted arguments")check (G, NTerm (Lam (t)), TPi (_, a, b))  = check (ctxcons (a, G), t, b) | check (G, ATerm (t), a)  = (try  with ) | check (G, NTerm (NRoot (Const n, s)), a)  = (* creates ref cells for evars *) let b = match classifier n with tclass b -> b | _ -> raise (Error "signature invariant violated!") let (p, q, _) = constraint_gen G (s, b, CG_CHECK a) in matching_succeeds G (p, q) | check _  = falsecheck_kind (G, Type)  = true | check_kind (G, KPi (OMIT, a, k))  = check_type CON_LF (G, a) && check_kind (ctxcons (a, G), k) && check_strict_kind (k) | check_kind (G, KPi (_, a, k))  = check_type CON_LF (G, a) && check_kind (ctxcons (a, G), k)check_type _ (G, TRoot (n, s))  = (* creates ref cells for evars *) let k = match classifier n with kclass k -> k | _ -> raise (Error "signature invariant violated!") let (p, q) = tp_constraint_gen G (s, k) in matching_succeeds G (p, q) | check_type con (G, TPi (OMIT, a, b))  = let plusconst = match con with CON_LF -> raise (Error "TPi(OMIT) where a pure LF function type expected") | CON_PLUS -> true | CON_MINUS -> false in check_type CON_LF (G, a) && check_type con (ctxcons (a, G), b) && check_strict_type plusconst b | check_type con (G, TPi (m, a, b))  = (match (con, m) with (CON_LF, PLUS) -> raise (Error "TPi(PLUS) where a pure LF function type expected") | _ -> check_type CON_LF (G, a) && check_type con (ctxcons (a, G), b))(* check a type spine *) check_type\' (G, Type, [])  = true | check_type\' (G, KPi (_, a, k), m :: s)  = let _ = if check_spinelt (G, m, a) then () else raise (Error "argument type mismatch") let k\' = subst_knd (TermDot (termof m, a, Id)) k in check_type\' (G, k\', s) | check_type\' _  = falsesynth (G, ARoot (Var n, s))  = synth\' (G, ctxLookup (G, n), s) | synth (G, ARoot (Const n, s))  = (* creates ref cells for evars *) (* DEBUG\t\t val _ = l3 := (p, q, aopt)::(!l3) *) (* raises Matching if not *) let b = match classifier n with tclass b -> b | _ -> raise (Error "signature invariant violated!") let (p, q, aopt) = constraint_gen G (s, b, CG_SYNTH) let _ = matching_succeeds G (p, q) in valOf aopt(* by invariant, aopt must be SOME *) | synth (G, t as ERoot _)  = elt_synth (G, eroot_elim_plus t)synth\' (G, a as TRoot (_, _), [])  = a | synth\' (G, TPi (_, a, b), m :: s)  = let _ = if check_spinelt (G, m, a) then () else raise (Error "argument type mismatch") let b\' = subst_tp (TermDot (termof m, a, Id)) b in synth\' (G, b\', s) | synth\' _  = raise (Error "applying nonfunction to argument")elt_synth (G, AElt t)  = synth (G, t) | elt_synth (G, Ascribe (t, a))  = if check (G, NTerm t, a) then a else raise (Error "ascription doesn\'t check") | elt_synth (G, Elt _)  = raise (Error "trying to synthesize a merely checkable element") | elt_synth (G, Omit)  = raise (Error "trying to synthesize an omitted argument") let rec check_plusconst_type t  = check_type CON_PLUS ([], t) let rec check_minusconst_type t  = check_type CON_MINUS ([], t) (* check_strictness_type : bool -> tp -> bool\n\n   For a type B = Pi x1 : A1 . Pi x2 : A2 ... a . S (where the Pis\n   may be omit or plus or minus) \n   and plus_const : bool\n   the call\n   check_strictness_type plus_const B\n   returns true iff for every i, the following holds:\n     the variable xi has either a strict occurrence in Aj for\n     some j > i where xj is bound by a plus-Pi, or else \n     plus_const = false and xi has a strict occurrence in a . S.\n\n  This function does *not* check to make sure types such as A1\n  do not contain omit-Pis and plus-Pis. This test is carried\n  out in check_type. check_strictness_type is useful mainly when\n  we are simply deciding, by trial and error, which of the arguments\n  to B we should omit and which to force to be synthesizing.\n *)  let rec check_strictness_type _ (TRoot (n, s))  = true | check_strictness_type plusconst (TPi (OMIT, _, b))  = check_strictness_type plusconst b && check_strict_type plusconst b | check_strictness_type plusconst (TPi (_, _, b))  = check_strictness_type plusconst b let check_plusconst_strictness = check_strictness_type true let check_minusconst_strictness = check_strictness_type false end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* `Compressed' terms with omitted redundant arguments *) module type COMPRESS = sig (*  type ConDec*) val sgnReset : unit -> unitval sgnLookup : cid -> sigent(*    val sgnApp       : (IntSyn.cid -> unit) -> unit *) val sgnResetUpTo : int -> unitval sgnCompressUpTo : int -> unitval check : tp list * term * tp -> boolval set_modes : int * mode list -> unit end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Compress (module Global : GLOBAL) = struct module I = IntSyn module S = Syntax module Sgn = Sgn exception Unimp exception NoModes (* modes are not appropriate for the given I.ConDec *)  let debug = ref ~1 let rec sgnReset ()  = clear () (* xlate_type : IntSyn.Exp -> Syntax.tp *)  let rec xlate_type (Pi ((Dec (_, e1), _), e2))  = TPi (MINUS, xlate_type e1, xlate_type e2) | xlate_type (Root (Const cid, sp))  = TRoot (cid, xlate_spine sp) | xlate_type (Root (Def cid, sp))  = TRoot (cid, xlate_spine sp) | xlate_type (Root (NSDef cid, sp))  = TRoot (cid, xlate_spine sp) | xlate_type (Lam (_, t))  = xlate_type t(* for type definitions, simply strip off the lambdas and leave\n                                                   the variables free*) xlate_spine Nil  = [] | xlate_spine (App (e, s))  = xlate_spinelt e :: xlate_spine sxlate_spinelt e  = Elt (xlate_term e)xlate_term (Root (Const cid, sp))  = ATerm (ARoot (Const cid, xlate_spine sp)) | xlate_term (Root (Def cid, sp))  = ATerm (ARoot (Const cid, xlate_spine sp)) | xlate_term (Root (NSDef cid, sp))  = ATerm (ARoot (Const cid, xlate_spine sp)) | xlate_term (Root (BVar vid, sp))  = ATerm (ARoot (Var (vid - 1), xlate_spine sp)) | xlate_term (Lam (_, e))  = NTerm (Lam (xlate_term e)) (* xlate_kind : IntSyn.Exp -> Syntax.knd *)  let rec xlate_kind (Pi ((Dec (_, e1), _), e2))  = KPi (MINUS, xlate_type e1, xlate_kind e2) | xlate_kind (Uni (Type))  = Type open Syntax (* simple skeletal form of types\n     omits all dependencies, type constants *) type simple_tp = Base | Arrow of simple_tp * simple_tp let rec simplify_tp (TPi (_, t1, t2))  = Arrow (simplify_tp t1, simplify_tp t2) | simplify_tp (TRoot _)  = Base let rec simplify_knd (KPi (_, t1, k2))  = Arrow (simplify_tp t1, simplify_knd k2) | simplify_knd (Type)  = Base (* hereditarily perform some eta-expansions on\n     a (term, type, spine, etc.) in a context\n    (and if not synthesizing) at a simple type.\n\n    The only type of eta-expansion performed is when we\n    encounter\n    x . (M_1, M_2, ... M_n)\n    for a variable x, and M_1, ..., M_n have fewer lambda abstractions\n    than their (skeletal) type would suggest.\n\n    The complication with doing full eta-expansion is that if\n    we were to wrap lambda abstractions around terms that occur\n    in a synthesizing position, we would need to add ascriptions,\n    and thus carry full types around everywhere.\n\n    Fortunately, this weakened form of eta-expansion is all\n    we need to reconcile the discrepancy between what twelf\n    maintains as an invariant, and full eta-longness. *) let rec eta_expand_term G (NTerm t) T  = NTerm (eta_expand_nterm G t T) | eta_expand_term G (ATerm t) T  = ATerm (eta_expand_aterm G t)eta_expand_nterm G (Lam t) (Arrow (t1, t2))  = Lam (eta_expand_term (t1 :: G) t t2) | eta_expand_nterm G (NRoot (h, s)) T  = NRoot (h, eta_expand_spine G s T) | eta_expand_nterm G (Lam t) Base  = raise (Syntax "Lambda occurred where term of base type expected")eta_expand_aterm G (ARoot (Const n, s))  = let stp = simplify_tp (typeOf (o_classifier n)) in ARoot (Const n, eta_expand_spine G s stp) | eta_expand_aterm G (ARoot (Var n, s))  = let stp = nth (G, n) in ARoot (Var n, eta_expand_var_spine G s stp) | eta_expand_aterm G (ERoot _)  = raise (Syntax "invariant violated in eta_expand_aterm")eta_expand_tp G (TRoot (n, s))  = let stp = simplify_knd (kindOf (o_classifier n)) in TRoot (n, eta_expand_spine G s stp) | eta_expand_tp G (TPi (m, a, b))  = TPi (m, eta_expand_tp G a, eta_expand_tp (simplify_tp a :: G) b)eta_expand_knd G (Type)  = Type | eta_expand_knd G (KPi (m, a, b))  = KPi (m, eta_expand_tp G a, eta_expand_knd (simplify_tp a :: G) b)eta_expand_spine G [] Base  = [] | eta_expand_spine G ((Elt m) :: tl) (Arrow (t1, t2))  = Elt (eta_expand_term G m t1) :: eta_expand_spine G tl t2 | eta_expand_spine G ((AElt m) :: tl) (Arrow (t1, t2))  = AElt (eta_expand_aterm G m) :: eta_expand_spine G tl t2 | eta_expand_spine G ((Ascribe (m, a)) :: tl) (Arrow (t1, t2))  = Ascribe (eta_expand_nterm G m t1, eta_expand_tp G a) :: eta_expand_spine G tl t2 | eta_expand_spine G (Omit :: tl) (Arrow (t1, t2))  = Omit :: eta_expand_spine G tl t2 | eta_expand_spine _ _ _  = raise (Syntax "Can\'t figure out how to eta expand spine")(* the behavior here is that we are eta-expanding all of the elements of the spine, not the head of *this* spine *) eta_expand_var_spine G [] _  = [] | eta_expand_var_spine G ((Elt m) :: tl) (Arrow (t1, t2))  = Elt (eta_expand_immediate (eta_expand_term G m t1, t1)) :: eta_expand_spine G tl t2 | eta_expand_var_spine _ _ _  = raise (Syntax "Can\'t figure out how to eta expand var-headed spine")(* here\'s where the actual expansion takes place *) eta_expand_immediate (m, Base)  = m | eta_expand_immediate (NTerm (Lam m), Arrow (t1, t2))  = NTerm (Lam (eta_expand_immediate (m, t2))) | eta_expand_immediate (m, Arrow (t1, t2))  = let variable = eta_expand_immediate (ATerm (ARoot (Var 0, [])), t1) in NTerm (Lam (eta_expand_immediate (apply_to (shift m, variable), t2)))apply_to (ATerm (ARoot (h, s)), m)  = ATerm (ARoot (h, s @ [Elt m])) | apply_to (NTerm (NRoot (h, s)), m)  = NTerm (NRoot (h, s @ [Elt m])) | apply_to _  = raise (Syntax "Invariant violated in apply_to")  let typeOf = typeOf let kindOf = kindOf exception Debug of spine * tp * tp (* val compress_type : Syntax.tp list -> Syntax.mode list option * Syntax.tp -> Syntax.tp *)  (* the length of the mode list, if there is one, should correspond to the number of pis in the input type.\n    however, as indicated in the XXX comment below, it seems necessary to treat SOME of empty list\n    as if it were NONE. This doesn\'t seem right. *)  let rec compress_type G s  = (* if !debug < 0\n                          then *)  compress_type\' G s(* else  (if !debug = 0 then raise Debug(G, s) else ();\n                                debug := !debug - 1; compress_type\' G s) *) compress_type\' G (NONE, TPi (_, a, b))  = TPi (MINUS, compress_type G (NONE, a), compress_type (a :: G) (NONE, b)) | compress_type\' G (SOME (m :: ms), TPi (_, a, b))  = TPi (m, compress_type G (NONE, a), compress_type (a :: G) (SOME ms, b)) | compress_type\' G (SOME [], TRoot (cid, sp))  = TRoot (cid, compress_type_spine G (sp, kindOf (o_classifier cid), kindOf (classifier cid))) | compress_type\' G (NONE, a as TRoot _)  = compress_type G (SOME [], a) | compress_type\' G (SOME [], a as TPi _)  = compress_type G (NONE, a)(* XXX sketchy *) (* XXX: optimization: don\'t compute mstar if omit? *) compress_type_spine G ([], w, wstar)  = [] | compress_type_spine G ((Elt m) :: sp, KPi (_, a, v), KPi (mode, astar, vstar))  = let mstar = compress_term G (m, a) let sstar = compress_type_spine G (sp, subst_knd (TermDot (m, a, Id)) v, subst_knd (TermDot (mstar, astar, Id)) vstar) in match (mode, mstar) with (OMIT, _) -> Omit :: sstar | (MINUS, _) -> Elt mstar :: sstar | (PLUS, ATerm t) -> AElt t :: sstar | (PLUS, NTerm t) -> Ascribe (t, compress_type G (NONE, a)) :: sstarcompress_spine G ([], w, wstar)  = [] | compress_spine G ((Elt m) :: sp, TPi (_, a, v), TPi (mode, astar, vstar))  = let mstar = compress_term G (m, a) let sstar = compress_spine G (sp, subst_tp (TermDot (m, a, Id)) v, subst_tp (TermDot (mstar, astar, Id)) vstar) in match (mode, mstar) with (OMIT, _) -> Omit :: sstar | (MINUS, _) -> Elt mstar :: sstar | (PLUS, ATerm t) -> AElt t :: sstar | (PLUS, NTerm t) -> Ascribe (t, compress_type G (NONE, a)) :: sstarcompress_term G (ATerm (ARoot (Var n, sp)), _)  = let a = ctxLookup (G, n) let astar = compress_type G (NONE, a) in ATerm (ARoot (Var n, compress_spine G (sp, a, astar))) | compress_term G (ATerm (ARoot (Const n, sp)), _)  = let a = typeOf (o_classifier n) let astar = typeOf (classifier n) let term_former = match get_p n with SOME false -> NTerm o NRoot | _ -> ATerm o ARoot in term_former (Const n, compress_spine G (sp, a, astar)) | compress_term G (NTerm (Lam t), TPi (_, a, b))  = NTerm (Lam (compress_term (a :: G) (t, b))) let rec compress_kind G (NONE, KPi (_, a, k))  = KPi (MINUS, compress_type G (NONE, a), compress_kind (a :: G) (NONE, k)) | compress_kind G (SOME (m :: ms), KPi (_, a, k))  = KPi (m, compress_type G (NONE, a), compress_kind (a :: G) (SOME ms, k)) | compress_kind G (SOME [], Type)  = Type | compress_kind G (NONE, Type)  = Type (* compress : cid * IntSyn.ConDec -> ConDec *)  let rec compress (cid, ConDec (name, NONE, _, Normal, a, Type))  = let x = xlate_type a let x = eta_expand_tp [] x let modes = get_modes cid in condec (name, compress_type [] (modes, x), x) | compress (cid, ConDec (name, NONE, _, Normal, k, Kind))  = let x = xlate_kind k let modes = get_modes cid in tycondec (name, compress_kind [] (modes, x), x) | compress (cid, ConDef (name, NONE, _, m, a, Type, _))  = let m = xlate_term m let a = xlate_type a let astar = compress_type [] (NONE, a) let mstar = compress_term [] (m, a) in defn (name, astar, a, mstar, m) | compress (cid, ConDef (name, NONE, _, a, k, Kind, _))  = let a = xlate_type a let k = xlate_kind k let kstar = compress_kind [] (NONE, k) let astar = compress_type (explodeKind kstar) (NONE, a) in tydefn (name, kstar, k, astar, a) | compress (cid, AbbrevDef (name, NONE, _, m, a, Type))  = let m = xlate_term m let a = xlate_type a let astar = compress_type [] (NONE, a) let mstar = compress_term [] (m, a) in abbrev (name, astar, a, mstar, m) | compress (cid, AbbrevDef (name, NONE, _, a, k, Kind))  = let a = xlate_type a let k = xlate_kind k let kstar = compress_kind [] (NONE, k) let astar = compress_type (explodeKind kstar) (NONE, a) in tyabbrev (name, kstar, k, astar, a) | compress _  = raise (Unimp) let rec sgnLookup (cid)  = let c = sub cid in match c with NONE -> let c\' = compress (cid, sgnLookup cid) let _ = update (cid, c\') let _ = print (toString cid ^ "\\n") in c\' | SOME x -> x (*  val sgnApp  = IntSyn.sgnApp\n\n  fun sgnCompress () = sgnApp (ignore o sgnLookup) *)  let rec sgnCompressUpTo x  = if x < 0 then () else (sgnCompressUpTo (x - 1); sgnLookup x; ()) let check = check let rec extract f  = (try  with ) let set_modes = set_modes (* val log : Sgn.sigent list ref = ref [] *)  (* given a cid, pick some vaguely plausible omission modes *)  let rec naiveModes cid  = let (ak, omitted_args, uni) = match sgnLookup cid with ConDec (name, package, o_a, status, ak, uni) -> (ak, o_a, uni) | ConDef (name, package, o_a, ak, def, uni, _) -> (ak, o_a, uni) | AbbrevDef (name, package, o_a, ak, def, uni) -> (ak, o_a, uni) | _ -> raise (NoModes) let rec count_args (Pi (_, ak\'))  = 1 + count_args ak\' | count_args _  = 0 let total_args = count_args ak let rec can_omit ms  = (*                val _ = if true then log := !log @ [s] else () *) (*                val _ = if isValid then print "yup\\n" else print "nope\\n" *) let _ = set_modes (cid, ms) let s = compress (cid, sgnLookup cid) let t = typeOfSigent s let isValid = check_plusconst_strictness t in isValid let rec optimize\' ms []  = rev ms | optimize\' ms (PLUS :: ms\')  = if can_omit ((rev ms) @ (MINUS :: ms\')) then optimize\' (MINUS :: ms) ms\' else optimize\' (PLUS :: ms) ms\' | optimize\' ms (MINUS :: ms\')  = if can_omit ((rev ms) @ (OMIT :: ms\')) then optimize\' (OMIT :: ms) ms\' else optimize\' (MINUS :: ms) ms\' let rec optimize ms  = optimize\' [] ms in if uni = Kind then tabulate (total_args, (fun _ -> MINUS)) else optimize (tabulate (total_args, (fun x -> if x < omitted_args then MINUS else PLUS))) (* Given a cid, return the "ideal" modes specified by twelf-\n     omitted arguments. It is cheating to really use these for\n     compression: the resulting signature will not typecheck. *)  let rec idealModes cid  = let (ak, omitted_args) = match sgnLookup cid with ConDec (name, package, o_a, status, ak, uni) -> (ak, o_a) | ConDef (name, package, o_a, ak, def, uni, _) -> (ak, o_a) | AbbrevDef (name, package, o_a, ak, def, uni) -> (ak, o_a) | _ -> raise (NoModes) let rec count_args (Pi (_, ak\'))  = 1 + count_args ak\' | count_args _  = 0 let total_args = count_args ak in tabulate (total_args, (fun x -> if x < omitted_args then OMIT else MINUS)) (* not likely to work if the mode-setting function f actually depends on\n   properties of earlier sgn entries *)  let rec setModesUpTo x f  = if x < 0 then () else (setModesUpTo (x - 1) f; set_modes (x, f x); ()) let rec sgnAutoCompress n f  = (try  with ) let rec sgnAutoCompressUpTo\' n0 n f  = if n0 > n then () else let _ = (* has this entry already been processed? *) match sub n0 with SOME _ -> ()(* if not, compress it *)  | NONE -> try  with  in sgnAutoCompressUpTo\' (n0 + 1) n f let rec sgnAutoCompressUpTo n f  = sgnAutoCompressUpTo\' 0 n f let check = check end(*\nc : ((o -> o) -> o -> o) -> o\n\na : o -> o\n\nc ([x] a)\n\neta_expand_immediate ( a) ( o -> o)\n*) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module type SGN = sig type sigenttype defDEF_NONEDEF_TERMtermDEF_TYPEtpval condec : string * tp * tp -> sigentval tycondec : string * knd * knd -> sigentval defn : string * tp * tp * term * term -> sigentval tydefn : string * knd * knd * tp * tp -> sigentval abbrev : string * tp * tp * term * term -> sigentval tyabbrev : string * knd * knd * tp * tp -> sigentval typeOfSigent : sigent -> tpval classifier : int -> classval o_classifier : int -> classval def : int -> defval o_def : int -> defval update : int * sigent -> unitval sub : int -> sigent optionval clear : unit -> unitval get_modes : int -> mode list optionval set_modes : int * mode list -> unitval get_p : int -> bool optionval set_p : int * bool -> unitval abbreviation : int -> bool endmodule Sgn = struct open Syntax exception NoSuch of int type def = DEF_NONE | DEF_TERM of term | DEF_TYPE of tp (* o_ means "original", i.e. before compression *)  type sigent = {name: string; classifier: class; o_classifier: class; def: def; o_def: def; abbreviation: bool} let sgn_size = 14000 (* XXX *)  let sigma : sigent option array = array (sgn_size, NONE) let all_modes : mode list option array = array (sgn_size, NONE) let all_ps : bool option array = array (sgn_size, NONE) let rec split (h :: tl) 0  = ([], h, tl) | split (h :: tl) n  = let (pre, thing, post) = split tl (n - 1) in (h :: pre, thing, post) | split [] n  = split [NONE] n let rec clear ()  = in modify (fun _ -> NONE) sigma; modify (fun _ -> NONE) all_modes; modify (fun _ -> NONE) all_ps let rec condec (s, a, oa)  = {name = s; classifier = tclass a; o_classifier = tclass oa; def = DEF_NONE; o_def = DEF_NONE; abbreviation = false} let rec tycondec (s, k, ok)  = {name = s; classifier = kclass k; o_classifier = kclass ok; def = DEF_NONE; o_def = DEF_NONE; abbreviation = false} let rec defn (s, a, oa, m, om)  = {name = s; classifier = tclass a; o_classifier = tclass oa; def = DEF_TERM m; o_def = DEF_TERM om; abbreviation = false} let rec tydefn (s, k, ok, a, oa)  = {name = s; classifier = kclass k; o_classifier = kclass ok; def = DEF_TYPE a; o_def = DEF_TYPE oa; abbreviation = false} let rec abbrev (s, a, oa, m, om)  = {name = s; classifier = tclass a; o_classifier = tclass oa; def = DEF_TERM m; o_def = DEF_TERM om; abbreviation = true} let rec tyabbrev (s, k, ok, a, oa)  = {name = s; classifier = kclass k; o_classifier = kclass ok; def = DEF_TYPE a; o_def = DEF_TYPE oa; abbreviation = true} let rec typeOfSigent (e : sigent)  = typeOf (classifier e) let rec setter table (n, x)  = update (table, n, SOME x) let rec getter table id  = sub (table, id) let set_modes = setter all_modes let get_modes = getter all_modes let set_p = setter all_ps let get_p = getter all_ps let update = setter sigma let sub = getter sigma let rec classifier id  = (try  with ) let rec o_classifier id  = (try  with ) let rec def id  = (try  with ) let rec o_def id  = (try  with ) let rec abbreviation id  = (try  with ) end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Rep = struct module I = IntSyn module S = Syntax let rec defSize x  = (match x with DEF_TERM y -> size_term y | DEF_TYPE y -> size_tp y) let rec cidSize cid  = (match sgnLookup cid with ConDec (_, _, _, _, _, Type) -> size_tp (typeOf (classifier cid)) | ConDec (_, _, _, _, _, Kind) -> size_knd (kindOf (classifier cid)) | ConDef (_, _, _, _, _, _, _) -> defSize (def cid) | AbbrevDef (_, _, _, _, _, _) -> defSize (def cid) | _ -> 0) let rec o_cidSize cid  = (match sgnLookup cid with ConDec (_, _, _, _, _, Type) -> size_tp (typeOf (o_classifier cid)) | ConDec (_, _, _, _, _, Kind) -> size_knd (kindOf (o_classifier cid)) | ConDef (_, _, _, _, _, _, _) -> defSize (o_def cid) | AbbrevDef (_, _, _, _, _, _) -> defSize (o_def cid) | _ -> 0) open SMLofNJCont (* val l : (Syntax.term * Syntax.tp) list ref = ref [] *)  let k : eq_c option ref = ref NONE exception Crap let rec sanityCheck cid  = (try  with ) let rec gen_graph n autoCompress  = let _ = autoCompress n let rec sanity n  = if n < 0 then true else (sanity (n - 1) && (if sanityCheck n then true else (print ("insane: <" ^ (toString n) ^ ">\\n"); raise (Crap)))) let _ = sanity n let pairs = tabulate (n + 1, (fun x -> (o_cidSize x, cidSize x))) let s = foldl ^ "" (map (fun (x, y) -> toString x ^ " " ^ toString y ^ "\\n") pairs) let f = openOut "/tmp/graph" let _ = output (f, s) let _ = closeOut (f) in () (* DEBUG  handle Reductio.Matching2 s => (print "doesn\'tmatch"; k := SOME s); *)  (* fun gg n = (Compress.sgnReset(); gen_graph n\n\t    (fn n => Compress.sgnAutoCompressUpTo n Compress.naiveModes)) *)  (* Syntax.size_term (Option.valOf(#o_def (Compress.sgnLookup n))) *)  open Reductio end(*\nfun autoCompress n modeFinder =\n    let\n(*\tval rep = Twelf.Names.lookup "represents"\n\tval rep_z = Twelf.Names.lookup "represents_z"\n\tval rep_s = Twelf.Names.lookup "represents_s" *)\n    in\n\tCompress.sgnReset();\n\tCompress.sgnAutoCompressUpTo(n)\n    (* Syntax.size_term (Option.valOf(#o_def (Compress.sgnLookup n))) *)\n    end\n*) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Theorems *) (* Author: Carsten Schuermann *) (* Modified: Brigitte Pientka *) module ThmSyn ((*! structure IntSyn : INTSYN !*) (*! structure ModeSyn\' : MODESYN !*) (*! sharing ModeSyn\'.IntSyn = IntSyn !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) (*! structure Paths\' : PATHS !*) module Names\' : NAMES(*! sharing Names\'.IntSyn = IntSyn !*) ) : THMSYN = struct (*! structure IntSyn = IntSyn !*)  (*! structure ModeSyn = ModeSyn\' *)  (*! structure Paths = Paths\' !*)  module Names = Names\' exception Error of string let rec error (r, msg)  = raise (Error (wrap (r, msg))) type Param = string option type Order = Varg of string list | Lex of Order list | Simul of Order list (* -bp *)  type Predicate = Less | Leq | Eq type RedOrder = RedOrder of Predicate * Order * Order type Callpats = Callpats of cid * Param list list (* Termination declaration *)  type TDecl = TDecl of (Order * Callpats) (* -bp *)  (* Reduction declaration *)  type RDecl = RDecl of (RedOrder * Callpats) (* Tabled declaration *)  type TabledDecl = TabledDecl of cid (* KeepTable declaration *)  type KeepTableDecl = KeepTableDecl of cid (* Theorem declaration *)  type ThDecl = ThDecl of Dec Ctx * Dec Ctx list * Dec Ctx * Mode Ctx * int (* Proof declaration *)  type PDecl = PDecl of int * TDecl (* World declaration *)  (*  datatype WDecl =\n    WDecl of (IntSyn.Dec IntSyn.Ctx *\n              IntSyn.Dec IntSyn.Ctx) list * Callpats *)  type WDecl = WDecl of Qid list * Callpats module I = IntSynmodule M = ModeSyn(* theoremDecToConDec (name, T) = D\'\n\n       Invariant:\n       If   name is the name of a theorem\n       and  T is the declaration of a theorem\n       then D\' is a constant type declaration of this theorem\n    *) let rec theoremDecToConDec ((name, ThDecl (GBs, G, MG, i)), r)  = (* theoremToConDec\' G V = V\'\n\n             Invariant:\n             If   G = V1 .. Vn\n             and  G |- V : kind\n             then V\' = {V1} .. {Vn} V\n             and  . |-  V\' : kind\n          *) let rec theoremToConDec\' (Null, V)  = V | theoremToConDec\' (Decl (G, D), V)  = if closedDec (G, (D, id)) then theoremToConDec\' (G, piDepend ((normalizeDec (D, id), Maybe), V)) else error (r, "Free variables in theorem declaration") in (GBs, ConDec (name, NONE, i, Normal, theoremToConDec\' (G, Uni (Type)), Kind)) (* theoremDecToModeSpine (name, T) = mS\'\n\n       Invariant:\n       If   name is the name of a theorem\n       and  T is the declaration of a theorem\n       then mS\' is a mode spine reflecting the\n         quantifier information for the theorem\n    *) let rec theoremDecToModeSpine ((name, ThDecl (GBs, G, MG, i)), r)  = let rec theoremToModeSpine\' (Null, Null, mS)  = mS | theoremToModeSpine\' (Decl (G, Dec (x, _)), Decl (MG, m), mS)  = theoremToModeSpine\' (G, MG, Mapp (Marg (m, x), mS)) in theoremToModeSpine\' (G, MG, Mnil) let theoremDecToConDec = theoremDecToConDec let theoremDecToModeSpine = theoremDecToModeSpine  (* local *)  end\n(* functor ThmSyn *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module ThmSyn = ThmSyn(struct module Abstract = Abstract module Whnf = Whnf module Paths' = Paths module Names' = Names end)
module ThmPrint = ThmPrint(struct module ThmSyn' = ThmSyn module Formatter = Formatter end)
module Thm = Thm(struct module Global = Global module ThmSyn' = ThmSyn module TabledSyn = TabledSyn module Order = Order module ModeTable = ModeTable module ThmPrint = ThmPrint module Paths' = Paths end)

Code parsed successfully: module ThmSyn = ThmSyn(struct module Abstract = Abstract module Whnf = Whnf module Paths' = Paths module Names' = Names end)
module ThmPrint = ThmPrint(struct module ThmSyn' = ThmSyn module Formatter = Formatter end)
module Thm = Thm(struct module Global = Global module ThmSyn' = ThmSyn module TabledSyn = TabledSyn module Order = Order module ModeTable = ModeTable module ThmPrint = ThmPrint module Paths' = Paths end)

('Error parsing code:', '(* Printer for Meta Theorems *) (* Author: Carsten Schuermann *) module type THMPRINT = sig module ThmSyn : THMSYNval tDeclToString : TDecl -> stringval callpatsToString : Callpats -> stringval rDeclToString : RDecl -> string(* -bp *) val ROrderToString : RedOrder -> string(* -bp *) val tabledDeclToString : TabledDecl -> string(* -bp *) val keepTableDeclToString : KeepTableDecl -> string(* -bp *)  end\n(* signature THMPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Theorems *) (* Author: Carsten Schuermann *) (* Modified: Brigitte Pientka *) module type THMSYN = sig module Names : NAMESexception Error of string(*! type Param = string option !*) type OrderVargstring listLexOrder listSimulOrder list(* -bp *) type PredicateLessLeqEqtype RedOrderRedOrderPredicate * Order * Ordertype CallpatsCallpatscid * string option list list(* Termination declaration *) type TDeclTDeclOrder * Callpats(* -bp *) (* Reduction declaration *) type RDeclRDecl(RedOrder * Callpats)(* Tabled declaration *) type TabledDeclTabledDeclcid(* KeepTable declaration *) type KeepTableDeclKeepTableDeclcid(* Theorem declaration  *) type ThDeclThDeclDec Ctx * Dec Ctx list * Dec Ctx * Mode Ctx * int(* Proof declaration *) type PDeclPDeclint * TDecl(* World declaration *) (*  datatype WDecl = \n    WDecl of (IntSyn.Dec IntSyn.Ctx * \n\t      IntSyn.Dec IntSyn.Ctx) list * Callpats\n*) type WDeclWDeclQid list * Callpatsval theoremDecToConDec : ((string * ThDecl) * region) -> Dec Ctx * Dec Ctx list * ConDecval theoremDecToModeSpine : ((string * ThDecl) * region) -> ModeSpine end\n(* signature THMSYN *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Printer for Meta Theorems *) (* Author: Carsten Schuermann *) (* Modified: Brigitte Pientka *) module ThmPrint (module ThmSyn\' : THMSYNmodule Formatter : FORMATTER) : THMPRINT = struct module ThmSyn = ThmSyn\' module L = ThmSynmodule I = IntSynmodule F = Formatterlet rec fmtIds nil  = [] | fmtIds (n :: nil)  = [String (n)] | fmtIds (n :: L)  = [String (n); String " "] @ (fmtIds L) let rec fmtParams nil  = [] | fmtParams (SOME n :: nil)  = [String (n)] | fmtParams (NONE :: nil)  = [String ("_")] | fmtParams (SOME n :: L)  = [String (n); String " "] @ (fmtParams L) | fmtParams (NONE :: L)  = [String ("_"); String " "] @ (fmtParams L) let rec fmtType (c, L)  = HVbox ([String (conDecName (sgnLookup c)); String " "] @ (fmtParams L)) let rec fmtCallpats nil  = [] | fmtCallpats (T :: nil)  = [String "("; fmtType T; String ")"] | fmtCallpats (T :: L)  = [String "("; fmtType T; String ") "] @ (fmtCallpats L) let rec fmtOptions (L as (_ :: nil))  = [HVbox (fmtIds L)] | fmtOptions L  = [String "("; HVbox (fmtIds L); String ") "] let rec fmtOrder (Varg L)  = (match L with (H :: nil) -> (fmtIds L) | _ -> [String "("; HVbox (fmtIds L); String ")"]) | fmtOrder (Lex L)  = [String "{"; HVbox (fmtOrders L); String "}"] | fmtOrder (Simul L)  = [String "["; HVbox (fmtOrders L); String "]"]fmtOrders nil  = nil | fmtOrders (O :: nil)  = fmtOrder O | fmtOrders (O :: L)  = fmtOrder O @ (String " " :: fmtOrders L) let rec tDeclToString (TDecl (O, Callpats L))  = makestring_fmt (HVbox (fmtOrder O @ (String " " :: fmtCallpats L))) let rec callpatsToString (Callpats L)  = makestring_fmt (HVbox (fmtCallpats L)) (* -bp *) let rec fmtROrder (RedOrder (P, O, O\'))  = match P with Less -> (fmtOrder O) @ (String " < " :: fmtOrder O\') | Leq -> (fmtOrder O) @ (String " <= " :: fmtOrder O\') | Eq -> (fmtOrder O) @ (String " = " :: fmtOrder O\') let rec ROrderToString R  = makestring_fmt (HVbox (fmtROrder R)) let rec rDeclToString (RDecl (R, Callpats L))  = makestring_fmt (HVbox ((fmtROrder R @ (String " " :: fmtCallpats L)))) let rec tabledDeclToString (TabledDecl cid)  = makestring_fmt (HVbox ([String (conDecName (sgnLookup cid))])) let rec keepTableDeclToString (KeepTableDecl cid)  = makestring_fmt (HVbox ([String (conDecName (sgnLookup cid))])) let tDeclToString = tDeclToString let callpatsToString = callpatsToString let ROrderToString = ROrderToString (* -bp *) let rDeclToString = rDeclToString (* -bp *) let tabledDeclToString = tabledDeclToString let keepTableDeclToString = keepTableDeclToString  (* local *)  end\n(* functor ThmPrint *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Theorem Declarations *) (* Author: Carsten Schuermann *) (* Modified: Brigitte Pientka, Frank Pfenning *) module type THM = sig module ThmSyn : THMSYN(*! structure Paths : PATHS !*) exception Error of stringval installTotal : TDecl * (region * region list) -> cid listval uninstallTotal : cid -> boolval installTerminates : TDecl * (region * region list) -> cid listval uninstallTerminates : cid -> bool(* true: was declared, false not *) val installReduces : RDecl * (region * region list) -> cid listval uninstallReduces : cid -> boolval installTabled : TabledDecl -> unitval installKeepTable : KeepTableDecl -> unit end\n(* signature THM *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Reduction and Termination checker *) (* Author: Brigitte Pientka *) module type REDUCES = sig (*! structure IntSyn : INTSYN !*) exception Error of stringval reset : unit -> unitval checkFamReduction : cid -> unitval checkFam : cid -> unit end\n(* signature REDUCES *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Reduction and Termination checker *) (* Author: Brigitte Pientka *) (* for termination checking see [Rohwedder,Pfenning ESOP\'96]\n   for a revised version incorporating reducation checking see\n   tech report CMU-CS-01-115\n *) module Reduces (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) module Formatter : FORMATTERmodule Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) PrintFormatterFormattermodule Order : ORDER(*! sharing Order.IntSyn = IntSyn\' !*) (*! structure Paths  : PATHS !*) module Checking : CHECKINGCheckingOrderOrder(*! sharing Checking.IntSyn = IntSyn\' !*) (*! sharing Checking.Paths = Paths !*) module Origins : ORIGINS(*! sharing Origins.Paths = Paths !*) (*! sharing Origins.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) ) : REDUCES = struct (*! structure IntSyn = IntSyn\' !*)  exception Error of string module I = IntSynmodule P = Pathsmodule N = Namesmodule F = Formattermodule R = Ordermodule C = Checkingexception Error\' of occ * string let rec error (c, occ, msg)  = (match originLookup c with (fileName, NONE) -> raise (Error (fileName ^ ":" ^ msg)) | (fileName, SOME occDec) -> raise (Error (wrapLoc\' (Loc (fileName, occToRegionDec occDec occ), linesInfoLookup (fileName), msg)))) let rec concat (G\', Null)  = G\' | concat (G\', Decl (G, D))  = Decl (concat (G\', G), D) (*--------------------------------------------------------------------*) (* Printing *) let rec fmtOrder (G, O)  = let rec fmtOrder\' (Arg (Us as (U, s), Vs as (V, s\')))  = Hbox [String "("; formatExp (G, EClo Us); String ")"] | fmtOrder\' (Lex L)  = Hbox [String "{"; HOVbox0 1 0 1 (fmtOrders L); String "}"] | fmtOrder\' (Simul L)  = Hbox [String "["; HOVbox0 1 0 1 (fmtOrders L); String "]"]fmtOrders []  = [] | fmtOrders (O :: [])  = fmtOrder\' O :: [] | fmtOrders (O :: L)  = fmtOrder\' O :: Break :: fmtOrders L in fmtOrder\' O let rec fmtComparison (G, O, comp, O\')  = HOVbox0 1 0 1 [fmtOrder (G, O); Break; String comp; Break; fmtOrder (G, O\')] let rec fmtPredicate (G, Less (O, O\'))  = fmtComparison (G, O, "<", O\') | fmtPredicate (G, Leq (O, O\'))  = fmtComparison (G, O, "<=", O\') | fmtPredicate (G, Eq (O, O\'))  = fmtComparison (G, O, "=", O\') | fmtPredicate (G, Pi (D, P))  = Hbox [String "Pi "; fmtPredicate (Decl (G, D), P)] let rec rlistToString\' (G, nil)  = "" | rlistToString\' (G, [P])  = makestring_fmt (fmtPredicate (G, P)) | rlistToString\' (G, (P :: Rl))  = makestring_fmt (fmtPredicate (G, P)) ^ " ," ^ rlistToString\' (G, Rl) let rec rlistToString (G, Rl)  = rlistToString\' (ctxName G, Rl) let rec orderToString (G, P)  = makestring_fmt (fmtPredicate (ctxName G, P)) (*--------------------------------------------------------------------*) (* select (c, (S, s)) = P\n\n      select parameters according to termination order\n\n      Invariant:\n      If   . |- c : V   G |- s : G\'    G\' |- S : V > type\n      and  V = {x1:V1} ... {xn:Vn} type.\n      then P = U1[s1] .. Un[sn] is parameter select of S[s] according to sel (c)\n      and  G |- si : Gi  Gi |- Ui : Vi\n      and  G |- Vi[s]  == V[si] : type   forall 1<=i<=n\n    *) let rec select (c, (S, s))  = let SO = selLookup c let Vid = (constType c, id) let rec select\'\' (n, (Ss\', Vs\'\'))  = select\'\'W (n, (Ss\', whnf Vs\'\'))select\'\'W (1, ((App (U\', S\'), s\'), (Pi ((Dec (_, V\'\'), _), _), s\'\')))  = ((U\', s\'), (V\'\', s\'\')) | select\'\'W (n, ((SClo (S\', s1\'), s2\'), Vs\'\'))  = select\'\'W (n, ((S\', comp (s1\', s2\')), Vs\'\')) | select\'\'W (n, ((App (U\', S\'), s\'), (Pi ((Dec (_, V1\'\'), _), V2\'\'), s\'\')))  = select\'\' (n - 1, ((S\', s\'), (V2\'\', Dot (Exp (EClo (U\', s\')), s\'\')))) let rec select\' (Arg n)  = Arg (select\'\' (n, ((S, s), Vid))) | select\' (Lex L)  = Lex (map select\' L) | select\' (Simul L)  = Simul (map select\' L) in select\' (selLookup c) let rec selectOcc (c, (S, s), occ)  = try  with (* selectROrder (c, (S, s)) = P\n\n       select parameters according to reduction order\n\n       Invariant:\n       If   . |- c : V   G |- s : G\'    G\' |- S : V > type\n       and  V = {x1:V1} ... {xn:Vn} type.\n       then P = U1[s1] .. Un[sn] is parameter select of S[s] according to sel (c)\n       and  G |- si : Gi  Gi |- Ui : Vi\n       and  G |- Vi[s]  == V[si] : type   forall 1<=i<=n\n    *) let rec selectROrder (c, (S, s))  = let Vid = (constType c, id) let rec select\'\' (n, (Ss\', Vs\'\'))  = select\'\'W (n, (Ss\', whnf Vs\'\'))select\'\'W (1, ((App (U\', S\'), s\'), (Pi ((Dec (_, V\'\'), _), _), s\'\')))  = ((U\', s\'), (V\'\', s\'\')) | select\'\'W (n, ((SClo (S\', s1\'), s2\'), Vs\'\'))  = select\'\'W (n, ((S\', comp (s1\', s2\')), Vs\'\')) | select\'\'W (n, ((App (U\', S\'), s\'), (Pi ((Dec (_, V1\'\'), _), V2\'\'), s\'\')))  = select\'\' (n - 1, ((S\', s\'), (V2\'\', Dot (Exp (EClo (U\', s\')), s\'\')))) let rec select\' (Arg n)  = Arg (select\'\' (n, ((S, s), Vid))) | select\' (Lex L)  = Lex (map select\' L) | select\' (Simul L)  = Simul (map select\' L) let rec selectP (Less (O1, O2))  = Less (select\' O1, select\' O2) | selectP (Leq (O1, O2))  = Leq (select\' O1, select\' O2) | selectP (Eq (O1, O2))  = Eq (select\' O1, select\' O2) in try  with (*--------------------------------------------------------------*) (* abstractRO (G, D, RO) = Pi D. RO\n       Invariant:\n\n       If  G, D |- RO\n       then  G |- Pi D . RO\n\n    *) let rec abstractRO (G, D, O)  = Pi (D, O) (* getROrder (G, Q, (V, s)) = O\n       If G: Q\n       and  G |- s : G1    and   G1 |- V : L\n       then O is the reduction order associated to V[s]\n       and  G |- O\n\n     *) let rec getROrder (G, Q, Vs, occ)  = getROrderW (G, Q, whnf Vs, occ)getROrderW (G, Q, Vs as (Root (Const a, S), s), occ)  = let O = selectROrder (a, (S, s)) let _ = match O with NONE -> () | SOME (O) -> if (! chatter) > 5 then print ("Reduction predicate for " ^ qidToString (constQid a) ^ " added : " ^ orderToString (G, O) ^ "\\n") else () in O | getROrderW (G, Q, (Pi ((D, Maybe), V), s), occ)  = let O = getROrder (Decl (G, decLUName (G, decSub (D, s))), Decl (Q, All), (V, dot1 s), body occ) in match O with NONE -> NONE | SOME (O\') -> SOME (abstractRO (G, decSub (D, s), O\')) | getROrderW (G, Q, (Pi ((D as Dec (_, V1), No), V2), s), occ)  = let O = getROrder (G, Q, (V2, comp (invShift, s)), body occ) in match O with NONE -> NONE | SOME (O\') -> SOME (O\') | getROrderW (G, Q, Vs as (Root (Def a, S), s), occ)  = raise (Error\' (occ, "Reduction checking for defined type families not yet available:\\n" ^ "Illegal use of " ^ qidToString (constQid a) ^ ".")) (*--------------------------------------------------------------------*) (* Termination Checker *) (* checkGoal (G0, Q0, Rl, (V, s), (V\', s\'), occ) = ()\n\n       Invariant:\n       If   G0 : Q0\n       and  G0 |- s : G1     and   G1 |- V : L     (V, s) in whnf\n       and  V[s], V\'[s\'] does not contain Skolem constants\n       and  G0 |- s\' : G2    and   G2 |- V\' : L\'   (V\', s\') in whnf\n       and  V\' = a\' @ S\'\n       and  G |- L = L\'\n       and  V[s] < V\'[s\']  (< termination ordering)\n         then ()\n       else Error is raised.\n    *) let rec checkGoal (G0, Q0, Rl, Vs, Vs\', occ)  = checkGoalW (G0, Q0, Rl, whnf Vs, Vs\', occ)checkGoalW (G0, Q0, Rl, (Pi ((D as Dec (_, V1), No), V2), s), Vs\', occ)  = (checkClause ((G0, Q0, Rl), Null, Null, (V1, s), label occ); checkGoal (G0, Q0, Rl, (V2, comp (invShift, s)), Vs\', body occ)) | checkGoalW (G0, Q0, Rl, (Pi ((D, Maybe), V), s), (V\', s\'), occ)  = checkGoal (Decl (G0, decLUName (G0, decSub (D, s))), Decl (Q0, All), shiftRCtx Rl (fun s -> comp (s, shift)), (V, dot1 s), (V\', comp (s\', shift)), body occ) | checkGoalW (G0, Q0, Rl, Vs as (Root (Const a, S), s), Vs\' as (Root (Const a\', S\'), s\'), occ)  = (* only if a terminates? *) (* always succeeds? -fp *) (* always succeeds? -fp *) let rec lookup (Empty, f)  = Empty | lookup (a\'s as LE (a, a\'s\'), f)  = if (f a) then a\'s else lookup (a\'s\', f) | lookup (a\'s as LT (a, a\'s\'), f)  = if (f a) then a\'s else lookup (a\'s\', f) let P = selectOcc (a, (S, s), occ) let P\' = select (a\', (S\', s\')) let a\'s = mutLookup a in (match lookup (a\'s, fun x\' -> x\' = a\') with Empty -> () | LE _ -> (if (! chatter) > 4 then (print ("Verifying termination order:\\n"); print (rlistToString (G0, Rl)); print (" ---> " ^ orderToString (G0, Leq (P, P\')) ^ "\\n")) else (); if deduce (G0, Q0, Rl, Leq (P, P\')) then () else raise (Error\' (occ, "Termination violation:\\n" ^ rlistToString (G0, Rl) ^ " ---> " ^ orderToString (G0, Leq (P, P\'))))) | LT _ -> (if (! chatter) > 4 then (print "Verifying termination order:\\n"; print (rlistToString (G0, Rl) ^ " ---> "); print (orderToString (G0, Less (P, P\')) ^ "\\n")) else (); if deduce (G0, Q0, Rl, Less (P, P\')) then () else raise (Error\' (occ, "Termination violation:\\n" ^ rlistToString (G0, Rl) ^ " ---> " ^ orderToString (G0, Less (P, P\')))))) | checkGoalW (G0, Q0, Rl, Vs as (Root (Def a, S), s), Vs\', occ)  = raise (Error\' (occ, "Reduction checking for defined type families not yet available:\\n" ^ "Illegal use of " ^ qidToString (constQid a) ^ ".")) | checkGoalW (G0, Q0, Rl, Vs, Vs\' as (Root (Def a\', S\'), s\'), occ)  = raise (Error\' (occ, "Reduction checking for defined type families not yet available:\\n" ^ "Illegal use of " ^ qidToString (constQid a\') ^ "."))(* checkSubgoals (G0, Q0, Rl, Vs, n, (G, Q), Vs, occ)\n\n      if    G0 |- Q0\n       and  G0 |- s : G1    and   G1 |- V : L\n       and  V[s] does not contain any skolem constants\n       and  Rl is a list of reduction propositions\n       and  G0 |- Rl\n       and  G0 |- V[s]\n       and  G0 = G0\', G\' where G\' <= G\n       and  n = |G\'| - |G|\n       and  G0 |- G[^n]\n       and  G |- Q\n     and\n       V[s] satisfies the associated termination order\n\n     *) checkSubgoals (G0, Q0, Rl, Vs, n, (Decl (G, D as Dec (_, V\')), Decl (Q, And (occ))))  = let _ = checkGoal (G0, Q0, Rl, (V\', Shift (n + 1)), Vs, occ) let RO = getROrder (G0, Q0, (V\', Shift (n + 1)), occ) let Rl\' = match RO with NONE -> Rl | SOME (O) -> O :: Rl in checkSubgoals (G0, Q0, Rl\', Vs, n + 1, (G, Q)) | checkSubgoals (G0, Q0, Rl, Vs, n, (Decl (G, D), Decl (Q, Exist)))  = checkSubgoals (G0, Q0, Rl, Vs, n + 1, (G, Q)) | checkSubgoals (G0, Q0, Rl, Vs, n, (Decl (G, D), Decl (Q, All)))  = checkSubgoals (G0, Q0, Rl, Vs, n + 1, (G, Q)) | checkSubgoals (G0, Q0, Rl, Vs, n, (Null, Null))  = ()(* checkClause (GQR as (G0, Q0, Rl), G, Q, Vs, occ)\n\n      if   G0, G |- Q0, Q\n       and  G0, G |- s : G1    and   G1 |- V : L\n       and  V[s] does not contain any skolem constants\n       and  Rl is a list of reduction propositions\n       and  G0, G |- Rl\n       and  G0, G |- V[s]\n     and\n       V[s] satisfies the associated termination order\n     *) checkClause (GQR, G, Q, Vs, occ)  = checkClauseW (GQR, G, Q, whnf Vs, occ)checkClauseW (GQR, G, Q, (Pi ((D, Maybe), V), s), occ)  = checkClause (GQR, Decl (G, decEName (G, decSub (D, s))), Decl (Q, Exist), (V, dot1 s), body occ) | checkClauseW (GQR, G, Q, (Pi ((D as Dec (_, V1), No), V2), s), occ)  = checkClause (GQR, Decl (G, decSub (D, s)), Decl (Q, And (label occ)), (V2, dot1 s), body occ) | checkClauseW (GQR as (G0, Q0, Rl), G, Q, Vs as (Root (Const a, S), s), occ)  = let n = ctxLength G let Rl\' = shiftRCtx Rl (fun s -> comp (s, Shift n)) in checkSubgoals (concat (G0, G), concat (Q0, Q), Rl\', Vs, 0, (G, Q)) | checkClauseW (GQR, G, Q, (Root (Def a, S), s), occ)  = raise (Error\' (occ, "Termination checking for defined type families not yet available:\\n" ^ "Illegal use of " ^ qidToString (constQid a) ^ ".")) let rec checkClause\' (Vs, occ)  = checkClause ((Null, Null, nil), Null, Null, Vs, occ) (*-------------------------------------------------------------------*) (* Reduction Checker *) (* checkRGoal (G, Q, Rl, (V1, s1), occ) = Rl\'\'\n\n       Invariant\n       If   G : Q\n       and  G |- s1 : G1   and   G1 |- V1 : type\n       and  V1[s1], V2[s2] does not contain Skolem constants\n       and  G |- s2 : G2   and   G2 |- V2 : type\n       and occ locates V1 in declaration\n       and Rl is a context of reduction predicates\n       and  G |- Rl\n       and Rl implies that V1[s1] satisfies its associated reduction order\n\n     *) let rec checkRGoal (G, Q, Rl, Vs, occ)  = checkRGoalW (G, Q, Rl, whnf Vs, occ)checkRGoalW (G, Q, Rl, Vs as (Root (Const a, S), s), occ)  = () | checkRGoalW (G, Q, Rl, (Pi ((D, Maybe), V), s), occ)  = checkRGoal (Decl (G, decLUName (G, decSub (D, s))), Decl (Q, All), shiftRCtx Rl (fun s -> comp (s, shift)), (V, dot1 s), body occ) | checkRGoalW (G, Q, Rl, (Pi ((D as Dec (_, V1), No), V2), s), occ)  = (checkRClause (G, Q, Rl, (V1, s), label occ); checkRGoal (G, Q, Rl, (V2, comp (invShift, s)), body occ)) | checkRGoalW (G, Q, Rl, (Root (Def a, S), s), occ)  = raise (Error\' (occ, "Reduction checking for defined type families not yet available:\\n" ^ "Illegal use of " ^ qidToString (constQid a) ^ "."))(* checkRImp (G, Q, Rl, (V1, s1), (V2, s2), occ) = ()\n\n       Invariant\n       If   G : Q\n       and  G |- s1 : G1   and   G1 |- V1 : type\n       and  V1[s1], V2[s2] does not contain Skolem constants\n       and  G |- s2 : G2   and   G2 |- V2 : type\n       and occ locates V1 in declaration\n       and Rl is a context for derived reduction order assumptions\n       and G |- Rl\n\n       then Rl implies that  V2[s2] satisfies its associated reduction order\n            with respect to V1[s1]\n    *) checkRImp (G, Q, Rl, Vs, Vs\', occ)  = checkRImpW (G, Q, Rl, whnf Vs, Vs\', occ)checkRImpW (G, Q, Rl, (Pi ((D\', Maybe), V\'), s\'), (V, s), occ)  = checkRImp (Decl (G, decEName (G, decSub (D\', s\'))), Decl (Q, Exist), shiftRCtx Rl (fun s -> comp (s, shift)), (V\', dot1 s\'), (V, comp (s, shift)), occ) | checkRImpW (G, Q, Rl, (Pi ((D\' as Dec (_, V1), No), V2), s\'), (V, s), occ)  = let Rl\' = match getROrder (G, Q, (V1, s\'), occ) with NONE -> Rl | SOME (O) -> O :: Rl in checkRImp (G, Q, Rl\', (V2, comp (invShift, s\')), (V, s), occ) | checkRImpW (G, Q, Rl, Vs\' as (Root (Const a, S), s), Vs, occ)  = checkRGoal (G, Q, Rl, Vs, occ) | checkRImpW (G, Q, Rl, Vs\' as (Root (Def a, S), s), Vs, occ)  = raise (Error\' (occ, "Reduction checking for defined type families not yet available:\\n" ^ "Illegal use of " ^ qidToString (constQid a) ^ "."))(* checkRClause (G, Q, Rl, (V, s)) = ()\n\n       Invariant:\n       If G: Q\n       and  G |- s : G1    and   G1 |- V : L\n       and  V[s] does not contain any Skolem constants\n       and  Rl is a context of reduction predicates\n       and  G |- Rl\n       then Rl implies that V[s] satifies the reduction order\n    *) checkRClause (G, Q, Rl, Vs, occ)  = checkRClauseW (G, Q, Rl, whnf Vs, occ)checkRClauseW (G, Q, Rl, (Pi ((D, Maybe), V), s), occ)  = checkRClause (Decl (G, decEName (G, decSub (D, s))), Decl (Q, Exist), shiftRCtx Rl (fun s -> comp (s, shift)), (V, dot1 s), body occ) | checkRClauseW (G, Q, Rl, (Pi ((D as Dec (_, V1), No), V2), s), occ)  = (* N.decEName (G, I.decSub (D, s)) *) (* will not be used *) let G\' = Decl (G, decSub (D, s)) let Q\' = Decl (Q, Exist) let Rl\' = shiftRCtx Rl (fun s -> comp (s, shift)) let Rl\'\' = match getROrder (G\', Q\', (V1, comp (s, shift)), occ) with NONE -> Rl\' | SOME (O) -> O :: Rl\' in checkRClause (G\', Q\', Rl\'\', (V2, dot1 s), body occ); checkRImp (G\', Q\', Rl\'\', (V2, dot1 s), (V1, comp (s, shift)), label occ) | checkRClauseW (G, Q, Rl, Vs as (Root (Const a, S), s), occ)  = let RO = match selectROrder (a, (S, s)) with NONE -> raise (Error\' (occ, "No reduction order assigned for " ^ qidToString (constQid a) ^ ".")) | SOME (O) -> O let _ = if ! chatter > 4 then print ("Verifying reduction property:\\n" ^ rlistToString (G, Rl) ^ " ---> " ^ orderToString (G, RO) ^ " \\n") else () in if deduce (G, Q, Rl, RO) then () else raise (Error\' (occ, "Reduction violation:\\n" ^ rlistToString (G, Rl) ^ " ---> " ^ (* rename ctx ??? *)  orderToString (G, RO))) | checkRClauseW (G, Q, Rl, VS as (Root (Def a, S), s), occ)  = raise (Error\' (occ, "Reduction checking for defined type families not yet available:\\n" ^ "Illegal use of " ^ qidToString (constQid a) ^ ".")) (* checkFamReduction a = ()\n\n       Invariant:\n       a is name of type family in the signature\n       raises invariant, if clauses for a does not fulfill\n       specified reducation property\n\n       Note: checking reduction is a separate property of termination\n    *) let rec checkFamReduction a  = let rec checkFam\' []  = (if ! chatter > 3 then print "\\n" else (); ()) | checkFam\' (Const (b) :: bs)  = (if (! chatter) > 3 then print (qidToString (constQid b) ^ " ") else (); (* reuse variable names when tracing *) if (! chatter) > 4 then (varReset Null; print "\\n") else (); (try  with ); checkFam\' bs) | checkFam\' (Def (d) :: bs)  = (if (! chatter) > 3 then print (qidToString (constQid d) ^ " ") else (); (* reuse variable names when tracing *) if (! chatter) > 4 then (varReset Null; print "\\n") else (); (try  with ); checkFam\' bs) let _ = if (! chatter) > 3 then print ("Reduction checking family " ^ qidToString (constQid a) ^ ":\\n") else () in checkFam\' (lookup a) (* checkFam a = ()\n\n       Invariant:\n       a is name of type family in the signature\n       raises invariant, if clauses for a do not terminate\n       according to specified termination order\n\n       Note: termination checking takes into account proven\n             reduction properties.\n    *) let rec checkFam a  = let rec checkFam\' []  = (if ! chatter > 3 then print "\\n" else (); ()) | checkFam\' (Const b :: bs)  = (if (! chatter) > 3 then print (qidToString (constQid b) ^ " ") else (); (* reuse variable names when tracing *) if (! chatter) > 4 then (varReset Null; print "\\n") else (); (try  with ); checkFam\' bs) | checkFam\' (Def (d) :: bs)  = (if (! chatter) > 3 then print (qidToString (constQid d) ^ " ") else (); (* reuse variable names when tracing *) if (! chatter) > 4 then (varReset Null; print "\\n") else (); (try  with ); checkFam\' bs) let _ = if (! chatter) > 3 then print ("Termination checking family " ^ qidToString (constQid a) ^ "\\n") else () in checkFam\' (lookup a) let rec reset ()  = (reset (); resetROrder ()) let reset = reset let checkFamReduction = checkFamReduction let checkFam = checkFam  (* local *)  end\n(* functor Reduces  *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Reasoning about orders *) (* Author: Brigitte Pientka *) module type CHECKING = sig (*! structure IntSyn : INTSYN !*) module Order : ORDER(*! structure Paths : PATHS !*) (* If Q marks all parameters in a context G we write   G : Q  *) type QuantifierAllExistAndocc(*     | And                     *) type 'aPredicateLess'a * 'aLeq'a * 'aEq'a * 'aPiDec * 'a Predicatetype order = eclo * eclo Order(* reduction predicate context (unordered) *) type rctx = order Predicate list(* mixed-prefix context *) type qctx = Quantifier Ctxval shiftRCtx : rctx -> (Sub -> Sub) -> rctxval shiftPred : order Predicate -> (Sub -> Sub) -> order Predicateval deduce : dctx * qctx * rctx * order Predicate -> bool end\n(* signature CHECKING *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Reasoning about structural orders *) (* Author: Brigitte Pientka *) (* for reasoning about orders see [Pientka IJCAR\'01] *) module Checking (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Index : INDEX(*! sharing Index.IntSyn = IntSyn\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) module Formatter : FORMATTERmodule Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) PrintFormatterFormattermodule Order : ORDER(*! sharing Order.IntSyn = IntSyn\' !*) (*! structure Paths  : PATHS !*) module Origins : ORIGINS(*! sharing Origins.Paths = Paths !*) (*! sharing Origins.IntSyn = IntSyn\' !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn\' !*) ) : CHECKING = struct (*! structure IntSyn = IntSyn\' !*)  module Order = Order (*! structure Paths = Paths !*)  type Quantifier = All | Exist | And of occ (*     | And                     *)  (* If Q marks all parameters in a context G we write   G : Q               *)  type Predicate = Less of \'a * \'a | Leq of \'a * \'a | Eq of \'a * \'a | Pi of Dec * \'a Predicate (* Abbreviation *)  type order = eclo * eclo Order (* reduction order assumptions (unordered) *)  type rctx = order Predicate list (* mixed prefix order contex *)  type qctx = Quantifier Ctx module I = IntSynmodule P = Pathsmodule N = Namesmodule F = Formattermodule R = Order(* Reasoning about order relations *) (*\n    Typing context        G\n    mixed prefix context  Q  := . | All | Existental\n\n    Orders                0  := U[s1] : V[s2] | Lex O1 ... On | Simul O1 ... On\n    Order Relation        P  := O < O\' | O <= O\' | O = O\'\n\n    Atomic Order Relation P\' := U[s1] : V[s2] <  U\'[s1\'] : V\'[s2\'] |\n                                U[s1] : V[s2] <= U\'[s1\'] : V\'[s2\'] |\n                                U[s1] : V[s2] =  U\'[s1\'] : V\'[s2\']\n\n    Order Relation Ctx    D  := . | R , D\n    Atomic Order Rel. Ctx D\' := . | R\',  D\'\n\n    Invariant:\n\n    sometimes we write G |- P as an abbreviation\n\n    if P = (O < O\')    then G |- O and G |- O\'\n    if P = (O <= O\')    then G |- O and G |- O\'\n    if P = (O = O\')    then G |- O and G |- O\'\n\n    if O = Lex O1 .. On  then G |- O1 and ....G |- On\n    if O = Simul O1 .. On  then G |- O1 and ....G |- On\n\n    if O = U[s1] : V[s2]\n      then     G : Q\n           and G |- s1 : G1, G1 |- U : V1\n           and G |- s2 : G2   G2 |- V : L\n           and G |- U[s1] : V[s2]\n\n  *) (*--------------------------------------------------------------------*) (* Printing atomic orders *) let rec atomicPredToString (G, Less ((Us, _), (Us\', _)))  = expToString (G, EClo (Us)) ^ " < " ^ expToString (G, EClo (Us\')) | atomicPredToString (G, Leq ((Us, _), (Us\', _)))  = expToString (G, EClo (Us)) ^ " <= " ^ expToString (G, EClo (Us\')) | atomicPredToString (G, Eq ((Us, _), (Us\', _)))  = expToString (G, EClo (Us)) ^ " = " ^ expToString (G, EClo (Us\')) let rec atomicRCtxToString (G, nil)  = " " | atomicRCtxToString (G, O :: nil)  = atomicPredToString (G, O) | atomicRCtxToString (G, O :: D\')  = atomicRCtxToString (G, D\') ^ ", " ^ atomicPredToString (G, O) (*--------------------------------------------------------------------*) (* shifting substitutions *) (* shiftO O f = O\'\n\n      if O is an order\n         then we shift the substitutions which are associated\n         with its terms by applying f to it\n    *) let rec shiftO (Arg ((U, us), (V, vs))) f  = Arg ((U, (f us)), (V, (f vs))) | shiftO (Lex L) f  = Lex (map (fun O -> shiftO O f) L) | shiftO (Simul L) f  = Simul (map (fun O -> shiftO O f) L) let rec shiftP (Less (O1, O2)) f  = Less (shiftO O1 f, shiftO O2 f) | shiftP (Leq (O1, O2)) f  = Leq (shiftO O1 f, shiftO O2 f) | shiftP (Eq (O1, O2)) f  = Eq (shiftO O1 f, shiftO O2 f) | shiftP (Pi (D as Dec (X, V), P)) f  = Pi (D, shiftP P f) let rec shiftRCtx Rl f  = map (fun p -> shiftP p f) Rl let rec shiftArg (Less (((U1, s1), (V1, s1\')), ((U2, s2), (V2, s2\')))) f  = Less (((U1, (f s1)), (V1, (f s1\'))), (((U2, (f s2)), (V2, (f s2\'))))) | shiftArg (Leq (((U1, s1), (V1, s1\')), ((U2, s2), (V2, s2\')))) f  = Leq (((U1, (f s1)), (V1, (f s1\'))), (((U2, (f s2)), (V2, (f s2\'))))) | shiftArg (Eq (((U1, s1), (V1, s1\')), ((U2, s2), (V2, s2\')))) f  = Eq (((U1, (f s1)), (V1, (f s1\'))), (((U2, (f s2)), (V2, (f s2\'))))) let rec shiftACtx Rl f  = map (fun p -> shiftArg p f) Rl (*--------------------------------------------------------------------*) (* Printing *) let rec fmtOrder (G, O)  = let rec fmtOrder\' (Arg (Us as (U, s), Vs as (V, s\')))  = Hbox [String "("; formatExp (G, EClo Us); String ")"] | fmtOrder\' (Lex L)  = Hbox [String "{"; HOVbox0 1 0 1 (fmtOrders L); String "}"] | fmtOrder\' (Simul L)  = Hbox [String "["; HOVbox0 1 0 1 (fmtOrders L); String "]"]fmtOrders []  = [] | fmtOrders (O :: [])  = fmtOrder\' O :: [] | fmtOrders (O :: L)  = fmtOrder\' O :: Break :: fmtOrders L in fmtOrder\' O let rec fmtComparison (G, O, comp, O\')  = HOVbox0 1 0 1 [fmtOrder (G, O); Break; String comp; Break; fmtOrder (G, O\')] let rec fmtPredicate\' (G, Less (O, O\'))  = fmtComparison (G, O, "<", O\') | fmtPredicate\' (G, Leq (O, O\'))  = fmtComparison (G, O, "<=", O\') | fmtPredicate\' (G, Eq (O, O\'))  = fmtComparison (G, O, "=", O\') | fmtPredicate\' (G, Pi (D, P))  = (* F.String "Pi predicate"  *)  Hbox [String "Pi "; fmtPredicate\' (Decl (G, D), P)] let rec fmtPredicate (G, P)  = fmtPredicate\' (ctxName G, P) let rec fmtRGCtx\' (G, nil)  = "" | fmtRGCtx\' (G, [P])  = makestring_fmt (fmtPredicate\' (G, P)) | fmtRGCtx\' (G, (P :: Rl))  = makestring_fmt (fmtPredicate\' (G, P)) ^ " ," ^ fmtRGCtx\' (G, Rl) let rec fmtRGCtx (G, Rl)  = fmtRGCtx\' (ctxName G, Rl) (*--------------------------------------------------------------------*) (* init () = true\n\n       Invariant:\n       The inital constraint continuation\n    *) let rec init ()  = true let rec eqCid (c, c\')  = (c = c\') let rec conv ((Us, Vs), (Us\', Vs\'))  = conv (Vs, Vs\') && conv (Us, Us\') let rec isUniversal (All)  = true | isUniversal (Exist)  = false | isUniversal (Exist\')  = false let rec isExistential (All)  = false | isExistential (Exist)  = true | isExistential (Exist\')  = true (* isParameter (Q, X) = B\n\n       Invariant:\n       If   G |- X : V\n       and  G : Q\n       then B holds iff X is unrestricted (uninstantiated and free\n       of constraints, or lowered only) or instantiated to a universal parameter\n    *) let rec isParameter (Q, X)  = isParameterW (Q, whnf (X, id))isParameterW (Q, Us)  = try  with(* isFreeEVar (Us) = true\n       iff Us represents a possibly lowered uninstantiated EVar.\n\n       Invariant: it participated only in matching, not full unification\n    *) isFreeEVar (EVar (_, _, _, ref []), _)  = true | isFreeEVar (Lam (D, U), s)  = isFreeEVar (whnf (U, dot1 s)) | isFreeEVar _  = false (* isAtomic (G, X) = true\n       Invariant:\n       If G |- X : V\n       and G : Q\n       then B holds iff X is an atomic term which is not a parameter\n     *) let rec isAtomic (GQ, Us)  = isAtomicW (GQ, whnf Us)isAtomicW (GQ, (X as Root (Const c, S), s))  = isAtomicS (GQ, (S, s)) | isAtomicW (GQ, (X as Root (Def c, S), s))  = isAtomicS (GQ, (S, s)) | isAtomicW (GQ as (G, Q), (X as Root (BVar n, S), s))  = isExistential (ctxLookup (Q, n)) || isAtomicS (GQ, (S, s)) | isAtomicW (GQ, _)  = falseisAtomicS (GQ, (Nil, _))  = true | isAtomicS (GQ, (SClo (S, s\'), s\'\'))  = isAtomicS (GQ, (S, comp (s\', s\'\'))) | isAtomicS (GQ, (App (U\', S\'), s1\'))  = false (*-----------------------------------------------------------*) (* eq (G, ((U, s1), (V, s2)), ((U\', s1\'), (V\', s2\')), sc) = B\n\n       Invariant:\n       B holds  iff\n            G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s\' : G3  G3 |- U\' : V\'\n       and  U[s1] is unifiable with to U\'[s\']\n       and  all restrictions in sc are satisfied\n       and V[s2] is atomic\n       and only U\'[s\'] contains EVars\n    *) let rec eq (G, (Us, Vs), (Us\', Vs\'))  = unifiable (G, Vs, Vs\') && unifiable (G, Us, Us\') (* lookupEq (GQ, D, UsVs, UsVs\', sc) = B\n\n     B holds iff\n\n     and  D is an atomic order relation ctx\n     and  UsVs and UsVs\' are atomic and may contain EVars\n\n          G : Q\n     and  G |- s1 : G1   G1 |- U : V1\n     and  G |- s2 : G2   G2 |- V : L\n     and  G |- U[s1] : V [s2]\n     and  G |- s\' : G3  G3 |- U\' : V\'\n\n     if there exists Eq(UsVs1, UsVs1\') in D\n        s.t. UsVs1 unifies with UsVs and\n             UsVs1\' unifies with UsVs\' and\n             all restrictions in sc are satisfied\n     or\n     if there exists Eq(UsVs1, UsVs1\') in D\n        s.t. UsVs1\' unifies with UsVs and\n             UsVs1 unifies with UsVs\' and\n             all restrictions in sc are satisfied\n             (symmetry)\n\n\n    *) let rec lookupEq (GQ, nil, UsVs, UsVs\', sc)  = false | lookupEq (GQ, (Less (_, _) :: D), UsVs, UsVs\', sc)  = lookupEq (GQ, D, UsVs, UsVs\', sc) | lookupEq (GQ as (G, Q), (Eq (UsVs1, UsVs1\') :: D), UsVs, UsVs\', sc)  = trail (fun () -> eq (G, UsVs1, UsVs) && eq (G, UsVs1\', UsVs\') && sc ()) || trail (fun () -> eq (G, UsVs1, UsVs\') && eq (G, UsVs1\', UsVs) && sc ()) || lookupEq (GQ, D, UsVs, UsVs\', sc) (* lookupLt (GQ, D, UsVs, UsVs\', sc) = B\n\n     B holds iff\n\n     and  D is an atomic order relation ctx\n     and  UsVs and UsVs\' are atomic and may contain EVars\n\n          G : Q\n     and  G |- s1 : G1   G1 |- U : V1\n     and  G |- s2 : G2   G2 |- V : L\n     and  G |- U[s1] : V [s2]\n     and  G |- s\' : G3  G3 |- U\' : V\'\n\n     if there exists Less(UsVs1, UsVs1\') in D\n        s.t. UsVs1 unifies with UsVs and\n             UsVs1\' unifies with UsVs\' and\n             all restrictions in sc are satisfied\n    *) let rec lookupLt (GQ, nil, UsVs, UsVs\', sc)  = false | lookupLt (GQ, (Eq (_, _) :: D), UsVs, UsVs\', sc)  = lookupLt (GQ, D, UsVs, UsVs\', sc) | lookupLt (GQ as (G, Q), (Less (UsVs1, UsVs1\') :: D), UsVs, UsVs\', sc)  = trail (fun () -> eq (G, UsVs1, UsVs) && eq (G, UsVs1\', UsVs\') && sc ()) || lookupLt (GQ, D, UsVs, UsVs\', sc) (*  eqAtomic (GQ, D, D\', UsVs, UsVs\', sc) = B\n\n        B iff\n            UsVs unifies with UsVs\'                (identity)\n        or  D, UsVs = UsVs\', D\' ---> UsVs = UsVs\'  (ctx lookup)\n        or  D, UsVs\' = UsVs, D\' ---> UsVs = UsVs\'  (ctx lookup + symmetry)\n        or  D, D\' ---> UsVs = UsVs\' by transitivity\n\n     *) let rec eqAtomic (GQ as (G, Q), nil, D\', UsVs, UsVs\', sc)  = trail (fun () -> eq (G, UsVs, UsVs\') && sc ()) || lookupEq (GQ, D\', UsVs, UsVs\', sc) | eqAtomic (GQ as (G, Q), D, D\', UsVs, UsVs\', sc)  = trail (fun () -> eq (G, UsVs, UsVs\') && sc ()) || lookupEq (GQ, D, UsVs, UsVs\', sc) || lookupEq (GQ, D\', UsVs, UsVs\', sc) || transEq (GQ, D, D\', UsVs, UsVs\', sc)(* transEq (GQ, D, D\', UsVs, UsVs\', sc) = B\n\n     B iff\n        if D, UsVs\' = UsVs1 ; D\' ---> UsVs = UsVs\'\n          then  D, D\' ---> UsVs = UsVs1            (transEq1)\n\n        or\n\n        if D, UsVs1 = UsVs\'; D\' ---> UsVs = UsVs\'  (transEq2)\n          then  D, D\' ---> UsVs = UsVs1\n\n       or\n\n       if D, UsVs1 = UsVs\'; D\' ---> UsVs = UsVs\'\n         then D; UsVs1 = UsVs\' D\' ---> UsVs = UsVs\'\n   *) transEq (GQ as (G, Q), nil, D, UsVs, UsVs\', sc)  = false | transEq (GQ as (G, Q), (Eq (UsVs1, UsVs1\') :: D), D\', UsVs, UsVs\', sc)  = trail (fun () -> eq (G, UsVs1\', UsVs\') && sc () && eqAtomicR (GQ, (D @ D\'), UsVs, UsVs1, sc, atomic)) || trail (fun () -> eq (G, UsVs1, UsVs\') && sc () && eqAtomicR (GQ, (D @ D\'), UsVs, UsVs1\', sc, atomic)) || transEq (GQ, D, (Eq (UsVs1, UsVs1\') :: D\'), UsVs, UsVs\', sc) | transEq (GQ as (G, Q), (Less (UsVs1, UsVs1\') :: D), D\', UsVs, UsVs\', sc)  = transEq (GQ, D, D\', UsVs, UsVs\', sc)(* ltAtomic (GQ, D, D\', UsVs, UsVs\', sc) = B\n\n     B iff\n        if D, UsVs <UsVs\' ; D\' ---> UsVs < UsVs\'   (identity)\n\n        or\n\n        if D, UsVs1 = UsVs\'; D\' ---> UsVs = UsVs\'  (transEq2)\n          then  D, D\' ---> UsVs = UsVs1\n\n       or\n\n       if D, UsVs1 = UsVs\'; D\' ---> UsVs = UsVs\'\n         then D; UsVs1 = UsVs\' D\' ---> UsVs = UsVs\'\n   *) ltAtomic (GQ as (G, Q), nil, D\', UsVs, UsVs\', sc)  = lookupLt (GQ, D\', UsVs, UsVs\', sc) | ltAtomic (GQ as (G, Q), D, D\', UsVs, UsVs\', sc)  = lookupLt (GQ, D, UsVs, UsVs\', sc) || lookupLt (GQ, D\', UsVs, UsVs\', sc) || transLt (GQ, D, D\', UsVs, UsVs\', sc)(* transLt (GQ, D, D\', UsVs, UsVs\', sc) = B\n\n     B iff\n        if D, UsVs\' = UsVs1 ; D\' ---> UsVs = UsVs\'\n          then  D, D\' ---> UsVs = UsVs1            (transEq1)\n\n        or\n\n        if D, UsVs1 = UsVs\'; D\' ---> UsVs = UsVs\'  (transEq2)\n          then  D, D\' ---> UsVs = UsVs1\n\n       or\n\n       if D, UsVs1 = UsVs\'; D\' ---> UsVs = UsVs\'\n         then D; UsVs1 = UsVs\' D\' ---> UsVs = UsVs\'\n   *) transLt (GQ as (G, Q), nil, D, UsVs, UsVs\', sc)  = false | transLt (GQ as (G, Q), (Eq (UsVs1, UsVs1\') :: D), D\', UsVs, UsVs\', sc)  = trail (fun () -> eq (G, UsVs1\', UsVs\') && sc () && ltAtomicR (GQ, (D @ D\'), UsVs, UsVs1, sc, atomic)) || trail (fun () -> eq (G, UsVs1, UsVs\') && sc () && ltAtomicR (GQ, (D @ D\'), UsVs, UsVs1\', sc, atomic)) || transLt (GQ, D, (Eq (UsVs1, UsVs1\') :: D\'), UsVs, UsVs\', sc) | transLt (GQ as (G, Q), (Less (UsVs1, UsVs1\') :: D), D\', UsVs, UsVs\', sc)  = trail (fun () -> eq (G, UsVs1\', UsVs\') && sc () && eqAtomicR (GQ, (D @ D\'), UsVs, UsVs1, sc, atomic)) || trail (fun () -> eq (G, UsVs1\', UsVs\') && sc () && ltAtomicR (GQ, (D @ D\'), UsVs, UsVs1, sc, atomic)) || transLt (GQ, D, (Less (UsVs1, UsVs1\') :: D\'), UsVs, UsVs\', sc)(* atomic (GQ, D, P) = B\n\n     An atomic order context D\' is maximally decomposed iff\n\n          T := Root(c, Nil) | Root(n, Nil)\n    and   T\' := Root(c,S) | Root(n, S)\n    and   all atomic order relations in D\' are\n          either T\' < T or T1\' = T1\'\n\n   An atomic order P\' is maximally decomposed iff\n          T := Root(c, nil) | Root(n, Nil)\n    and   T\' := Root(c,S) | Root(n, S)\n    and   T\' < T or T1 = T1\n\n    Invariant:\n\n    B iff\n          D and P are maximally decomposed,\n      and they may contain EVars\n      and G : Q\n      and G |- P\n      and G |- D\n      and D --> P\n\n      *) atomic (GQ, D, D\', Eq (UsVs, UsVs\'), sc)  = eqAtomic (GQ, D, D\', UsVs, UsVs\', sc) | atomic (GQ, D, D\', Less (UsVs, UsVs\'), sc)  = ltAtomic (GQ, D, D\', UsVs, UsVs\', sc)(*-----------------------------------------------------------*) (* leftInstantiate ((G,Q), D, D\', P, sc) = B\n\n     B iff\n           G : Q\n       and G |- D\n       and G |- D\'\n       and G |- P\n\n       and  D is an atomic order relation ctx, which does not\n              contain any EVars\n       and  D\' is an atomic order relation ctx, which may\n              contain EVars\n       and  P\' is a atomic order relation\n\n       and  D --> P\n\n    D\' accumulates all orders\n    *) leftInstantiate (GQ as (G, Q), nil, D\', P, sc)  = if atomic (GQ, D\', nil, P, sc) then (if ! chatter > 4 then print (" Proved: " ^ atomicRCtxToString (G, D\') ^ " ---> " ^ atomicPredToString (G, P) ^ "\\n") else (); true) else (* should never happen by invariant *) false | leftInstantiate (GQ, (Less (UsVs, UsVs\') :: D), D\', P, sc)  = ltInstL (GQ, D, D\', UsVs, UsVs\', P, sc) | leftInstantiate (GQ, (Leq (UsVs, UsVs\') :: D), D\', P, sc)  = leInstL (GQ, D, D\', UsVs, UsVs\', P, sc) | leftInstantiate (GQ, (Eq (UsVs, UsVs\') :: D), D\', P, sc)  = eqInstL (GQ, D, D\', UsVs, UsVs\', P, sc)(* ltInstL ((G, Q), D, D\', UsVs, UsVs\', P, sc) = B\n     Invariant:\n       B holds  iff\n            G : Q\n       and  D is an atomic order relation ctx\n       and  D\' is an atomic order relation ctx\n       and  P\' is a atomic order relation\n\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V [s2]\n       and  G |- s\' : G3  G3 |- U\' : V\'\n       and  sc is a constraint continuation representing restrictions on EVars\n       and  V[s2] atomic\n       and  only U[s1] contains EVars\n       and  D, D\', U[s1] < U\'[s\'] ---> P\n    *) ltInstL (GQ, D, D\', UsVs, UsVs\', P\', sc)  = ltInstLW (GQ, D, D\', whnfEta UsVs, UsVs\', P\', sc)ltInstLW (GQ as (G, Q), D, D\', ((Lam (Dec as Dec (_, V1), U), s1), (Pi ((Dec (_, V2), _), V), s2)), ((U\', s1\'), (V\', s2\')), P\', sc)  = if equiv (targetFam V\', targetFam V1)(* == I.targetFam V2\' *)  then (* = I.newEVar (I.EClo (V2\', s2\')) *) (* enforces that X can only bound to parameter or remain uninstantiated *) let X = newEVar (G, EClo (V1, s1)) let sc\' = fun () -> (isParameter (Q, X) && sc ()) in ltInstL ((G, Q), D, D\', ((U, Dot (Exp (X), s1)), (V, Dot (Exp (X), s2))), ((U\', s1\'), (V\', s2\')), P\', sc\') else if below (targetFam V1, targetFam V\') then (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1, s1)) in ltInstL ((G, Q), D, D\', ((U, Dot (Exp (X), s1)), (V, Dot (Exp (X), s2))), ((U\', s1\'), (V\', s2\')), P\', sc) else false | ltInstLW (GQ, D, D\', UsVs, UsVs\', P\', sc)  = leftInstantiate (GQ, D, (Less (UsVs, UsVs\') :: D\'), P\', sc)(* leInstL ((G, Q), D, D\', UsVs, UsVs\', P\', sc) = B\n     Invariant:\n       B holds  iff\n            G : Q\n       and  D is an atomic order relation ctx\n       and  D\' is an atomic order relation ctx\n       and  P\' is a atomic order relation\n\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V [s2]\n       and  G |- s\' : G3  G3 |- U\' : V\'\n       and  sc is a constraint continuation representing restrictions on EVars\n       and  V[s2] atomic\n       and  only U[s1] contains EVars\n       and  D, D\', U[s1] <= U\'[s\'] ---> P\'\n    *) leInstL (GQ, D, D\', UsVs, UsVs\', P\', sc)  = leInstLW (GQ, D, D\', whnfEta UsVs, UsVs\', P\', sc)leInstLW (GQ as (G, Q), D, D\', ((Lam (Dec (_, V1), U), s1), (Pi ((Dec (_, V2), _), V), s2)), ((U\', s1\'), (V\', s2\')), P\', sc)  = if equiv (targetFam V\', targetFam V1)(* == I.targetFam V2\' *)  then (* = I.newEVar (I.EClo (V2\', s2\')) *) (* enforces that X can only bound to parameter or remain uninstantiated *) let X = newEVar (G, EClo (V1, s1)) let sc\' = fun () -> (isParameter (Q, X) && sc ()) in leInstL ((G, Q), D, D\', ((U, Dot (Exp (X), s1)), (V, Dot (Exp (X), s2))), ((U\', s1\'), (V\', s2\')), P\', sc\') else if below (targetFam V1, targetFam V\') then (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1, s1)) in leInstL ((G, Q), D, D\', ((U, Dot (Exp (X), s1)), (V, Dot (Exp (X), s2))), ((U\', s1\'), (V\', s2\')), P\', sc) else false | leInstLW (GQ, D, D\', UsVs, UsVs\', P, sc)  = leftInstantiate (GQ, D, (Less (UsVs, UsVs\') :: D\'), P, sc)(* eqInstL ((G, Q), D, D\', UsVs, UsVs\', P, sc) = B\n\n     Invariant:\n       B holds  iff\n            G : Q\n       and  D is an atomic order relation ctx\n       and  D\' is an atomic order relation ctx\n       and  P\' is a atomic order relation\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V [s2]\n       and  G |- s\' : G3  G3 |- U\' : V\'\n       and  sc is a constraint continuation representing restrictions on EVars\n       and  V[s2] atomic\n       and  only U[s1] and U\'[s\'] contain EVars\n       and  D, D\', U[s1] = U\'[s\'] ---> P\'\n    *) eqInstL (GQ, D, D\', UsVs, UsVs\', P\', sc)  = eqInstLW (GQ, D, D\', whnfEta UsVs, whnfEta UsVs\', P\', sc)eqInstLW (GQ as (G, Q), D, D\', ((Lam (Dec (_, V1\'), U\'), s1\'), (Pi ((Dec (_, V2\'), _), V\'), s2\')), ((Lam (Dec (_, V1\'\'), U\'\'), s1\'\'), (Pi ((Dec (_, V2\'\'), _), V\'\'), s2\'\')), P\', sc)  = (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\'\', s1\'\')) in eqInstL (GQ, D, D\', ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), ((U\'\', Dot (Exp (X), s1\'\')), (V\'\', Dot (Exp (X), s2\'\'))), P\', fun () -> (isParameter (Q, X); sc ())) | eqInstLW (GQ, D, D\', UsVs, UsVs\', P\', sc)  = eqIL (GQ, D, D\', UsVs, UsVs\', P\', sc)(* eqIL ((G, Q), D, D\', UsVs, UsVs\', P, sc) = B\n\n     Invariant:\n       B holds  iff\n            G : Q\n       and  D is an atomic order relation ctx\n       and  D\' is an atomic order relation ctx\n       and  P\' is a atomic order relation\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V [s2]\n       and  G |- s\' : G3  G3 |- U\' : V\'\n       and  sc is a constraint continuation representing restrictions on EVars\n       and  V[s2] atomic\n       and  only U[s1] and U\'[s\'] contain EVars\n       and  D, D\', U[s1] = U\'[s\'] ---> P\'\n       and U, U\' will be maximally unfolded\n    *) eqIL (GQ as (G, Q), D, D\', UsVs as ((Root (Const c, S), s), Vs), UsVs\' as ((Root (Const c\', S\'), s\'), Vs\'), P\', sc)  = if eqCid (c, c\') then eqSpineIL (GQ, D, D\', ((S, s), (constType c, id)), ((S\', s\'), (constType c\', id)), P\', sc) else (if ! chatter > 4 then print (" Proved: " ^ atomicRCtxToString (G, (Eq (UsVs, UsVs\') :: D)) ^ atomicRCtxToString (G, D\') ^ " ---> " ^ atomicPredToString (G, P\') ^ "\\n") else (); true) | eqIL (GQ as (G, Q), D, D\', UsVs as ((Root (Def c, S), s), Vs), UsVs\' as ((Root (Def c\', S\'), s\'), Vs\'), P\', sc)  = if eqCid (c, c\') then eqSpineIL (GQ, D, D\', ((S, s), (constType c, id)), ((S\', s\'), (constType c\', id)), P\', sc) else (if ! chatter > 4 then print (" Proved: " ^ atomicRCtxToString (G, (Eq (UsVs, UsVs\') :: D)) ^ atomicRCtxToString (G, D\') ^ " ---> " ^ atomicPredToString (G, P\') ^ "\\n") else (); true) | eqIL (GQ as (G, Q), D, D\', (Us as (Root (Const c, S), s), Vs), (Us\' as (Root (BVar n, S\'), s\'), Vs\'), P\', sc)  = if isAtomic (GQ, Us\') then leftInstantiate (GQ, D, (Eq ((Us\', Vs\'), (Us, Vs)) :: D\'), P\', sc) else (if ! chatter > 4 then print (" Proved: " ^ atomicRCtxToString (G, (Eq ((Us, Vs), (Us\', Vs\')) :: D)) ^ atomicRCtxToString (G, D\') ^ " ---> " ^ atomicPredToString (G, P\') ^ "\\n") else (); true) | eqIL (GQ as (G, Q), D, D\', (Us as (Root (Def c, S), s), Vs), (Us\' as (Root (BVar n, S\'), s\'), Vs\'), P\', sc)  = if isAtomic (GQ, Us\') then leftInstantiate (GQ, D, (Eq ((Us\', Vs\'), (Us, Vs)) :: D\'), P\', sc) else (if ! chatter > 4 then print (" Proved: " ^ atomicRCtxToString (G, (Eq ((Us, Vs), (Us\', Vs\')) :: D)) ^ atomicRCtxToString (G, D\') ^ " ---> " ^ atomicPredToString (G, P\') ^ "\\n") else (); true) | eqIL (GQ as (G, Q), D, D\', (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (Def c, S\'), s\'), Vs\'), P\', sc)  = if isAtomic (GQ, Us) then leftInstantiate (GQ, D, (Eq ((Us, Vs), (Us\', Vs\')) :: D\'), P\', sc) else (if ! chatter > 4 then print (" Proved: " ^ atomicRCtxToString (G, (Eq ((Us, Vs), (Us\', Vs\')) :: D\')) ^ atomicRCtxToString (G, D\') ^ " ---> " ^ atomicPredToString (G, P\') ^ "\\n") else (); true) | eqIL (GQ as (G, Q), D, D\', (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (Const c, S\'), s\'), Vs\'), P\', sc)  = if isAtomic (GQ, Us) then leftInstantiate (GQ, D, (Eq ((Us, Vs), (Us\', Vs\')) :: D\'), P\', sc) else (if ! chatter > 4 then print (" Proved: " ^ atomicRCtxToString (G, (Eq ((Us, Vs), (Us\', Vs\')) :: D\')) ^ atomicRCtxToString (G, D\') ^ " ---> " ^ atomicPredToString (G, P\') ^ "\\n") else (); true) | eqIL (GQ as (G, Q), D, D\', (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (BVar n\', S\'), s\'), Vs\'), P\', sc)  = if (n = n\') then let Dec (_, V\') = ctxDec (G, n) in eqSpineIL (GQ, D, D\', ((S, s), (V\', id)), ((S\', s\'), (V\', id)), P\', sc) else leftInstantiate (GQ, D, (Eq ((Us, Vs), (Us\', Vs\')) :: D\'), P\', sc) | eqIL (GQ as (G, Q), D, D\', UsVs, UsVs\', P\', sc)  = (* (Us, Vs as (I.Pi _ , _)) and (Us\', Vs\' as (I.Root _, _))\n           or the other way\n         *)  (if ! chatter > 4 then print (" Proved: " ^ atomicRCtxToString (G, (Eq ((UsVs), (UsVs\')) :: D)) ^ atomicRCtxToString (G, D\') ^ " ---> " ^ atomicPredToString (G, P\') ^ "\\n") else (); true)eqSpineIL (GQ, D, D\', (Ss, Vs), (Ss\', Vs\'), P\', sc)  = eqSpineILW (GQ, D, D\', (Ss, whnf Vs), (Ss\', whnf Vs\'), P\', sc)eqSpineILW (GQ, D, D\', ((Nil, s), Vs), ((Nil, s\'), Vs\'), P\', sc)  = leftInstantiate (GQ, D, D\', P\', sc) | eqSpineILW (GQ, D, D\', ((SClo (S, s\'), s\'\'), Vs), SsVs\', P\', sc)  = eqSpineIL (GQ, D, D\', ((S, comp (s\', s\'\')), Vs), SsVs\', P\', sc) | eqSpineILW (GQ, D, D\', SsVs, ((SClo (S\', s\'), s\'\'), Vs\'), P\', sc)  = eqSpineIL (GQ, D, D\', SsVs, ((S\', comp (s\', s\'\')), Vs\'), P\', sc) | eqSpineILW (GQ, D, D\', ((App (U, S), s1), (Pi ((Dec (_, V1), _), V2), s2)), ((App (U\', S\'), s1\'), (Pi ((Dec (_, V1\'), _), V2\'), s2\')), P\', sc)  = let D1 = (Eq (((U, s1), (V1, s2)), ((U\', s1\'), (V1\', s2\'))) :: D) in eqSpineIL (GQ, D1, D\', ((S, s1), (V2, Dot (Exp (EClo (U, s1)), s2))), ((S\', s1\'), (V2\', Dot (Exp (EClo (U\', s1\')), s2\'))), P\', sc)(*--------------------------------------------------------------*) (* rightDecompose (GQ, D\', P) = B\n\n    B iff\n        G : Q\n    and D is maximally unfolded, but does not contain any EVars\n    and P is a order relation\n    and G |- P\n    and D --> P\n\n    *) rightDecompose (GQ, D\', Less (O, O\'))  = ordLtR (GQ, D\', O, O\') | rightDecompose (GQ, D\', Leq (O, O\'))  = ordLeR (GQ, D\', O, O\') | rightDecompose (GQ, D\', Eq (O, O\'))  = ordEqR (GQ, D\', O, O\')(* ordLtR (GQ, D, O1, O2) = B\'\n\n       Invariant:\n       If   G : Q\n       and  G |- O1 augmented subterm\n       and  G |- O2 augmented subterm not containing any EVars\n       then B\' holds iff D --> O1 < O2\n    *) ordLtR (GQ, D\', Arg UsVs, Arg UsVs\')  = ltAtomicR (GQ, D\', UsVs, UsVs\', init, leftInstantiate) | ordLtR (GQ, D\', Lex O, Lex O\')  = ltLexR (GQ, D\', O, O\') | ordLtR (GQ, D\', Simul O, Simul O\')  = ltSimulR (GQ, D\', O, O\')(* ordLeR (GQ, D, O1, O2) = B\'\n\n       Invariant:\n       If   G : Q\n       and  G |- O1 augmented subterm\n       and  G |- O2 augmented subterm not containing any EVars\n       then B\' holds iff D --> O1 <= O2\n    *) ordLeR (GQ, D\', Arg UsVs, Arg UsVs\')  = leAtomicR (GQ, D\', UsVs, UsVs\', init, leftInstantiate) | ordLeR (GQ, D\', Lex O, Lex O\')  = ltLexR (GQ, D\', O, O\') || ordEqsR (GQ, D\', O, O\') | ordLeR (GQ, D\', Simul O, Simul O\')  = leSimulR (GQ, D\', O, O\')(* ordEqR (GQ, D, O1, O2) = B\'\n\n       Invariant:\n       If   G : Q\n       and  G |- O1 augmented subterm\n       and  G |- O2 augmented subterm not containing any EVars\n       then B\' holds iff D --> O1 = O2\n    *) ordEqR (GQ, D\', Arg UsVs, Arg UsVs\')  = conv (UsVs, UsVs\') || eqAtomicR (GQ, D\', UsVs, UsVs\', init, leftInstantiate) | ordEqR (GQ, D\', Lex O, Lex O\')  = ordEqsR (GQ, D\', O, O\') | ordEqR (GQ, D\', Simul O, Simul O\')  = ordEqsR (GQ, D\', O, O\')(* ordEqsR (GQ, D\', L1, L2) = B\'\n\n       Invariant:\n       If   G : Q\n       and  G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms not containing any EVars\n       then B\' holds iff D\' --> L1 = L2\n    *) ordEqsR (GQ, D\', nil, nil)  = true | ordEqsR (GQ, D\', O :: L, O\' :: L\')  = ordEqR (GQ, D\', O, O\') && ordEqsR (GQ, D\', L, L\')(* ltLexR (GQ, D\', L1, L2) = B\'\n\n       Invariant:\n       If   G : Q\n       and  G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms not contianing any EVars\n       then B\' holds iff D\' --> L1 is lexically smaller than L2\n    *) ltLexR (GQ, D\', nil, nil)  = false | ltLexR (GQ, D\', O :: L, O\' :: L\')  = ordLtR (GQ, D\', O, O\') || (ordEqR (GQ, D\', O, O\') && ltLexR (GQ, D\', L, L\'))leLexR (GQ, D\', L, L\')  = ltLexR (GQ, D\', L, L\') || ordEqsR (GQ, D\', L, L\')(* ltSimulR (GQ, D, L1, L2) = B\'\n\n       Invariant:\n       If   G : Q\n       and  G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms not contianing any EVars\n       then B\' holds iff D implies that L1 is simultaneously smaller than L2\n    *) ltSimulR (GQ, D, nil, nil)  = false | ltSimulR (GQ, D, O :: L, O\' :: L\')  = (ordLtR (GQ, D, O, O\') && leSimulR (GQ, D, L, L\')) || (ordEqR (GQ, D, O, O\') && ltSimulR (GQ, D, L, L\'))(* leSimulR (G, Q, L1, L2) = B\'\n\n       Invariant:\n       If   G : Q\n       and  G |- L1 list of augmented subterms\n       and  G |- L2 list of augmented subterms not containing any EVars\n       then B\' holds iff D implies that L1 is simultaneously less than or equal to L2\n    *) leSimulR (GQ, D, nil, nil)  = true | leSimulR (GQ, D, O :: L, O\' :: L\')  = ordLeR (GQ, D, O, O\') && leSimulR (GQ, D, L, L\')(*--------------------------------------------------------------*) (* Atomic Orders (Right) *) (* ltAtomicR (GQ, (D, D\'), UsVs, UsVs\', sc, k) = B\n     Invariant:\n       B\' holds  iff\n            G : Q\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s1\' : G3   G3 |- U\' : V1\'\n       and  G |- s2\' : G4   G4 |- V\' : L\n       and  G |- U\'[s1\'] : V\'[s2\']\n       and  D\' implies U[s1] is a strict subterm of U\'[s1\']\n       and  sc is a constraint continuation representing restrictions on EVars\n       and only U\'[s\'] contains EVars\n       and k is a continuation describing what happens when\n           UsVs and UsVs\' are maximally unfolded\n    *) ltAtomicR (GQ, D, UsVs, UsVs\', sc, k)  = ltAtomicRW (GQ, D, whnfEta UsVs, UsVs\', sc, k)ltAtomicRW (GQ, D, UsVs as (Us, Vs as (Root _, s\')), UsVs\', sc, k)  = ltR (GQ, D, UsVs, UsVs\', sc, k) | ltAtomicRW (GQ as (G, Q), D, ((Lam (_, U), s1), (Pi ((Dec, _), V), s2)), ((U\', s1\'), (V\', s2\')), sc, k)  = let UsVs\' = ((U\', comp (s1\', shift)), (V\', comp (s2\', shift))) let UsVs = ((U, dot1 s1), (V, dot1 s2)) let D\' = shiftACtx D (fun s -> comp (s, shift)) in ltAtomicR ((Decl (G, decLUName (G, decSub (Dec, s2))), Decl (Q, All)), D\', UsVs, UsVs\', sc, k)(* leAtomicR (GQ, D, UsVs, UsVs\', sc, k) = B\n     Invariant:\n       B\' holds  iff\n            G : Q\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s1\' : G3   G3 |- U\' : V1\'\n       and  G |- s2\' : G4   G4 |- V\' : L\n       and  G |- U\'[s1\'] : V\'[s2\']\n       and  D implies U[s1] is a subterm of U\'[s1\']\n       and  sc is a constraint continuation representing restrictions on EVars\n       and only U\'[s\'] contains EVars\n       and k is a continuation describing what happens when\n           UsVs and UsVs\' are maximally unfolded\n    *) leAtomicR (GQ, D, UsVs, UsVs\', sc, k)  = leAtomicRW (GQ, D, whnfEta UsVs, UsVs\', sc, k)leAtomicRW (GQ, D, UsVs as (Us, Vs as (Root _, s\')), UsVs\', sc, k)  = leR (GQ, D, UsVs, UsVs\', sc, k) | leAtomicRW (GQ as (G, Q), D, ((Lam (_, U), s1), (Pi ((Dec, _), V), s2)), ((U\', s1\'), (V\', s2\')), sc, k)  = let D\' = shiftACtx D (fun s -> comp (s, shift)) let UsVs\' = ((U\', comp (s1\', shift)), (V\', comp (s2\', shift))) let UsVs = ((U, dot1 s1), (V, dot1 s2)) in leAtomicR ((Decl (G, decLUName (G, decSub (Dec, s2))), Decl (Q, All)), D\', UsVs, UsVs\', sc, k)(* eqAtomicR (GQ, D, UsVs, UsVs\', sc, k) = B\n     Invariant:\n       B\' holds  iff\n            G : Q\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s1\' : G3   G3 |- U\' : V1\'\n       and  G |- s2\' : G4   G4 |- V\' : L\n       and  G |- U\'[s1\'] : V\'[s2\']\n       and  D implies U[s1] is structurally equivalent to U\'[s1\']\n       and  sc is a constraint continuation representing restrictions on EVars\n       and only U\'[s\'] contains EVars\n       and k is a continuation describing what happens when\n           UsVs and UsVs\' are maximally unfolded\n    *) eqAtomicR (GQ as (G, Q), D, UsVs, UsVs\', sc, k)  = eqAtomicRW (GQ, D, whnfEta UsVs, whnfEta UsVs\', sc, k)eqAtomicRW (GQ as (G, Q), D, ((Lam (_, U), s1), (Pi ((Dec, _), V), s2)), ((Lam (_, U\'), s1\'), (Pi ((Dec\', _), V\'), s2\')), sc, k)  = (* Dec = Dec\' *)  eqAtomicR ((Decl (G, decLUName (G, decSub (Dec, s2))), Decl (Q, All)), shiftACtx D (fun s -> comp (s, shift)), ((U, dot1 s1\'), (V, dot1 s2\')), ((U\', dot1 s1\'), (V\', dot1 s2\')), sc, k) | eqAtomicRW (GQ, D, (Us, Vs as (Root _, s2)), (Us\', Vs\' as (Root _, s2\')), sc, k)  = eqR (GQ, D, (Us, Vs), (Us\', Vs\'), sc, k) | eqAtomicRW (GQ, D, (Us, Vs), (Us\', Vs\'), sc, k)  = (* mismatch: not equal *)  (* Fri Feb 25 21:26:39 2005 -fp !!! *)  false(* ltR (GQ, D, UsVs, UsVs\', sc, k) = B\n\n       Invariant:\n       B\' holds  iff\n            G : Q\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s1\' : G3   G3 |- U\' : V1\'\n       and  G |- s2\' : G4   G4 |- V\' : L\n       and  G |- U\'[s1\'] : V\'[s2\']\n       and  D\' --> U[s1] is a strict subterm of U\'[s1\']\n       and  sc is a constraint continuation representing restrictions on EVars\n       and only U\'[s\'] contains EVars\n       and U\'[s\'] will be maximally unfolded\n       and k is a continuation describing what happens when\n           UsVs and UsVs\' are maximally unfolded\n\n    *) ltR (GQ as (G, Q), D, UsVs, UsVs\', sc, k)  = ltRW (GQ, D, UsVs, whnfEta UsVs\', sc, k)ltRW (GQ, D, (Us, Vs), (Us\' as (Root (Const c, S\'), s\'), Vs\'), sc, k)  = if isAtomic (GQ, Us\') then k (GQ, D, nil, Less ((Us, Vs), (Us\', Vs\')), sc)(* either leftInstantiate D or  atomic reasoning *)  else ltSpineR (GQ, D, (Us, Vs), ((S\', s\'), (constType c, id)), sc, k) | ltRW (GQ, D, (Us, Vs), (Us\' as (Root (Def c, S\'), s\'), Vs\'), sc, k)  = if isAtomic (GQ, Us\') then k (GQ, D, nil, Less ((Us, Vs), (Us\', Vs\')), sc)(* either leftInstantiate D or  atomic reasoning *)  else ltSpineR (GQ, D, (Us, Vs), ((S\', s\'), (constType c, id)), sc, k) | ltRW (GQ as (G, Q), D, (Us, Vs), (Us\' as (Root (BVar n, S\'), s\'), Vs\'), sc, k)  = if isAtomic (GQ, Us\') then k (GQ, D, nil, Less ((Us, Vs), (Us\', Vs\')), sc)(* either leftInstantiate D or  atomic reasoning *)  else let Dec (_, V\') = ctxDec (G, n) in ltSpineR (GQ, D, (Us, Vs), ((S\', s\'), (V\', id)), sc, k) | ltRW (GQ, D, _, ((EVar _, _), _), _, _)  = false | ltRW (GQ as (G, Q), D, ((U, s1), (V, s2)), ((Lam (Dec (_, V1\'), U\'), s1\'), (Pi ((Dec (_, V2\'), _), V\'), s2\')), sc, k)  = if equiv (targetFam V, targetFam V1\')(* == I.targetFam V2\' *)  then (* enforce that X is only instantiated to parameters *) (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\', s1\')) let sc\' = fun () -> (isParameter (Q, X); sc ()) in ltR (GQ, D, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc\', k) else if below (targetFam V1\', targetFam V) then (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\', s1\')) in ltR (GQ, D, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc, k) else false(* possibly redundant if lhs always subordinate to rhs *) ltSpineR (GQ, D, (Us, Vs), (Ss\', Vs\'), sc, k)  = ltSpineRW (GQ, D, (Us, Vs), (Ss\', whnf Vs\'), sc, k)ltSpineRW (GQ, D, (Us, Vs), ((Nil, _), _), _, _)  = (* cannot happen Sat Apr 20 16:08:30 2002 -bp *)  false | ltSpineRW (GQ, D, (Us, Vs), ((SClo (S, s\'), s\'\'), Vs\'), sc, k)  = ltSpineR (GQ, D, (Us, Vs), ((S, comp (s\', s\'\')), Vs\'), sc, k) | ltSpineRW (GQ, D, (Us, Vs), ((App (U\', S\'), s1\'), (Pi ((Dec (_, V1\'), _), V2\'), s2\')), sc, k)  = leAtomicR (GQ, D, (Us, Vs), ((U\', s1\'), (V1\', s2\')), sc, k) || ltSpineR (GQ, D, (Us, Vs), ((S\', s1\'), (V2\', Dot (Exp (EClo (U\', s1\')), s2\'))), sc, k)(* leR (GQ, D, UsVs, UsVs\', sc, k) = B\n\n       Invariant:\n       B\' holds  iff\n            G : Q\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s1\' : G3   G3 |- U\' : V1\'\n       and  G |- s2\' : G4   G4 |- V\' : L\n       and  G |- U\'[s1\'] : V\'[s2\']\n       and  D\' --> U[s1] is a subterm of U\'[s1\']\n       and  sc is a constraint continuation representing restrictions on EVars\n       and only U\'[s\'] contains EVars\n       and U\'[s\'] will be maximally unfolded\n    *) leR (GQ, D, UsVs, UsVs\', sc, k)  = leRW (GQ, D, UsVs, whnfEta UsVs\', sc, k)leRW (GQ as (G, Q), D, ((U, s1), (V, s2)), ((Lam (Dec (_, V1\'), U\'), s1\'), (Pi ((Dec (_, V2\'), _), V\'), s2\')), sc, k)  = if equiv (targetFam V, targetFam V1\')(* == I.targetFam V2\' *)  then (* = I.newEVar (I.EClo (V2\', s2\')) *) (* enforces that X can only bound to parameter or remain uninstantiated *) let X = newEVar (G, EClo (V1\', s1\')) let sc\' = fun () -> (isParameter (Q, X) && sc ()) in leR (GQ, D, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc\', k) else if below (targetFam V1\', targetFam V) then (* = I.newEVar (I.EClo (V2\', s2\')) *) let X = newEVar (G, EClo (V1\', s1\')) in leR (GQ, D, ((U, s1), (V, s2)), ((U\', Dot (Exp (X), s1\')), (V\', Dot (Exp (X), s2\'))), sc, k) else false | leRW (GQ, D, UsVs, UsVs\', sc, k)  = ltR (GQ, D, UsVs, UsVs\', sc, k) || eqR (GQ, D, UsVs, UsVs\', sc, k)(* eqR (GQ, D, UsVs, UsVs\', sc, k) = B\n\n       Invariant:\n       B\' holds  iff\n            G : Q\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s1\' : G3   G3 |- U\' : V1\'\n       and  G |- s2\' : G4   G4 |- V\' : L\n       and  G |- U\'[s1\'] : V\'[s2\']\n       and  D\' --> U[s1] = U\'[s1\']\n       and  sc is a constraint continuation representing restrictions on EVars\n       and only U\'[s\'] contains EVars\n       and U\'[s\'] will be maximally unfolded\n    *) eqR (GQ as (G, Q), D, UsVs, UsVs\', sc, k)  = trail (fun () -> eq (G, UsVs, UsVs\') && sc ()) || eqR\' (GQ, D, UsVs, UsVs\', sc, k)eqR\' (GQ, D, (Us, Vs as (Pi ((Dec (_, V2\'), _), V\'), s2\')), (Us\', Vs\' as (Root _, s2\'\')), sc, k)  = false | eqR\' (GQ, D, (Us, Vs as (Root _, s2\')), (Us\', Vs\' as (Pi ((Dec (_, V2\'\'), _), V\'\'), s2\'\')), sc, k)  = false | eqR\' (GQ, D, UsVs as ((Root (Const c, S), s), Vs), UsVs\' as ((Root (Const c\', S\'), s\'), Vs\'), sc, k)  = if eqCid (c, c\') then eqSpineR (GQ, D, ((S, s), (constType c, id)), ((S\', s\'), (constType c\', id)), sc, k) else false | eqR\' (GQ, D, (Us as (Root (Const c, S), s), Vs), (Us\' as (Root (BVar n, S\'), s\'), Vs\'), sc, k)  = if isAtomic (GQ, Us\') then k (GQ, D, nil, Eq ((Us\', Vs\'), (Us, Vs)), sc)(* either leftInstantiate D or atomic reasoning *)  else false | eqR\' (GQ, D, (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (Const c, S\'), s\'), Vs\'), sc, k)  = if isAtomic (GQ, Us) then k (GQ, D, nil, Eq ((Us, Vs), (Us\', Vs\')), sc)(* either leftInstantiate D or atomic reasoning *)  else false | eqR\' (GQ, D, UsVs as ((Root (Def c, S), s), Vs), UsVs\' as ((Root (Def c\', S\'), s\'), Vs\'), sc, k)  = if eqCid (c, c\') then eqSpineR (GQ, D, ((S, s), (constType c, id)), ((S\', s\'), (constType c\', id)), sc, k) else false | eqR\' (GQ, D, (Us as (Root (Def c, S), s), Vs), (Us\' as (Root (BVar n, S\'), s\'), Vs\'), sc, k)  = if isAtomic (GQ, Us\') then k (GQ, D, nil, Eq ((Us\', Vs\'), (Us, Vs)), sc)(* either leftInstantiate D or atomic reasoning *)  else false | eqR\' (GQ, D, (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (Def c, S\'), s\'), Vs\'), sc, k)  = if isAtomic (GQ, Us) then k (GQ, D, nil, Eq ((Us, Vs), (Us\', Vs\')), sc)(* either leftInstantiate D or atomic reasoning *)  else false | eqR\' (GQ as (G, Q), D, (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (BVar n\', S\'), s\'), Vs\'), sc, k)  = if (n = n\') then let Dec (_, V\') = ctxDec (G, n) in eqSpineR (GQ, D, ((S, s), (V\', id)), ((S\', s\'), (V\', id)), sc, k) else k (GQ, D, nil, Eq ((Us, Vs), (Us\', Vs\')), sc) | eqR\' (GQ, D, UsVs, UsVs\', sc, k)  = k (GQ, D, nil, Eq (UsVs, UsVs\'), sc)(* either leftInstantiate D or atomic reasoning *) eqSpineR (GQ, D, (Ss, Vs), (Ss\', Vs\'), sc, k)  = eqSpineRW (GQ, D, (Ss, (whnf Vs)), (Ss\', (whnf Vs\')), sc, k)eqSpineRW (GQ, D, ((Nil, s), Vs), ((Nil, s\'), Vs\'), sc, k)  = true | eqSpineRW (GQ, D, ((SClo (S, s\'), s\'\'), Vs), SsVs\', sc, k)  = eqSpineR (GQ, D, ((S, comp (s\', s\'\')), Vs), SsVs\', sc, k) | eqSpineRW (GQ, D, SsVs, ((SClo (S\', s\'), s\'\'), Vs\'), sc, k)  = eqSpineR (GQ, D, SsVs, ((S\', comp (s\', s\'\')), Vs\'), sc, k) | eqSpineRW (GQ, D, ((App (U, S), s1), (Pi ((Dec (_, V1), _), V2), s2)), ((App (U\', S\'), s1\'), (Pi ((Dec (_, V1\'), _), V2\'), s2\')), sc, k)  = eqAtomicR (GQ, D, ((U, s1), (V1, s2)), ((U\', s1\'), (V1\', s2\')), sc, k) && eqSpineR (GQ, D, ((S, s1), (V2, Dot (Exp (EClo (U, s1)), s2))), ((S\', s1\'), (V2\', Dot (Exp (EClo (U\', s1\')), s2\'))), sc, k) | eqSpineRW (GQ, D, SsVs, SsVs\', sc, k)  = false (*--------------------------------------------------------------*) (* leftDecompose (G, Q, D, D\', P) = B\n\n      if G : Q and\n         D --> P  where D might contain orders (lex and simul)\n\n      then D\' --> P\n           where all orders in D\' are atomic\n\n      D\' accumulates all orders which are maximally unfolded,\n      but do not contain any EVars\n\n      maximally unfolded orders not containing EVars are:\n\n      Less: R < L\n\n      L := Root(c, Nil) | Root(n, Nil)\n      R := Root(c, S) | Root(n, S) | Lam(x:A, R)\n      S := . | App(R, S)\n\n\n      Eq : R = L\n      R := Root(n, Nil) | Lam(x:A, R)\n      L := Root(c, S) | Root(n, S) | Lam(x:A, R)\n      S := . | App(R, S)\n\n    *) let rec leftDecompose (GQ as (G, Q), nil, D\', P)  = rightDecompose (GQ, D\', P) | leftDecompose (GQ, (Less (Arg UsVs, Arg UsVs\') :: D), D\', P)  = ltAtomicL (GQ, D, D\', UsVs, UsVs\', P) | leftDecompose (GQ, (Less (Lex O, Lex O\') :: D), D\', P)  = ltLexL (GQ, D, D\', O, O\', P) | leftDecompose (GQ, (Less (Simul O, Simul O\') :: D), D\', P)  = ltSimulL (GQ, D, D\', O, O\', P) | leftDecompose (GQ, (Leq (Arg UsVs, Arg UsVs\') :: D), D\', P)  = leAtomicL (GQ, D, D\', UsVs, UsVs\', P) | leftDecompose (GQ, (Leq (Lex O, Lex O\') :: D), D\', P)  = leftDecompose (GQ, (Less (Lex O, Lex O\') :: D), D\', P) && leftDecompose (GQ, (Eq (Lex O, Lex O\') :: D), D\', P) | leftDecompose (GQ, (Leq (Simul O, Simul O\') :: D), D\', P)  = leSimulL (GQ, D, D\', O, O\', P) | leftDecompose (GQ, (Eq (Arg UsVs, Arg UsVs\') :: D), D\', P)  = eqAtomicL (GQ, D, D\', UsVs, UsVs\', P) | leftDecompose (GQ, (Eq (Lex O, Lex O\') :: D), D\', P)  = eqsL (GQ, D, D\', O, O\', P) | leftDecompose (GQ, (Eq (Simul O, Simul O\') :: D), D\', P)  = eqsL (GQ, D, D\', O, O\', P) | leftDecompose (GQ as (G, Q), (Pi (Dec, O) :: D), D\', P)  = (* drop assumption Pi D. P *)  ((if ! chatter > 3 then (print " Ignoring quantified order "; print (makestring_fmt (fmtPredicate (G, Pi (Dec, O))))) else ()); leftDecompose (GQ, D, D\', P))(*--------------------------------------------------------------*) (* Lexicographic and Simultanous Orders (left)*) (* If D, D\', Lex O1, ....On < Lex O\'1, ....O\'n --> P\n      then\n            D, D\', O1 < O1\' --> P\n        and D, D\', O1 = O1\', O2 < O2 --> P\n\n        ...\n        and D, D\', O1 = O1\', .., O_n-1 = O\'_n-1, O_n < O\'_n --> P\n    *) ltLexL (GQ, D, D\', nil, nil, P)  = true | ltLexL (GQ, D, D\', O :: L, O\' :: L\', P)  = leftDecompose (GQ, (Less (O, O\') :: D), D\', P) && ltLexL (GQ, (Eq (O, O\') :: D), D\', L, L\', P)(* If D, D\', Lex O1, ....On = Lex O\'1, ....O\'n --> P\n      If D, D\', Simul O1, ....On = Simul O\'1, ....O\'n --> P\n      then\n            D, D\', O1 = O1\' --> P\n        and D, D\', O2 = O2\' --> P\n\n        ...\n        and D, D\', On = On\' --> P\n    *) eqsL (GQ, D, D\', nil, nil, P)  = true | eqsL (GQ, D, D\', O :: L, O\' :: L\', P)  = leftDecompose (GQ, (Eq (O, O\') :: D), D\', P) && eqsL (GQ, D, D\', L, L\', P)ltSimulL (GQ, D, D\', nil, nil, P)  = leftDecompose (GQ, D, D\', P) | ltSimulL (GQ, D, D\', O :: L, O\' :: L\', P)  = leSimulL (GQ, (Less (O, O\') :: D), D\', L, L\', P) || ltSimulL (GQ, (Eq (O, O\') :: D), D\', L, L\', P)leSimulL (GQ, D, D\', nil, nil, P)  = leftDecompose (GQ, D, D\', P) | leSimulL (GQ, D, D\', O :: L, O\' :: L\', P)  = leSimulL (GQ, (Leq (O, O\') :: D), D\', L, L\', P)(*--------------------------------------------------------------*) (* Atomic Orders (left) *) (* U := Root(c, S) | Root(n, S) | Lam(x:A, U) *) (* ltAtomicL (GQ as (G, Q), D, D\', ((U, s1), (V, s2)), ((U\', s1\'), (V\', s2\')), P) = B\n\n     B holds iff\n\n            G : Q\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s1\' : G3   G3 |- U\' : V1\'\n       and  G |- s2\' : G4   G4 |- V\' : L\n       and  G |- U\'[s1\'] : V\'[s2\']\n\n       and  G |- D, D\', (U[s1]:V[s2]) < U\'[s1\']:V\'[s2\']) --> P\n\n\n       if G |- D, D\', (Us:Vs) < (\\x1:A1....\\xn:An. U\'[s1\']: V\'[s2\']) --> P and\n               (n >= 0)\n       then\n          G, a1:A1, .... an:An |-\n             D^n, D\'^n, (Us^n:Vs^n) < U\'[a1... an . s1\'^n]:V\'[a1. ... . an . s2\'^n] --> P^n\n\n       where D^n, (Us^n, P^n) means all substitutions in D (U, P etc)\n             are shifted by n\n    *) ltAtomicL (GQ, D, D\', UsVs, UsVs\', P)  = ltAtomicLW (GQ, D, D\', UsVs, whnfEta UsVs\', P)ltAtomicLW (GQ as (G, Q), D, D\', UsVs, (Us\', Vs\' as (Root _, s\')), P)  = ltL (GQ, D, D\', UsVs, (Us\', Vs\'), P) | ltAtomicLW (GQ as (G, Q), D, D\', ((U, s1), (V, s2)), ((Lam (_, U\'), s1\'), (Pi ((Dec\', _), V\'), s2\')), P)  = let D1 = shiftRCtx D (fun s -> comp (s, shift)) let D1\' = shiftACtx D\' (fun s -> comp (s, shift)) let UsVs = ((U, comp (s1, shift)), (V, comp (s2, shift))) let UsVs\' = ((U\', dot1 s1\'), (V\', dot1 s2\')) let P\' = shiftP P (fun s -> comp (s, shift)) in ltAtomicL ((Decl (G, decLUName (G, decSub (Dec\', s2\'))), Decl (Q, All)), D1, D1\', UsVs, UsVs\', P\')(* see invariant for ltAtomic *) leAtomicL (GQ, D, D\', UsVs, UsVs\', P)  = leAtomicLW (GQ, D, D\', UsVs, whnfEta UsVs\', P)leAtomicLW (GQ, D, D\', UsVs, (Us\', Vs\' as (Root (H, S), s\')), P)  = leL (GQ, D, D\', UsVs, (Us\', Vs\'), P) | leAtomicLW (GQ as (G, Q), D, D\', ((U, s1), (V, s2)), ((Lam (_, U\'), s1\'), (Pi ((Dec\', _), V\'), s2\')), P)  = let D1 = shiftRCtx D (fun s -> comp (s, shift)) let D1\' = shiftACtx D\' (fun s -> comp (s, shift)) let UsVs = ((U, comp (s1, shift)), (V, comp (s2, shift))) let UsVs\' = ((U\', dot1 s1\'), (V\', dot1 s2\')) let P\' = shiftP P (fun s -> comp (s, shift)) in leAtomicL ((Decl (G, decLUName (G, decSub (Dec\', s2\'))), Decl (Q, All)), D1, D1\', UsVs, UsVs\', P\')(*  *) eqAtomicL (GQ, D, D\', UsVs, UsVs\', P)  = eqAtomicLW (GQ, D, D\', whnfEta UsVs, whnfEta UsVs\', P)eqAtomicLW (GQ, D, D\', (Us, Vs as (Root _, s)), (Us\', Vs\' as (Root _, s\')), P)  = eqL (GQ, D, D\', (Us, Vs), (Us\', Vs\'), P) | eqAtomicLW (GQ, D, D\', (Us, Vs as (Root _, s)), (Us\', Vs\' as (Pi _, s\')), P)  = true | eqAtomicLW (GQ, D, D\', (Us, Vs as (Pi _, s)), (Us\', Vs\' as (Root _, s\')), P)  = true | eqAtomicLW (GQ, D, D\', (Us, Vs as (Pi _, s)), (Us\', Vs\' as (Pi _, s\')), P)  = leftDecompose (GQ, D, (Eq ((Us, Vs), (Us\', Vs\')) :: D\'), P)(*--------------------------------------------------------------*) (* U\' := Root(c, S) | Root(n, S) *) (* add definitions! *) leL (GQ, D, D\', UsVs, UsVs\', P)  = ltAtomicL (GQ, D, D\', UsVs, UsVs\', P) && eqAtomicL (GQ, D, D\', UsVs, UsVs\', P)(*  If D, D\', U < Root(c, S) --> P\n      then D, D\', U <= S\' --> P\n   *) ltL (GQ, D, D\', UsVs, (Us\', Vs\'), P)  = ltLW (GQ, D, D\', UsVs, (whnf Us\', Vs\'), P)ltLW (GQ as (G, Q), D, D\', UsVs, (Us\' as (Root (BVar n, S\'), s\'), Vs\'), P)  = if isAtomic (GQ, Us\') then leftDecompose (GQ, D, (Less (UsVs, (Us\', Vs\')) :: D\'), P) else let Dec (_, V\') = ctxDec (G, n) in ltSpineL (GQ, D, D\', UsVs, ((S\', s\'), (V\', id)), P) | ltLW (GQ, D, D\', UsVs, ((Root (Const c, S\'), s\'), Vs\'), P)  = ltSpineL (GQ, D, D\', UsVs, ((S\', s\'), (constType c, id)), P) | ltLW (GQ, D, D\', UsVs, ((Root (Def c, S\'), s\'), Vs\'), P)  = ltSpineL (GQ, D, D\', UsVs, ((S\', s\'), (constType c, id)), P)ltSpineL (GQ, D, D\', UsVs, (Ss\', Vs\'), P)  = ltSpineLW (GQ, D, D\', UsVs, (Ss\', whnf Vs\'), P)ltSpineLW (GQ, D, D\', UsVs, ((Nil, _), _), _)  = true | ltSpineLW (GQ, D, D\', UsVs, ((SClo (S, s\'), s\'\'), Vs\'), P)  = ltSpineL (GQ, D, D\', UsVs, ((S, comp (s\', s\'\')), Vs\'), P) | ltSpineLW (GQ, D, D\', UsVs, ((App (U\', S\'), s1\'), (Pi ((Dec (_, V1\'), _), V2\'), s2\')), P)  = leAtomicL (GQ, D, D\', UsVs, ((U\', s1\'), (V1\', s2\')), P) && ltSpineL (GQ, D, D\', UsVs, ((S\', s1\'), (V2\', Dot (Exp (EClo (U\', s1\')), s2\'))), P)(*  eqL (GQ, D, D\', UsVs, UsVs\', P) = B\n\n       B holds iff\n\n            G : Q\n\n       and  D is an Order relation ctx\n       and  D\' is an atomic order relation ctx\n       and  P is a order relation\n\n       and  G |- s1 : G1   G1 |- U : V1\n       and  G |- s2 : G2   G2 |- V : L\n       and  G |- U[s1] : V[s2]\n       and  G |- s1\' : G3   G3 |- U\' : V1\'\n       and  G |- s2\' : G4   G4 |- V\' : L\n       and  G |- U\'[s1\'] : V\'[s2\']\n\n       and D, D\', U[s1] = U\'[s1\'] --> P\n\n       note: D, D\', UsVs, UsVs\' and P do not\n             contain any EVars\n   *) eqL (GQ, D, D\', UsVs, UsVs\', P)  = eqLW (GQ, D, D\', whnfEta UsVs, whnfEta UsVs\', P)eqLW (GQ, D, D\', (Us, Vs as (Pi ((Dec (_, V2\'), _), V\'), s2\')), (Us\', Vs\' as (Pi ((Dec (_, V2\'\'), _), V\'\'), s2\'\')), P)  = leftDecompose (GQ, D, (Eq ((Us, Vs), (Us\', Vs\')) :: D\'), P) | eqLW (GQ, D, D\', (Us, Vs as (Pi ((Dec (_, V2\'), _), V\'), s2\')), (Us\', Vs\' as (Root _, s2\'\')), P)  = true | eqLW (GQ, D, D\', (Us, Vs as (Root _, s2\')), (Us\', Vs\' as (Pi ((Dec (_, V2\'\'), _), V\'\'), s2\'\')), P)  = true | eqLW (GQ, D, D\', UsVs as ((Root (Const c, S), s), Vs), UsVs\' as ((Root (Const c\', S\'), s\'), Vs\'), P)  = if eqCid (c, c\') then eqSpineL (GQ, D, D\', ((S, s), (constType c, id)), ((S\', s\'), (constType c\', id)), P) else true | eqLW (GQ, D, D\', (Us as (Root (Const c, S), s), Vs), (Us\' as (Root (BVar n, S\'), s\'), Vs\'), P)  = if isAtomic (GQ, Us\') then leftDecompose (GQ, D, (Eq ((Us\', Vs\'), (Us, Vs)) :: D\'), P) else true | eqLW (GQ, D, D\', (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (Const c, S\'), s\'), Vs\'), P)  = if isAtomic (GQ, Us) then leftDecompose (GQ, D, (Eq ((Us, Vs), (Us\', Vs\')) :: D\'), P) else true | eqLW (GQ, D, D\', UsVs as ((Root (Def c, S), s), Vs), UsVs\' as ((Root (Def c\', S\'), s\'), Vs\'), P)  = if eqCid (c, c\') then eqSpineL (GQ, D, D\', ((S, s), (constType c, id)), ((S\', s\'), (constType c\', id)), P) else true | eqLW (GQ, D, D\', (Us as (Root (Def c, S), s), Vs), (Us\' as (Root (BVar n, S\'), s\'), Vs\'), P)  = if isAtomic (GQ, Us\') then leftDecompose (GQ, D, (Eq ((Us\', Vs\'), (Us, Vs)) :: D\'), P) else true | eqLW (GQ, D, D\', (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (Def c, S\'), s\'), Vs\'), P)  = if isAtomic (GQ, Us) then leftDecompose (GQ, D, (Eq ((Us, Vs), (Us\', Vs\')) :: D\'), P) else true | eqLW (GQ as (G, Q), D, D\', (Us as (Root (BVar n, S), s), Vs), (Us\' as (Root (BVar n\', S\'), s\'), Vs\'), P)  = if (n = n\') then let Dec (_, V\') = ctxDec (G, n) in eqSpineL (GQ, D, D\', ((S, s), (V\', id)), ((S\', s\'), (V\', id)), P) else leftDecompose (GQ, D, (Eq ((Us, Vs), (Us\', Vs\')) :: D\'), P) | eqLW (GQ, D, D\', UsVs, UsVs\', P)  = leftDecompose (GQ, D, (Eq (UsVs, UsVs\') :: D\'), P)eqSpineL (GQ, D, D\', (Ss, Vs), (Ss\', Vs\'), P)  = eqSpineLW (GQ, D, D\', (Ss, whnf Vs), (Ss\', whnf Vs\'), P)eqSpineLW (GQ, D, D\', ((Nil, s), Vs), ((Nil, s\'), Vs\'), P)  = leftDecompose (GQ, D, D\', P) | eqSpineLW (GQ, D, D\', ((SClo (S, s\'), s\'\'), Vs), SsVs\', P)  = eqSpineL (GQ, D, D\', ((S, comp (s\', s\'\')), Vs), SsVs\', P) | eqSpineLW (GQ, D, D\', SsVs, ((SClo (S\', s\'), s\'\'), Vs\'), P)  = eqSpineL (GQ, D, D\', SsVs, ((S\', comp (s\', s\'\')), Vs\'), P) | eqSpineLW (GQ, D, D\', ((App (U, S), s1), (Pi ((Dec (_, V1), _), V2), s2)), ((App (U\', S\'), s1\'), (Pi ((Dec (_, V1\'), _), V2\'), s2\')), P)  = let D1 = (Eq (Arg ((U, s1), (V1, s2)), Arg ((U\', s1\'), (V1\', s2\'))) :: D) in eqSpineL (GQ, D1, D\', ((S, s1), (V2, Dot (Exp (EClo (U, s1)), s2))), ((S\', s1\'), (V2\', Dot (Exp (EClo (U\', s1\')), s2\'))), P) (*--------------------------------------------------------------*) (* Infer: D --> P *) (* deduce (G, Q, D, P) = B\n\n      B iff\n         G :  Q\n     and G |- D\n     and G |- P\n     and D implies P\n    *) let rec deduce (G, Q, D, P)  = leftDecompose ((G, Q), D, nil, P) let deduce = deduce let shiftRCtx = shiftRCtx let shiftPred = shiftP  (* local *)  end\n(* functor checking  *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: module Checking = Checking(struct module Global = Global module Whnf = Whnf module Conv = Conv module Unify = UnifyTrail module Trail = Trail module Names = Names module Index = Index module Subordinate = Subordinate module Formatter = Formatter module Print = Print module Order = Order module Paths = Paths module Origins = Origins end)
module Reduces = Reduces(struct module Global = Global module Whnf = Whnf module Names = Names module Index = Index module Subordinate = Subordinate module Formatter = Formatter module Print = Print module Order = Order module Checking = Checking module Paths = Paths module Origins = Origins end)

Code parsed successfully: module FormatterFORMATTER = Formatter()
Code parsed successfully: module FormatterFORMATTER = Formatter()
('Error parsing code:', "(*\n% ForML Version 0.6 - 25 January 1993 - er@cs.cmu.edu\n%*********************************************************************\n{\\bf File {\\tt formatter.sig} with signature {\\tt FORMATTER}.}\n%*********************************************************************\n*) module type FORMATTER = sig (*\n\\subsection{Default values}\nThese may may be changed by the user.\n*) val Indent : int refval Blanks : int refval Skip : int refval Pagewidth : int ref(* flag specifying whether bailouts should occur when page too narrow *) val Bailout : bool refval BailoutIndent : int refval BailoutSpot : int ref(*\n\\subsection{Formats}\n*) (* The Format datatype *) type format(* return the minimum/maximum width of a format *) val Width : format -> (int * int)(* routines to create a format *) (* Note: the xxxx0 functions take extra arguments *) val Break : formatval Break0 : int -> int -> format(* blanks, indent *) val String : string -> formatval String0 : int -> string -> format(* output width *) val Space : formatval Spaces : int -> formatval Newline : unit -> formatval Newlines : int -> formatval Newpage : unit -> formatval Vbox : format list -> formatval Vbox0 : int -> int -> format list -> format(* indent, skip *) val Hbox : format list -> formatval Hbox0 : int -> format list -> format(* blanks *) val HVbox : format list -> formatval HVbox0 : int -> int -> int -> format list -> format(* blanks, indent, skip *) val HOVbox : format list -> formatval HOVbox0 : int -> int -> int -> format list -> format(* blanks, indent, skip *) (*\n\\subsection{Output routines}\n*) val makestring_fmt : format -> stringval print_fmt : format -> unittype fmtstreamval open_fmt : outstream -> fmtstreamval close_fmt : fmtstream -> outstreamval output_fmt : (fmtstream * format) -> unitval file_open_fmt : string -> ((unit -> unit) * fmtstream)val with_open_fmt : string -> (fmtstream -> 'a) -> 'a end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Clause Printing *) (* Author: Frank Pfenning, Carsten Schuermann *) (* This is like printing of expressions, except that\n   types are interpreted as programs and therefore\n   printed with backward arrows `<-\'\n*) module ClausePrint ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Formatter\' : FORMATTERmodule Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) PrintFormatterFormatter\'module Symbol : SYMBOL) : CLAUSEPRINT = struct (*! structure IntSyn = IntSyn\' !*)  module Formatter = Formatter\' (* some shorthands *) module I = IntSynmodule F = Formatterlet Str = String let rec Str0 (s, n)  = String0 n s let rec sym (s)  = Str0 (sym s) let rec parens (fmt)  = Hbox [sym "("; fmt; sym ")"] (* assumes NF *) let rec fmtDQuants (G, Pi ((D as Dec (_, V1), Maybe), V2))  = let D\' = decEName (G, D) in sym "{" :: formatDec (G, D\') :: sym "}" :: Break :: fmtDQuants (Decl (G, D\'), V2) | fmtDQuants (G, Pi ((D as Dec (_, V1), Meta), V2))  = let D\' = decEName (G, D) in sym "{" :: formatDec (G, D\') :: sym "}" :: Break :: fmtDQuants (Decl (G, D\'), V2) | fmtDQuants (G, V as Pi _)  = (* P = I.No *)  [HOVbox (fmtDSubGoals (G, V, nil))] | fmtDQuants (G, V)  = (* V = Root _ *)  [formatExp (G, V)]fmtDSubGoals (G, Pi ((D as Dec (_, V1), No), V2), acc)  = fmtDSubGoals (Decl (G, D), V2, Break :: sym "<-" :: Space :: fmtGparens (G, V1) :: acc) | fmtDSubGoals (G, V as Pi _, acc)  = (* acc <> nil *)  parens (HVbox (fmtDQuants (G, V))) :: acc | fmtDSubGoals (G, V, acc)  = (* V = Root _ *)  formatExp (G, V) :: accfmtDparens (G, V as Pi _)  = parens (HVbox (fmtDQuants (G, V))) | fmtDparens (G, V)  = (* V = Root _ *)  formatExp (G, V)fmtGparens (G, V as Pi _)  = parens (HVbox (fmtGQuants (G, V))) | fmtGparens (G, V)  = (* V = Root _ *)  formatExp (G, V)fmtGQuants (G, Pi ((D as Dec (_, V1), Maybe), V2))  = let D\' = decLUName (G, D) in sym "{" :: formatDec (G, D\') :: sym "}" :: Break :: fmtGQuants (Decl (G, D\'), V2) | fmtGQuants (G, Pi ((D as Dec (_, V1), Meta), V2))  = let D\' = decLUName (G, D) in sym "{" :: formatDec (G, D\') :: sym "}" :: Break :: fmtGQuants (Decl (G, D\'), V2) | fmtGQuants (G, V)  = (* P = I.No or V = Root _ *)  [HOVbox (fmtGHyps (G, V))]fmtGHyps (G, Pi ((D as Dec (_, V1), No), V2))  = fmtDparens (G, V1) :: Break :: sym "->" :: Space :: fmtGHyps (Decl (G, D), V2) | fmtGHyps (G, V as Pi _)  = (* P = I.Maybe *)  [HVbox (fmtGQuants (G, V))] | fmtGHyps (G, V)  = (* V = Root _ *)  [formatExp (G, V)] let rec fmtClause (G, V)  = HVbox (fmtDQuants (G, V)) let rec fmtClauseI (0, G, V)  = fmtClause (G, V) | fmtClauseI (i, G, Pi ((D, _), V))  = fmtClauseI (i - 1, Decl (G, decEName (G, D)), V) let rec fmtConDec (ConDec (id, parent, i, _, V, Type))  = let _ = varReset Null let Vfmt = fmtClauseI (i, Null, V) in HVbox [Str0 (const (id)); Space; sym ":"; Break; Vfmt; sym "."] | fmtConDec (condec)  = (* type family declaration, definition, or Skolem constant *)  formatConDec (condec) let rec formatClause (G, V)  = fmtClause (G, V) let rec formatConDec (condec)  = fmtConDec (condec) let rec clauseToString (G, V)  = makestring_fmt (formatClause (G, V)) let rec conDecToString (condec)  = makestring_fmt (formatConDec (condec)) let rec printSgn ()  = sgnApp (fun (cid) -> (print (conDecToString (sgnLookup cid)); print "\\n"))  (* local ... *)  end(* functor ClausePrint *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Generic Traversal Intended for Language-Specific Printing *) (* Author: Frank Pfenning *) module type TRAVERSER = sig (* type kind *) type tptype objtype headtype spinetype dectype condecval atom : head * spine -> tpval arrow : tp * tp -> tpval pi : dec * tp -> tpval root : head * spine * tp -> obj(* propagate type to every root *) val lam : dec * obj -> objval bvar : string -> headval const : string list * string -> headval def : string list * string -> head(* no evar, skonst, or fvar *) val nils : spineval app : obj * spine -> spineval dec : string * tp -> decval objdec : string * tp -> condec(* val famdec : string * kind -> condec *) (* val objdef : string * obj * tp -> condec *) (* val famdef : string * tp * kind -> condec *) (* val skodec : string * tp -> condec *)  end\n(* signature TRAVERSER *) module type TRAVERSE = sig (*! structure IntSyn : INTSYN !*) module Traverser : TRAVERSERexception Error of stringval fromConDec : ConDec -> condec optionval const : string -> condec end\n(* signature TRAVERSE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module SymbolAscii = SymbolAscii()
module SymbolTeX = SymbolTeX()
(*
structure WorldPrint = WorldPrint 
  (structure Global = Global
   (*! structure IntSyn = IntSyn !*)
   (*! structure Tomega' = Tomega !*)
   structure WorldSyn' = WorldSyn
   structure Names = Names
   structure Formatter' = Formatter
   structure Print = Print);
*) module Print = Print(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter module Symbol = SymbolAscii end)
module ClausePrint = ClausePrint(struct module Whnf = Whnf module Names = Names module Formatter' = Formatter module Print = Print module Symbol = SymbolAscii end)
module PrintTeX = Print(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter module Symbol = SymbolTeX end)
module ClausePrintTeX = ClausePrint(struct module Whnf = Whnf module Constraints = Constraints module Names = Names module Formatter' = Formatter module Print = PrintTeX module Symbol = SymbolTeX end)
module PrintTwega = PrintTwega(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter end)
module PrintXML = PrintXML(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter end)
module PrintOMDoc = PrintOMDoc(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter end)

('Error parsing code:', '(* Printing *) (* Author: Frank Pfenning *) (* Modified: Jeff Polakow *) (* Modified: Carsten Schuermann *) module PrintXML ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Formatter\' : FORMATTER) : PRINT_XML = struct (*! structure IntSyn = IntSyn\' !*)  module Formatter = Formatter\' (* Shorthands *) module I = IntSynmodule F = Formatterlet Str = String let rec Str0 (s, n)  = String0 n s let rec Name (x)  = String ("\\"" ^ x ^ "\\"") let rec Integer (n)  = String ("\\"" ^ toString n ^ "\\"") let rec sexp (fmts)  = Hbox [HVbox fmts] (* fmtCon (c) = "c" where the name is assigned according the the Name table\n     maintained in the names module.\n     FVar\'s are printed with a preceding "`" (backquote) character\n  *) let rec fmtCon (G, BVar (n))  = let Dec (SOME n, _) = ctxDec (G, n) in sexp [Str ("<Var name = \\"" ^ n ^ "\\"/>")] | fmtCon (G, Const (cid))  = sexp [Str "<Const name=\\""; Str (conDecName (sgnLookup cid)); Str "\\"/>"] | fmtCon (G, Def (cid))  = sexp [Str "<Def>"; Break; Integer cid; Str "</Def>"] | fmtCon (G, FgnConst (csid, condec))  = sexp [Str "FngConst"] (* FIX -cs Fri Jan 28 17:45:35 2005*) (* I.Skonst, I.FVar cases should be impossible *) (* fmtUni (L) = "L" *) let rec fmtUni (Type)  = Str "<Type/>" | fmtUni (Kind)  = Str "<Kind/>" (* fmtExpW (G, (U, s)) = fmt\n\n     format the expression U[s].\n\n     Invariants:\n       G is a "printing context" (names in it are unique, but\n            types may be incorrect) approximating G\'\n       G\'\' |- U : V   G\' |- s : G\'\'  (so  G\' |- U[s] : V[s])\n       (U,s) in whnf\n  *) let rec fmtExpW (G, (Uni (L), s))  = sexp [Str "<Uni>"; Break; fmtUni L; Str "</Uni>"] | fmtExpW (G, (Pi ((D as Dec (_, V1), P), V2), s))  = (match P(* if Pi is dependent but anonymous, invent name here *)  with Maybe -> (* could sometimes be EName *) let D\' = decLUName (G, D) let G\' = Decl (G, D\') in sexp [Str "<Pi>"; Break; fmtDec (G, (D\', s)); Break; (* Str "tw*maybe", F.Break, *) fmtExp (G\', (V2, dot1 s)); Str "</Pi>"] | No -> let G\' = Decl (G, D) in sexp [Str "<Arrow>"; Break; fmtDec\' (G, (D, s)); Break; (* Str "tw*no", F.Break,*) fmtExp (G\', (V2, dot1 s)); Str "</Arrow>"]) | fmtExpW (G, (Root (H, S), s))  = (match (fmtSpine (G, (S, s))) with NONE -> fmtCon (G, H) | SOME fmts -> HVbox [Str "<App>"; fmtCon (G, H); Break; sexp (fmts); Str "</App>"]) | fmtExpW (G, (Lam (D, U), s))  = let D\' = decLUName (G, D) let G\' = Decl (G, D\') in sexp [Str "<Lam>"; Break; fmtDec (G, (D\', s)); Break; fmtExp (G\', (U, dot1 s)); Str "</Lam>"] | fmtExpW (G, (FgnExp (csid, F), s))  = sexp [Str "FgnExp"](* FIX -cs Fri Jan 28 17:45:43 2005 *) (* I.EClo, I.Redex, I.EVar not possible *) fmtExp (G, (U, s))  = fmtExpW (G, whnf (U, s))(* fmtSpine (G, (S, s)) = fmts\n     format spine S[s] at printing depth d, printing length l, in printing\n     context G which approximates G\', where G\' |- S[s] is valid\n  *) fmtSpine (G, (Nil, _))  = NONE | fmtSpine (G, (SClo (S, s\'), s))  = fmtSpine (G, (S, comp (s\', s))) | fmtSpine (G, (App (U, S), s))  = (match (fmtSpine (G, (S, s))) with NONE -> SOME [fmtExp (G, (U, s))] | SOME fmts -> SOME ([fmtExp (G, (U, s)); Break] @ fmts))fmtDec (G, (Dec (NONE, V), s))  = sexp [Str "<Dec>"; Break; fmtExp (G, (V, s)); Str "</Dec>"] | fmtDec (G, (Dec (SOME (x), V), s))  = sexp [Str "<Dec name ="; Name x; Str ">"; Break; fmtExp (G, (V, s)); Str "</Dec>"]fmtDec\' (G, (Dec (NONE, V), s))  = sexp [fmtExp (G, (V, s))] | fmtDec\' (G, (Dec (SOME (x), V), s))  = sexp [fmtExp (G, (V, s))] (* fmtConDec (condec) = fmt\n     formats a constant declaration (which must be closed and in normal form)\n\n     This function prints the quantifiers and abstractions only if hide = false.\n  *) let rec fmtConDec (ConDec (name, parent, imp, _, V, L))  = let _ = varReset Null in sexp [Str "<Condec name="; Name (name); Break; Str "implicit="; Integer (imp); Str ">"; Break; fmtExp (Null, (V, id)); Break; fmtUni (L); Str "</Condec>"] | fmtConDec (SkoDec (name, parent, imp, V, L))  = Str ("<! Skipping Skolem constant " ^ name ^ ">") | fmtConDec (ConDef (name, parent, imp, U, V, L, _))  = let _ = varReset Null in sexp [Str "<Condef name="; Name (name); Break; Str "implicit="; Integer (imp); Str ">"; Break; fmtExp (Null, (U, id)); Break; fmtExp (Null, (V, id)); Break; fmtUni (L); Str "</Condef>"] | fmtConDec (AbbrevDef (name, parent, imp, U, V, L))  = let _ = varReset Null in sexp [Str "<Abbrevdef name="; Name (name); Str ">"; Break; Integer (imp); Break; fmtExp (Null, (U, id)); Break; fmtExp (Null, (V, id)); Break; fmtUni (L); Str "</Abbrevdef>"] | fmtConDec (BlockDec (name, _, _, _))  = Str ("<! Skipping Skolem constant " ^ name ^ ">") (* fmtEqn assumes that G is a valid printing context *) let rec fmtEqn (Eqn (G, U1, U2))  = (* print context?? *)  sexp [Str "<Equation>"; Break; fmtExp (G, (U1, id)); Break; fmtExp (G, (U2, id)); Str "</Equation>"] (* fmtEqnName and fmtEqns do not assume that G is a valid printing\n     context and will name or rename variables to make it so.\n     fmtEqns should only be used for printing constraints.\n  *) let rec fmtEqnName (Eqn (G, U1, U2))  = fmtEqn (Eqn (ctxLUName G, U1, U2)) (* In the functions below, G must be a "printing context", that is,\n     (a) unique names must be assigned to each declaration which may\n         actually applied in the scope (typically, using Names.decName)\n     (b) types need not be well-formed, since they are not used\n  *) let rec formatDec (G, D)  = fmtDec (G, (D, id)) let rec formatExp (G, U)  = fmtExp (G, (U, id)) (*  fun formatSpine (G, S) = sexp (fmtSpine (G, (S, I.id))) *) let rec formatConDec (condec)  = fmtConDec (condec) let rec formatEqn (E)  = fmtEqn E let rec decToString (G, D)  = makestring_fmt (formatDec (G, D)) let rec expToString (G, U)  = makestring_fmt (formatExp (G, U)) let rec conDecToString (condec)  = makestring_fmt (formatConDec (condec)) let rec eqnToString (E)  = makestring_fmt (formatEqn E) let rec printSgn ()  = sgnApp (fun (cid) -> (print (makestring_fmt (formatConDec (sgnLookup cid))); print "\\n")) let rec printSgnToFile path filename  = let file = openOut (path ^ filename) let _ = output (file, "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n<!-- nsgmls ex.xml -->\\n<!DOCTYPE Signature SYSTEM \\"lf.dtd\\">\\n<Signature>") let _ = sgnApp (fun (cid) -> (output (file, makestring_fmt (formatConDec (sgnLookup cid))); output (file, "\\n"))) let _ = output (file, "</Signature>") let _ = closeOut file in ()  (* local ... *)  end(* functor PrintXml *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Printing *) (* Author: Frank Pfenning *) (* Modified: Jeff Polakow *) module type PRINT = sig (*! structure IntSyn : INTSYN !*) module Formatter : FORMATTERval implicit : bool refval printInfix : bool refval printDepth : int option refval printLength : int option refval noShadow : bool refval formatDec : dctx * Dec -> formatval formatDecList : dctx * Dec list -> formatval formatDecList' : dctx * (Dec list * Sub) -> formatval formatExp : dctx * Exp -> formatval formatSpine : dctx * Spine -> format listval formatConDec : ConDec -> formatval formatConDecI : ConDec -> formatval formatCnstr : Cnstr -> formatval formatCtx : dctx * dctx -> formatval decToString : dctx * Dec -> stringval expToString : dctx * Exp -> stringval conDecToString : ConDec -> stringval cnstrToString : Cnstr -> stringval cnstrsToString : cnstr list -> string(* assigns names in contexts *) val ctxToString : dctx * dctx -> stringval evarInstToString : Exp * string list -> stringval evarCnstrsToStringOpt : Exp * string list -> string optionval formatWorlds : Worlds -> formatval worldsToString : Worlds -> stringval printSgn : unit -> unit end\n(* signature PRINT *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module Traverse ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Traverser\' : TRAVERSER) : TRAVERSE(* shares types from Traverser\' *)  = struct (*! structure IntSyn = IntSyn\' !*)  module Traverser = Traverser\' exception Error of string module I = IntSynmodule T = Traverser(* from typecheck.fun *) (* inferCon (G, C) = V\'\n\n     Invariant:\n     If    G |- C : V\n     and  (C  doesn\'t contain FVars)\n     then  G\' |- V\' : L      (for some level L)\n     and   G |- V = V\' : L\n     else exception Error is raised.\n  *) let rec inferConW (G, BVar (k\'))  = let Dec (_, V) = ctxDec (G, k\') in whnf (V, id) | inferConW (G, Const (c))  = (constType (c), id) | inferConW (G, Def (d))  = (constType (d), id) (* no case for FVar, Skonst *) let rec fromHead (G, BVar (n))  = bvar (bvarName (G, n)) | fromHead (G, Const (cid))  = let Qid (ids, id) = constQid (cid) in const (ids, id) | fromHead (G, Def (cid))  = let Qid (ids, id) = constQid (cid) in def (ids, id) | fromHead _  = raise (Error ("Head not recognized")) (* see also: print.fun *) let rec impCon (Const (cid))  = constImp (cid) | impCon (Def (cid))  = constImp (cid) | impCon _  = 0 (* see also: print.fun *) (*\n  fun dropImp (0, S) = S\n    | dropImp (i, I.App (U, S)) = dropImp (i-1, S)\n    | dropImp (i, I.SClo (S, s)) = I.SClo (dropImp (i, S), s)\n    | dropImp _ = raise Error ("Missing implicit arguments")\n  *) let rec fromTpW (G, (Root (C, S), s))  = atom (fromHead (G, C), fromSpine (impCon C, G, (S, s), inferConW (G, C))) | fromTpW (G, (Pi ((D as Dec (_, V1), No), V2), s))  = arrow (fromTp (G, (V1, s)), fromTp (Decl (G, decSub (D, s)), (V2, dot1 s))) | fromTpW (G, (Pi ((D, Maybe), V2), s))  = let D\' = decUName (G, D) in pi (fromDec (G, (D\', s)), fromTp (Decl (G, decSub (D\', s)), (V2, dot1 s))) | fromTpW _  = raise (Error ("Type not recognized"))fromTp (G, Vs)  = fromTpW (G, whnf Vs)fromObjW (G, (Root (C, S), s), (V, t))  = root (fromHead (G, C), fromSpine (impCon C, G, (S, s), inferConW (G, C)), fromTp (G, (V, t))) | fromObjW (G, (Lam (D, U), s), (Pi (_, V), t))  = let D\' = decUName (G, D) in lam (fromDec (G, (D\', s)), fromObj (Decl (G, decSub (D\', s)), (U, dot1 s), (V, dot1 t))) | fromObjW _  = raise (Error ("Object not recognized"))fromObj (G, Us, Vt)  = fromObjW (G, whnf Us, whnf Vt)fromSpine (i, G, (Nil, s), Vt)  = nils | fromSpine (i, G, (SClo (S, s\'), s), Vt)  = fromSpine (i, G, (S, comp (s\', s)), Vt) | fromSpine (i, G, (App (U, S), s), (Pi ((Dec (_, V1), _), V2), t))  = if i > 0(* drop implicit arg *)  then fromSpine (i - 1, G, (S, s), whnf (V2, Dot (Exp (EClo (U, s)), t))) else app (fromObj (G, (U, s), (V1, t)), fromSpine (i, G, (S, s), whnf (V2, Dot (Exp (EClo (U, s)), t))))fromDec (G, (Dec (SOME (x), V), s))  = dec (x, fromTp (G, (V, s))) (* NONE should not occur because of call to decName *) (*\n    | fromDec (G, (I.Dec (NONE, V), s)) =\n        T.dec ("_", fromTp (G, (V, s)))\n    *) (* ignore a : K, d : A = M, b : K = A, and skolem constants *) let rec fromConDec (ConDec (c, parent, i, _, V, Type))  = SOME (objdec (c, fromTp (Null, (V, id)))) | fromConDec _  = NONE let fromConDec = fromConDec let rec const (name)  = let qid = match stringToQid name with NONE -> raise (Error ("Malformed qualified identifier " ^ name)) | SOME qid -> qid let cidOpt = constLookup qid let rec getConDec (NONE)  = raise (Error ("Undeclared identifier " ^ qidToString qid)) | getConDec (SOME cid)  = sgnLookup cid let conDec = getConDec cidOpt let _ = varReset Null let rec result (NONE)  = raise (Error ("Wrong kind of declaration")) | result (SOME (r))  = r in result (fromConDec conDec)  (* local ... *)  end\n(* functor Traverse *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', 'module SymbolAscii ()SYMBOL = struct let rec idSize s  = (s, size s) let str = idSize let evar = idSize let bvar = idSize let const = idSize let skonst = idSize let label = idSize let def = idSize let rec fvar s  = idSize ("`" ^ s) let sym = idSize end\n(* functor SymbolAscii *) module SymbolTeXfp ()SYMBOL = struct (* Illegal constituents: \\ _ $ # *)  (* { } are also special, but cannot occur in identifiers *)  let rec quoteChar \'\\\\\'  = "\\\\\\\\" | quoteChar \'_\'  = "\\\\_" | quoteChar \'$\'  = "\\\\$" | quoteChar \'#\'  = "\\\\#" | quoteChar \'\'\'  = "$\'$" | quoteChar \'<\'  = "$<$" | quoteChar \'>\'  = "$>$" | quoteChar \'^\'  = "\\\\^{\\\\ }" | quoteChar \'0\'  = "$_0$" | quoteChar \'1\'  = "$_1$" | quoteChar \'2\'  = "$_2$" | quoteChar \'3\'  = "$_3$" | quoteChar \'4\'  = "$_4$" | quoteChar \'5\'  = "$_5$" | quoteChar \'6\'  = "$_6$" | quoteChar \'7\'  = "$_7$" | quoteChar \'8\'  = "$_8$" | quoteChar \'9\'  = "$_9$" | quoteChar c  = str c let rec quote s  = translate quoteChar s (*\n  fun mathQuoteChar #"\\\\" = "\\\\\\\\"\n    | mathQuoteChar #"_" = "\\\\_"\n    | mathQuoteChar #"$" = "\\\\$"\n    | mathQuoteChar #"#" = "\\\\#"\n    | mathquoteChar #"^" = "\\\\hat{\\\\quad}$"\n    | mathQuoteChar #"0" = "{_0}"\n    | mathQuoteChar #"1" = "{_1}"\n    | mathQuoteChar #"2" = "{_2}"\n    | mathQuoteChar #"3" = "{_3}"\n    | mathQuoteChar #"4" = "{_4}"\n    | mathQuoteChar #"5" = "{_5}"\n    | mathQuoteChar #"6" = "{_6}"\n    | mathQuoteChar #"7" = "{_7}"\n    | mathQuoteChar #"8" = "{_8}"\n    | mathQuoteChar #"9" = "{_9}"\n    | mathQuoteChar c = String.str c\n\n  fun mathQuote s = String.translate mathQuoteChar s\n  *)  let rec str s  = ("\\\\Str{" ^ quote s ^ "}", size s) let rec evar s  = ("\\\\EVar{" ^ quote s ^ "}", size s) let rec bvar s  = ("\\\\BVar{" ^ quote s ^ "}", size s) let rec const s  = ("\\\\Const{" ^ quote s ^ "}", size s) let rec label s  = ("\\\\Label{" ^ quote s ^ "}", size s) let rec skonst s  = ("\\\\Skonst{" ^ quote s ^ "}", size s) let rec def s  = ("\\\\Def{" ^ quote s ^ "}", size s) let rec fvar s  = ("\\\\FVar{" ^ quote s ^ "}", size s) let rec sym "->"  = ("$\\\\rightarrow$", 1) | sym "<-"  = ("$\\\\leftarrow$", 1) | sym "{"  = ("$\\\\Pi$", 1) | sym "}"  = (".", 1) | sym "["  = ("$\\\\lambda$", 1) | sym "]"  = (".", 1) | sym "type"  = ("{\\\\Type}", 4) | sym "kind"  = ("{\\\\Kind}", 4) | sym "_"  = ("\\\\_", 1) | sym "..."  = ("$\\\\ldots$", 3) | sym "%%"  = ("%%", 2) | sym "%skolem"  = ("%skolem", 7) | sym s  = (s, size s) (* ():.= *)  end\n(* functor SymbolTeX *) module SymbolTeX ()SYMBOL = struct (* Illegal constituents: \\ _ $ # *)  (* { } are also special, but cannot occur in identifiers *)  let rec quoteChar \'\\\\\'  = "\\\\\\\\" | quoteChar \'_\'  = "\\\\_" | quoteChar \'$\'  = "\\\\$" | quoteChar \'#\'  = "\\\\#" | quoteChar \'^\'  = "\\\\^{\\\\ }" | quoteChar \'0\'  = "$_0$" | quoteChar \'1\'  = "$_1$" | quoteChar \'2\'  = "$_2$" | quoteChar \'3\'  = "$_3$" | quoteChar \'4\'  = "$_4$" | quoteChar \'5\'  = "$_5$" | quoteChar \'6\'  = "$_6$" | quoteChar \'7\'  = "$_7$" | quoteChar \'8\'  = "$_8$" | quoteChar \'9\'  = "$_9$" | quoteChar c  = str c let rec quote s  = translate quoteChar s (*\n  fun mathQuoteChar #"\\\\" = "\\\\\\\\"\n    | mathQuoteChar #"_" = "\\\\_"\n    | mathQuoteChar #"$" = "\\\\$"\n    | mathQuoteChar #"#" = "\\\\#"\n    | mathquoteChar #"^" = "\\\\hat{\\\\quad}$"\n    | mathQuoteChar #"0" = "{_0}"\n    | mathQuoteChar #"1" = "{_1}"\n    | mathQuoteChar #"2" = "{_2}"\n    | mathQuoteChar #"3" = "{_3}"\n    | mathQuoteChar #"4" = "{_4}"\n    | mathQuoteChar #"5" = "{_5}"\n    | mathQuoteChar #"6" = "{_6}"\n    | mathQuoteChar #"7" = "{_7}"\n    | mathQuoteChar #"8" = "{_8}"\n    | mathQuoteChar #"9" = "{_9}"\n    | mathQuoteChar c = String.str c\n\n  fun mathQuote s = String.translate mathQuoteChar s\n  *)  let rec str s  = ("\\\\Str{" ^ quote s ^ "}", size s) let rec evar s  = ("\\\\EVar{" ^ quote s ^ "}", size s) let rec bvar s  = ("\\\\BVar{" ^ quote s ^ "}", size s) let rec const s  = ("\\\\Const{" ^ quote s ^ "}", size s) let rec label s  = ("\\\\Label{" ^ quote s ^ "}", size s) let rec skonst s  = ("\\\\Skonst{" ^ quote s ^ "}", size s) let rec def s  = ("\\\\Def{" ^ quote s ^ "}", size s) let rec fvar s  = ("\\\\FVar{" ^ quote s ^ "}", size s) let rec sym "->"  = ("$\\\\rightarrow$", 1) | sym "<-"  = ("$\\\\leftarrow$", 1) | sym "{"  = ("$\\\\Pi$", 1) | sym "}"  = (".", 1) | sym "["  = ("$\\\\lambda$", 1) | sym "]"  = (".", 1) | sym "type"  = ("{\\\\Type}", 4) | sym "kind"  = ("{\\\\Kind}", 4) | sym "_"  = ("\\\\_", 1) | sym "..."  = ("$\\\\ldots$", 3) | sym "%%"  = ("%%", 2) | sym "%skolem"  = ("%skolem", 7) | sym s  = (s, size s) (* ():.= *)  end\n(* functor SymbolTeXcd *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Clause Printing *) (* Author: Frank Pfenning, Carsten Schuermann *) module type CLAUSEPRINT = sig (*! structure IntSyn : INTSYN !*) module Formatter : FORMATTERval formatClause : dctx * Exp -> formatval formatConDec : ConDec -> formatval clauseToString : dctx * Exp -> stringval conDecToString : ConDec -> stringval printSgn : unit -> unit end\n(* signature CLAUSEPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module SymbolAscii = SymbolAscii()
module SymbolTeX = SymbolTeX()
(*
structure WorldPrint = WorldPrint 
  (structure Global = Global
   (*! structure IntSyn = IntSyn !*)
   (*! structure Tomega' = Tomega !*)
   structure WorldSyn' = WorldSyn
   structure Names = Names
   structure Formatter' = Formatter
   structure Print = Print);
*) module Print = Print(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter module Symbol = SymbolAscii end)
module ClausePrint = ClausePrint(struct module Whnf = Whnf module Names = Names module Formatter' = Formatter module Print = Print module Symbol = SymbolAscii end)
module PrintTeX = Print(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter module Symbol = SymbolTeX end)
module ClausePrintTeX = ClausePrint(struct module Whnf = Whnf module Constraints = Constraints module Names = Names module Formatter' = Formatter module Print = PrintTeX module Symbol = SymbolTeX end)
module PrintTwega = PrintTwega(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter end)
module PrintXML = PrintXML(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter end)
module PrintOMDoc = PrintOMDoc(struct module Whnf = Whnf module Abstract = Abstract module Constraints = Constraints module Names = Names module Formatter' = Formatter end)

('Error parsing code:', '(* Printing Signatures *) (* Author: Frank Pfenning *) (* modified: Carsten Schuermann *) module type PRINT_XML = sig val printSgn : unit -> unitval printSgnToFile : string -> string -> unit end\n(* signature PRINT_XML *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: (* Printing Signatures to OMDoc*) (* Author: Florian Rabe *) module type PRINT_OMDOC = sig (* printSgn F n exports the current signature as an OMDoc document to the file with path F. If n is true, all constant and variable names are replaced to guarantee uniqueness of names. Otherwise, the user has to make sure that no overloading is used. *) val printSgn : string -> bool -> unit(* printConst c prints the OMDoc fragment (without name safety) for the constant with cid c. *) val printConst : cid -> string end
(* signature PRINT_XML *) 
('Error parsing code:', '(* Printing *) (* Author: Frank Pfenning *) (* Modified: Jeff Polakow *) (* Modified: Carsten Schuermann *) (* Modified: Florian Rabe *) module PrintOMDoc ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Formatter\' : FORMATTER) : PRINT_OMDOC = struct (*! structure IntSyn = IntSyn\' !*)  module Formatter = Formatter\' (* Shorthands *) module I = IntSyn(* The Formatter isn\'t really helpful for OMDoc output. So the basic functions are reimplemented here.\n     indent : current indentatioin width\n     nl_ind()() : newline and indent\n     nl_unind()() : newline and unindent\n     nl() : newline (with current indentation) *) let indent = ref 0 let tabstring = "   " let rec tabs (n)  = if (n <= 0) then "" else tabstring ^ tabs (n - 1) let rec ind_reset ()  = (indent := 0) let rec ind (n)  = indent := ! indent + n let rec unind (n)  = indent := ! indent - n let rec nl_ind ()  = (indent := ! indent + 1; "\\n" ^ tabs (! indent)) let rec nl_unind ()  = (indent := ! indent - 1; "\\n" ^ tabs (! indent)) let rec nl ()  = "\\n" ^ tabs (! indent) let rec escape s  = let rec escapelist nil  = nil | escapelist (\'&\' :: rest)  = explode "&amp;" @ (escapelist rest) | escapelist (\'<\' :: rest)  = explode "&lt;" @ (escapelist rest) | escapelist (\'>\' :: rest)  = explode "&gt;" @ (escapelist rest) | escapelist (c :: rest)  = c :: (escapelist rest) in implode (escapelist (explode s)) (* If namesafe is true during printing, the output is guaranteed to be namesafe (no duplicate names).\n    But it doesn\'t look good. If the user knows that are no overloaded constants, namesafe can be set to false. *) let namesafe = ref true (* XML start characters: ":" | "_" | [A-Z] | [a-z], further characters: "-" | "." | [0-9] *) let rec replace c  = if (isAlphaNum c) || (contains ":_-." c) then (str c) else "_" let rec Name (cid)  = let n = conDecName (sgnLookup cid) let name = translate replace n let start = if (isAlpha (sub (name, 0))) || (sub (name, 0) = \'_\') then "" else "_" in if (! namesafe) then start ^ name ^ "__c" ^ (toString cid) else n (* x must be the number of the varialbe in left ro right order in the context *) let rec VarName (x, n)  = let name = translate replace n let start = if (isAlpha (sub (name, 0))) || (sub (name, 0) = \'_\') then "" else "_" in if (! namesafe) then start ^ name ^ "__v" ^ (toString x) else n (* Some original Formatter functions replaced with trivial functions. *) (* val Str  = F.String\n  fun Str0 (s, n) = F.String0 n s\n  fun Integer (n) = ("\\"" ^ Int.toString n ^ "\\"") *) let rec Str (s)  = s (* fun sexp (fmts) = F.Hbox [F.HVbox fmts] *) let rec sexp (l)  = concat l (* This is probably defined elsewhere, too. It\'s needed to check how many arguments there will be in an om:OMA element *) let rec spineLength Nil  = 0 | spineLength (SClo (S, _))  = spineLength S | spineLength (App (_, S))  = 1 + (spineLength S) (* fmtCon (c) = "c" where the name is assigned according the the Name table\n     maintained in the names module.\n     FVar\'s are printed with a preceding "`" (backquote) character\n  *) let rec fmtCon (G, BVar (x))  = let Dec (SOME n, _) = ctxDec (G, x) in sexp [Str ("<om:OMV name=\\"" ^ VarName (ctxLength G - x + 1, n) ^ "\\"/>")] | fmtCon (G, Const (cid))  = sexp [Str "<om:OMS cd=\\"global\\" name=\\""; Name cid; Str "\\"/>"] | fmtCon (G, Def (cid))  = sexp [Str "<om:OMS cd=\\"global\\" name=\\""; Name cid; Str "\\"/>"] | fmtCon (G, FgnConst (csid, condec))  = sexp [Str "FgnConst"] (* FIX -cs Fri Jan 28 17:45:35 2005*) (* I.Skonst, I.FVar cases should be impossible *) (* fmtUni (L) = "L" *) let rec fmtUni (Type)  = Str "<om:OMS cd=\\"twelf\\" name=\\"type\\"/>" | fmtUni (Kind)  = Str "<om:OMS cd=\\"twelf\\" name=\\"kind\\"/>" (* fmtExpW (G, (U, s)) = fmt\n\n     format the expression U[s].\n\n     Invariants:\n       G is a "printing context" (names in it are unique, but\n            types may be incorrect) approximating G\'\n       G\'\' |- U : V   G\' |- s : G\'\'  (so  G\' |- U[s] : V[s])\n       (U,s) in whnf\n  *) let rec fmtExpW (G, (Uni (L), s), _)  = sexp [fmtUni L] | fmtExpW (G, (Pi ((D as Dec (_, V1), P), V2), s), imp)  = (match P(* if Pi is dependent but anonymous, invent name here *)  with Maybe -> (* could sometimes be EName *) (* temporary indentation *) let (D\' as Dec (SOME (name), V1\')) = decLUName (G, D) let G\' = Decl (G, D\') let _ = ind (1) let fmtBody = fmtExp (G\', (V2, dot1 s), max (0, imp - 1)) let _ = ind (1) let fmtType = fmtExp (G, (V1\', s), 0) let _ = unind (2) let pi = if (imp > 0) then "implicit_Pi" else "Pi" let id = VarName (ctxLength G\', name) in fmtBinder (pi, name, id, fmtType, fmtBody) | No -> let G\' = Decl (G, D) in sexp [Str "<om:OMA>"; nl_ind (); Str "<om:OMS cd=\\"twelf\\" name=\\"arrow\\"/>"; nl (); fmtExp (G, (V1, s), 0); nl (); fmtExp (G\', (V2, dot1 s), 0); nl_unind (); Str "</om:OMA>"]) | fmtExpW (G, (Root (H, S), s), _)  = let l = spineLength (S) let out = ref "" let _ = if (l = 0) then (* no arguments *) out := ! out ^ fmtCon (G, H) else (* an application *) (* If there are more than two explicit arguments to an infix operator,\n                   the implict and the first two explicit arguments have to be wrapped in their own om:OMA element.\n                   In this case, the output will not be in normal form. *) (* print constant and arguments,\n           args is passed to fmtSpine so that fmtSpine can insert a closing tag after args arguments, 0 means no effect *) let _ = out := ! out ^ "<om:OMA>" ^ nl_ind () let (test, cid) = match H with Const (c) -> (true, c) | Skonst (c) -> (true, c) | Def (c) -> (true, c) | NSDef (c) -> (true, c) | _ -> (false, 0) let imp = conDecImp (sgnLookup cid) let (test, args) = if test then match getFixity cid with Infix (_, _) -> (true, imp + 2) | _ -> (false, 0) else (false, 0) let _ = if test && (l > args) then out := ! out ^ "<om:OMA>" ^ nl_ind () else () in out := ! out ^ fmtCon (G, H) ^ fmtSpine (G, (S, s), args) ^ "</om:OMA>" in ! out | fmtExpW (G, (Lam (D, U), s), imp)  = (* temporary indentation *) let (D\' as Dec (SOME (name), V)) = decLUName (G, D) let G\' = Decl (G, D\') let _ = ind (1) let fmtBody = fmtExp (G\', (U, dot1 s), max (0, imp - 1)) let _ = ind (1) let fmtType = fmtExp (G, (V, s), 0) let _ = unind (2) let lam = if (imp > 0) then "implicit_lambda" else "lambda" let id = VarName (ctxLength G\', name) in fmtBinder (lam, name, id, fmtType, fmtBody) | fmtExpW (G, (FgnExp (csid, F), s), 0)  = sexp [Str "FgnExp"](* FIX -cs Fri Jan 28 17:45:43 2005 *) (* I.EClo, I.Redex, I.EVar not possible *) fmtExp (G, (U, s), imp)  = fmtExpW (G, whnf (U, s), imp)(* fmtSpine (G, (S, s), args) = fmts\n     format spine S[s] at printing depth d, printing length l, in printing\n     context G which approximates G\', where G\' |- S[s] is valid\n     args is the number of arguments after which </om:OMA> must be inserted, no effect if negative\n  *) fmtSpine (G, (Nil, _), _)  = nl_unind () | fmtSpine (G, (SClo (S, s\'), s), args)  = fmtSpine (G, (S, comp (s\', s)), args) | fmtSpine (G, (App (U, S), s), args)  = (* print first argument, 0 is dummy value *) (* close application if args reaches 0 *) (* print remaining arguments *) let out = ref (nl () ^ fmtExp (G, (U, s), 0)) let _ = if (args = 1) && (spineLength (S) > 0) then out := ! out ^ nl_unind () ^ "</om:OMA>" else () in ! out ^ fmtSpine (G, (S, s), args - 1)fmtExpTop (G, (U, s), imp)  = sexp [Str "<om:OMOBJ>"; nl_ind (); fmtExp (G, (U, s), imp); nl_unind (); Str "</om:OMOBJ>"](* top-level and shared OMDoc output, used in fmtConDec *) fmtBinder (binder, varname, varid, typ, body)  = "<om:OMBIND>" ^ nl_ind () ^ "<om:OMS cd=\\"twelf\\" name=\\"" ^ binder ^ "\\"/>" ^ nl () ^ "<om:OMBVAR><om:OMATTR>" ^ nl_ind () ^ (if (! namesafe) then ("<om:OMATP><om:OMS cd=\\"omdoc\\" name=\\"notation\\"/><om:OMFOREIGN encoding=\\"application/omdoc+xml\\">" ^ "<presentation for=\\"#" ^ varid ^ "\\"><use format=\\"twelf\\">" ^ varname ^ "</use></presentation>" ^ "</om:OMFOREIGN></om:OMATP>") else (* In the presentation information for variables can be omitted since it\'s their name anyway *) "") ^ "<om:OMATP>" ^ nl () ^ "<om:OMS cd=\\"twelf\\" name=\\"oftype\\"/>" ^ nl () ^ typ ^ nl () ^ "</om:OMATP>" ^ nl () ^ "<om:OMV name=\\"" ^ varid ^ "\\"/>" ^ nl_unind () ^ "</om:OMATTR></om:OMBVAR>" ^ nl () ^ body ^ nl_unind () ^ "</om:OMBIND>"fmtSymbol (name, V, imp)  = "<symbol name=\\"" ^ name ^ "\\">" ^ nl_ind () ^ "<type system=\\"twelf\\">" ^ nl_ind () ^ fmtExpTop (Null, (V, id), imp) ^ nl_unind () ^ "</type>" ^ nl_unind () ^ "</symbol>"fmtDefinition (name, U, imp)  = "<definition xml:id=\\"" ^ name ^ ".def\\" for=\\"#" ^ name ^ "\\">" ^ nl_ind () ^ fmtExpTop (Null, (U, id), imp) ^ nl_unind () ^ "</definition>"fmtPresentation (cid)  = let imp = conDecImp (sgnLookup cid) let fixity = getFixity (cid) let fixString = " fixity=\\"" ^ (match fixity with Nonfix -> "prefix"(* case identified by @precedence = Names.Fixity.minPrefInt *)  | Infix (prec, assoc) -> (match assoc with Left -> "infixl" | Right -> "infixr" | None -> "infix") | Prefix (prec) -> "prefix" | Postfix (prec) -> "postfix") ^ "\\"" let precString = " precedence=\\"" ^ (toString (precToIntAsc (fixity))) ^ "\\"" let bracString = " bracket-style=\\"lisp\\" lbrack=\\"(\\" rbrack=\\")\\"" let sepString = " separator=\\" \\"" let implicitString = " implicit=\\"" ^ (toString imp) ^ "\\"" let useString1 = "<use format=\\"twelf\\"" let useString2 = ">" ^ (escape (conDecName (sgnLookup cid))) ^ "</use>" let presString1 = "<presentation for=\\"#" ^ (Name cid) ^ "\\"" let presString2 = "</presentation>" in presString1 ^ ">" ^ nl_ind () ^ useString1 ^ useString2 ^ nl_unind () ^ presString2 ^ nl () ^ presString1 ^ " role=\\"applied\\"" ^ fixString ^ precString ^ bracString ^ sepString ^ implicitString ^ ">" ^ nl_ind () ^ useString1 ^ useString2 ^ nl_unind () ^ presString2(* fixity string attached to omdoc file in private element (no escaping, fixity string cannot contain ]]>) *) fmtFixity (cid)  = let fixity = getFixity (cid) let name = conDecName (sgnLookup cid) in if (fixity = Nonfix) then "" else nl () ^ "<private for=\\"#" ^ (Name cid) ^ "\\">" ^ nl_ind () ^ "<data format=\\"twelf\\"><![CDATA[" ^ (toString fixity) ^ " " ^ name ^ ".]]></data>" ^ nl_unind () ^ "</private>" (* fmtConDec (condec) = fmt\n     formats a constant declaration (which must be closed and in normal form)\n\n     This function prints the quantifiers and abstractions only if hide = false.\n  *) let rec fmtConDec (cid, ConDec (name, parent, imp, _, V, L))  = let _ = varReset Null let name = Name cid in fmtSymbol (name, V, imp) | fmtConDec (_, SkoDec (name, parent, imp, V, L))  = Str ("<!-- Skipping Skolem constant " ^ name ^ "-->") | fmtConDec (cid, ConDef (name, parent, imp, U, V, L, _))  = let _ = varReset Null let name = Name cid in fmtSymbol (name, V, imp) ^ nl () ^ fmtDefinition (name, U, imp) | fmtConDec (cid, AbbrevDef (name, parent, imp, U, V, L))  = let _ = varReset Null let name = Name cid in fmtSymbol (name, V, imp) ^ nl () ^ fmtDefinition (name, U, imp) | fmtConDec (_, BlockDec (name, _, _, _))  = Str ("<!-- Skipping Skolem constant " ^ name ^ "-->") (* In the functions below, G must be a "printing context", that is,\n     (a) unique names must be assigned to each declaration which may\n         actually applied in the scope (typically, using Names.decName)\n     (b) types need not be well-formed, since they are not used\n  *) let rec formatExp (G, U, imp)  = fmtExp (G, (U, id), imp) (*  fun formatSpine (G, S) = sexp (fmtSpine (G, (S, I.id))) *) let rec formatConDec (condec)  = fmtConDec (condec) (* fun expToString (G, U) = F.makestring_fmt (formatExp (G, U, 0)) *) let rec conDecToString (condec)  = (formatConDec (condec)) let rec fmtConst cid  = formatConDec (cid, sgnLookup cid) ^ "\\n" ^ fmtPresentation (cid) ^ fmtFixity (cid) let rec printConst cid  = (namesafe := false; fmtConst cid) let rec printSgn filename ns  = let _ = namesafe := ns let _ = ind_reset () let file = openOut (filename) let OMDocPrefix = "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n" ^ "<!DOCTYPE omdoc PUBLIC \\"-//OMDoc//DTD OMDoc V1.2//EN\\" " ^ (* "\\"https://svn.mathweb.org/repos/mathweb.org/branches/omdoc-1.2/dtd/omdoc.dtd\\">\\n" ^ *)  "\\"../../dtd/omdoc.dtd\\">\\n" ^ "<omdoc xml:id=\\"" ^ filename ^ "\\" " ^ "xmlns=\\"http://www.mathweb.org/omdoc\\" " ^ "xmlns:om=\\"http://www.openmath.org/OpenMath\\" " ^ "version=\\"1.2\\">\\n\\n" let _ = output (file, OMDocPrefix ^ "<theory xml:id=\\"global\\">\\n\\n") let _ = sgnApp (fun (cid) -> ((output (file, fmtConst cid)); output (file, "\\n\\n"))) let _ = output (file, "</theory>\\n\\n</omdoc>") let _ = closeOut file in ()  (* local ... *)  end(* functor PrintXml *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module type SYMBOL = sig val str : string -> string * intval evar : string -> string * intval bvar : string -> string * intval const : string -> string * intval label : string -> string * intval skonst : string -> string * intval def : string -> string * intval fvar : string -> string * intval sym : string -> string * int end\n(* signature SYMBOL *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Printing *) (* Author: Frank Pfenning *) (* Modified: Jeff Polakow *) module PrintTwega ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module Constraints : CONSTRAINTS(*! sharing Constraints.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Formatter\' : FORMATTER) : PRINT_TWEGA = struct (*! structure IntSyn = IntSyn\' !*)  module Formatter = Formatter\' (* Shorthands *) module I = IntSynmodule F = Formatterlet Str = String let rec Str0 (s, n)  = String0 n s let rec Name (x)  = String ("\\"" ^ x ^ "\\"") let rec Integer (n)  = String (toString n) let rec sexp (fmts)  = Hbox [Str "("; HVbox fmts; Str ")"] (* fmtCon (c) = "c" where the name is assigned according the the Name table\n     maintained in the names module.\n     FVar\'s are printed with a preceding "`" (backquote) character\n  *) let rec fmtCon (G, BVar (n))  = sexp [Str "tw~bvar"; Break; Integer n] | fmtCon (G, Const (cid))  = sexp [Str "tw~const"; Break; Integer cid] | fmtCon (G, Def (cid))  = sexp [Str "tw~def"; Break; Integer cid] (* I.Skonst, I.FVar cases should be impossible *) (* fmtUni (L) = "L" *) let rec fmtUni (Type)  = Str "tw*type" | fmtUni (Kind)  = Str "tw*kind" (* fmtExpW (G, (U, s)) = fmt\n\n     format the expression U[s].\n\n     Invariants:\n       G is a "printing context" (names in it are unique, but\n            types may be incorrect) approximating G\'\n       G\'\' |- U : V   G\' |- s : G\'\'  (so  G\' |- U[s] : V[s])\n       (U,s) in whnf\n  *) let rec fmtExpW (G, (Uni (L), s))  = sexp [Str "tw~uni"; Break; fmtUni L] | fmtExpW (G, (Pi ((D as Dec (_, V1), P), V2), s))  = (match P(* if Pi is dependent but anonymous, invent name here *)  with Maybe -> (* could sometimes be EName *) let D\' = decLUName (G, D) let G\' = Decl (G, D\') in sexp [Str "tw~pi"; Break; fmtDec (G, (D\', s)); Break; Str "tw*maybe"; Break; fmtExp (G\', (V2, dot1 s))] | No -> let G\' = Decl (G, D) in sexp [Str "tw~pi"; Break; fmtDec (G, (D, s)); Break; Str "tw*no"; Break; fmtExp (G\', (V2, dot1 s))]) | fmtExpW (G, (Root (H, S), s))  = sexp [Str "tw~root"; Break; fmtCon (G, H); Break; fmtSpine (G, (S, s))] | fmtExpW (G, (Lam (D, U), s))  = let D\' = decLUName (G, D) let G\' = Decl (G, D\') in sexp [Str "tw~lam"; Break; fmtDec (G, (D\', s)); Break; fmtExp (G\', (U, dot1 s))](* I.EClo, I.Redex, I.EVar not possible *) fmtExp (G, (U, s))  = fmtExpW (G, whnf (U, s))(* fmtSpine (G, (S, s)) = fmts\n     format spine S[s] at printing depth d, printing length l, in printing\n     context G which approximates G\', where G\' |- S[s] is valid\n  *) fmtSpine (G, (Nil, _))  = Str "tw*empty-spine" | fmtSpine (G, (SClo (S, s\'), s))  = fmtSpine (G, (S, comp (s\', s))) | fmtSpine (G, (App (U, S), s))  = sexp [Str "tw~app"; Break; fmtExp (G, (U, s)); Break; fmtSpine (G, (S, s))]fmtDec (G, (Dec (NONE, V), s))  = sexp [Str "tw~decl"; Break; Str "nil"; Break; fmtExp (G, (V, s))] | fmtDec (G, (Dec (SOME (x), V), s))  = sexp [Str "tw~decl"; Break; Name x; Break; fmtExp (G, (V, s))] (* fmtConDec (condec) = fmt\n     formats a constant declaration (which must be closed and in normal form)\n\n     This function prints the quantifiers and abstractions only if hide = false.\n  *) let rec fmtConDec (ConDec (name, parent, imp, _, V, L))  = let _ = varReset Null in sexp [Str "tw~defConst"; Space; Name (name); Break; Integer (imp); Break; fmtExp (Null, (V, id)); Break; fmtUni (L)] | fmtConDec (SkoDec (name, parent, imp, V, L))  = Str ("%% Skipping Skolem constant " ^ name ^ " %%") | fmtConDec (ConDef (name, parent, imp, U, V, L, _))  = let _ = varReset Null in sexp [Str "tw~defConst"; Space; Name (name); Break; Integer (imp); Break; fmtExp (Null, (U, id)); Break; fmtExp (Null, (V, id)); Break; fmtUni (L)] | fmtConDec (AbbrevDef (name, parent, imp, U, V, L))  = let _ = varReset Null in sexp [Str "tw~defConst"; Space; Name (name); Break; Integer (imp); Break; fmtExp (Null, (U, id)); Break; fmtExp (Null, (V, id)); Break; fmtUni (L)] (* fmtEqn assumes that G is a valid printing context *) let rec fmtEqn (Eqn (G, U1, U2))  = (* print context?? *)  sexp [Str "tw*eqn"; Break; fmtExp (G, (U1, id)); Break; fmtExp (G, (U2, id))] (* fmtEqnName and fmtEqns do not assume that G is a valid printing\n     context and will name or rename variables to make it so.\n     fmtEqns should only be used for printing constraints.\n  *) let rec fmtEqnName (Eqn (G, U1, U2))  = fmtEqn (Eqn (ctxLUName G, U1, U2)) (* In the functions below, G must be a "printing context", that is,\n     (a) unique names must be assigned to each declaration which may\n         actually applied in the scope (typically, using Names.decName)\n     (b) types need not be well-formed, since they are not used\n  *) let rec formatDec (G, D)  = fmtDec (G, (D, id)) let rec formatExp (G, U)  = fmtExp (G, (U, id)) let rec formatSpine (G, S)  = fmtSpine (G, (S, id)) let rec formatConDec (condec)  = fmtConDec (condec) let rec formatEqn (E)  = fmtEqn E let rec decToString (G, D)  = makestring_fmt (formatDec (G, D)) let rec expToString (G, U)  = makestring_fmt (formatExp (G, U)) let rec conDecToString (condec)  = makestring_fmt (formatConDec (condec)) let rec eqnToString (E)  = makestring_fmt (formatEqn E) let rec printSgn ()  = sgnApp (fun (cid) -> (print (makestring_fmt (formatConDec (sgnLookup cid))); print "\\n")) let rec printSgnToFile filename  = let file = openOut filename let _ = sgnApp (fun (cid) -> (output (file, makestring_fmt (formatConDec (sgnLookup cid))); output (file, "\\n"))) let _ = closeOut file in ()  (* local ... *)  end(* functor Print *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Printing Signatures *) (* Author: Frank Pfenning *) module type PRINT_TWEGA = sig val printSgn : unit -> unitval printSgnToFile : string -> unit end\n(* signature PRINT_TWEGA *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Stream Library *) (* Author: Frank Pfenning *) (* BASIC_STREAM defines the visible "core" of streams *) module type BASIC_STREAM = sig type \'astreamtype \'afrontEmptyCons\'a * \'a stream(* Lazy stream construction and exposure *) val delay : (unit -> \'a front) -> \'a streamval expose : \'a stream -> \'a front(* Eager stream construction *) val empty : \'a streamval cons : \'a * \'a stream -> \'a stream end\nmodule BasicStreamBASIC_STREAM = struct type stream = Stream of unit -> \'a front and front = Empty | Cons of \'a * \'a stream let rec delay (d)  = Stream (d) let rec expose (Stream (d))  = d () let empty = Stream (fun () -> Empty) let rec cons (x, s)  = Stream (fun () -> Cons (x, s)) end\n(* Note that this implementation is NOT semantically *) (* equivalent to the plain (non-memoizing) streams, since *) (* effects will be executed only once in this implementation *) module BasicMemoStreamBASIC_STREAM = struct type stream = Stream of unit -> \'a front and front = Empty | Cons of \'a * \'a stream exception Uninitialized let rec expose (Stream (d))  = d () let rec delay (d)  = let memo = ref (fun () -> raise (Uninitialized)) let rec memoFun ()  = try  with in memo := memoFun; Stream (fun () -> ! memo ()) let empty = Stream (fun () -> Empty) let rec cons (x, s)  = Stream (fun () -> Cons (x, s)) end\n(* STREAM extends BASIC_STREAMS by operations *) (* definable without reference to the implementation *) module type STREAM = sig include BASIC_STREAMexception EmptyStreamval null : \'a stream -> boolval hd : \'a stream -> \'aval tl : \'a stream -> \'a streamval map : (\'a -> \'b) -> \'a stream -> \'b streamval filter : (\'a -> bool) -> \'a stream -> \'a streamval exists : (\'a -> bool) -> \'a stream -> boolval take : \'a stream * int -> \'a listval drop : \'a stream * int -> \'a streamval fromList : \'a list -> \'a streamval toList : \'a stream -> \'a listval tabulate : (int -> \'a) -> \'a stream end\nmodule Stream (module BasicStream : BASIC_STREAM)STREAM = struct open BasicStream exception EmptyStream (* functions null, hd, tl, map, filter, exists, take, drop *)  (* parallel the functions in the List structure *)  let rec null (s)  = null\' (expose s)null\' (Empty)  = true | null\' (Cons _)  = false let rec hd (s)  = hd\' (expose s)hd\' (Empty)  = raise (EmptyStream) | hd\' (Cons (x, s))  = x let rec tl (s)  = tl\' (expose s)tl\' (Empty)  = raise (EmptyStream) | tl\' (Cons (x, s))  = s let rec map f s  = delay (fun () -> map\' f (expose s))map\' f (Empty)  = Empty | map\' f (Cons (x, s))  = Cons (f (x), map f s) let rec filter p s  = delay (fun () -> filter\' p (expose s))filter\' p (Empty)  = Empty | filter\' p (Cons (x, s))  = if p (x) then Cons (x, filter p s) else filter\' p (expose s) let rec exists p s  = exists\' p (expose s)exists\' p (Empty)  = false | exists\' p (Cons (x, s))  = p (x) || exists p s let rec takePos (s, 0)  = nil | takePos (s, n)  = take\' (expose s, n)take\' (Empty, _)  = nil | take\' (Cons (x, s), n)  = x :: takePos (s, n - 1) let rec take (s, n)  = if n < 0 then raise (Subscript) else takePos (s, n) let rec fromList (nil)  = empty | fromList (x :: l)  = cons (x, fromList (l)) let rec toList (s)  = toList\' (expose s)toList\' (Empty)  = nil | toList\' (Cons (x, s))  = x :: toList (s) let rec dropPos (s, 0)  = s | dropPos (s, n)  = drop\' (expose s, n)drop\' (Empty, _)  = empty | drop\' (Cons (x, s), n)  = dropPos (s, n - 1) let rec drop (s, n)  = if n < 0 then raise (Subscript) else dropPos (s, n) let rec tabulate f  = delay (fun () -> tabulate\' f)tabulate\' f  = Cons (f (0), tabulate (fun i -> f (i + 1))) end\n(* structure Stream :> STREAM --- non-memoizing *) module StreamSTREAM = Stream(module BasicStream = BasicStream)\n(* structure MStream :> STREAM --- memoizing *) module MStreamSTREAM = Stream(module BasicStream = BasicMemoStream)\n(*\nstructure S = Stream;  (* abbreviation *)\n\n(* simple definition *)\nfun ones\' () = S.Cons(1, S.delay ones\');\nval ones = S.delay ones\';\n\n(* alternative definitions *)\nval ones = S.tabulate (fn _ => 1);\nval nats = S.tabulate (fn i => i);\nval poss = S.map (fn i => i+1) nats;\nval evens = S.map (fn i => 2*i) nats;\n\n(* notMultiple p q >=> true iff q is not a multiple of p *)\nfun notMultiple p q = (q mod p <> 0);\n\nfun sieve s = S.delay (fn () => sieve\' (S.expose s))\nand sieve\' (S.Empty) = S.Empty\n  | sieve\' (S.Cons(p, s)) =\n      S.Cons (p, sieve (S.filter (notMultiple p) s));\n\nval primes = sieve (S.tabulate (fn i => i+2));\n*) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', "(* Gaussian-Elimination Equation Solver *) (* Author: Roberto Virga *) module type CS_EQ_FIELD = sig include CSmodule Field : FIELD(*! structure IntSyn : INTSYN !*) (* Foreign expressions *) type 'amset = 'a list(* MultiSet                   *) type SumSumnumber * Mon mset and MonMonnumber * Exp * Sub mset(* Mon ::= n * U1[s1] * ...   *) val fromExp : eclo -> Sumval toExp : Sum -> Expval normalize : Sum -> Sumval compatibleMon : Mon * Mon -> bool(* Internal expressions constructors *) val number : unit -> Expval unaryMinus : Exp -> Expval plus : Exp * Exp -> Expval minus : Exp * Exp -> Expval times : Exp * Exp -> Expval constant : number -> Exp end(* signature CS_EQ_FIELD *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Solver for linear inequations, based on branch & bound *) (* Author: Roberto Virga *) module CSIneqIntegers (module Integers : INTEGERSmodule Rationals : RATIONALSRationalsIntegersIntegers(*! structure IntSyn : INTSYN !*) module Trail : TRAILmodule Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) module SparseArray : SPARSE_ARRAYmodule SparseArray2 : SPARSE_ARRAY2(*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) module CSEqIntegers : CS_EQ_INTEGERSCSEqIntegersIntegersIntegers(*! sharing CSEqIntegers.IntSyn = IntSyn !*) (*! sharing CSEqIntegers.CSManager = CSManager !*) module Compat : COMPAT) = struct (*! structure CSManager = CSManager !*)  open IntSyn open Rationals open CSEqIntegers module CSM = CSManagermodule FX = CSMFixitymodule MS = ModeSyn(* CSM.ModeSyn *) module Array = SparseArraymodule Array2 = SparseArray2(* useful integer values *) let zero_int = fromInt (0) let one_int = fromInt (1) (* solver ID of this solver *) let myID = ref ~1 : cid ref (* constant IDs of the declared type constants *) let geqID = ref ~1 : cid ref (* constructors for the declared types *) let rec geq (U, V)  = Root (Const (! geqID), App (U, App (V, Nil))) (* specialized constructors for the declared types *) let rec geq0 (U)  = geq (U, constant (zero_int)) (* constant IDs of the declared object constants *) let geqAddID = ref ~1 : cid ref (* constructors for the declared objects *) let rec geqAdd (U1, U2, V, W)  = Root (Const (! geqAddID), App (U1, App (U2, App (V, App (W, Nil))))) (* constant declaration for the proof object d>=0 *) let rec geqNConDec (d)  = ConDec (toString (d) ^ ">=" ^ toString (zero_int), NONE, 0, Normal, geq0 (constant (d)), Type) (* foreign constant for the proof object d>=0 *) let rec geqNExp (d)  = Root (FgnConst (! myID, geqNConDec (d)), Nil) (* parsing proof objects d>=0 *) let rec parseGeqN string  = let suffix = (">=" ^ (toString (zero))) let stringLen = size string let suffixLen = size suffix let numLen = - (stringLen, suffixLen) in if > (stringLen, suffixLen) && (substring (string, numLen, suffixLen) = suffix) then (match fromString (substring (string, 0, numLen)) with SOME (d) -> if >= (d, zero_int) then SOME (geqNConDec (d)) else NONE | NONE -> NONE) else NONE type Position = Row of int | Col of int type Owner = Var of dctx * Mon | Exp of dctx * Sum (*   - sum                           *) type Restriction = Restr of dctx * Exp (*   Restr (G, U)                    *) type label = {owner: Owner; (* owner of the row/column (if any)  *) ; tag: int ref; (* tag: used to keep track of the    *) ; (* position of a tableau entry       *) ; restr: Restriction option ref; (* restriction (if any)              *) ; dead: bool ref} (* has the row/column already been   *) (* solved?                           *) type Operation = Insert of Position | Pivot of int * int | Kill of Position | Restrict of Position | UpdateOwner of Position * Owner * int ref (* change the owner                  *) type tableau = (* Tableau:                          *) {rlabels: label array; (* row labels                        *) ; clabels: label array; (* column labels                     *) ; consts: number array; (* constant terms                    *) ; coeffs: number array; (* variables coefficients            *) ; nrows: int ref; ncols: int ref; (* dimensions                        *) ; trail: Operation trail} (* undo mechanism                    *) exception MyFgnCnstrRep of int ref (* FgnCnstr representation *) exception Error (* Representational invariants:\n         rlabels[i] = vacuous\n         clabels[j] = vacuous\n         const[i] = zero\n         coeff[i,j] = zero\n       for i >= !nrows or j > !ncols, where "vacuous" is the vacuous label:\n          #owner(vacuous) = Exp (Null, Sum (zero, nil))\n          #restr(vacuous) = ref NONE\n          #dead(vacuous) = ref true\n    *) (* little random generation routine taken from Paulson \'91 *) let a = 16807.0 and m = 2147483647.0 let seed = ref 1999.0 let rec rand (min, size)  = let rec nextrand ()  = let t = * (a, ! seed) in (seed := - (t, * (m, fromInt (floor (t / m)))); - (! seed, 1.0) / - (m, 1.0)) in + (min, floor (* (nextrand (), fromInt (size)))) (* create a new (empty) tableau *) let tableau = let l = {owner = Exp (Null, Sum (zero_int, nil)); tag = ref 0; restr = ref NONE; dead = ref true} in {rlabels = array (l); clabels = array (l); consts = array (zero); coeffs = array (zero); nrows = ref 0; ncols = ref 0; trail = trail ()} : tableau (* i-th tableau row label *) let rec rlabel (i)  = sub (rlabels (tableau), i) (* j-th tableau column label *) let rec clabel (j)  = sub (clabels (tableau), j) (* i-th tableau constant term *) let rec const (i)  = sub (consts (tableau), i) (* coefficient in row i, column j *) let rec coeff (i, j)  = sub (coeffs (tableau), i, j) (* number of rows *) let rec nRows ()  = ! (nrows (tableau)) (* number of columns *) let rec nCols ()  = ! (ncols (tableau)) (* increase the number of rows, and return the index of the last row *) let rec incrNRows ()  = let old = nRows () in (nrows (tableau) := + (old, 1); old) (* increase the number of columns, and return the index of the last column *) let rec incrNCols ()  = let old = nCols () in (ncols (tableau) := + (old, 1); old) (* decrease the number of rows *) let rec decrNRows ()  = nrows (tableau) := - (nRows (), 1) (* decrease the number of columns *) let rec decrNCols ()  = ncols (tableau) := - (nCols (), 1) (* increase by the given amount the element i of the array *) let rec incrArray (array, i, value)  = update (array, i, sub (array, i) + value) (* increase by the given amount the element (i, j) of the array *) let rec incrArray2 (array, i, j, value)  = update (array, i, j, sub (array, i, j) + value) (* increase by f(j\') all the elements (i, j\'), with j <= j\' < j+len *) let rec incrArray2Row (array, i, (j, len), f)  = mapi (fun (j, value) -> update (array, i, j, value + f (j))) (row (array, i, (j, len))) (* increase by f(i\') all the elements (i\', j), with i <= i\' < i+len *) let rec incrArray2Col (array, j, (i, len), f)  = mapi (fun (i, value) -> update (array, i, j, value + f (i))) (column (array, j, (i, len))) (* set the given row to zero *) let rec clearArray2Row (array, i, (j, len))  = mapi (fun (j, value) -> update (array, i, j, zero)) (row (array, i, (j, len))) (* set the given column to zero *) let rec clearArray2Col (array, j, (i, len))  = mapi (fun (i, value) -> update (array, i, j, zero)) (column (array, j, (i, len))) (* return the label at the given position (row or column) *) let rec label (Row (i))  = rlabel (i) | label (Col (j))  = clabel (j) (* return the restriction on the given label *) let rec restriction (l : label)  = ! (restr (l)) (* is the given label is restricted? *) let rec restricted (l : label)  = (match (restriction (l)) with SOME _ -> true | NONE -> false) (* return true iff the given label has been solved *) let rec dead (l : label)  = ! (dead (l)) (* set the ownership of the given position *) let rec setOwnership (pos, owner, tag)  = let old = label (pos) let new = {owner = owner; tag = tag; restr = ref (restriction (old)); dead = ref (dead (old))} in (match pos with Row (i) -> update (rlabels (tableau), i, new) | Col (j) -> update (clabels (tableau), j, new)) (* return the context of a owner *) let rec ownerContext (Var (G, mon))  = G | ownerContext (Exp (G, sum))  = G (* return the owner as a sum *) let rec ownerSum (Var (G, mon))  = Sum (zero_int, [mon]) | ownerSum (Exp (G, sum))  = sum (* debugging code - REMOVE *) let rec displayPos (Row (row))  = print ("row " ^ toString (row) ^ "\\n") | displayPos (Col (col))  = print ("column " ^ toString (col) ^ "\\n") (* debugging code - REMOVE *) let rec displaySum (Sum (m, Mon (n, _) :: monL))  = (print (toString n); print " ? + "; displaySum (Sum (m, monL))) | displaySum (Sum (m, nil))  = (print (toString m); print " >= 0\\n") (* debugging code - REMOVE *) let rec display ()  = let rec printLabel (col, l : label)  = (print "\\t"; (match (owner (l)) with Var _ -> print "V" | Exp _ -> print "E"); if restricted (l) then print ">" else print "*"; if dead (l) then print "#" else print "") let rec printRow (row, l : label)  = let rec printCol (col, d : number)  = (print "\\t"; print (toString d)) let vec = row (coeffs (tableau), row, (0, nCols ())) in ((match (owner (l)) with Var _ -> print "V" | Exp _ -> print "E"); if restricted (l) then print ">" else print "*"; if dead (l) then print "#" else print ""; print "\\t"; mapi printCol vec; print "\\t"; print (toString (const (row))); print "\\n") in (print "\\t"; app printLabel (clabels (tableau), 0, nCols ()); print "\\n"; app printRow (rlabels (tableau), 0, nRows ()); print "Columns:\\n"; app (fun (_, l : label) -> displaySum (ownerSum (owner (l)))) (clabels (tableau), 0, nCols ()); print "Rows:\\n"; app (fun (_, l : label) -> displaySum (ownerSum (owner (l)))) (rlabels (tableau), 0, nRows ())) (* find the given monomial in the tableau *) let rec findMon (mon)  = exception Found of int let rec find (i, l : label)  = (match (owner (l)) with (Var (G, mon\')) -> if compatibleMon (mon, mon\') then raise (Found i) else () | _ -> ()) in try  with (* return the a position in the tableau of the tagged expression *) let rec findTag (t)  = exception Found of int let rec find (i, l : label)  = if (tag (l) = t) then raise (Found i) else () in try  with (* return true iff the given row is null at all the active columns *) let rec isConstant (row)  = foldl (fun (j, l, rest) -> (dead (l) || (coeff (row, j) = zero)) && rest) true (clabels (tableau), 0, nCols ()) (* return the position of the row/column of the tableau (if any) that makes the\n       given row redundant *) let rec isSubsumed (row)  = let constRow = const (row) let rec isSubsumedByRow ()  = (* the candidates are those (active) rows with the same constant\n                       term *) (* if j is active, trim the list of candidates to those that have\n                       the same coefficient in column j\n                    *) let candidates = foldl (fun (i, l : label, rest) -> if (i <> row) && not (dead (l)) && (const (i) = constRow) then (i :: rest) else rest) nil (rlabels (tableau), 0, nRows ()) let rec filter (j, l, nil)  = nil | filter (j, l : label, candidates)  = if not (dead (l)) then filter (fun i -> (coeff (i, j) = coeff (row, j))) candidates else candidates in (match (foldl filter candidates (clabels (tableau), 0, nCols ())) with nil -> NONE | (i :: _) -> SOME (i)) let rec isSubsumedByCol ()  = if (constRow = zero) then (* compute the list of non-null coefficients in the row *) let nonNull = foldl (fun (j, l : label, rest) -> if not (dead (l)) then let value = coeff (row, j) in if (value <> zero) then ((j, value) :: rest) else rest else rest) nil (clabels (tableau), 0, nCols ()) in (match nonNull with [(j, value)] -> if (value = one) then SOME (j) else NONE | _ -> NONE) else NONE in match isSubsumedByRow () with SOME (i) -> SOME (Row (i)) | NONE -> (match isSubsumedByCol () with SOME (j) -> SOME (Col (j)) | NONE -> NONE) (* find the coordinates of the pivot which gives the largest increase in\n        const(row) *) let rec findPivot (row)  = (* extend Integers.compare to deal with NONE (= infinity) *) (* find the best pivot candidates for the given row *) let rec compareScore (SOME (d), SOME (d\'))  = compare (d, d\') | compareScore (SOME (d), NONE)  = LESS | compareScore (NONE, SOME (d\'))  = GREATER | compareScore (NONE, NONE)  = EQUAL let rec findPivotCol (j, l : label, result as (score, champs))  = (* find the best pivot candidates for the given row and column *) let value = coeff (row, j) let rec findPivotRow sgn (i, l : label, result as (score, champs))  = let value = coeff (i, j) in if (not (dead (l))) && (i <> row) && restricted (l) && ((fromInt (sgn) * value) < zero) then let score\' = SOME (abs (const (i) * inverse (value))) in match compareScore (score, score\')(* always choose the smallest *)  with GREATER -> (score\', [(i, j)]) | EQUAL -> (score, (i, j) :: champs) | LESS -> result else result in if (not (dead (l))) && (value <> zero) && (not (restricted (l)) || (value > zero)) then let (result\' as (score\', champs\')) = foldl (findPivotRow (sign value)) (NONE, [(row, j)]) (rlabels (tableau), 0, nRows ()) in match compareScore (score, score\')(* always choose the largest *)  with GREATER -> result | EQUAL -> (score, champs @ champs\') | LESS -> result\' else result in match (foldl findPivotCol (SOME (zero), nil) (clabels (tableau), 0, nCols ())) with (_, nil) -> NONE | (_, champs) -> (* choose one randomly to ensure fairness *) SOME (nth (champs, rand (0, length (champs)))) (* pivot the element at the given coordinates *) let rec pivot (row, col)  = let pCoeffInverse = inverse (coeff (row, col)) let pRowVector = row (coeffs (tableau), row, (0, nCols ())) let rec pRow (j)  = sub (pRowVector, j) let pColVector = column (coeffs (tableau), col, (0, nRows ())) let rec pCol (i)  = sub (pColVector, i) let pConst = const (row) let pRLabel = rlabel (row) let pCLabel = clabel (col) in (modify (fun (i, value) -> if (i = row) then (* same row as the pivot *) ~ (value * pCoeffInverse) else (* any other row *) value - (pConst * pCol (i) * pCoeffInverse)) (consts (tableau), 0, nRows ()); modify ColMajor (fun (i, j, value) -> (match (i = row, j = col) with (true, true) -> (* pivot *) pCoeffInverse | (true, false) -> (* same row as the pivot *) ~ (value * pCoeffInverse) | (false, true) -> (* same column as the pivot *) value * pCoeffInverse | (false, false) -> (* any other row/column *) value - (pRow (j) * pCol (i) * pCoeffInverse))) {base = (coeffs (tableau)); row = 0; col = 0; nrows = nRows (); ncols = nCols ()}; update (rlabels (tableau), row, pCLabel); update (clabels (tableau), col, pRLabel)) (* delay all terms of a monomial on the given constraint *) let rec delayMon (Mon (n, UsL), cnstr)  = app (fun Us -> delay (Us, cnstr)) UsL (* unify two restrictions *) let rec unifyRestr (Restr (G, proof), proof\')  = if unifiable (G, (proof, id), (proof\', id)) then () else raise (Error) (* unify a sum with a number *) let rec unifySum (G, sum, d)  = if (unify (G, (toExp (sum), id), (constant (floor (d)), id)); true) then () else raise (Error) (* decomposition of an expression as the weighted sum of tableau positions *) type decomp = number * number * Position list (* change sign to the given decomposition *) let rec unaryMinusDecomp ((d, wposL))  = (~ d, map (fun (d, pos) -> (~ d, pos)) wposL) type MaximizeResult = Nonnegative of number | Unbounded of int (* manifestly unbounded, pivoting on column col *) type BranchResult = BranchSucceed of int option | BranchFail | BranchDivide of int * BranchResult * BranchResult (* decompose a sum in whnf into a weighted sum of tableau positions *) let rec decomposeSum (G, Sum (m, monL))  = let rec monToWPos (mon as (Mon (n, UsL)))  = (match findMon (mon) with SOME (pos) -> (fromInteger (n), pos) | NONE -> let new = incrNCols () let l = {owner = Var (G, Mon (one_int, UsL)); tag = ref 0; restr = ref NONE; dead = ref false} in (log (trail (tableau), Insert (Col (new))); delayMon (mon, ref (makeCnstr (tag (l)))); update (clabels (tableau), new, l); (fromInteger (n), Col (new)))) in (fromInteger (m), map monToWPos monL)(* maximize the given row by performing pivot operations.\n       Return a term of type MaximizeResult *) maximizeRow (row)  = let value = const (row) in if (value < zero) then (match findPivot (row) with SOME (i, j) -> if (i <> row) then (log (trail (tableau), Pivot (i, j)); pivot (i, j); maximizeRow row) else (* the tableau is unbounded *) Unbounded j | NONE -> raise (Error)) else Nonnegative value(* insert the given expression in the tableau, labelling it with owner *) insertDecomp (decomp as (d, wposL), owner)  = let new = incrNRows () let rec insertWPos (d, pos)  = (match pos with Row (row) -> (incrArray2Row (coeffs (tableau), new, (0, nCols ()), (fun (j) -> d * coeff (row, j))); incrArray (consts (tableau), new, d * const (row))) | Col (col) -> incrArray2 (coeffs (tableau), new, col, d)) in ((* add the decomposition to the newly created row *) app insertWPos wposL; incrArray (consts (tableau), new, d); (* is this row trivial? *) match isSubsumed (new) with SOME (pos) -> (clearArray2Row (coeffs (tableau), new, (0, nCols ())); update (consts (tableau), new, zero); decrNRows (); pos) | NONE -> (setOwnership (Row (new), owner, ref 0); dead (label (Row (new))) := isConstant (new); (* log the creation of this row *) log (trail (tableau), Insert (Row (new))); (* return its position *) Row (new)))(* insert the given (unrestricted) expression in the tableau *) insert (G, Us)  = let sum = fromExp Us in insertDecomp (decomposeSum (G, sum), Exp (G, sum))(* restrict the given row/column to be nonnegative *) restrict (pos as Col (col), restr)  = let l = label (pos) in if dead (l) then (unifyRestr (restr, geqNExp (zero_int)); NONE) else match restriction (l) with SOME (Restr (_, proof\')) -> (unifyRestr (restr, proof\'); NONE) | NONE -> (* compute the list of non-null row entries *) let nonNull = foldl (fun (i, l : label, rest) -> if not (dead (l)) then let value = coeff (i, col) in if (value <> zero) then (i :: rest) else rest else rest) nil (rlabels (tableau), 0, nRows ()) in match nonNull with (row :: _) -> ((* pivot to a row position; this is sound since\n                                   the column is unrestricted (see Nelson \'81)\n                                *) log (trail (tableau), Pivot (row, col)); pivot (row, col); restrict (Row (row), restr)) | nil -> ((* the column is zero at all the active row\n                                   positions, so we can restrict it right away\n                                *) log (trail (tableau), Restrict (Col (col))); restr (label (Col (col))) := SOME (restr); NONE) | restrict (pos as Row (row), restr)  = let l = label (pos) in if dead (l) then (* it is an integer *) (unifyRestr (restr, geqNExp (floor (const (row)))); NONE) else match restriction (l) with SOME (Restr (_, proof\')) -> (unifyRestr (restr, proof\'); NONE) | NONE -> match maximizeRow (row) with Unbounded col -> (log (trail (tableau), Restrict (Row (row))); restr (sub (rlabels (tableau), row)) := SOME (restr); if (const (row) < zero) then (log (trail (tableau), Pivot (row, col)); pivot (row, col)) else (); NONE) | Nonnegative value -> (log (trail (tableau), Restrict (Row (row))); restr (sub (rlabels (tableau), row)) := SOME (restr); SOME (row))(* insert the equality Var(pos) = Us as two inequalities:\n         Var(pos) - Us >= zero\n         Us - Var(pos) >= zero\n    *) insertEqual (G, pos, sum)  = let (m, wposL) = decomposeSum (G, sum) let decomp\' = (m, (~ one, pos) :: wposL) let pos\' = insertDecomp (decomp\', Exp (G, Sum (zero_int, nil))) let decomp\'\' = unaryMinusDecomp (decomp\') let tag\'\' = tag (label (insertDecomp (decomp\'\', Exp (G, Sum (zero_int, nil))))) in ((* the second expression may change position when we\n                  restrict the first. We use tags to keep track of it *) restrictBB (exploreBB (pos\', Restr (G, geqNExp (zero_int)))); (match findTag (tag\'\') with SOME (pos\'\') -> restrictBB (exploreBB (pos\'\', Restr (G, geqNExp (zero_int))))))(* update the tableau upon discovery that Var(pos) = sum *) update (G, pos, sum)  = let l = label (pos) in ((* if the given position has a owner, delete it, since not doing so\n                 may violate the invariant *) log (trail (tableau), UpdateOwner (pos, owner (l), tag (l))); setOwnership (pos, Exp (G, sum), ref 0); (* analyze the given position to see exactly how to represent this\n                 equality *) if dead (l) then (match pos with Row (row) -> (* find out why it died *) if isConstant (row) then (* row is dead because constant and equal to n *) unifySum (G, sum, const (row)) else (* row is dead because is subsumed by another *) (match isSubsumed (row) with SOME (pos\') -> update (G, pos\', sum)) | Col (col) -> (* column is dead because = 0 *) unifySum (G, sum, zero)) else let rec isVar (Sum (m, [mon as Mon (n, _)]))  = if (m = zero_int) && (n = one_int) then SOME (mon) else NONE | isVar (sum)  = NONE in match isVar (sum) with SOME (mon) -> (* the nf is another variable *) (match findMon (mon) with SOME _ -> insertEqual (G, pos, sum) | NONE -> let tag = ref 0 in ((* recycle the current label *) log (trail (tableau), UpdateOwner (pos, owner (l), tag (l))); setOwnership (pos, Var (G, mon), tag); delayMon (mon, ref (makeCnstr (tag))))) | NONE -> insertEqual (G, pos, sum))(* insert the proof term used to restrict l (if any) at the beginning of UL *) insertRestrExp (l, UL)  = (match restriction (l) with NONE -> UL | SOME (Restr (_, _)) -> let owner = owner (l) let G = ownerContext (owner) let U = toExp (ownerSum (owner)) in (G, geq0 (U)) :: UL)(* returns the list of unsolved constraints associated with the given position *) restrictions (pos)  = let rec member (x, l)  = exists (fun y -> x = y) l let rec test (l)  = restricted (l) && not (dead (l)) let rec reachable ((pos as Row (row)) :: candidates, tried, closure)  = if member (pos, tried) then reachable (candidates, tried, closure) else let new_candidates = foldl (fun (col, _, candidates) -> if (coeff (row, col) <> zero) then (Col (col)) :: candidates else candidates) nil (clabels (tableau), 0, nCols ()) let closure\' = if test (label (pos)) then (pos :: closure) else closure in reachable (new_candidates @ candidates, pos :: tried, closure\') | reachable ((pos as Col (col)) :: candidates, tried, closure)  = if member (pos, tried) then reachable (candidates, tried, closure) else let candidates\' = foldl (fun (row, _, candidates) -> if (coeff (row, col) <> zero) then (Row (row)) :: candidates else candidates) nil (rlabels (tableau), 0, nRows ()) let closure\' = if test (label (pos)) then (pos :: closure) else closure in reachable (candidates\' @ candidates, pos :: tried, closure\') | reachable (nil, _, closure)  = closure let rec restrExp (pos)  = let l = label (pos) let owner = owner (l) let G = ownerContext (owner) let U = toExp (ownerSum (owner)) in (G, geq0 (U)) in map restrExp (reachable ([pos], nil, nil))(* returns the list of unsolved constraints associated with the given tag *) toInternal (tag) ()  = (match findTag (tag) with NONE -> nil | SOME (pos) -> restrictions (pos))(* awake function for tableau constraints *) awake (tag) ()  = (try  with )(* simplify function for tableau constraints *) simplify (tag) ()  = (match toInternal (tag) () with nil -> true | (_ :: _) -> false)(* create a foreign constraint for the given tag *) makeCnstr (tag)  = FgnCnstr (! myID, MyFgnCnstrRep (tag))(* checks if the (primally and dually) feasible solution is an integral solution;\n       returns NONE if it is, otherwise the coordinate of a non-integral component *) isIntegral ()  = (* unbounded component *) exception Found of int let rec find (i, l : label)  = if not (dead (l)) then if (denominator (const (i)) <> one_int) then raise (Found i) else () else () in try  with(* bound the given expression below d *) boundLower (G, decomp, d)  = let W = newEVar (G, number ()) let proof = newEVar (G, geq0 (W)) let (d\', wPosL) = unaryMinusDecomp (decomp) let pos = insertDecomp ((d\' + d, wPosL), Var (G, Mon (one_int, [(W, id)]))) in (pos, Restr (G, proof))(* bound the given expression above d *) boundUpper (G, decomp, d)  = let W = newEVar (G, number ()) let proof = newEVar (G, geq0 (W)) let (d\', wPosL) = decomp let pos = insertDecomp ((d\' - d, wPosL), Var (G, Mon (one_int, [(W, id)]))) in (pos, Restr (G, proof))(* explore the relaxed solution space looking for integer solutions *) exploreBB (pos, restr)  = try  with(* minimize a tableau that has been determined non-minimal (but consistent) as a\n       consequence of adding the given row\n    *) minimizeBB (row)  = (* check if the column is zero for all possible solutions *) (* equate the given column to zero if coeff(row, j) <> zero *) (* find out if the given row has been made trivial by killing some columns *) let rec zeroColumn (j, l : label)  = let decomp = (zero, [(one, Col (j))]) let G = ownerContext (owner (label (Col (j)))) let lower = ~ one let upper = one let rec left ()  = exploreBB (boundLower (G, decomp, lower)) let rec right ()  = exploreBB (boundUpper (G, decomp, upper)) in if restricted (l) then (trail right = BranchFail) else (trail left = BranchFail) && (trail right = BranchFail) let rec killColumn (j, l : label)  = if (not (dead (l))) && (coeff (row, j) <> zero) && zeroColumn (j, l) then ((* mark the column dead *) log (trail (tableau), Kill (Col (j))); dead (sub (clabels (tableau), j)) := true; (* if restricted, instantiate the proof object to 0>=0 *) (match restriction (l) with SOME (restr) -> unifyRestr (restr, geqNExp (zero_int)) | NONE -> ()); (* if owned by a monomial, unify it with zero *) (match owner (l) with (owner as (Var _)) -> unifySum (ownerContext (owner), ownerSum (owner), zero) | _ -> ())) else () let rec killRow (i, l : label)  = if not (dead (l)) then if isConstant (i) then (* row is now constant and equal to n = const(i) *) ((* check if it is an integer *) if denominator (const (i)) = one_int then () else raise (Error); (* mark the row dead *) log (trail (tableau), Kill (Row (i))); dead (sub (rlabels (tableau), i)) := true; (* if restricted, instantiate the proof object to n>=0 *) (match restriction (l) with SOME (restr) -> if denominator (const (i)) = one_int then unifyRestr (restr, geqNExp (floor (const (i)))) else raise (Error) | NONE -> ()); (* if owned by a monomial, unify it with n *) (match owner (l) with (owner as (Var _)) -> unifySum (ownerContext (owner), ownerSum (owner), const (i)) | _ -> ())) else match isSubsumed (i) with SOME (pos\') -> let l\' = label (pos\') in (log (trail (tableau), Kill (Row (i))); dead (sub (rlabels (tableau), i)) := true; (match (restriction (l), restriction (l\')) with (SOME (restr), SOME (Restr (_, proof\'))) -> unifyRestr (restr, proof\') | (SOME _, NONE) -> ((* it is safe to restrict without doing all\n                                              the checks in this case, since the two rows\n                                              are identical *) log (trail (tableau), Restrict (pos\')); restr (l\') := restriction (l)) | (NONE, _) -> ())) | NONE -> () else () in (app killColumn (clabels (tableau), 0, nCols ()); app killRow (rlabels (tableau), 0, nRows ()))restrictBB (result)  = match result with BranchFail -> raise (Error) | BranchDivide (row, resultL, BranchFail) -> let value = fromInteger (floor (const (row))) let decomp = (zero, [(one, Row (row))]) let G = ownerContext (owner (label (Row (row)))) let _ = restrict (boundLower (G, decomp, value)) in restrictBB (resultL) | BranchDivide (row, BranchFail, resultR) -> let value = fromInteger (ceiling (const (row))) let decomp = (zero, [(one, Row (row))]) let G = ownerContext (owner (label (Row (row)))) let _ = restrict (boundUpper (G, decomp, value)) in restrictBB (resultR) | BranchSucceed result -> (match result with SOME (row) -> minimizeBB (row) | NONE -> ()) | _ -> () (* undo function for trailing tableau operations *) let rec undo (Insert (Row (row)))  = (dead (sub (rlabels (tableau), row)) := true; clearArray2Row (coeffs (tableau), row, (0, nCols ())); update (consts (tableau), row, zero); decrNRows ()) | undo (Insert (Col (col)))  = (dead (sub (clabels (tableau), col)) := true; clearArray2Col (coeffs (tableau), col, (0, nRows ())); decrNCols ()) | undo (Pivot (row, col))  = pivot (row, col) | undo (Kill (pos))  = dead (label (pos)) := false | undo (Restrict (pos))  = restr (label (pos)) := NONE | undo (UpdateOwner (pos, owner, tag))  = setOwnership (pos, owner, tag) (* reset the internal status of the tableau *) let rec reset ()  = let l = {owner = Exp (Null, Sum (zero_int, nil)); tag = ref 0; restr = ref NONE; dead = ref true} in (modify (fun _ -> l) (rlabels (tableau), 0, nRows ()); modify (fun _ -> l) (clabels (tableau), 0, nCols ()); modify (fun _ -> zero) (consts (tableau), 0, nRows ()); modify RowMajor (fun _ -> zero) {base = coeffs (tableau); row = 0; col = 0; nrows = nRows (); ncols = nCols ()}; nrows (tableau) := 0; ncols (tableau) := 0; reset (trail (tableau))) (* trailing functions *) let rec mark ()  = mark (trail (tableau)) let rec unwind ()  = unwind (trail (tableau), undo) (* fst (S, s) = U1, the first argument in S[s] *) let rec fst (App (U1, _), s)  = (U1, s) | fst (SClo (S, s\'), s)  = fst (S, comp (s\', s)) (* snd (S, s) = U2, the second argument in S[s] *) let rec snd (App (U1, S), s)  = fst (S, s) | snd (SClo (S, s\'), s)  = snd (S, comp (s\', s)) (* checks if the given foreign term can be simplified to a constant *) let rec isConstantExp (U)  = (match (fromExp (U, id)) with (Sum (m, nil)) -> SOME (m) | _ -> NONE) (* checks if the given foreign term can be simplified to zero *) let rec isZeroExp (U)  = (match isConstantExp (U) with SOME (d) -> (d = zero_int) | NONE -> false) (* solveGeq (G, S, n) tries to find the n-th solution to G |- \'>=\' @ S : type *) let rec solveGeq (G, S, 0)  = let rec solveGeq0 (W)  = match isConstantExp (W) with SOME (d) -> if >= (d, zero_int) then geqNExp (d) else raise (Error) | NONE -> let proof = newEVar (G, geq0 (W)) let _ = restrictBB (exploreBB (insert (G, (W, id)), Restr (G, proof))) in proof let U1 = EClo (fst (S, id)) let U2 = EClo (snd (S, id)) in try  with | solveGeq (G, S, n)  = NONE (* constructors for higher-order types *) let rec pi (name, U, V)  = Pi ((Dec (SOME (name), U), Maybe), V) let rec arrow (U, V)  = Pi ((Dec (NONE, U), No), V) let rec installFgnCnstrOps ()  = let csid = ! myID let _ = install (csid, (fun (MyFgnCnstrRep tag) -> toInternal (tag) | fc -> raise (UnexpectedFgnCnstr fc))) let _ = install (csid, (fun (MyFgnCnstrRep tag) -> awake (tag) | fc -> raise (UnexpectedFgnCnstr fc))) let _ = install (csid, (fun (MyFgnCnstrRep tag) -> simplify (tag) | fc -> raise (UnexpectedFgnCnstr fc))) in () (* install the signature *) let rec init (cs, installF)  = (myID := cs; geqID := installF (ConDec (">=", NONE, 0, Constraint (! myID, solveGeq), arrow (number (), arrow (number (), Uni (Type))), Kind), SOME (Infix (minPrec, None)), [Mapp (Marg (Star, NONE), Mapp (Marg (Star, NONE), Mnil))]); geqAddID := installF (ConDec ("+>=", NONE, 2, Normal, pi ("X", number (), pi ("Y", number (), pi ("Z", number (), arrow (geq (Root (BVar 3, Nil), Root (BVar 2, Nil)), geq (plus (Root (BVar 4, Nil), Root (BVar 2, Nil)), plus (Root (BVar 3, Nil), Root (BVar 2, Nil))))))), Type), NONE, nil); installFgnCnstrOps (); ()) let solver = {name = ("inequality/integers"); keywords = "arithmetic,inequality"; needs = ["Unify"; name (solver)]; fgnConst = SOME ({parse = parseGeqN}); init = init; reset = reset; mark = mark; unwind = unwind} : solver  end(* functor CSIneqIntegers *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {})])
('Error parsing code:', "(* Constraint Solver Manager *) (* Author: Roberto Virga *) module type CS_MANAGER = sig (* structure IntSyn : INTSYN *) module Fixity : FIXITY(*! structure ModeSyn : MODESYN !*) type sigEntry = (* global signature entry *) (* constant declaration plus optional precedence and mode information *) ConDec * fixity option * ModeSpine listtype fgnConDec = (* foreign constant declaration *) {parse: string -> ConDec option}type solver = (* constraint solver *) {(* name is the name of the solver *) ; name: string; (* keywords identifying the type of solver *) ; (* NOTE: no two solvers with the same keywords may be active simultaneously *) ; keywords: string; (* names of other constraint solvers needed *) ; needs: string list; (* foreign constants declared (if any) *) ; fgnConst: fgnConDec option; (* install constants *) ; init: (int * (sigEntry -> cid)) -> unit; (* reset internal status *) ; reset: unit -> unit; (* trailing operations *) ; mark: unit -> unit; unwind: unit -> unit}exception Error of string(* solver handling functions *) val setInstallFN : (sigEntry -> cid) -> unitval installSolver : solver -> csidval resetSolvers : unit -> unitval useSolver : string -> unit(* parsing foreign constatnts *) val parse : string -> csid * ConDec option(* trailing operations *) val reset : unit -> unitval trail : (unit -> 'a) -> 'a end(* signature CS_MANAGER *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Gaussian-Elimination Equation Solver *) (* Author: Roberto Virga *) module type CS_EQ_INTEGERS = sig include CSmodule Integers : INTEGERS(*! structure IntSyn : INTSYN !*) (* Foreign expressions *) type 'amset = 'a list(* MultiSet                   *) type SumSumint * Mon mset and MonMonint * Exp * Sub mset(* Mon ::= n * U1[s1] * ...   *) val fromExp : eclo -> Sumval toExp : Sum -> Expval normalize : Sum -> Sumval compatibleMon : Mon * Mon -> bool(* Internal expressions constructors *) val number : unit -> Expval unaryMinus : Exp -> Expval plus : Exp * Exp -> Expval minus : Exp * Exp -> Expval times : Exp * Exp -> Expval constant : int -> Exp end(* signature CS_EQ_FIELD *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Gaussian-Elimination Equation Solver *) (* Author: Roberto Virga *) module CSEqField (module Field : FIELD(*! structure IntSyn : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) ) : CS_EQ_FIELD = struct (*! structure CSManager = CSManager !*)  module Field = Field (*! structure IntSyn = IntSyn !*)  type \'amset = \'a list (* MultiSet                   *)  type Sum = Sum of number * Mon mset and Mon = Mon of number * Exp * Sub mset (* Mon ::= n * U1[s1] * ...   *)  (* A monomial (n * U1[s1] * U2[s2] * ...) is said to be normal iff\n       (a) the coefficient n is different from zero;\n       (b) each (Ui,si) is in whnf and not a foreign term corresponding\n           to a sum.\n     A sum is normal iff all its monomials are normal, and moreover they\n     are pairwise distinct.\n  *)  open IntSyn open Field module FX = CSManagerFixitymodule MS = ModeSyn(* CSManager.ModeSyn *) exception MyIntsynRep of Sum (* FgnExp representation for this domain *) let rec extractSum (MyIntsynRep sum)  = sum | extractSum fe  = raise ((UnexpectedFgnExp fe)) (* constraint solver ID of this module *) let myID = ref ~1 : csid ref (* constant ID of the type family constant "number" *) let numberID = ref ~1 : cid ref let rec number ()  = Root (Const (! numberID), Nil) (* constant ID\'s of the object constants defined by this module *) let unaryMinusID = ref ~1 : cid ref (* ~ : number -> number           *) let plusID = ref ~1 : cid ref (* + : number -> number -> number *) let minusID = ref ~1 : cid ref (* - : number -> number -> number *) let timesID = ref ~1 : cid ref (* * : number -> number -> number *) let rec unaryMinusExp (U)  = Root (Const (! unaryMinusID), App (U, Nil)) let rec plusExp (U, V)  = Root (Const (! plusID), App (U, App (V, Nil))) let rec minusExp (U, V)  = Root (Const (! minusID), App (U, App (V, Nil))) let rec timesExp (U, V)  = Root (Const (! timesID), App (U, App (V, Nil))) let rec numberConDec (d)  = ConDec (toString (d), NONE, 0, Normal, number (), Type) let rec numberExp (d)  = Root (FgnConst (! myID, numberConDec (d)), Nil) (* parseNumber str = SOME(conDec) or NONE\n\n       Invariant:\n       If str parses to the number n\n       then conDec is the (foreign) constant declaration of n\n    *) let rec parseNumber string  = (match fromString (string) with SOME (d) -> SOME (numberConDec (d)) | NONE -> NONE) (* solveNumber k = SOME(U)\n\n       Invariant:\n       U is the term obtained applying the foreign constant\n       corresponding to the number k to an empty spine\n    *) let rec solveNumber (G, S, k)  = SOME (numberExp (fromInt k)) (* findMset eq (x, L) =\n         SOME (y, L\') if there exists y such that eq (x, y)\n                         and L ~ (y :: L\') (multiset equality)\n         NONE if there is no y in L such that eq (x, y)\n    *) let rec findMSet eq (x, L)  = let rec findMSet\' (tried, nil)  = NONE | findMSet\' (tried, y :: L)  = if eq (x, y) then SOME (y, tried @ L) else findMSet\' (y :: tried, L) in findMSet\' (nil, L) (* equalMset eq (L, L\') = true iff L ~ L\' (multiset equality) *) let rec equalMSet eq  = let rec equalMSet\' (nil, nil)  = true | equalMSet\' (x :: L1\', L2)  = (match (findMSet eq (x, L2)) with SOME (y, L2\') -> (equalMSet\' (L1\', L2\')) | NONE -> false) | equalMSet\' _  = false in equalMSet\' (* toExp sum = U\n\n       Invariant:\n       If sum is normal\n       G |- U : V and U is the Twelf syntax conversion of sum\n    *) let rec toExp (Sum (m, nil))  = numberExp m | toExp (Sum (m, [mon]))  = if (m = zero) then toExpMon mon else plusExp (toExp (Sum (m, nil)), toExpMon mon) | toExp (Sum (m, monLL as (mon :: monL)))  = plusExp (toExp (Sum (m, monL)), toExpMon mon)(* toExpMon mon = U\n\n       Invariant:\n       If mon is normal\n       G |- U : V and U is the Twelf syntax conversion of mon\n    *) toExpMon (Mon (n, nil))  = numberExp n | toExpMon (Mon (n, [Us]))  = if (n = one) then toExpEClo Us else timesExp (toExpMon (Mon (n, nil)), toExpEClo Us) | toExpMon (Mon (n, Us :: UsL))  = timesExp (toExpMon (Mon (n, UsL)), toExpEClo Us)(* toExpEClo (U,s) = U\n\n       Invariant:\n       G |- U : V and U is the Twelf syntax conversion of Us\n    *) toExpEClo (U, Shift (0))  = U | toExpEClo Us  = EClo Us (* compatibleMon (mon1, mon2) = true only if mon1 = mon2 (as monomials) *) let rec compatibleMon (Mon (_, UsL1), Mon (_, UsL2))  = equalMSet (fun (Us1, Us2) -> sameExpW (Us1, Us2)) (UsL1, UsL2)(* sameExpW ((U1,s1), (U2,s2)) = T\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1    (U1,s1)  in whnf\n       and  G |- s2 : G2    G2 |- U2 : V2    (U2,s2)  in whnf\n       then T only if U1[s1] = U2[s2] (as expressions)\n    *) sameExpW (Us1 as (Root (H1, S1), s1), Us2 as (Root (H2, S2), s2))  = (match (H1, H2) with (BVar (k1), BVar (k2)) -> (k1 = k2) && sameSpine ((S1, s1), (S2, s2)) | (FVar (n1, _, _), FVar (n2, _, _)) -> (n1 = n2) && sameSpine ((S1, s1), (S2, s2)) | _ -> false) | sameExpW (Us1 as (U1 as EVar (r1, G1, V1, cnstrs1), s1), Us2 as (U2 as EVar (r2, G2, V2, cnstrs2), s2))  = (r1 = r2) && sameSub (s1, s2) | sameExpW _  = false(* sameExp ((U1,s1), (U2,s2)) = T\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1\n       and  G |- s2 : G2    G2 |- U2 : V2\n       then T only if U1[s1] = U2[s2] (as expressions)\n    *) sameExp (Us1, Us2)  = sameExpW (whnf Us1, whnf Us2)(* sameSpine (S1, S2) = T\n\n       Invariant:\n       If   G |- S1 : V > W\n       and  G |- S2 : V > W\n       then T only if S1 = S2 (as spines)\n    *) sameSpine ((Nil, s1), (Nil, s2))  = true | sameSpine ((SClo (S1, s1\'), s1), Ss2)  = sameSpine ((S1, comp (s1\', s1)), Ss2) | sameSpine (Ss1, (SClo (S2, s2\'), s2))  = sameSpine (Ss1, (S2, comp (s2\', s2))) | sameSpine ((App (U1, S1), s1), (App (U2, S2), s2))  = sameExp ((U1, s1), (U2, s2)) && sameSpine ((S1, s1), (S2, s2)) | sameSpine _  = false(* sameSub (s1, s2) = T\n\n       Invariant:\n       If   G |- s1 : G\'\n       and  G |- s2 : G\'\n       then T only if s1 = s2 (as substitutions)\n    *) sameSub (Shift _, Shift _)  = true | sameSub (Dot (Idx (k1), s1), Dot (Idx (k2), s2))  = (k1 = k2) && sameSub (s1, s2) | sameSub (s1 as Dot (Idx _, _), Shift (k2))  = sameSub (s1, Dot (Idx (+ (k2, 1)), Shift (+ (k2, 1)))) | sameSub (Shift (k1), s2 as Dot (Idx _, _))  = sameSub (Dot (Idx (+ (k1, 1)), Shift (+ (k1, 1))), s2) | sameSub _  = false (* plusSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 + sum2\n    *) let rec plusSum (Sum (m1, nil), Sum (m2, monL2))  = Sum (m1 + m2, monL2) | plusSum (Sum (m1, monL1), Sum (m2, nil))  = Sum (m1 + m2, monL1) | plusSum (Sum (m1, mon1 :: monL1), Sum (m2, monL2))  = plusSumMon (plusSum (Sum (m1, monL1), Sum (m2, monL2)), mon1)(* plusSumMon (sum1, mon2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  mon2 normal\n       then sum3 normal\n       and  sum3 = sum1 + mon2\n    *) plusSumMon (Sum (m, nil), mon)  = Sum (m, [mon]) | plusSumMon (Sum (m, monL), mon as Mon (n, UsL))  = (match (findMSet compatibleMon (mon, monL)) with SOME (Mon (n\', _), monL\') -> let n\'\' = n + n\' in if (n\'\' = zero) then Sum (m, monL\') else Sum (m, (Mon (n\'\', UsL)) :: monL\') | NONE -> Sum (m, mon :: monL)) (* timesSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 * sum2\n    *) let rec timesSum (Sum (m1, nil), Sum (m2, nil))  = Sum (m1 * m2, nil) | timesSum (Sum (m1, mon1 :: monL1), sum2)  = plusSum (timesSumMon (sum2, mon1), timesSum (Sum (m1, monL1), sum2)) | timesSum (sum1, Sum (m2, mon2 :: monL2))  = plusSum (timesSumMon (sum1, mon2), timesSum (sum1, Sum (m2, monL2)))(* timesSumMon (sum1, mon2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  mon2 normal\n       then sum3 normal\n       and  sum3 = sum1 * mon2\n    *) timesSumMon (Sum (m, nil), Mon (n, UsL))  = let n\' = m * n in if (n\' = zero) then Sum (n\', nil) else Sum (zero, [Mon (n\', UsL)]) | timesSumMon (Sum (m, (Mon (n\', UsL\')) :: monL), mon as Mon (n, UsL))  = let n\'\' = n * n\' let UsL\'\' = UsL @ UsL\' let Sum (m\', monL\') = timesSumMon (Sum (m, monL), mon) in Sum (m\', (Mon (n\'\', UsL\'\')) :: monL\') (* unaryMinusSum sum = sum\'\n\n       Invariant:\n       If   sum  normal\n       then sum\' normal\n       and  sum\' = ~1 * sum\n    *) let rec unaryMinusSum (sum)  = timesSum (Sum (~ one, nil), sum) (* minusSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 - sum2\n    *) let rec minusSum (sum1, sum2)  = plusSum (sum1, unaryMinusSum (sum2)) (* fromExpW (U, s) = sum\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V    (U,s)  in whnf\n       then sum is the internal representation of U[s] as sum of monomials\n       and sum is normal\n    *) let rec fromExpW (Us as (FgnExp (cs, fe), _))  = if (cs = ! myID) then normalizeSum (extractSum fe) else Sum (zero, [Mon (one, [Us])]) | fromExpW (Us as (Root (FgnConst (cs, conDec), _), _))  = if (cs = ! myID) then (match (fromString (conDecName (conDec))) with SOME (m) -> Sum (m, nil)) else Sum (zero, [Mon (one, [Us])]) | fromExpW (Us as (Root (Def (d), _), _))  = fromExpW (expandDef (Us)) | fromExpW Us  = Sum (zero, [Mon (one, [Us])])(* fromExp (U, s) = sum\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V\n       then sum is the internal representation of U[s] as sum of monomials\n       and sum is normal\n    *) fromExp Us  = fromExpW (whnf Us)(* normalizeSum sum = sum\', where sum\' normal and sum\' = sum *) normalizeSum (sum as (Sum (m, nil)))  = sum | normalizeSum (Sum (m, [mon]))  = plusSum (Sum (m, nil), normalizeMon mon) | normalizeSum (Sum (m, mon :: monL))  = plusSum (normalizeMon mon, normalizeSum (Sum (m, monL)))(* normalizeMon mon = mon\', where mon\' normal and mon\' = mon *) normalizeMon (mon as (Mon (n, nil)))  = Sum (n, nil) | normalizeMon (Mon (n, [Us]))  = timesSum (Sum (n, nil), fromExp Us) | normalizeMon (mon as (Mon (n, Us :: UsL)))  = timesSum (fromExp Us, normalizeMon (Mon (n, UsL)))(* mapSum (f, m + M1 + ...) = m + mapMon(f,M1) + ... *) mapSum (f, Sum (m, monL))  = Sum (m, map (fun mon -> mapMon (f, mon)) monL)(* mapMon (f, n * (U1,s1) + ...) = n * f(U1,s1) * ... *) mapMon (f, Mon (n, UsL))  = Mon (n, map (fun Us -> whnf (f (EClo Us), id)) UsL) (* appSum (f, m + M1 + ...) = ()     and appMon (f, Mi) for each i *) let rec appSum (f, Sum (m, monL))  = app (fun mon -> appMon (f, mon)) monL(* appMon (f, n * (U1, s1) + ... ) = () and f (Ui[si]) for each i *) appMon (f, Mon (n, UsL))  = app (fun Us -> f (EClo Us)) UsL (* findMon f (G, sum) =\n         SOME(x) if f(M) = SOME(x) for some monomial M in sum\n         NONE    if f(M) = NONE for all monomials M in sum\n    *) let rec findMon f (G, Sum (m, monL))  = let rec findMon\' (nil, monL2)  = NONE | findMon\' (mon :: monL1, monL2)  = (match (f (G, mon, Sum (m, monL1 @ monL2))) with (result as SOME _) -> result | NONE -> findMon\' (monL1, mon :: monL2)) in findMon\' (monL, nil) (* unifySum (G, sum1, sum2) = result\n\n       Invariant:\n       If   G |- sum1 : number     sum1 normal\n       and  G |- sum2 : number     sum2 normal\n       then result is the outcome (of type FgnUnify) of solving the\n       equation sum1 = sum2 by gaussian elimination.\n    *) let rec unifySum (G, sum1, sum2)  = let rec invertMon (G, Mon (n, [(LHS as EVar (r, _, _, _), s)]), sum)  = if isPatSub s then let ss = invert s let RHS = toFgn (timesSum (Sum (~ (inverse n), nil), sum)) in if invertible (G, (RHS, id), ss, r) then SOME (G, LHS, RHS, ss) else NONE else NONE | invertMon _  = NONE in match minusSum (sum2, sum1) with Sum (m, nil) -> if (m = zero) then Succeed nil else Fail | sum -> (match findMon invertMon (G, sum) with SOME assignment -> Succeed [Assign assignment] | NONE -> let U = toFgn sum let cnstr = ref (Eqn (G, U, numberExp (zero))) in Succeed [Delay (U, cnstr)])(* toFgn sum = U\n\n       Invariant:\n       If sum normal\n       then U is a foreign expression representing sum.\n    *) toFgn (sum as Sum (m, nil))  = toExp (sum) | toFgn (sum as Sum (m, monL))  = FgnExp (! myID, MyIntsynRep sum) (* toInternal (fe) = U\n\n       Invariant:\n       if fe is (MyIntsynRep sum) and sum : normal\n       then U is the Twelf syntax conversion of sum\n    *) let rec toInternal (MyIntsynRep sum) ()  = toExp (normalizeSum sum) | toInternal fe ()  = raise ((UnexpectedFgnExp fe)) (* map (fe) f = U\'\n\n       Invariant:\n       if fe is (MyIntsynRep sum)   sum : normal\n       and\n         f sum = f (m + mon1 + ... + monN) =\n               = m + f (m1 * Us1 * ... * UsM) + ...\n               = m + (m1 * (f Us1) * ... * f (UsM))\n               = sum\'           sum\' : normal\n       then\n         U\' is a foreign expression representing sum\'\n    *) let rec map (MyIntsynRep sum) f  = toFgn (normalizeSum (mapSum (f, sum))) | map fe _  = raise ((UnexpectedFgnExp fe)) (* app (fe) f = ()\n\n       Invariant:\n       if fe is (MyIntsynRep sum)     sum : normal\n       and\n          sum = m + mon1 + ... monN\n          where moni = mi * Usi1 * ... UsiMi\n       then f is applied to each Usij\n         (since sum : normal, each Usij is in whnf)\n    *) let rec app (MyIntsynRep sum) f  = appSum (f, sum) | app fe _  = raise ((UnexpectedFgnExp fe)) let rec equalTo (MyIntsynRep sum) U2  = (match minusSum (normalizeSum sum, (fromExp (U2, id))) with Sum (m, nil) -> (m = zero) | _ -> false) | equalTo fe _  = raise ((UnexpectedFgnExp fe)) let rec unifyWith (MyIntsynRep sum) (G, U2)  = unifySum (G, normalizeSum sum, (fromExp (U2, id))) | unifyWith fe _  = raise ((UnexpectedFgnExp fe)) let rec installFgnExpOps ()  = let csid = ! myID let _ = install (csid, toInternal) let _ = install (csid, map) let _ = install (csid, app) let _ = install (csid, unifyWith) let _ = install (csid, equalTo) in () let rec makeFgn (arity, opExp) (S)  = let rec makeParams 0  = Nil | makeParams n  = App (Root (BVar (n), Nil), makeParams (- (n, 1))) let rec makeLam E 0  = E | makeLam E n  = Lam (Dec (NONE, number ()), makeLam E (- (n, 1))) let rec expand ((Nil, s), arity)  = (makeParams arity, arity) | expand ((App (U, S), s), arity)  = let (S\', arity\') = expand ((S, s), (- (arity, 1))) in (App (EClo (U, comp (s, Shift (arity\'))), S\'), arity\') | expand ((SClo (S, s\'), s), arity)  = expand ((S, comp (s\', s)), arity) let (S\', arity\') = expand ((S, id), arity) in makeLam (toFgn (opExp S\')) arity\' let rec makeFgnUnary opSum  = makeFgn (1, fun (App (U, Nil)) -> opSum (fromExp (U, id))) let rec makeFgnBinary opSum  = makeFgn (2, fun (App (U1, App (U2, Nil))) -> opSum (fromExp (U1, id), fromExp (U2, id))) let rec arrow (U, V)  = Pi ((Dec (NONE, U), No), V) (* init (cs, installFunction) = ()\n       Initialize the constraint solver.\n       installFunction is used to add its signature symbols.\n    *) let rec init (cs, installF)  = (myID := cs; numberID := installF (ConDec (name, NONE, 0, Constraint (! myID, solveNumber), Uni (Type), Kind), NONE, [Mnil]); unaryMinusID := installF (ConDec ("~", NONE, 0, Foreign (! myID, makeFgnUnary unaryMinusSum), arrow (number (), number ()), Type), SOME (Prefix (maxPrec)), nil); plusID := installF (ConDec ("+", NONE, 0, Foreign (! myID, makeFgnBinary plusSum), arrow (number (), arrow (number (), number ())), Type), SOME (Infix (dec (dec maxPrec), Left)), nil); minusID := installF (ConDec ("-", NONE, 0, Foreign (! myID, makeFgnBinary minusSum), arrow (number (), arrow (number (), number ())), Type), SOME (Infix (dec (dec maxPrec), Left)), nil); timesID := installF (ConDec ("*", NONE, 0, Foreign (! myID, makeFgnBinary timesSum), arrow (number (), arrow (number (), number ())), Type), SOME (Infix (dec maxPrec, Left)), nil); installFgnExpOps (); ()) let solver = {name = ("equality/" ^ name ^ "s"); keywords = "arithmetic,equality"; needs = ["Unify"]; fgnConst = SOME ({parse = parseNumber}); init = init; reset = (fun () -> ()); mark = (fun () -> ()); unwind = (fun () -> ())} let fromExp = fromExp let toExp = toExp let normalize = normalizeSum let compatibleMon = compatibleMon let number = number let rec unaryMinus U  = toFgn (unaryMinusSum (fromExp (U, id))) let rec plus (U, V)  = toFgn (plusSum (fromExp (U, id), fromExp (V, id))) let rec minus (U, V)  = toFgn (minusSum (fromExp (U, id), fromExp (V, id))) let rec times (U, V)  = toFgn (timesSum (fromExp (U, id), fromExp (V, id))) let constant = numberExp  (* local *)  end(* functor CSEqField *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Booleans Equation Solver *) (* Author: Roberto Virga *) module CSEqBools ((*! structure IntSyn : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) ) : CS = struct (*! structure CSManager = CSManager !*)  (*! structure IntSyn = IntSyn !*)  type \'aset = \'a list (* Set                        *)  type Sum = Sum of bool * Mon set and Mon = Mon of Exp * Sub set (* Mon ::= U1[s1] * ...       *)  (* A monomial (U1[s1] * U2[s2] * ...) is said to be normal iff\n       (a) each (Ui,si) is in whnf and not a foreign term corresponding\n           to a sum;\n       (b) the terms Ui[si] are pairwise distinct.\n     A sum is normal iff all its monomials are normal, and moreover they\n     are pairwise distinct.\n  *)  open IntSyn module FX = CSManagerFixitymodule MS = ModeSyn(* CSManager.ModeSyn *) exception MyIntsynRep of Sum let rec extractSum (MyIntsynRep sum)  = sum | extractSum fe  = raise ((UnexpectedFgnExp fe)) let myID = ref ~1 : csid ref let boolID = ref ~1 : cid ref let rec bool ()  = Root (Const (! boolID), Nil) let trueID = ref ~1 : cid ref let falseID = ref ~1 : cid ref let rec trueExp ()  = Root (Const (! trueID), Nil) let rec falseExp ()  = Root (Const (! falseID), Nil) let rec solveBool (G, S, 0)  = SOME (trueExp ()) | solveBool (G, S, 1)  = SOME (falseExp ()) | solveBool (G, S, k)  = NONE let notID = ref ~1 : cid ref let xorID = ref ~1 : cid ref let andID = ref ~1 : cid ref let orID = ref ~1 : cid ref let impliesID = ref ~1 : cid ref let iffID = ref ~1 : cid ref let rec notExp (U)  = Root (Const (! notID), App (U, Nil)) let rec xorExp (U, V)  = Root (Const (! xorID), App (U, App (V, Nil))) let rec andExp (U, V)  = Root (Const (! andID), App (U, App (V, Nil))) let rec orExp (U, V)  = Root (Const (! orID), App (U, App (V, Nil))) let rec impliesExp (U, V)  = Root (Const (! impliesID), App (U, App (V, Nil))) let rec iffExp (U, V)  = Root (Const (! iffID), App (U, App (V, Nil))) (* member eq (x, L) = true iff there there is a y in L s.t. eq(y, x) *) let rec member eq (x, L)  = exists (fun y -> eq (x, y)) L (* differenceSet eq L1 L2 = (L1 \\ L2) U (L2 \\ L1) *) let rec differenceSet eq (L1, L2)  = let L1\' = filter (fun x -> not (member eq (x, L2))) L1 let L2\' = filter (fun x -> not (member eq (x, L1))) L2 in L1\' @ L2\' (* equalSet eq (L1, L2) = true iff L1 is equal to L2 (both seen as sets) *) let rec equalSet eq (L1, L2)  = (match differenceSet eq (L1, L2) with nil -> true | (_ :: _) -> false) (* unionSet eq (L1, L2) = L1 U L2 *) let rec unionSet eq (L1, L2)  = let L2\' = filter (fun x -> not (member eq (x, L1))) L2 in L1 @ L2\' (* toExp sum = U\n\n       Invariant:\n       If sum is normal\n       G |- U : V and U is the Twelf syntax conversion of sum\n    *) let rec toExp (Sum (m, nil))  = let cid = if m then ! trueID else ! falseID in Root (Const (cid), Nil) | toExp (Sum (m, [mon]))  = if (m = false) then toExpMon mon else xorExp (toExp (Sum (m, nil)), toExpMon mon) | toExp (Sum (m, monLL as (mon :: monL)))  = xorExp (toExp (Sum (m, monL)), toExpMon mon)(* toExpMon mon = U\n\n       Invariant:\n       If mon is normal\n       G |- U : V and U is the Twelf syntax conversion of mon\n    *) toExpMon (Mon [Us])  = toExpEClo Us | toExpMon (Mon (Us :: UsL))  = andExp (toExpMon (Mon UsL), toExpEClo Us)(* toExpEClo (U,s) = U\n\n       Invariant:\n       G |- U : V and U is the Twelf syntax conversion of Us\n    *) toExpEClo (U, Shift (0))  = U | toExpEClo Us  = EClo Us (* compatibleMon (mon1, mon2) = true only if mon1 = mon2 (as monomials) *) let rec compatibleMon (Mon UsL1, Mon UsL2)  = equalSet (fun (Us1, Us2) -> sameExp (Us1, Us2)) (UsL1, UsL2)(* sameExpW ((U1,s1), (U2,s2)) = T\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1    (U1,s1)  in whnf\n       and  G |- s2 : G2    G2 |- U2 : V2    (U2,s2)  in whnf\n       then T only if U1[s1] = U2[s2] (as expressions)\n    *) sameExpW (Us1 as (Root (H1, S1), s1), Us2 as (Root (H2, S2), s2))  = (match (H1, H2) with (BVar (k1), BVar (k2)) -> (k1 = k2) && sameSpine ((S1, s1), (S2, s2)) | (FVar (n1, _, _), FVar (n2, _, _)) -> (n1 = n2) && sameSpine ((S1, s1), (S2, s2)) | _ -> false) | sameExpW (Us1 as (U1 as EVar (r1, G1, V1, cnstrs1), s1), Us2 as (U2 as EVar (r2, G2, V2, cnstrs2), s2))  = (r1 = r2) && sameSub (s1, s2) | sameExpW _  = false(* sameExp ((U1,s1), (U2,s2)) = T\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1\n       and  G |- s2 : G2    G2 |- U2 : V2\n       then T only if U1[s1] = U2[s2] (as expressions)\n    *) sameExp (Us1, Us2)  = sameExpW (whnf Us1, whnf Us2)(* sameSpine (S1, S2) = T\n\n       Invariant:\n       If   G |- S1 : V > W\n       and  G |- S2 : V > W\n       then T only if S1 = S2 (as spines)\n    *) sameSpine ((Nil, s1), (Nil, s2))  = true | sameSpine ((SClo (S1, s1\'), s1), Ss2)  = sameSpine ((S1, comp (s1\', s1)), Ss2) | sameSpine (Ss1, (SClo (S2, s2\'), s2))  = sameSpine (Ss1, (S2, comp (s2\', s2))) | sameSpine ((App (U1, S1), s1), (App (U2, S2), s2))  = sameExp ((U1, s1), (U2, s2)) && sameSpine ((S1, s1), (S2, s2)) | sameSpine _  = false(* sameSub (s1, s2) = T\n\n       Invariant:\n       If   G |- s1 : G\'\n       and  G |- s2 : G\'\n       then T only if s1 = s2 (as substitutions)\n    *) sameSub (Shift _, Shift _)  = true | sameSub (Dot (Idx (k1), s1), Dot (Idx (k2), s2))  = (k1 = k2) && sameSub (s1, s2) | sameSub (s1 as Dot (Idx _, _), Shift (k2))  = sameSub (s1, Dot (Idx (+ (k2, 1)), Shift (+ (k2, 1)))) | sameSub (Shift (k1), s2 as Dot (Idx _, _))  = sameSub (Dot (Idx (+ (k1, 1)), Shift (+ (k1, 1))), s2) | sameSub _  = false (* xorSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 xor sum2\n    *) let rec xorSum (Sum (m1, monL1), Sum (m2, monL2))  = Sum (not (m1 = m2), differenceSet compatibleMon (monL1, monL2)) (* andSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 and sum2\n    *) let rec andSum (sum1 as Sum (false, nil), sum2)  = sum1 | andSum (sum1, sum2 as Sum (false, nil))  = sum2 | andSum (sum1 as Sum (true, nil), sum2)  = sum2 | andSum (sum1, sum2 as Sum (true, nil))  = sum1 | andSum (Sum (m1, mon1 :: monL1), sum2)  = xorSum (andSumMon (sum2, mon1), andSum (Sum (m1, monL1), sum2))(* andSumMon (sum1, mon2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  mon2 normal\n       then sum3 normal\n       and  sum3 = sum1 and mon2\n    *) andSumMon (Sum (true, nil), mon)  = Sum (false, [mon]) | andSumMon (sum1 as Sum (false, nil), mon)  = sum1 | andSumMon (Sum (m1, (Mon UsL1) :: monL1), mon2 as Mon UsL2)  = let UsL = unionSet sameExp (UsL1, UsL2) in xorSum (Sum (false, [Mon UsL]), andSumMon (Sum (m1, monL1), mon2)) (* notSum sum = sum\'\n\n       Invariant:\n       If   sum  normal\n       then sum\' normal\n       and  sum\' = not sum\n    *) let rec notSum (Sum (m, monL))  = Sum (not m, monL) (* orSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 or sum2\n    *) let rec orSum (sum1, sum2)  = xorSum (sum1, xorSum (sum2, andSum (sum1, sum2))) (* impliesSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 implies sum2\n    *) let rec impliesSum (sum1, sum2)  = notSum (xorSum (sum1, andSum (sum1, sum2))) (* iffSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 iff sum2\n    *) let rec iffSum (sum1, sum2)  = notSum (xorSum (sum1, sum2)) (* fromExpW (U, s) = sum\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V    (U,s)  in whnf\n       then sum is the internal representation of U[s] as sum of monomials\n       and sum is normal\n    *) let rec fromExpW (Us as (FgnExp (cs, fe), _))  = if (cs = ! myID) then normalizeSum (extractSum fe) else Sum (false, [Mon [Us]]) | fromExpW Us  = Sum (false, [Mon [Us]])fromExp Us  = fromExpW (whnf Us)(* normalizeSum sum = sum\', where sum\' normal and sum\' = sum *) normalizeSum (sum as (Sum (m, nil)))  = sum | normalizeSum (Sum (m, [mon]))  = xorSum (Sum (m, nil), normalizeMon mon) | normalizeSum (Sum (m, mon :: monL))  = xorSum (normalizeMon mon, normalizeSum (Sum (m, monL)))(* normalizeMon mon = mon\', where mon\' normal and mon\' = mon *) normalizeMon (Mon [Us])  = fromExp Us | normalizeMon (Mon (Us :: UsL))  = andSum (fromExp Us, normalizeMon (Mon UsL))(* mapSum (f, m + M1 + ...) = m + mapMon(f,M1) + ... *) mapSum (f, Sum (m, monL))  = Sum (m, map (fun mon -> mapMon (f, mon)) monL)(* mapMon (f, n * (U1,s1) + ...) = n * f(U1,s1) * ... *) mapMon (f, Mon UsL)  = Mon (map (fun Us -> whnf (f (EClo Us), id)) UsL) (* appSum (f, m + M1 + ...) = ()     and appMon (f, Mi) for each i *) let rec appSum (f, Sum (m, monL))  = app (fun mon -> appMon (f, mon)) monL(* appMon (f, n * (U1, s1) + ... ) = () and f (Ui[si]) for each i *) appMon (f, Mon UsL)  = app (fun Us -> f (EClo Us)) UsL (* findMon f (G, sum) =\n         SOME(x) if f(M) = SOME(x) for some monomial M in sum\n         NONE    if f(M) = NONE for all monomials M in sum\n    *) let rec findMon f (G, Sum (m, monL))  = let rec findMon\' (nil, monL2)  = NONE | findMon\' (mon :: monL1, monL2)  = (match (f (G, mon, Sum (m, monL1 @ monL2))) with (result as SOME _) -> result | NONE -> findMon\' (monL1, mon :: monL2)) in findMon\' (monL, nil) (* unifySum (G, sum1, sum2) = result\n\n       Invariant:\n       If   G |- sum1 : number     sum1 normal\n       and  G |- sum2 : number     sum2 normal\n       then result is the outcome (of type FgnUnify) of solving the\n       equation sum1 = sum2 by gaussian elimination.\n    *) let rec unifySum (G, sum1, sum2)  = let rec invertMon (G, Mon [(LHS as EVar (r, _, _, _), s)], sum)  = if isPatSub s then let ss = invert s let RHS = toFgn sum in if invertible (G, (RHS, id), ss, r) then SOME (G, LHS, RHS, ss) else NONE else NONE | invertMon _  = NONE in match xorSum (sum2, sum1) with Sum (false, nil) -> Succeed nil | Sum (true, nil) -> Fail | sum -> (match findMon invertMon (G, sum) with SOME assignment -> Succeed [Assign assignment] | NONE -> let U = toFgn sum let cnstr = ref (Eqn (G, U, falseExp ())) in Succeed [Delay (U, cnstr)])(* toFgn sum = U\n\n       Invariant:\n       If sum normal\n       then U is a foreign expression representing sum.\n    *) toFgn (sum as Sum (m, nil))  = toExp (sum) | toFgn (sum as Sum (m, monL))  = FgnExp (! myID, MyIntsynRep sum) (* toInternal (fe) = U\n\n       Invariant:\n       if fe is (MyIntsynRep sum) and sum : normal\n       then U is the Twelf syntax conversion of sum\n    *) let rec toInternal (MyIntsynRep sum) ()  = toExp (normalizeSum sum) | toInternal fe ()  = raise ((UnexpectedFgnExp fe)) (* map (fe) f = U\'\n\n       Invariant:\n       if fe is (MyIntsynRep sum)   sum : normal\n       and\n         f sum = f (m + mon1 + ... + monN) =\n               = m + f (m1 * Us1 * ... * UsM) + ...\n               = m + (m1 * (f Us1) * ... * f (UsM))\n               = sum\'           sum\' : normal\n       then\n         U\' is a foreign expression representing sum\'\n    *) let rec map (MyIntsynRep sum) f  = toFgn (normalizeSum (mapSum (f, sum))) | map fe _  = raise ((UnexpectedFgnExp fe)) (* app (fe) f = ()\n\n       Invariant:\n       if fe is (MyIntsynRep sum)     sum : normal\n       and\n          sum = m + mon1 + ... monN\n          where moni = mi * Usi1 * ... UsiMi\n       then f is applied to each Usij\n         (since sum : normal, each Usij is in whnf)\n    *) let rec app (MyIntsynRep sum) f  = appSum (f, sum) | app fe _  = raise ((UnexpectedFgnExp fe)) let rec equalTo (MyIntsynRep sum) U2  = (match xorSum (normalizeSum (sum), fromExp (U2, id))(* AK: redundant normalizeSum ? *)  with Sum (m, nil) -> (m = false) | _ -> false) | equalTo fe _  = raise ((UnexpectedFgnExp fe)) let rec unifyWith (MyIntsynRep sum) (G, U2)  = unifySum (G, normalizeSum sum, fromExp (U2, id)) | unifyWith fe _  = raise ((UnexpectedFgnExp fe)) let rec installFgnExpOps ()  = let csid = ! myID let _ = install (csid, toInternal) let _ = install (csid, map) let _ = install (csid, app) let _ = install (csid, unifyWith) let _ = install (csid, equalTo) in () let rec makeFgn (arity, opExp) (S)  = let rec makeParams 0  = Nil | makeParams n  = App (Root (BVar (n), Nil), makeParams (- (n, 1))) let rec makeLam E 0  = E | makeLam E n  = Lam (Dec (NONE, bool ()), makeLam E (- (n, 1))) let rec expand ((Nil, s), arity)  = (makeParams arity, arity) | expand ((App (U, S), s), arity)  = let (S\', arity\') = expand ((S, s), (- (arity, 1))) in (App (EClo (U, comp (s, Shift (arity\'))), S\'), arity\') | expand ((SClo (S, s\'), s), arity)  = expand ((S, comp (s\', s)), arity) let (S\', arity\') = expand ((S, id), arity) in makeLam (toFgn (opExp S\')) arity\' let rec makeFgnUnary opSum  = makeFgn (1, fun (App (U, Nil)) -> opSum (fromExp (U, id))) let rec makeFgnBinary opSum  = makeFgn (2, fun (App (U1, App (U2, Nil))) -> opSum (fromExp (U1, id), fromExp (U2, id))) let rec arrow (U, V)  = Pi ((Dec (NONE, U), No), V) (* init (cs, installFunction) = ()\n       Initialize the constraint solver.\n       installFunction is used to add its signature symbols.\n    *) let rec init (cs, installF)  = (myID := cs; boolID := installF (ConDec ("bool", NONE, 0, Constraint (! myID, solveBool), Uni (Type), Kind), NONE, [Mnil]); trueID := installF (ConDec ("true", NONE, 0, Foreign (! myID, (fun _ -> toFgn (Sum (true, nil)))), bool (), Type), NONE, nil); falseID := installF (ConDec ("false", NONE, 0, Foreign (! myID, (fun _ -> toFgn (Sum (false, nil)))), bool (), Type), NONE, nil); notID := installF (ConDec ("!", NONE, 0, Foreign (! myID, makeFgnUnary notSum), arrow (bool (), bool ()), Type), SOME (Prefix (maxPrec)), nil); xorID := installF (ConDec ("||", NONE, 0, Foreign (! myID, makeFgnBinary xorSum), arrow (bool (), arrow (bool (), bool ())), Type), SOME (Infix (dec maxPrec, Left)), nil); andID := installF (ConDec ("&", NONE, 0, Foreign (! myID, makeFgnBinary andSum), arrow (bool (), arrow (bool (), bool ())), Type), SOME (Infix (dec maxPrec, Left)), nil); orID := installF (ConDec ("|", NONE, 0, Foreign (! myID, makeFgnBinary orSum), arrow (bool (), arrow (bool (), bool ())), Type), SOME (Infix (dec maxPrec, Left)), nil); impliesID := installF (ConDec ("=>", NONE, 0, Foreign (! myID, makeFgnBinary impliesSum), arrow (bool (), arrow (bool (), bool ())), Type), SOME (Infix (dec (dec maxPrec), Left)), nil); iffID := installF (ConDec ("<=>", NONE, 0, Foreign (! myID, makeFgnBinary iffSum), arrow (bool (), arrow (bool (), bool ())), Type), SOME (Infix (dec (dec maxPrec), Left)), nil); installFgnExpOps (); ()) let solver = {name = "equality/booleans"; keywords = "booleans,equality"; needs = ["Unify"]; fgnConst = NONE; init = init; reset = (fun () -> ()); mark = (fun () -> ()); unwind = (fun () -> ())}  end(* functor CSEqBools *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* Solver for machine integers *) (* Author: Roberto Virga *) module CSIntWord ((*! structure IntSyn : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) val wordSize : int) : CS = struct (*! structure CSManager = CSManager !*)  open IntSyn module W = LargeWordmodule FX = CSManagerFixitymodule MS = ModeSyn(* CSManager.ModeSyn *) exception MyFgnCnstrRepPlus of dctx * Exp * Exp * Exp * Exp (* FgnCnstr Representation: (G, proof, U1, U2, U3) *) exception MyFgnCnstrRepTimes of dctx * Exp * Exp * Exp * Exp exception MyFgnCnstrRepQuot of dctx * Exp * Exp * Exp * Exp let wordSize\' = min (wordSize, wordSize) let zero = fromInt 0 let max = >> (notb zero, fromInt (wordSize - wordSize\')) (* numCheck (d) = true iff d <= max *) let rec numCheck (d)  = <= (d, max) (* plusCheck (d1, d2) = true iff d1 + d2 <= max *) let rec plusCheck (d1, d2)  = let d3 = + (d1, d2) in >= (d3, d1) && >= (d3, d2) && <= (d3, max) (* timesCheck (d1, d2) = true iff d1 * d2 <= max *) let rec timesCheck (d1, d2)  = if (d1 = zero || d2 = zero) then true else let d3 = div (div (max, d1), d2) in > (d3, zero) (* quotCheck (d1, d2) = true iff  d2 != zero *) let rec quotCheck (d1, d2)  = > (d2, zero) (* constraint solver ID of this module *) let myID = ref ~1 : csid ref (* constant ID of the type family constant "wordXX" *) let wordID = ref ~1 : cid ref let rec word ()  = Root (Const (! wordID), Nil) (* constant ID\'s of the operators defined by this module *) let plusID = ref ~1 : cid ref (* + : wordXX -> wordXX -> wordXX -> type *) let timesID = ref ~1 : cid ref (* * : wordXX -> wordXX -> wordXX -> type *) let quotID = ref ~1 : cid ref (* / : wordXX -> wordXX -> wordXX -> type *) let rec plusExp (U, V, W)  = Root (Const (! plusID), App (U, App (V, App (W, Nil)))) let rec timesExp (U, V, W)  = Root (Const (! timesID), App (U, App (V, App (W, Nil)))) let rec quotExp (U, V, W)  = Root (Const (! quotID), App (U, App (V, App (W, Nil)))) (* constant ID\'s of the proof object generators and their proof objects *) (* (these are used as workaround for the lack of sigma types in Twelf)  *) let provePlusID = ref ~1 : cid ref (* prove+ : {U}{V}{W} + U V W -> type *) let proveTimesID = ref ~1 : cid ref (* prove* : {U}{V}{W} * U V W -> type *) let proveQuotID = ref ~1 : cid ref (* prove/ : {U}{V}{W} / U V W -> type *) let proofPlusID = ref ~1 : cid ref (* proof* : {U}{V}{W}{P} prove+ U V W P *) let proofTimesID = ref ~1 : cid ref (* proof* : {U}{V}{W}{P} prove* U V W P *) let proofQuotID = ref ~1 : cid ref (* proof/ : {U}{V}{W}{P} prove/ U V W P *) let rec provePlusExp (U, V, W, P)  = Root (Const (! provePlusID), App (U, App (V, App (W, App (P, Nil))))) let rec proofPlusExp (U, V, W, P)  = Root (Const (! proofPlusID), App (U, App (V, App (W, App (P, Nil))))) let rec proofTimesExp (U, V, W, P)  = Root (Const (! proofTimesID), App (U, App (V, App (W, App (P, Nil))))) let rec proveTimesExp (U, V, W, P)  = Root (Const (! proveTimesID), App (U, App (V, App (W, App (P, Nil))))) let rec proveQuotExp (U, V, W, P)  = Root (Const (! proveQuotID), App (U, App (V, App (W, App (P, Nil))))) let rec proofQuotExp (U, V, W, P)  = Root (Const (! proofQuotID), App (U, App (V, App (W, App (P, Nil))))) let rec numberConDec (d)  = ConDec (fmt DEC (d), NONE, 0, Normal, word (), Type) let rec numberExp (d)  = Root (FgnConst (! myID, numberConDec (d)), Nil) (* scanNumber (str) = numOpt\n\n       Invariant:\n         numOpt = SOME(n) if str is the decimal representation of the number n\n                = NONE otherwise\n    *) let rec scanNumber (str)  = let rec check (chars as (_ :: _))  = (all isDigit chars) | check nil  = false in if check (explode str) then match (scanString (scan DEC) str) with SOME (d) -> (if numCheck (d) then SOME (d) else NONE) | NONE -> NONE else NONE (* parseNumber str = SOME(conDec) or NONE\n\n       Invariant:\n       If str parses to the number n\n       then conDec is the (foreign) constant declaration of n\n    *) let rec parseNumber string  = match (scanNumber string) with SOME (d) -> SOME (numberConDec d) | NONE -> NONE let rec plusPfConDec (d1, d2)  = let d3 = + (d1, d2) in ConDec (fmt DEC d1 ^ "+" ^ fmt DEC d2, NONE, 0, Normal, plusExp (numberExp d1, numberExp d2, numberExp d3), Type) let rec plusPfExp ds  = Root (FgnConst (! myID, plusPfConDec ds), Nil) let rec timesPfConDec (d1, d2)  = let d3 = * (d1, d2) in ConDec (fmt DEC d1 ^ "*" ^ fmt DEC d2, NONE, 0, Normal, timesExp (numberExp d1, numberExp d2, numberExp d3), Type) let rec timesPfExp ds  = Root (FgnConst (! myID, timesPfConDec ds), Nil) let rec quotPfConDec (d1, d2)  = let d3 = div (d1, d2) in ConDec (fmt DEC d1 ^ "/" ^ fmt DEC d2, NONE, 0, Normal, quotExp (numberExp d1, numberExp d2, numberExp d3), Type) let rec quotPfExp ds  = Root (FgnConst (! myID, quotPfConDec ds), Nil) let rec scanBinopPf oper string  = let args = tokens (fun c -> c = oper) string in match args with [arg1; arg2] -> (match (scanString (scan DEC) arg1, scanString (scan DEC) arg2) with (SOME (d1), SOME (d2)) -> SOME (d1, d2) | _ -> NONE) | _ -> NONE (* parseBinopPf operator string = SOME(conDec) or NONE\n\n       Invariant:\n       If string parses to the proof object of n1<operator>n2\n       then conDec is the (foreign) constant declaration of n1<operator>n2\n    *) let rec parseBinopPf oper string  = match (oper, scanBinopPf oper string) with (\'+\', SOME (ds)) -> SOME (plusPfConDec ds) | (\'*\', SOME (ds)) -> SOME (timesPfConDec ds) | (\'/\', SOME (ds)) -> SOME (quotPfConDec ds) | _ -> NONE let parsePlusPf = parseBinopPf \'+\' let parseTimesPf = parseBinopPf \'*\' let parseQuotPf = parseBinopPf \'/\' let rec parseAll string  = (match (parseNumber (string)) with SOME (conDec) -> SOME (conDec) | NONE -> (match (parsePlusPf (string)) with SOME (conDec) -> SOME (conDec) | NONE -> (match (parseTimesPf (string)) with SOME (conDec) -> SOME (conDec) | NONE -> parseQuotPf (string)))) type FixTerm = Num of word | PlusPf of (word * word) | TimesPf of (word * word) | QuotPf of (word * word) | Expr of (Exp * Sub) (*        | <Expr>            *) (* fromExpW (U, s) = t\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V    (U,s)  in whnf\n       then t is the internal representation of U[s] as term\n    *) let rec fromExpW (Us as (Root (FgnConst (cs, conDec), _), _))  = if (cs = ! myID) then let string = conDecName conDec in (match (scanNumber string) with SOME (d) -> Num d | NONE -> (match (scanBinopPf \'/\' string) with SOME (ds) -> QuotPf ds | NONE -> (match (scanBinopPf \'+\' string) with SOME (ds) -> PlusPf ds | NONE -> (match (scanBinopPf \'*\' string) with SOME (ds) -> TimesPf ds | NONE -> Expr Us)))) else Expr Us | fromExpW (Us as (Root (Def (d), _), _))  = fromExpW (expandDef (Us)) | fromExpW Us  = Expr Us(* fromExp (U, s) = t\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V\n       then t is the internal representation of U[s] as term\n    *) fromExp Us  = fromExpW (whnf Us) (* toExp t = U\n\n       Invariant:\n       G |- U : V and U is the Twelf syntax conversion of t\n    *) let rec toExp (Num d)  = numberExp d | toExp (PlusPf ds)  = plusPfExp ds | toExp (TimesPf ds)  = timesPfExp ds | toExp (QuotPf ds)  = quotPfExp ds | toExp (Expr Us)  = EClo Us let rec solveNumber (G, S, k)  = SOME (numberExp (fromInt k)) (* fst (S, s) = U1, the first argument in S[s] *) let rec fst (App (U1, _), s)  = (U1, s) | fst (SClo (S, s\'), s)  = fst (S, comp (s\', s)) (* snd (S, s) = U2, the second argument in S[s] *) let rec snd (App (_, S), s)  = fst (S, s) | snd (SClo (S, s\'), s)  = snd (S, comp (s\', s)) (* trd (S, s) = U1, the third argument in S[s] *) let rec trd (App (_, S), s)  = snd (S, s) | trd (SClo (S, s\'), s)  = trd (S, comp (s\', s)) (* fth (S, s) = U1, the fourth argument in S[s] *) let rec fth (App (_, S), s)  = trd (S, s) | fth (SClo (S, s\'), s)  = fth (S, comp (s\', s)) let rec toInternalPlus (G, U1, U2, U3) ()  = [(G, plusExp (U1, U2, U3))]awakePlus (G, proof, U1, U2, U3) ()  = match (solvePlus (G, App (U1, App (U2, App (U3, Nil))), 0)) with SOME (proof\') -> unifiable (G, (proof, id), (proof\', id)) | NONE -> false(* constraint constructor *) makeCnstrPlus (G, proof, U1, U2, U3)  = FgnCnstr (! myID, MyFgnCnstrRepPlus (G, proof, U1, U2, U3))(* solvePlus (G, S, n) tries to find the n-th solution to\n          G |- \'+\' @ S : type\n    *) solvePlus (G, S, 0)  = let Us1 = fst (S, id) let Us2 = snd (S, id) let Us3 = trd (S, id) in (match (fromExp (Us1), fromExp (Us2), fromExp (Us3)) with (Num d1, Num d2, Num d3) -> if (d3 = + (d1, d2) && plusCheck (d1, d2)) then SOME (plusPfExp (d1, d2)) else NONE | (Expr Us1, Num d2, Num d3) -> if (>= (d3, d2) && unifiable (G, Us1, (numberExp (- (d3, d2)), id))) then SOME (plusPfExp (- (d3, d2), d2)) else NONE | (Num d1, Expr Us2, Num d3) -> if (>= (d3, d1) && unifiable (G, Us2, (numberExp (- (d3, d1)), id))) then SOME (plusPfExp (d1, - (d3, d1))) else NONE | (Num d1, Num d2, Expr Us3) -> if (plusCheck (d1, d2) && unifiable (G, Us3, (numberExp (+ (d1, d2)), id))) then SOME (plusPfExp (d1, d2)) else NONE | _ -> let proof = newEVar (G, plusExp (EClo Us1, EClo Us2, EClo Us3)) let cnstr = makeCnstrPlus (G, proof, EClo Us1, EClo Us2, EClo Us3) let _ = app (fun Us -> delay (Us, ref cnstr)) [Us1; Us2; Us3] in SOME (proof)) | solvePlus (G, S, n)  = NONEtoInternalTimes (G, U1, U2, U3) ()  = [(G, timesExp (U1, U2, U3))]awakeTimes (G, proof, U1, U2, U3) ()  = match (solveTimes (G, App (U1, App (U2, App (U3, Nil))), 0)) with SOME (proof\') -> unifiable (G, (proof, id), (proof\', id)) | NONE -> falsemakeCnstrTimes (G, proof, U1, U2, U3)  = FgnCnstr (! myID, MyFgnCnstrRepTimes (G, proof, U1, U2, U3))(* solveTimes (G, S, n) tries to find the n-th solution to\n         G |- \'*\' @ S : type\n    *) solveTimes (G, S, 0)  = let Us1 = fst (S, id) let Us2 = snd (S, id) let Us3 = trd (S, id) in (match (fromExp Us1, fromExp Us2, fromExp Us3) with (Num d1, Num d2, Num d3) -> if (d3 = * (d1, d2) && timesCheck (d1, d2)) then SOME (timesPfExp (d1, d2)) else NONE | (Expr Us1, Num d2, Num d3) -> if (d3 = zero && unifiable (G, Us1, (numberExp (zero), id))) then SOME (timesPfExp (zero, d2)) else if (> (d2, zero) && > (d3, zero) && mod (d3, d2) = zero && unifiable (G, Us1, (numberExp (div (d3, d2)), id))) then SOME (timesPfExp (div (d3, d2), d2)) else NONE | (Num d1, Expr Us2, Num d3) -> if (d3 = zero && unifiable (G, Us2, (numberExp (zero), id))) then SOME (timesPfExp (d1, zero)) else if (> (d1, zero) && > (d3, zero) && mod (d3, d1) = zero && unifiable (G, Us2, (numberExp (div (d3, d1)), id))) then SOME (timesPfExp (d1, div (d3, d1))) else NONE | (Num d1, Num d2, Expr Us3) -> if (timesCheck (d1, d2) && unifiable (G, Us3, (numberExp (* (d1, d2)), id))) then SOME (timesPfExp (d1, d2)) else NONE | _ -> let proof = newEVar (G, timesExp (EClo Us1, EClo Us2, EClo Us3)) let cnstr = makeCnstrTimes (G, proof, EClo Us1, EClo Us2, EClo Us3) let _ = app (fun Us -> delay (Us, ref cnstr)) [Us1; Us2; Us3] in SOME (proof)) | solveTimes (G, S, n)  = NONEtoInternalQuot (G, U1, U2, U3) ()  = [(G, quotExp (U1, U2, U3))]awakeQuot (G, proof, U1, U2, U3) ()  = match (solveQuot (G, App (U1, App (U2, App (U3, Nil))), 0)) with SOME (proof\') -> unifiable (G, (proof, id), (proof\', id)) | NONE -> false(* constraint constructor *) makeCnstrQuot (G, proof, U1, U2, U3)  = FgnCnstr (! myID, MyFgnCnstrRepQuot (G, proof, U1, U2, U3))(* solveQuot (G, S, n) tries to find the n-th solution to\n         G |- \'/\' @ S : type\n    *) solveQuot (G, S, 0)  = let Us1 = fst (S, id) let Us2 = snd (S, id) let Us3 = trd (S, id) in (match (fromExp Us1, fromExp Us2, fromExp Us3) with (Num d1, Num d2, Num d3) -> if (quotCheck (d1, d2) && d3 = div (d1, d2)) then SOME (quotPfExp (d1, d2)) else NONE | (Num d1, Num d2, Expr Us3) -> if (quotCheck (d1, d2) && unifiable (G, Us3, (numberExp (div (d1, d2)), id))) then SOME (quotPfExp (d1, d2)) else NONE | _ -> let proof = newEVar (G, quotExp (EClo Us1, EClo Us2, EClo Us3)) let cnstr = makeCnstrQuot (G, proof, EClo Us1, EClo Us2, EClo Us3) let _ = app (fun Us -> delay (Us, ref cnstr)) [Us1; Us2; Us3] in SOME (proof)) | solveQuot (G, S, n)  = NONE (* solveProvePlus (G, S, n) tries to find the n-th solution to\n         G |- prove+ @ S : type\n    *) let rec solveProvePlus (G, S, k)  = let Us1 = fst (S, id) let Us2 = snd (S, id) let Us3 = trd (S, id) let Us4 = fth (S, id) in match (solvePlus (G, App (EClo Us1, App (EClo Us2, App (EClo Us3, Nil))), k)) with SOME (U) -> if unifiable (G, Us4, (U, id)) then SOME (proofPlusExp (EClo Us1, EClo Us2, EClo Us3, EClo Us4)) else NONE | NONE -> NONE (* solveProveTimes (G, S, n) tries to find the n-th solution to\n         G |- prove* @ S : type\n    *) let rec solveProveTimes (G, S, k)  = let Us1 = fst (S, id) let Us2 = snd (S, id) let Us3 = trd (S, id) let Us4 = fth (S, id) in match (solveTimes (G, App (EClo Us1, App (EClo Us2, App (EClo Us3, Nil))), k)) with SOME (U) -> if unifiable (G, Us4, (U, id)) then SOME (proofTimesExp (EClo Us1, EClo Us2, EClo Us3, EClo Us4)) else NONE | NONE -> NONE (* solveProveQuot (G, S, n) tries to find the n-th solution to\n         G |- prove/ @ S : type\n    *) let rec solveProveQuot (G, S, k)  = let Us1 = fst (S, id) let Us2 = snd (S, id) let Us3 = trd (S, id) let Us4 = fth (S, id) in match (solveQuot (G, App (EClo Us1, App (EClo Us2, App (EClo Us3, Nil))), k)) with SOME (U) -> if unifiable (G, Us4, (U, id)) then SOME (proofQuotExp (EClo Us1, EClo Us2, EClo Us3, EClo Us4)) else NONE | NONE -> NONE let rec arrow (U, V)  = Pi ((Dec (NONE, U), No), V) let rec pi (name, U, V)  = Pi ((Dec (SOME (name), U), Maybe), V) let rec bvar n  = Root (BVar n, Nil) let rec installFgnCnstrOps ()  = let csid = ! myID let _ = install (csid, (fun (MyFgnCnstrRepPlus (G, _, U1, U2, U3)) -> toInternalPlus (G, U1, U2, U3) | (MyFgnCnstrRepTimes (G, _, U1, U2, U3)) -> toInternalTimes (G, U1, U2, U3) | (MyFgnCnstrRepQuot (G, _, U1, U2, U3)) -> toInternalQuot (G, U1, U2, U3) | fc -> raise ((UnexpectedFgnCnstr fc)))) let _ = install (csid, (fun (MyFgnCnstrRepPlus (G, proof, U1, U2, U3)) -> awakePlus (G, proof, U1, U2, U3) | (MyFgnCnstrRepTimes (G, proof, U1, U2, U3)) -> awakeTimes (G, proof, U1, U2, U3) | (MyFgnCnstrRepQuot (G, proof, U1, U2, U3)) -> awakeQuot (G, proof, U1, U2, U3) | fc -> raise ((UnexpectedFgnCnstr fc)))) let _ = install (csid, (fun (MyFgnCnstrRepPlus _) -> (fun () -> false) | (MyFgnCnstrRepTimes _) -> (fun () -> false) | (MyFgnCnstrRepQuot _) -> (fun () -> false) | fc -> raise ((UnexpectedFgnCnstr fc)))) in () (* init (cs, installFunction) = ()\n       Initialize the constraint solver.\n       installFunction is used to add its signature symbols.\n    *) let rec init (cs, installF)  = (myID := cs; wordID := installF (ConDec ("word" ^ toString (wordSize\'), NONE, 0, Constraint (! myID, solveNumber), Uni (Type), Kind), NONE : fixity option, [Mnil]); plusID := installF (ConDec ("+", NONE, 0, Constraint (! myID, solvePlus), arrow (word (), arrow (word (), arrow (word (), Uni (Type)))), Kind), NONE, [Mapp (Marg (Plus, SOME "X"), Mapp (Marg (Plus, SOME "Y"), Mapp (Marg (Minus, SOME "Z"), Mnil))); Mapp (Marg (Plus, SOME "X"), Mapp (Marg (Minus, SOME "Y"), Mapp (Marg (Plus, SOME "Z"), Mnil))); Mapp (Marg (Minus, SOME "X"), Mapp (Marg (Plus, SOME "Y"), Mapp (Marg (Plus, SOME "Z"), Mnil)))]); timesID := installF (ConDec ("*", NONE, 0, Constraint (! myID, solveTimes), arrow (word (), arrow (word (), arrow (word (), Uni (Type)))), Kind), NONE, [Mapp (Marg (Plus, SOME "X"), Mapp (Marg (Plus, SOME "Y"), Mapp (Marg (Minus, SOME "Z"), Mnil))); Mapp (Marg (Plus, SOME "X"), Mapp (Marg (Minus, SOME "Y"), Mapp (Marg (Plus, SOME "Z"), Mnil))); Mapp (Marg (Minus, SOME "X"), Mapp (Marg (Plus, SOME "Y"), Mapp (Marg (Plus, SOME "Z"), Mnil)))]); quotID := installF (ConDec ("/", NONE, 0, Constraint (! myID, solveQuot), arrow (word (), arrow (word (), arrow (word (), Uni (Type)))), Kind), NONE, [Mapp (Marg (Plus, SOME "X"), Mapp (Marg (Plus, SOME "Y"), Mapp (Marg (Minus, SOME "Z"), Mnil))); Mapp (Marg (Plus, SOME "X"), Mapp (Marg (Minus, SOME "Y"), Mapp (Marg (Plus, SOME "Z"), Mnil)))]); provePlusID := installF (ConDec ("prove+", NONE, 0, Constraint (! myID, solveProvePlus), pi ("X", word (), pi ("Y", word (), pi ("Z", word (), pi ("P", plusExp (bvar 3, bvar 2, bvar 1), Uni (Type))))), Kind), NONE, [Mapp (Marg (Star, SOME "X"), Mapp (Marg (Star, SOME "Y"), Mapp (Marg (Star, SOME "Z"), Mapp (Marg (Star, SOME "P"), Mnil))))]); proofPlusID := installF (ConDec ("proof+", NONE, 0, Normal, pi ("X", word (), pi ("Y", word (), pi ("Z", word (), pi ("P", plusExp (bvar 3, bvar 2, bvar 1), provePlusExp (bvar 4, bvar 3, bvar 2, bvar 1))))), Type), NONE, nil); proveTimesID := installF (ConDec ("prove*", NONE, 0, Constraint (! myID, solveProveTimes), pi ("X", word (), pi ("Y", word (), pi ("Z", word (), pi ("P", timesExp (bvar 3, bvar 2, bvar 1), Uni (Type))))), Kind), NONE, [Mapp (Marg (Star, SOME "X"), Mapp (Marg (Star, SOME "Y"), Mapp (Marg (Star, SOME "Z"), Mapp (Marg (Star, SOME "P"), Mnil))))]); proofTimesID := installF (ConDec ("proof*", NONE, 0, Normal, pi ("X", word (), pi ("Y", word (), pi ("Z", word (), pi ("P", timesExp (bvar 3, bvar 2, bvar 1), proveTimesExp (bvar 4, bvar 3, bvar 2, bvar 1))))), Type), NONE, nil); proveQuotID := installF (ConDec ("prove/", NONE, 0, Constraint (! myID, solveProveQuot), pi ("X", word (), pi ("Y", word (), pi ("Z", word (), pi ("P", quotExp (bvar 3, bvar 2, bvar 1), Uni (Type))))), Kind), NONE, [Mapp (Marg (Star, SOME "X"), Mapp (Marg (Star, SOME "Y"), Mapp (Marg (Star, SOME "Z"), Mapp (Marg (Star, SOME "P"), Mnil))))]); proofQuotID := installF (ConDec ("proof/", NONE, 0, Normal, pi ("X", word (), pi ("Y", word (), pi ("Z", word (), pi ("P", quotExp (bvar 3, bvar 2, bvar 1), proveQuotExp (bvar 4, bvar 3, bvar 2, bvar 1))))), Type), NONE, nil); installFgnCnstrOps (); ()) let solver = {name = "word" ^ toString (wordSize\'); keywords = "numbers,equality"; needs = ["Unify"]; fgnConst = SOME ({parse = parseAll}); init = init; reset = (fun () -> ()); mark = (fun () -> ()); unwind = (fun () -> ())}  end(* functor CSIntWord *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: (* Constraint Solver *) module type CS = sig (*! structure CSManager : CS_MANAGER !*) (* all a constraint solver must define is a structure
     suitable for the constraint solver manager to install.
  *) val solver : solver end(* signature CS *) 
('Error parsing code:', '(* Solver for a linearly ordered field, based on the simplex method *) (* Author: Roberto Virga *) module CSIneqField (module OrderedField : ORDERED_FIELD(*! structure IntSyn : INTSYN !*) module Trail : TRAILmodule Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) module SparseArray : SPARSE_ARRAYmodule SparseArray2 : SPARSE_ARRAY2(*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) module CSEqField : CS_EQ_FIELDCSEqFieldFieldOrderedField(*! sharing CSEqField.IntSyn = IntSyn !*) (*! sharing CSEqField.CSManager = CSManager !*) module Compat : COMPAT) : CS = struct (*! structure CSManager = CSManager !*)  open IntSyn open OrderedField open CSEqField module FX = CSManagerFixitymodule MS = ModeSyn(* CSManager.ModeSyn *) module Array = SparseArraymodule Array2 = SparseArray2(* solver ID of this solver *) let myID = ref ~1 : cid ref (* constant IDs of the declared type constants *) let gtID = ref ~1 : cid ref let geqID = ref ~1 : cid ref (* constructors for the declared types *) let rec gt (U, V)  = Root (Const (! gtID), App (U, App (V, Nil))) let rec geq (U, V)  = Root (Const (! geqID), App (U, App (V, Nil))) (* specialized constructors for the declared types *) let rec gt0 (U)  = gt (U, constant (zero)) let rec geq0 (U)  = geq (U, constant (zero)) (* constant IDs of the declared object constants *) let gtAddID = ref ~1 : cid ref let geqAddID = ref ~1 : cid ref let gtGeqID = ref ~1 : cid ref let geq00ID = ref ~1 : cid ref (* constructors for the declared objects *) let rec gtAdd (U1, U2, V, W)  = Root (Const (! gtAddID), App (U1, App (U2, App (V, App (W, Nil))))) let rec geqAdd (U1, U2, V, W)  = Root (Const (! geqAddID), App (U1, App (U2, App (V, App (W, Nil))))) let rec gtGeq (U, V, W)  = Root (Const (! gtGeqID), App (U, App (V, App (W, Nil)))) let rec geq00 ()  = Root (Const (! geq00ID), Nil) (* constant declaration for the proof object d>0 *) let rec gtNConDec (d)  = ConDec (toString (d) ^ ">" ^ toString (zero), NONE, 0, Normal, gt0 (constant (d)), Type) (* foreign constant for the proof object d>0 *) let rec gtNExp (d)  = Root (FgnConst (! myID, gtNConDec (d)), Nil) (* specialized constructors for the declared objects *) let rec geqN0 (d)  = if (d = zero) then geq00 () else gtGeq (constant (d), constant (zero), gtNExp (d)) (* parsing proof objects d>0 *) let rec parseGtN string  = let suffix = (">" ^ (toString (zero))) let stringLen = size string let suffixLen = size suffix let numLen = - (stringLen, suffixLen) in if > (stringLen, suffixLen) && (substring (string, numLen, suffixLen) = suffix) then (match fromString (substring (string, 0, numLen)) with SOME (d) -> if (d > zero) then SOME (gtNConDec (d)) else NONE | NONE -> NONE) else NONE type Position = Row of int | Col of int type Owner = Var of dctx * Mon | Exp of dctx * Sum (*   - sum                           *) type Restriction = Restr of dctx * Exp * bool (*   Restr (G, U, strict)            *) type label = {owner: Owner; (* owner of the row/column (if any)  *) ; tag: int ref; (* tag: used to keep track of the    *) ; (* position of a tableau entry       *) ; restr: Restriction option ref; (* restriction (if any)              *) ; dead: bool ref} (* has the row/column already been   *) (* solved?                           *) type Operation = Insert of Position | Pivot of int * int | Kill of Position | Restrict of Position | UpdateOwner of Position * Owner * int ref (* change the owner                  *) type tableau = (* Tableau:                          *) {rlabels: label array; (* row labels                        *) ; clabels: label array; (* column labels                     *) ; consts: number array; (* constant terms                    *) ; coeffs: number array; (* variables coefficients            *) ; nrows: int ref; ncols: int ref; (* dimensions                        *) ; trail: Operation trail} (* undo mechanism                    *) exception MyFgnCnstrRep of int ref (* FgnCnstr representation *) exception Error (* Representational invariants:\n         rlabels[i] = vacuous\n         clabels[j] = vacuous\n         const[i] = zero\n         coeff[i,j] = zero\n       for i >= !nrows or j > !ncols, where "vacuous" is the vacuous label:\n          #owner(vacuous) = Exp (Null, Sum (zero, nil))\n          #restr(vacuous) = ref NONE\n          #dead(vacuous) = ref true\n    *) (* little random generation routine taken from Paulson \'91 *) let a = 16807.0 and m = 2147483647.0 let seed = ref 1999.0 let rec rand (min, size)  = let rec nextrand ()  = let t = * (a, ! seed) in (seed := - (t, * (m, fromInt (floor (t / m)))); - (! seed, 1.0) / - (m, 1.0)) in + (min, floor (* (nextrand (), fromInt (size)))) (* create a new (empty) tableau *) let tableau = let l = {owner = Exp (Null, Sum (zero, nil)); tag = ref 0; restr = ref NONE; dead = ref true} in {rlabels = array (l); clabels = array (l); consts = array (zero); coeffs = array (zero); nrows = ref 0; ncols = ref 0; trail = trail ()} : tableau (* i-th tableau row label *) let rec rlabel (i)  = sub (rlabels (tableau), i) (* j-th tableau column label *) let rec clabel (j)  = sub (clabels (tableau), j) (* i-th tableau constant term *) let rec const (i)  = sub (consts (tableau), i) (* coefficient in row i, column j *) let rec coeff (i, j)  = sub (coeffs (tableau), i, j) (* number of rows *) let rec nRows ()  = ! (nrows (tableau)) (* number of columns *) let rec nCols ()  = ! (ncols (tableau)) (* increase the number of rows, and return the index of the last row *) let rec incrNRows ()  = let old = nRows () in (nrows (tableau) := + (old, 1); old) (* increase the number of columns, and return the index of the last column *) let rec incrNCols ()  = let old = nCols () in (ncols (tableau) := + (old, 1); old) (* decrease the number of rows *) let rec decrNRows ()  = nrows (tableau) := - (nRows (), 1) (* decrease the number of columns *) let rec decrNCols ()  = ncols (tableau) := - (nCols (), 1) (* increase by the given amount the element i of the array *) let rec incrArray (array, i, value)  = update (array, i, sub (array, i) + value) (* increase by the given amount the element (i, j) of the array *) let rec incrArray2 (array, i, j, value)  = update (array, i, j, sub (array, i, j) + value) (* increase by f(j\') all the elements (i, j\'), with j <= j\' < j+len *) let rec incrArray2Row (array, i, (j, len), f)  = mapi (fun (j, value) -> update (array, i, j, value + f (j))) (row (array, i, (j, len))) (* increase by f(i\') all the elements (i\', j), with i <= i\' < i+len *) let rec incrArray2Col (array, j, (i, len), f)  = mapi (fun (i, value) -> update (array, i, j, value + f (i))) (column (array, j, (i, len))) (* set the given row to zero *) let rec clearArray2Row (array, i, (j, len))  = mapi (fun (j, value) -> update (array, i, j, zero)) (row (array, i, (j, len))) (* set the given column to zero *) let rec clearArray2Col (array, j, (i, len))  = mapi (fun (i, value) -> update (array, i, j, zero)) (column (array, j, (i, len))) (* return the label at the given position (row or column) *) let rec label (Row (i))  = rlabel (i) | label (Col (j))  = clabel (j) (* return the restriction on the given label *) let rec restriction (l : label)  = ! (restr (l)) (* is the given label is restricted? *) let rec restricted (l : label)  = (match (restriction (l)) with SOME _ -> true | NONE -> false) (* return true iff the given label has been solved *) let rec dead (l : label)  = ! (dead (l)) (* set the ownership of the given position *) let rec setOwnership (pos, owner, tag)  = let old = label (pos) let new = {owner = owner; tag = tag; restr = ref (restriction (old)); dead = ref (dead (old))} in (match pos with Row (i) -> update (rlabels (tableau), i, new) | Col (j) -> update (clabels (tableau), j, new)) (* return the context of a owner *) let rec ownerContext (Var (G, mon))  = G | ownerContext (Exp (G, sum))  = G (* return the owner as a sum *) let rec ownerSum (Var (G, mon))  = Sum (zero, [mon]) | ownerSum (Exp (G, sum))  = sum (* debugging code - REMOVE *) let rec displayPos (Row (row))  = print ("row " ^ toString (row) ^ "\\n") | displayPos (Col (col))  = print ("column " ^ toString (col) ^ "\\n") (* debugging code - REMOVE *) let rec displaySum (Sum (m, Mon (n, _) :: monL))  = (print (toString n); print " ? + "; displaySum (Sum (m, monL))) | displaySum (Sum (m, nil))  = (print (toString m); print " >= 0\\n") (* debugging code - REMOVE *) let rec display ()  = let rec printLabel (col, l : label)  = (print "\\t"; (match (owner (l)) with Var _ -> print "V" | Exp _ -> print "E"); if restricted (l) then print ">" else print "*"; if dead (l) then print "#" else print "") let rec printRow (row, l : label)  = let rec printCol (col, d : number)  = (print "\\t"; print (toString d)) let vec = row (coeffs (tableau), row, (0, nCols ())) in ((match (owner (l)) with Var _ -> print "V" | Exp _ -> print "E"); if restricted (l) then print ">" else print "*"; if dead (l) then print "#" else print ""; print "\\t"; mapi printCol vec; print "\\t"; print (toString (const (row))); print "\\n") in (print "\\t"; app printLabel (clabels (tableau), 0, nCols ()); print "\\n"; app printRow (rlabels (tableau), 0, nRows ()); print "Columns:\\n"; app (fun (_, l : label) -> displaySum (ownerSum (owner (l)))) (clabels (tableau), 0, nCols ()); print "Rows:\\n"; app (fun (_, l : label) -> displaySum (ownerSum (owner (l)))) (rlabels (tableau), 0, nRows ())) (* find the given monomial in the tableau *) let rec findMon (mon)  = exception Found of int let rec find (i, l : label)  = (match (owner (l)) with (Var (G, mon\')) -> if compatibleMon (mon, mon\') then raise (Found i) else () | _ -> ()) in try  with (* return the a position in the tableau of the tagged expression *) let rec findTag (t)  = exception Found of int let rec find (i, l : label)  = if (tag (l) = t) then raise (Found i) else () in try  with (* return true iff the given row is null at all the active columns *) let rec isConstant (row)  = foldl (fun (j, l, rest) -> (dead (l) || (coeff (row, j) = zero)) && rest) true (clabels (tableau), 0, nCols ()) (* return the position of the row/column of the tableau (if any) that makes the\n       given row redundant *) let rec isSubsumed (row)  = let constRow = const (row) let rec isSubsumedByRow ()  = (* the candidates are those (active) rows with the same constant\n                       term *) (* if j is active, trim the list of candidates to those that have\n                       the same coefficient in column j\n                    *) let candidates = foldl (fun (i, l : label, rest) -> if (i <> row) && not (dead (l)) && (const (i) = constRow) then (i :: rest) else rest) nil (rlabels (tableau), 0, nRows ()) let rec filter (j, l, nil)  = nil | filter (j, l : label, candidates)  = if not (dead (l)) then filter (fun i -> (coeff (i, j) = coeff (row, j))) candidates else candidates in (match (foldl filter candidates (clabels (tableau), 0, nCols ())) with nil -> NONE | (i :: _) -> SOME (i)) let rec isSubsumedByCol ()  = if (constRow = zero) then (* compute the list of non-null coefficients in the row *) let nonNull = foldl (fun (j, l : label, rest) -> if not (dead (l)) then let value = coeff (row, j) in if (value <> zero) then ((j, value) :: rest) else rest else rest) nil (clabels (tableau), 0, nCols ()) in (match nonNull with [(j, value)] -> if (value = one) then SOME (j) else NONE | _ -> NONE) else NONE in match isSubsumedByRow () with SOME (i) -> SOME (Row (i)) | NONE -> (match isSubsumedByCol () with SOME (j) -> SOME (Col (j)) | NONE -> NONE) (* find the coordinates of the pivot which gives the largest increase in const(row) *) let rec findPivot (row)  = (* extend Field.compare to deal with NONE (= infinity) *) (* find the best pivot candidates for the given row *) let rec compareScore (SOME (d), SOME (d\'))  = compare (d, d\') | compareScore (SOME (d), NONE)  = LESS | compareScore (NONE, SOME (d\'))  = GREATER | compareScore (NONE, NONE)  = EQUAL let rec findPivotCol (j, l : label, result as (score, champs))  = (* find the best pivot candidates for the given row and column *) let value = coeff (row, j) let rec findPivotRow sgn (i, l : label, result as (score, champs))  = let value = coeff (i, j) in if (not (dead (l))) && (i <> row) && restricted (l) && ((fromInt (sgn) * value) < zero) then let score\' = SOME (abs (const (i) * inverse (value))) in match compareScore (score, score\')(* always choose the smallest *)  with GREATER -> (score\', [(i, j)]) | EQUAL -> (score, (i, j) :: champs) | LESS -> result else result in if (not (dead (l))) && (value <> zero) && (not (restricted (l)) || (value > zero)) then let (result\' as (score\', champs\')) = foldl (findPivotRow (sign value)) (NONE, [(row, j)]) (rlabels (tableau), 0, nRows ()) in match compareScore (score, score\')(* always choose the largest *)  with GREATER -> result | EQUAL -> (score, champs @ champs\') | LESS -> result\' else result in match (foldl findPivotCol (SOME (zero), nil) (clabels (tableau), 0, nCols ())) with (_, nil) -> NONE | (_, champs) -> (* choose one randomly to ensure fairness *) SOME (nth (champs, rand (0, length (champs)))) (* pivot the element at the given coordinates *) let rec pivot (row, col)  = let pCoeffInverse = inverse (coeff (row, col)) let pRowVector = row (coeffs (tableau), row, (0, nCols ())) let rec pRow (j)  = sub (pRowVector, j) let pColVector = column (coeffs (tableau), col, (0, nRows ())) let rec pCol (i)  = sub (pColVector, i) let pConst = const (row) let pRLabel = rlabel (row) let pCLabel = clabel (col) in (modify (fun (i, value) -> if (i = row) then (* same row as the pivot *) ~ (value * pCoeffInverse) else (* any other row *) value - (pConst * pCol (i) * pCoeffInverse)) (consts (tableau), 0, nRows ()); modify ColMajor (fun (i, j, value) -> (match (i = row, j = col) with (true, true) -> (* pivot *) pCoeffInverse | (true, false) -> (* same row as the pivot *) ~ (value * pCoeffInverse) | (false, true) -> (* same column as the pivot *) value * pCoeffInverse | (false, false) -> (* any other row/column *) value - (pRow (j) * pCol (i) * pCoeffInverse))) {base = (coeffs (tableau)); row = 0; col = 0; nrows = nRows (); ncols = nCols ()}; update (rlabels (tableau), row, pCLabel); update (clabels (tableau), col, pRLabel)) type MaximizeResult = Positive | Maximized of number | Unbounded of int (* manifestly unbounded, pivoting on column col *) (* maximize the given row by performing pivot operations.\n       Return a term of type MaximizeResult.\n    *) let rec maximizeRow (row)  = let value = const (row) in if (value <= zero) then match findPivot (row) with SOME (i, j) -> if (i <> row) then (log (trail (tableau), Pivot (i, j)); pivot (i, j); maximizeRow row) else Unbounded j | NONE -> Maximized value else Positive (* delay all terms of a monomial on the given constraint *) let rec delayMon (Mon (n, UsL), cnstr)  = app (fun Us -> delay (Us, cnstr)) UsL (* unify two restrictions *) let rec unifyRestr (Restr (G, proof, strict), proof\')  = if unifiable (G, (proof, id), (proof\', id)) then () else raise (Error) (* unify a sum with a number *) let rec unifySum (G, sum, d)  = if unifiable (G, (toExp (sum), id), (constant (d), id)) then () else raise (Error) (* decomposition of an expression as the weighted sum of tableau positions *) type decomp = number * number * Position list (* change sign to the given decomposition *) let rec unaryMinusDecomp ((d, wposL))  = (~ d, map (fun (d, pos) -> (~ d, pos)) wposL) (* decompose a sum in whnf into a weighted sum of tableau positions *) let rec decomposeSum (G, Sum (m, monL))  = let rec monToWPos (mon as (Mon (n, UsL)))  = (match findMon (mon) with SOME (pos) -> (n, pos) | NONE -> let new = incrNCols () let l = {owner = Var (G, Mon (one, UsL)); tag = ref 0; restr = ref NONE; dead = ref false} in (log (trail (tableau), Insert (Col (new))); delayMon (mon, ref (makeCnstr (tag (l)))); update (clabels (tableau), new, l); (n, Col (new)))) in (m, map monToWPos monL)(* insert the given expression in the tableau, labelling it with owner *) insertDecomp (decomp as (d, wposL), owner)  = let new = incrNRows () let rec insertWPos (d, pos)  = (match pos with Row (row) -> (incrArray2Row (coeffs (tableau), new, (0, nCols ()), (fun (j) -> d * coeff (row, j))); incrArray (consts (tableau), new, d * const (row))) | Col (col) -> incrArray2 (coeffs (tableau), new, col, d)) in ((* add the decomposition to the newly created row *) app insertWPos wposL; incrArray (consts (tableau), new, d); (* is this row trivial? *) match isSubsumed (new) with SOME (pos) -> (clearArray2Row (coeffs (tableau), new, (0, nCols ())); update (consts (tableau), new, zero); decrNRows (); pos) | NONE -> (setOwnership (Row (new), owner, ref 0); dead (label (Row (new))) := isConstant (new); (* log the creation of this row *) log (trail (tableau), Insert (Row (new))); (* return its position *) Row (new)))(* insert the given (unrestricted) expression in the tableau *) insert (G, Us)  = let sum = fromExp Us in insertDecomp (decomposeSum (G, sum), Exp (G, sum))(* minimize a tableau that has been determined non-minimal (but consistent) as a\n       consequence of adding the given row.\n    *) minimize (row)  = (* equate the given column to zero if coeff(row, j) <> zero *) (* find out if the given row has been made trivial by killing some\n               columns\n            *) let rec killColumn (j, l : label)  = if (not (dead (l))) && (coeff (row, j) <> zero) then ((* mark the column dead *) log (trail (tableau), Kill (Col (j))); dead (sub (clabels (tableau), j)) := true; (* if restricted, instantiate the proof object to 0>=0 *) (match restriction (l) with SOME (restr) -> unifyRestr (restr, geq00 ()) | NONE -> ()); (* if owned by a monomial, unify it with zero *) (match owner (l) with (owner as (Var _)) -> unifySum (ownerContext (owner), ownerSum (owner), zero) | _ -> ())) else () let rec killRow (i, l : label)  = if not (dead (l)) then if isConstant (i) then (* row is now constant and equal to n = const(i) *) ((* mark the row dead *) log (trail (tableau), Kill (Row (i))); dead (sub (rlabels (tableau), i)) := true; (* if restricted, instantiate the proof object to n>=0 *) (match restriction (l) with SOME (restr) -> unifyRestr (restr, geqN0 (const (i))) | NONE -> ()); (* if owned by a monomial, unify it with n *) (match owner (l) with (owner as (Var _)) -> unifySum (ownerContext (owner), ownerSum (owner), const (i)) | _ -> ())) else match isSubsumed (i) with SOME (pos\') -> let l\' = label (pos\') in (log (trail (tableau), Kill (Row (i))); dead (sub (rlabels (tableau), i)) := true; (match (restriction (l), restriction (l\')) with (SOME (restr), SOME (Restr (_, proof\', _))) -> unifyRestr (restr, proof\') | (SOME _, NONE) -> ((* it is safe to restrict without doing all\n                                              the checks in this case, since the two rows\n                                              are identical *) log (trail (tableau), Restrict (pos\')); restr (l\') := restriction (l)) | (NONE, _) -> ())) | NONE -> () else () in (app killColumn (clabels (tableau), 0, nCols ()); app killRow (rlabels (tableau), 0, nRows ()))(* restrict the given row/column to be nonnegative *) restrict (pos as Col (col), restr)  = let l = label (pos) in if dead (l) then unifyRestr (restr, geq00 ()) else match restriction (l) with SOME (Restr (_, proof\', _)) -> unifyRestr (restr, proof\') | NONE -> (* compute the list of non-null row entries *) let nonNull = foldl (fun (i, l : label, rest) -> if not (dead (l)) then let value = coeff (i, col) in if (value <> zero) then (i :: rest) else rest else rest) nil (rlabels (tableau), 0, nRows ()) in match nonNull with (row :: _) -> ((* pivot to a row position; this is sound since\n                                   the column is unrestricted (see Nelson \'81)\n                                *) log (trail (tableau), Pivot (row, col)); pivot (row, col); restrict (Row (row), restr)) | nil -> ((* the column is zero at all the active row\n                                   positions, so we can restrict it right away\n                                *) log (trail (tableau), Restrict (Col (col))); restr (label (Col (col))) := SOME (restr)) | restrict (pos as Row (row), restr)  = let l = label (pos) in if dead (l) then unifyRestr (restr, geqN0 (const (row))) else match restriction (l) with SOME (Restr (_, proof\', _)) -> unifyRestr (restr, proof\') | NONE -> match maximizeRow row with Unbounded col -> (log (trail (tableau), Restrict (Row (row))); restr (sub (rlabels (tableau), row)) := SOME (restr); if (const (row) < zero) then (log (trail (tableau), Pivot (row, col)); pivot (row, col)) else ()) | Positive -> ((* the tableau is satisfiable and minimal *) log (trail (tableau), Restrict (Row (row))); restr (sub (rlabels (tableau), row)) := SOME (restr)) | Maximized value -> if (value = zero) then ((* the tableau is satisfiable but not minimal*) log (trail (tableau), Restrict (Row (row))); restr (sub (rlabels (tableau), row)) := SOME (restr); minimize (row)) else raise (Error)(* insert the equality Var(pos) = Us as two inequalities:\n         Var(pos) - Us >= zero\n         Us - Var(pos) >= zero\n    *) insertEqual (G, pos, sum)  = let (m, wposL) = decomposeSum (G, sum) let decomp\' = (m, (~ one, pos) :: wposL) let pos\' = insertDecomp (decomp\', Exp (G, Sum (zero, nil))) let decomp\'\' = unaryMinusDecomp (decomp\') let tag\'\' = tag (label (insertDecomp (decomp\'\', Exp (G, Sum (zero, nil))))) in ((* the second expression may change position when we\n                  restrict the first. We use tags to keep track of it *) restrict (pos\', Restr (G, geq00 (), false)); (match findTag (tag\'\') with SOME (pos\'\') -> restrict (pos\'\', Restr (G, geq00 (), false))))(* update the tableau upon discovery that Var(pos) = sum *) update (G, pos, sum)  = let l = label (pos) in ((* if the given position has a owner, delete it, since not doing so\n                 may violate the invariant *) log (trail (tableau), UpdateOwner (pos, owner (l), tag (l))); setOwnership (pos, Exp (G, sum), ref 0); (* analyze the given position to see exactly how to represent this\n                 equality *) if dead (l) then (match pos with Row (row) -> (* find out why it died *) if isConstant (row) then (* row is dead because constant and equal to n *) unifySum (G, sum, const (row)) else (* row is dead because is subsumed by another *) (match isSubsumed (row) with SOME (pos\') -> update (G, pos\', sum)) | Col (col) -> (* column is dead because = 0 *) unifySum (G, sum, zero)) else let rec isVar (Sum (m, [mon as Mon (n, _)]))  = if (m = zero) && (n = one) then SOME (mon) else NONE | isVar (sum)  = NONE in match isVar (sum) with SOME (mon) -> (* the nf is another variable *) (match findMon (mon) with SOME _ -> insertEqual (G, pos, sum) | NONE -> let tag = ref 0 in ((* recycle the current label *) log (trail (tableau), UpdateOwner (pos, owner (l), tag (l))); setOwnership (pos, Var (G, mon), tag); delayMon (mon, ref (makeCnstr (tag))))) | NONE -> insertEqual (G, pos, sum))(* returns the list of unsolved constraints associated with the given position *) restrictions (pos)  = let rec member (x, l)  = exists (fun y -> x = y) l let rec test (l)  = restricted (l) && not (dead (l)) let rec reachable ((pos as Row (row)) :: candidates, tried, closure)  = if member (pos, tried) then reachable (candidates, tried, closure) else let new_candidates = foldl (fun (col, _, candidates) -> if (coeff (row, col) <> zero) then (Col (col)) :: candidates else candidates) nil (clabels (tableau), 0, nCols ()) let closure\' = if test (label (pos)) then (pos :: closure) else closure in reachable (new_candidates @ candidates, pos :: tried, closure\') | reachable ((pos as Col (col)) :: candidates, tried, closure)  = if member (pos, tried) then reachable (candidates, tried, closure) else let candidates\' = foldl (fun (row, _, candidates) -> if (coeff (row, col) <> zero) then (Row (row)) :: candidates else candidates) nil (rlabels (tableau), 0, nRows ()) let closure\' = if test (label (pos)) then (pos :: closure) else closure in reachable (candidates\' @ candidates, pos :: tried, closure\') | reachable (nil, _, closure)  = closure let rec restrExp (pos)  = let l = label (pos) let owner = owner (l) let G = ownerContext (owner) let U = toExp (ownerSum (owner)) in (match restriction (label (pos)) with SOME (Restr (_, _, true)) -> (G, gt0 (U)) | _ -> (G, geq0 (U))) in map restrExp (reachable ([pos], nil, nil))(* create a foreingn constraint for the given tag *) makeCnstr (tag)  = FgnCnstr (! myID, MyFgnCnstrRep tag) (* returns the list of unsolved constraints associated with the given tag *) let rec toInternal (tag) ()  = (match findTag (tag) with NONE -> nil | SOME (pos) -> restrictions (pos)) (* awake function for tableau constraints *) let rec awake (tag) ()  = (try  with ) (* simplify function for tableau constraints *) let rec simplify (tag) ()  = (match toInternal (tag) () with nil -> true | (_ :: _) -> false) (* undo function for trailing tableau operations *) let rec undo (Insert (Row (row)))  = (dead (sub (rlabels (tableau), row)) := true; clearArray2Row (coeffs (tableau), row, (0, nCols ())); update (consts (tableau), row, zero); decrNRows ()) | undo (Insert (Col (col)))  = (dead (sub (clabels (tableau), col)) := true; clearArray2Col (coeffs (tableau), col, (0, nRows ())); decrNCols ()) | undo (Pivot (row, col))  = pivot (row, col) | undo (Kill (pos))  = dead (label (pos)) := false | undo (Restrict (pos))  = restr (label (pos)) := NONE | undo (UpdateOwner (pos, owner, tag))  = setOwnership (pos, owner, tag) (* reset the internal status of the tableau *) let rec reset ()  = let l = {owner = Exp (Null, Sum (zero, nil)); tag = ref 0; restr = ref NONE; dead = ref true} in (modify (fun _ -> l) (rlabels (tableau), 0, nRows ()); modify (fun _ -> l) (clabels (tableau), 0, nCols ()); modify (fun _ -> zero) (consts (tableau), 0, nRows ()); modify RowMajor (fun _ -> zero) {base = coeffs (tableau); row = 0; col = 0; nrows = nRows (); ncols = nCols ()}; nrows (tableau) := 0; ncols (tableau) := 0; reset (trail (tableau))) (* trailing functions *) let rec mark ()  = mark (trail (tableau)) let rec unwind ()  = unwind (trail (tableau), undo) (* fst (S, s) = U1, the first argument in S[s] *) let rec fst (App (U1, _), s)  = (U1, s) | fst (SClo (S, s\'), s)  = fst (S, comp (s\', s)) (* snd (S, s) = U2, the second argument in S[s] *) let rec snd (App (U1, S), s)  = fst (S, s) | snd (SClo (S, s\'), s)  = snd (S, comp (s\', s)) (* checks if the given foreign term can be simplified to a constant *) let rec isConstantExp (U)  = (match (fromExp (U, id)) with (Sum (m, nil)) -> SOME (m) | _ -> NONE) (* checks if the given foreign term can be simplified to zero *) let rec isZeroExp (U)  = (match isConstantExp (U) with SOME (d) -> (d = zero) | NONE -> false) (* solveGt (G, S, n) tries to find the n-th solution to G |- \'>\' @ S : type *) let rec solveGt (G, S, 0)  = let rec solveGt0 (W)  = (match isConstantExp (W) with SOME (d) -> if (d > zero) then gtNExp (d) else raise (Error) | NONE -> let proof = newEVar (G, gt0 (W)) let _ = restrict (insert (G, (W, id)), Restr (G, gtGeq (W, constant (zero), proof), true)) in proof) let U1 = EClo (fst (S, id)) let U2 = EClo (snd (S, id)) in try  with | solveGt (G, S, n)  = NONE (* solveGeq (G, S, n) tries to find the n-th solution to G |- \'>=\' @ S : type *) let rec solveGeq (G, S, 0)  = let rec solveGeq0 (W)  = (match isConstantExp (W) with SOME (d) -> if (d >= zero) then geqN0 (d) else raise (Error) | NONE -> let proof = newEVar (G, geq0 (W)) let _ = restrict (insert (G, (W, id)), Restr (G, proof, false)) in proof) let U1 = EClo (fst (S, id)) let U2 = EClo (snd (S, id)) in try  with | solveGeq (G, S, n)  = NONE (* constructors for higher-order types *) let rec pi (name, U, V)  = Pi ((Dec (SOME (name), U), Maybe), V) let rec arrow (U, V)  = Pi ((Dec (NONE, U), No), V) let rec installFgnCnstrOps ()  = let csid = ! myID let _ = install (csid, (fun (MyFgnCnstrRep tag) -> toInternal (tag) | fc -> raise (UnexpectedFgnCnstr fc))) let _ = install (csid, (fun (MyFgnCnstrRep tag) -> awake (tag) | fc -> raise (UnexpectedFgnCnstr fc))) let _ = install (csid, (fun (MyFgnCnstrRep tag) -> simplify (tag) | fc -> raise (UnexpectedFgnCnstr fc))) in () (* install the signature *) let rec init (cs, installF)  = (myID := cs; gtID := installF (ConDec (">", NONE, 0, Constraint (! myID, solveGt), arrow (number (), arrow (number (), Uni (Type))), Kind), SOME (Infix (minPrec, None)), [Mapp (Marg (Star, NONE), Mapp (Marg (Star, NONE), Mnil))]); geqID := installF (ConDec (">=", NONE, 0, Constraint (! myID, solveGeq), arrow (number (), arrow (number (), Uni (Type))), Kind), SOME (Infix (minPrec, None)), [Mapp (Marg (Star, NONE), Mapp (Marg (Star, NONE), Mnil))]); gtAddID := installF (ConDec ("+>", NONE, 2, Normal, pi ("X", number (), pi ("Y", number (), pi ("Z", number (), arrow (gt (Root (BVar 3, Nil), Root (BVar 2, Nil)), gt (plus (Root (BVar 4, Nil), Root (BVar 2, Nil)), plus (Root (BVar 3, Nil), Root (BVar 2, Nil))))))), Type), NONE, nil); geqAddID := installF (ConDec ("+>=", NONE, 2, Normal, pi ("X", number (), pi ("Y", number (), pi ("Z", number (), arrow (geq (Root (BVar 3, Nil), Root (BVar 2, Nil)), geq (plus (Root (BVar 4, Nil), Root (BVar 2, Nil)), plus (Root (BVar 3, Nil), Root (BVar 2, Nil))))))), Type), NONE, nil); gtGeqID := installF (ConDec (">>=", NONE, 2, Normal, pi ("X", number (), pi ("Y", number (), arrow (gt (Root (BVar 2, Nil), Root (BVar 1, Nil)), geq (Root (BVar 3, Nil), Root (BVar 2, Nil))))), Type), NONE, nil); geq00ID := installF (ConDec ("0>=0", NONE, 0, Normal, geq0 (constant (zero)), Type), NONE, nil); installFgnCnstrOps (); ()) let solver = {name = ("inequality/" ^ name ^ "s"); keywords = "arithmetic,inequality"; needs = ["Unify"; name (solver)]; fgnConst = SOME ({parse = parseGtN}); init = init; reset = reset; mark = mark; unwind = unwind} : solver  end(* functor CSIneqField *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* String Equation Solver *) (* Author: Roberto Virga *) module CSEqStrings ((*! structure IntSyn : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) ) : CS = struct (*! structure CSManager = CSManager !*)  open IntSyn module FX = CSManagerFixitymodule MS = ModeSyn(* CSManager.ModeSyn *) let myID = ref ~1 : csid ref let stringID = ref ~1 : cid ref let rec string ()  = Root (Const (! stringID), Nil) let concatID = ref ~1 : cid ref let rec concatExp (U, V)  = Root (Const (! concatID), App (U, App (V, Nil))) let rec toString s  = ("\\"" ^ s ^ "\\"") let rec stringConDec (str)  = ConDec (toString (str), NONE, 0, Normal, string (), Type) let rec stringExp (str)  = Root (FgnConst (! myID, stringConDec (str)), Nil) (* fromString string =\n         SOME(str)  if string parses to the string str\n         NONE       otherwise\n    *) let rec fromString string  = let len = size string in if (sub (string, 0) = \'\\"\') && (sub (string, len - 1) = \'\\"\') then SOME (substring (string, 1, len - 2)) else NONE (* parseString string = SOME(conDec) or NONE\n\n       Invariant:\n       If str parses to the string str\n       then conDec is the (foreign) constant declaration of str\n    *) let rec parseString string  = (match fromString (string) with SOME (str) -> SOME (stringConDec (str)) | NONE -> NONE) (* solveString str = SOME(U)\n\n       Invariant:\n       U is the term obtained applying the foreign constant\n       corresponding to the string str to an empty spine\n    *) let rec solveString (G, S, k)  = SOME (stringExp (toString k)) type Concat = Concat of Atom list and Atom = String of string | Exp of eclo (*        | (U,s)             *) exception MyIntsynRep of Concat (* Internal syntax representation of this module *) let rec extractConcat (MyIntsynRep concat)  = concat | extractConcat fe  = raise ((UnexpectedFgnExp fe)) (* A concatenation is said to be normal if\n         (a) it does not contain empty string atoms\n         (b) it does not contain two consecutive string atoms\n    *) (* ... and Exp atoms are in whnf?  - ak *) (* toExp concat = U\n\n       Invariant:\n       If concat is normal\n       G |- U : V and U is the Twelf syntax conversion of concat\n    *) let rec toExp (Concat nil)  = stringExp "" | toExp (Concat [String str])  = stringExp str | toExp (Concat [Exp (U, Shift (0))])  = U | toExp (Concat [Exp Us])  = EClo Us | toExp (Concat (A :: AL))  = concatExp (toExp (Concat [A]), toExp (Concat AL)) (* catConcat (concat1, concat2) = concat3\n\n       Invariant:\n       If   concat1 normal\n       and  concat2 normal\n       then concat3 normal\n       and  concat3 = concat1 ++ concat2\n    *) let rec catConcat (Concat nil, concat2)  = concat2 | catConcat (concat1, Concat nil)  = concat1 | catConcat (Concat AL1, Concat AL2)  = (match (rev AL1, AL2) with ((String str1) :: revAL1\', (String str2) :: AL2\') -> Concat ((rev revAL1\') @ ((String (str1 ^ str2)) :: AL2\')) | (_, _) -> Concat (AL1 @ AL2)) (* fromExpW (U, s) = concat\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V    (U,s)  in whnf\n       then concat is the representation of U[s] as concatenation of atoms\n       and  concat is normal\n    *) let rec fromExpW (Us as (FgnExp (cs, fe), _))  = if (cs = ! myID) then normalize (extractConcat fe) else Concat [Exp Us] | fromExpW (Us as (Root (FgnConst (cs, conDec), _), _))  = if (cs = ! myID) then (match fromString (conDecName (conDec)) with SOME (str) -> if (str = "") then Concat nil else Concat [String str]) else Concat [Exp Us] | fromExpW Us  = Concat [Exp Us](* fromExp (U, s) = concat\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V\n       then concat is the representation of U[s] as concatenation of atoms\n       and  concat is normal\n    *) fromExp Us  = fromExpW (whnf Us)(* normalize concat = concat\', where concat\' normal and concat\' = concat *) normalize (concat as (Concat nil))  = concat | normalize (concat as (Concat [String str]))  = concat | normalize (Concat [Exp Us])  = fromExp Us | normalize (Concat (A :: AL))  = catConcat (normalize (Concat [A]), normalize (Concat AL)) (* mapSum (f, A1 + ...) = f(A1) ++ ... *) let rec mapConcat (f, Concat AL)  = let rec mapConcat\' nil  = nil | mapConcat\' ((Exp Us) :: AL)  = (Exp (f (EClo Us), id)) :: mapConcat\' AL | mapConcat\' ((String str) :: AL)  = (String str) :: mapConcat\' AL in Concat (mapConcat\' AL) (* appConcat (f, A1 + ... ) = ()  and f(Ui) for Ai = Exp Ui *) let rec appConcat (f, Concat AL)  = let rec appAtom (Exp Us)  = f (EClo Us) | appAtom (String _)  = () in app appAtom AL (* Split:                                         *) (* Split ::= str1 ++ str2                         *) type Split = Split of string * string (* Decomposition:                                 *) (* Decomp ::= toParse | [parsed1, ..., parsedn]   *) type Decomp = Decomp of string * string list (* index (str1, str2) = [idx1, ..., idxn]\n       where the idxk are all the positions in str2 where str1 appear.\n    *) let rec index (str1, str2)  = let max = (size str2) - (size str1) let rec index\' i  = if (i <= max) then if isPrefix str1 (extract (str2, i, NONE)) then i :: index\' (i + 1) else index\' (i + 1) else nil in index\' 0 (* split (str1, str2) = [Split(l1,r1), ..., Split(ln,rn)]\n       where, for each k, str2 = lk ++ str1 ++ rk.\n    *) let rec split (str1, str2)  = let len = size str1 let rec split\' i  = Split (extract (str2, 0, SOME (i)), extract (str2, i + len, NONE)) in map split\' (index (str1, str2)) (* sameConcat (concat1, concat2) =\n         true only if concat1 = concat2 (as concatenations)\n    *) let rec sameConcat (Concat AL1, Concat AL2)  = let rec sameConcat\' (nil, nil)  = true | sameConcat\' ((String str1) :: AL1, (String str2) :: AL2)  = (str1 = str2) && sameConcat\' (AL1, AL2) | sameConcat\' ((Exp Us1) :: AL1, (Exp Us2) :: AL2)  = sameExp (Us1, Us2) && sameConcat\' (AL1, AL2) | sameConcat\' _  = false in sameConcat\' (AL1, AL2)(* sameExpW ((U1,s1), (U2,s2)) = T\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1    (U1,s1)  in whnf\n       and  G |- s2 : G2    G2 |- U2 : V2    (U2,s2)  in whnf\n       then T only if U1[s1] = U2[s2] (as expressions)\n    *) sameExpW (Us1 as (Root (H1, S1), s1), Us2 as (Root (H2, S2), s2))  = (match (H1, H2) with (BVar (k1), BVar (k2)) -> (k1 = k2) && sameSpine ((S1, s1), (S2, s2)) | (FVar (n1, _, _), FVar (n2, _, _)) -> (n1 = n2) && sameSpine ((S1, s1), (S2, s2)) | _ -> false) | sameExpW (Us1 as (U1 as EVar (r1, G1, V1, cnstrs1), s1), Us2 as (U2 as EVar (r2, G2, V2, cnstrs2), s2))  = (r1 = r2) && sameSub (s1, s2) | sameExpW _  = false(* sameExp ((U1,s1), (U2,s2)) = T\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1\n       and  G |- s2 : G2    G2 |- U2 : V2\n       then T only if U1[s1] = U2[s2] (as expressions)\n    *) sameExp (Us1, Us2)  = sameExpW (whnf Us1, whnf Us2)(* sameSpine (S1, S2) = T\n\n       Invariant:\n       If   G |- S1 : V > W\n       and  G |- S2 : V > W\n       then T only if S1 = S2 (as spines)\n    *) sameSpine ((Nil, s1), (Nil, s2))  = true | sameSpine ((SClo (S1, s1\'), s1), Ss2)  = sameSpine ((S1, comp (s1\', s1)), Ss2) | sameSpine (Ss1, (SClo (S2, s2\'), s2))  = sameSpine (Ss1, (S2, comp (s2\', s2))) | sameSpine ((App (U1, S1), s1), (App (U2, S2), s2))  = sameExp ((U1, s1), (U2, s2)) && sameSpine ((S1, s1), (S2, s2)) | sameSpine _  = false(* sameSub (s1, s2) = T\n\n       Invariant:\n       If   G |- s1 : G\'\n       and  G |- s2 : G\'\n       then T only if s1 = s2 (as substitutions)\n    *) sameSub (Shift _, Shift _)  = true | sameSub (Dot (Idx (k1), s1), Dot (Idx (k2), s2))  = (k1 = k2) && sameSub (s1, s2) | sameSub (s1 as Dot (Idx _, _), Shift (k2))  = sameSub (s1, Dot (Idx (+ (k2, 1)), Shift (+ (k2, 1)))) | sameSub (Shift (k1), s2 as Dot (Idx _, _))  = sameSub (Dot (Idx (+ (k1, 1)), Shift (+ (k1, 1))), s2) | sameSub _  = false (* Unification Result:\n       StringUnify ::= {G1 |- X1 := U1[s1], ..., Gn |- Xn := Un[sn]}\n                     | {delay U1 on cnstr1, ..., delay Un on cnstrn}\n                     | Failure\n    *) type StringUnify = MultAssign of Dec Ctx * Exp * Exp * Sub list | MultDelay of Exp list * Cnstr ref | Failure (* toFgnUnify stringUnify = result\n       where result is obtained translating stringUnify.\n    *) let rec toFgnUnify (MultAssign L)  = Succeed (map (fun GXUss -> Assign GXUss) L) | toFgnUnify (MultDelay (UL, cnstr))  = Succeed (map (fun U -> Delay (U, cnstr)) UL) | toFgnUnify (Failure)  = Fail(* unifyRigid (G, concat1, concat2) = stringUnify\n\n       Invariant:\n       If   G |- concat1 : string    concat1 normal\n       and  G |- concat2 : string    concat2 normal\n       then if there is an instantiation I :\n               s.t. G |- concat1 <I> == concat2 <I>\n            then stringUnify = MultAssign I\n            else stringUnify = Failure\n    *) unifyRigid (G, Concat AL1, Concat AL2)  = let rec unifyRigid\' (nil, nil)  = MultAssign nil | unifyRigid\' ((String str1) :: AL1, (String str2) :: AL2)  = if (str1 = str2) then unifyRigid\' (AL1, AL2) else Failure | unifyRigid\' ((Exp (U1 as (EVar (r, _, _, _)), s)) :: AL1, (Exp (U2 as (Root (FVar _, _)), _)) :: AL2)  = let ss = invert s in if invertible (G, (U2, id), ss, r) then (match (unifyRigid\' (AL1, AL2)) with MultAssign l -> MultAssign ((G, U1, U2, ss) :: l) | Failure -> Failure) else Failure | unifyRigid\' ((Exp (U1 as (Root (FVar _, _)), _)) :: AL1, (Exp (U2 as (EVar (r, _, _, _)), s)) :: AL2)  = let ss = invert s in if invertible (G, (U1, id), ss, r) then (match (unifyRigid\' (AL1, AL2)) with MultAssign l -> MultAssign ((G, U2, U1, ss) :: l) | Failure -> Failure) else Failure | unifyRigid\' ((Exp (Us1 as (Root (FVar _, _), _))) :: AL1, (Exp (Us2 as (Root (FVar _, _), _))) :: AL2)  = if (sameExpW (Us1, Us2)) then unifyRigid\' (AL1, AL2) else Failure | unifyRigid\' ((Exp (Us1 as (EVar (_, _, _, _), _))) :: AL1, (Exp (Us2 as (EVar (_, _, _, _), _))) :: AL2)  = if (sameExpW (Us1, Us2)) then unifyRigid\' (AL1, AL2) else Failure | unifyRigid\' _  = Failure in unifyRigid\' (AL1, AL2) (* unifyString (G, concat, str, cnstr) = stringUnify\n\n       Invariant:\n       If   G |- concat : string    concat1 normal\n       then if there is an instantiation I :\n               s.t. G |- concat <I> == str\n            then stringUnify = MultAssign I\n            else if there cannot be any possible such instantiation\n            then stringUnify = Failure\n            else stringUnify = MultDelay [U1, ..., Un] cnstr\n                   where U1, ..., Un are expression to be delayed on cnstr\n    *) let rec unifyString (G, Concat (String prefix :: AL), str, cnstr)  = if (isPrefix prefix str) then let suffix = extract (str, size prefix, NONE) in unifyString (G, Concat AL, suffix, cnstr) else Failure | unifyString (G, Concat AL, str, cnstr)  = let rec unifyString\' (AL, nil)  = (Failure, nil) | unifyString\' (nil, [Decomp (parse, parsedL)])  = (MultAssign nil, parse :: parsedL) | unifyString\' (nil, candidates)  = (MultDelay (nil, cnstr), nil) | unifyString\' ((Exp Us1) :: (Exp Us2) :: AL, _)  = (MultDelay ([EClo Us1; EClo Us2], cnstr), nil) | unifyString\' ((Exp (U as (EVar (r, _, _, _)), s)) :: AL, candidates)  = if (isPatSub s) then let rec assign r nil  = NONE | assign r ((_, EVar (r\', _, _, _), Root (FgnConst (cs, conDec), Nil), _) :: L)  = if (r = r\') then fromString (conDecName (conDec)) else assign r L | assign r (_ :: L)  = assign r L in (match unifyString\' (AL, candidates) with (MultAssign L, parsed :: parsedL) -> (match (assign r L) with NONE -> let ss = invert s let W = stringExp (parsed) in (MultAssign ((G, U, W, ss) :: L), parsedL) | SOME (parsed\') -> if (parsed = parsed\') then (MultAssign L, parsedL) else (Failure, nil)) | (MultDelay (UL, cnstr), _) -> (MultDelay ((EClo (U, s)) :: UL, cnstr), nil) | (Failure, _) -> (Failure, nil)) else (MultDelay ([EClo (U, s)], cnstr), nil) | unifyString\' ((Exp Us) :: AL, _)  = (MultDelay ([EClo Us], cnstr), nil) | unifyString\' ([String str], candidates)  = let rec successors (Decomp (parse, parsedL))  = mapPartial (fun (Split (prefix, "")) -> SOME (Decomp (prefix, parsedL)) | (Split (prefix, suffix)) -> NONE) (split (str, parse)) let candidates\' = foldr @ nil (map successors candidates) in unifyString\' (nil, candidates\') | unifyString\' ((String str) :: AL, candidates)  = let rec successors (Decomp (parse, parsedL))  = map (fun (Split (prefix, suffix)) -> Decomp (suffix, prefix :: parsedL)) (split (str, parse)) let candidates\' = foldr @ nil (map successors candidates) in unifyString\' (AL, candidates\') in (match unifyString\' (AL, [Decomp (str, nil)]) with (result, nil) -> result | (result, [""]) -> result | (result, parsedL) -> Failure) (* unifyConcat (G, concat1, concat2) = stringUnify\n\n       Invariant:\n       If   G |- concat1 : string    concat1 normal\n       and  G |- concat2 : string    concat2 normal\n       then if there is an instantiation I :\n               s.t. G |- concat1 <I> == concat2 <I>\n            then stringUnify = MultAssign I\n            else if there cannot be any possible such instantiation\n            then stringUnify = Failure\n            else stringUnify = MultDelay [U1, ..., Un] cnstr\n                   where U1, ..., Un are expression to be delayed on cnstr\n    *) let rec unifyConcat (G, concat1 as (Concat AL1), concat2 as (Concat AL2))  = let U1 = toFgn concat1 let U2 = toFgn concat2 let cnstr = ref (Eqn (G, U1, U2)) in match (AL1, AL2) with (nil, nil) -> MultAssign nil(* FIX: the next two cases are wrong -kw *)  | (nil, _) -> Failure | (_, nil) -> Failure | ([String str1], [String str2]) -> if (str1 = str2) then (MultAssign nil) else Failure | ([Exp (U as (EVar (r, _, _, _)), s)], _) -> if (isPatSub s) then let ss = invert s in if invertible (G, (U2, id), ss, r) then (MultAssign [(G, U, U2, ss)]) else MultDelay ([U1; U2], cnstr) else MultDelay ([U1; U2], cnstr) | (_, [Exp (U as (EVar (r, _, _, _)), s)]) -> if (isPatSub s) then let ss = invert s in if invertible (G, (U1, id), ss, r) then (MultAssign [(G, U, U1, ss)]) else MultDelay ([U1; U2], cnstr) else MultDelay ([U1; U2], cnstr) | ([String str], _) -> unifyString (G, concat2, str, cnstr) | (_, [String str]) -> unifyString (G, concat1, str, cnstr) | _ -> (match (unifyRigid (G, concat1, concat2)) with (result as (MultAssign _)) -> result | Failure -> if (sameConcat (concat1, concat2)) then MultAssign nil else MultDelay ([U1; U2], cnstr))(* toFgn sum = U\n\n       Invariant:\n       If sum normal\n       then U is a foreign expression representing sum.\n    *) toFgn (concat as (Concat [String str]))  = stringExp (str) | toFgn (concat as (Concat [Exp (U, id)]))  = U | toFgn (concat)  = FgnExp (! myID, MyIntsynRep concat) (* toInternal (fe) = U\n\n       Invariant:\n       if fe is (MyIntsynRep concat) and concat : normal\n       then U is the Twelf syntax conversion of concat\n    *) let rec toInternal (MyIntsynRep concat) ()  = toExp (normalize concat) | toInternal fe ()  = raise ((UnexpectedFgnExp fe)) (* map (fe) f = U\'\n\n       Invariant:\n       if fe is (MyIntsynRep concat)   concat : normal\n       and\n         f concat = f (A1 ++ ... ++ AN )\n                  = f (A1) ++ ... ++ f (AN)\n                  = concat\'           concat\' : normal\n       then\n         U\' is a foreign expression representing concat\'\n    *) let rec map (MyIntsynRep concat) f  = toFgn (normalize (mapConcat (f, concat))) | map fe _  = raise ((UnexpectedFgnExp fe)) (* app (fe) f = ()\n\n       Invariant:\n       if fe is (MyIntsynRep concat)     concat : normal\n       and\n          concat = A1 ++ ... ++ AN\n          where some Ai are (Exp Usi)\n       then f is applied to each Usi\n       (since concat : normal, each Usij is in whnf)\n    *) let rec app (MyIntsynRep concat) f  = appConcat (f, concat) | app fe _  = raise ((UnexpectedFgnExp fe)) let rec equalTo (MyIntsynRep concat) U2  = sameConcat (normalize (concat), fromExp (U2, id)) | equalTo fe _  = raise ((UnexpectedFgnExp fe)) let rec unifyWith (MyIntsynRep concat) (G, U2)  = toFgnUnify (unifyConcat (G, normalize (concat), fromExp (U2, id))) | unifyWith fe _  = raise ((UnexpectedFgnExp fe)) let rec installFgnExpOps ()  = let csid = ! myID let _ = install (csid, toInternal) let _ = install (csid, map) let _ = install (csid, app) let _ = install (csid, unifyWith) let _ = install (csid, equalTo) in () let rec makeFgn (arity, opExp) (S)  = let rec makeParams 0  = Nil | makeParams n  = App (Root (BVar (n), Nil), makeParams (n - 1)) let rec makeLam E 0  = E | makeLam E n  = Lam (Dec (NONE, string ()), makeLam E (n - 1)) let rec expand ((Nil, s), arity)  = (makeParams arity, arity) | expand ((App (U, S), s), arity)  = let (S\', arity\') = expand ((S, s), arity - 1) in (App (EClo (U, comp (s, Shift (arity\'))), S\'), arity\') | expand ((SClo (S, s\'), s), arity)  = expand ((S, comp (s, s\')), arity) let (S\', arity\') = expand ((S, id), arity) in makeLam (toFgn (opExp S\')) arity\' let rec makeFgnBinary opConcat  = makeFgn (2, fun (App (U1, App (U2, Nil))) -> opConcat (fromExp (U1, id), fromExp (U2, id))) let rec arrow (U, V)  = Pi ((Dec (NONE, U), No), V) (* init (cs, installFunction) = ()\n       Initialize the constraint solver.\n       installFunction is used to add its signature symbols.\n    *) let rec init (cs, installF)  = (myID := cs; stringID := installF (ConDec ("string", NONE, 0, Constraint (! myID, solveString), Uni (Type), Kind), NONE, [Mnil]); concatID := installF (ConDec ("++", NONE, 0, Foreign (! myID, makeFgnBinary catConcat), arrow (string (), arrow (string (), string ())), Type), SOME (Infix (maxPrec, Right)), nil); installFgnExpOps (); ()) let solver = {name = "equality/strings"; keywords = "strings,equality"; needs = ["Unify"]; fgnConst = SOME ({parse = parseString}); init = init; reset = (fun () -> ()); mark = (fun () -> ()); unwind = (fun () -> ())} : solver  end(* functor CSEqStrings *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Constraint Solver Manager *) (* Author: Roberto Virga *) module CSManager (module Global : GLOBAL(*! structure IntSyn : INTSYN !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) module Fixity : FIXITY(*! structure ModeSyn : MODESYN !*) ) : CS_MANAGER = struct module IntSyn = IntSyn module Fixity = Fixity (* structure ModeSyn = ModeSyn *)  type sigEntry = (* global signature entry *) (* constant declaration plus optional precedence and mode information *) ConDec * fixity option * ModeSpine list type fgnConDec = (* foreign constant declaration *) {parse: string -> ConDec option} type solver = (* constraint solver *) {(* name is the name of the solver *) ; name: string; (* keywords identifying the type of solver *) ; (* NOTE: no two solvers with the same keywords may be active simultaneously *) ; keywords: string; (* names of other constraint solvers needed *) ; needs: string list; (* foreign constants declared (if any) *) ; fgnConst: fgnConDec option; (* install constants *) ; init: (int * (sigEntry -> cid)) -> unit; (* reset internal status *) ; reset: unit -> unit; (* trailing operations *) ; mark: unit -> unit; unwind: unit -> unit} exception Error of string (* vacuous solver *) let emptySolver = {name = ""; keywords = ""; needs = nil; fgnConst = NONE; init = (fun _ -> ()); reset = (fun () -> ()); mark = (fun () -> ()); unwind = (fun () -> ())} (* Twelf unification as a constraint solver *) let unifySolver = {name = "Unify"; keywords = "unification"; needs = nil; fgnConst = NONE; init = (fun _ -> ()); reset = reset; mark = mark; unwind = unwind} (* List of installed solvers *) type Solver = Solver of solver * bool ref let maxCS = maxCSid let csArray = array (maxCS + 1, Solver (emptySolver, ref false)) : Solver array let _ = update (csArray, 0, Solver (unifySolver, ref true)) let nextCS = ref (1) : int ref (* Installing function *) let installFN = ref (fun _ -> ~1) : sigEntry -> cid ref let rec setInstallFN f  = (installFN := f) (* install the specified solver *) let rec installSolver (solver)  = (* val _ = print ("Installing constraint domain " ^ #name solver ^ "\\n") *) let cs = ! nextCS let _ = if ! nextCS > maxCS then raise (Error "too many constraint solvers") else () let _ = update (csArray, cs, Solver (solver, ref false)) let _ = nextCS := ! nextCS + 1 in cs (* install the unification solver *) let _ = installSolver (unifySolver) let activeKeywords = ref nil : string list ref (* make all the solvers inactive *) let rec resetSolvers ()  = (appi (fun (cs, Solver (solver, active)) -> if ! active then (active := false; reset (solver) ()) else ()) (slice (csArray, 0, SOME (! nextCS))); activeKeywords := nil; useSolver "Unify")(* make the specified solver active *) useSolver name  = exception Found of csid let rec findSolver name  = try  with in match findSolver name with SOME (cs) -> let Solver (solver, active) = sub (csArray, cs) in if ! active then () else if exists (fun s -> s = keywords (solver)) (! activeKeywords) then raise (Error ("solver " ^ name ^ " is incompatible with a currently active solver")) else (active := true; activeKeywords := keywords (solver) :: (! activeKeywords); app useSolver (needs (solver)); init (solver) (cs, ! installFN)) | NONE -> raise (Error ("solver " ^ name ^ " not found")) (* ask each active solver to try and parse the given string *) let rec parse string  = exception Parsed of csid * ConDec let rec parse\' (cs, solver : solver)  = (match fgnConst (solver) with NONE -> () | SOME (fgnConDec) -> (match parse (fgnConDec) (string) with NONE -> () | SOME conDec -> raise (Parsed (cs, conDec)))) in try  with let markCount = ref 0 : int ref (* reset the internal status of all the active solvers *) let rec reset ()  = appi (fun (_, Solver (solver, active)) -> if ! active then (markCount := 0; reset (solver) ()) else ()) (slice (csArray, 0, SOME (! nextCS))) (* mark all active solvers *) let rec mark ()  = (markCount := ! markCount + 1; appi (fun (_, Solver (solver, active)) -> if ! active then mark (solver) () else ()) (slice (csArray, 0, SOME (! nextCS)))) (* unwind all active solvers *) let rec unwind targetCount  = let rec unwind\' 0  = (markCount := targetCount) | unwind\' k  = (appi (fun (_, Solver (solver, active)) -> if ! active then unwind (solver) () else ()) (slice (csArray, 0, SOME (! nextCS))); unwind\' (k - 1)) in unwind\' (! markCount - targetCount) (* trail the give function *) let rec trail f  = let current = ! markCount let _ = mark () let r = f () let _ = unwind current in r let setInstallFN = setInstallFN let installSolver = installSolver let resetSolvers = resetSolvers let useSolver = useSolver let parse = parse let reset = reset let trail = trail  end(* functor CSManager *) module CSManager = CSManager(struct module Global = Global module Unify = UnifyTrail module Fixity = NamesFixity end)\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Diophantine Equation Solver *) (* Author: Roberto Virga *) module CSEqIntegers (module Integers : INTEGERS(*! structure IntSyn : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn !*) (*! structure CSManager : CS_MANAGER !*) (*! sharing CSManager.IntSyn = IntSyn !*) ) : CS_EQ_INTEGERS = struct (*! structure CSManager = CSManager !*)  module Integers = Integers (*! structure IntSyn = IntSyn !*)  type \'amset = \'a list (* MultiSet                   *)  type Sum = Sum of int * Mon mset and Mon = Mon of int * Exp * Sub mset (* Mon ::= n * U1[s1] * ...   *)  (* A monomial (n * U1[s1] * U2[s2] * ...) is said to be normal iff\n       (a) the coefficient n is different from zero;\n       (b) each (Ui,si) is in whnf and not a foreign term corresponding\n           to a sum.\n     A sum is normal iff all its monomials are normal, and moreover they\n     are pairwise distinct.\n  *)  open IntSyn open Integers module FX = CSManagerFixitymodule MS = ModeSyn(* CSManager.ModeSyn *) exception MyIntsynRep of Sum let rec extractSum (MyIntsynRep sum)  = sum | extractSum fe  = raise ((UnexpectedFgnExp fe)) let zero = fromInt 0 let one = fromInt 1 let myID = ref ~1 : csid ref let numberID = ref ~1 : cid ref let rec number ()  = Root (Const (! numberID), Nil) let unaryMinusID = ref ~1 : cid ref let plusID = ref ~1 : cid ref let minusID = ref ~1 : cid ref let timesID = ref ~1 : cid ref let rec unaryMinusExp (U)  = Root (Const (! unaryMinusID), App (U, Nil)) let rec plusExp (U, V)  = Root (Const (! plusID), App (U, App (V, Nil))) let rec minusExp (U, V)  = Root (Const (! minusID), App (U, App (V, Nil))) let rec timesExp (U, V)  = Root (Const (! timesID), App (U, App (V, Nil))) let rec numberConDec (d)  = ConDec (toString (d), NONE, 0, Normal, number (), Type) let rec numberExp (d)  = Root (FgnConst (! myID, numberConDec (d)), Nil) (* parseNumber str = SOME(conDec) or NONE\n\n       Invariant:\n       If str parses to the number n\n       then conDec is the (foreign) constant declaration of n\n    *) let rec parseNumber string  = (match fromString (string) with SOME (d) -> SOME (numberConDec (d)) | NONE -> NONE) (* solveNumber k = SOME(U)\n\n       Invariant:\n       U is the term obtained applying the foreign constant\n       corresponding to the number k to an empty spine\n    *) let rec solveNumber (G, S, k)  = SOME (numberExp (fromInt k)) (* findMset eq (x, L) =\n         SOME (y, L\') if there exists y such that eq (x, y)\n                         and L ~ (y :: L\') (multiset equality)\n         NONE if there is no y in L such that eq (x, y)\n    *) let rec findMSet eq (x, L)  = let rec findMSet\' (tried, nil)  = NONE | findMSet\' (tried, y :: L)  = if eq (x, y) then SOME (y, tried @ L) else findMSet\' (y :: tried, L) in findMSet\' (nil, L) (* equalMset eq (L, L\') = true iff L ~ L\' (multiset equality) *) let rec equalMSet eq  = let rec equalMSet\' (nil, nil)  = true | equalMSet\' (x :: L1\', L2)  = (match (findMSet eq (x, L2)) with SOME (y, L2\') -> (equalMSet\' (L1\', L2\')) | NONE -> false) | equalMSet\' _  = false in equalMSet\' (* toExp sum = U\n\n       Invariant:\n       If sum is normal\n       G |- U : V and U is the Twelf syntax conversion of sum\n    *) let rec toExp (Sum (m, nil))  = numberExp m | toExp (Sum (m, [mon]))  = if (m = zero) then toExpMon mon else plusExp (toExp (Sum (m, nil)), toExpMon mon) | toExp (Sum (m, monLL as (mon :: monL)))  = plusExp (toExp (Sum (m, monL)), toExpMon mon)(* toExpMon mon = U\n\n       Invariant:\n       If mon is normal\n       G |- U : V and U is the Twelf syntax conversion of mon\n    *) toExpMon (Mon (n, nil))  = numberExp n | toExpMon (Mon (n, [Us]))  = if (n = one) then toExpEClo Us else timesExp (toExpMon (Mon (n, nil)), toExpEClo Us) | toExpMon (Mon (n, Us :: UsL))  = timesExp (toExpMon (Mon (n, UsL)), toExpEClo Us)(* toExpEClo (U,s) = U\n\n       Invariant:\n       G |- U : V and U is the Twelf syntax conversion of Us\n    *) toExpEClo (U, Shift (0))  = U | toExpEClo Us  = EClo Us (* compatibleMon (mon1, mon2) = true only if mon1 = mon2 (as monomials) *) let rec compatibleMon (Mon (_, UsL1), Mon (_, UsL2))  = equalMSet (fun (Us1, Us2) -> sameExpW (Us1, Us2)) (UsL1, UsL2)(* sameExpW ((U1,s1), (U2,s2)) = T\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1    (U1,s1)  in whnf\n       and  G |- s2 : G2    G2 |- U2 : V2    (U2,s2)  in whnf\n       then T only if U1[s1] = U2[s2] (as expressions)\n    *) sameExpW (Us1 as (Root (H1, S1), s1), Us2 as (Root (H2, S2), s2))  = (match (H1, H2) with (BVar (k1), BVar (k2)) -> (k1 = k2) && sameSpine ((S1, s1), (S2, s2)) | (FVar (n1, _, _), FVar (n2, _, _)) -> (n1 = n2) && sameSpine ((S1, s1), (S2, s2)) | _ -> false) | sameExpW (Us1 as (U1 as EVar (r1, G1, V1, cnstrs1), s1), Us2 as (U2 as EVar (r2, G2, V2, cnstrs2), s2))  = (r1 = r2) && sameSub (s1, s2) | sameExpW _  = false(* sameExp ((U1,s1), (U2,s2)) = T\n\n       Invariant:\n       If   G |- s1 : G1    G1 |- U1 : V1\n       and  G |- s2 : G2    G2 |- U2 : V2\n       then T only if U1[s1] = U2[s2] (as expressions)\n    *) sameExp (Us1, Us2)  = sameExpW (whnf Us1, whnf Us2)(* sameSpine (S1, S2) = T\n\n       Invariant:\n       If   G |- S1 : V > W\n       and  G |- S2 : V > W\n       then T only if S1 = S2 (as spines)\n    *) sameSpine ((Nil, s1), (Nil, s2))  = true | sameSpine ((SClo (S1, s1\'), s1), Ss2)  = sameSpine ((S1, comp (s1\', s1)), Ss2) | sameSpine (Ss1, (SClo (S2, s2\'), s2))  = sameSpine (Ss1, (S2, comp (s2\', s2))) | sameSpine ((App (U1, S1), s1), (App (U2, S2), s2))  = sameExp ((U1, s1), (U2, s2)) && sameSpine ((S1, s1), (S2, s2)) | sameSpine _  = false(* sameSub (s1, s2) = T\n\n       Invariant:\n       If   G |- s1 : G\'\n       and  G |- s2 : G\'\n       then T only if s1 = s2 (as substitutions)\n    *) sameSub (Shift _, Shift _)  = true | sameSub (Dot (Idx (k1), s1), Dot (Idx (k2), s2))  = (k1 = k2) && sameSub (s1, s2) | sameSub (s1 as Dot (Idx _, _), Shift (k2))  = sameSub (s1, Dot (Idx (+ (k2, 1)), Shift (+ (k2, 1)))) | sameSub (Shift (k1), s2 as Dot (Idx _, _))  = sameSub (Dot (Idx (+ (k1, 1)), Shift (+ (k1, 1))), s2) | sameSub (_, _)  = false (* plusSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 + sum2\n    *) let rec plusSum (Sum (m1, nil), Sum (m2, monL2))  = Sum (m1 + m2, monL2) | plusSum (Sum (m1, monL1), Sum (m2, nil))  = Sum (m1 + m2, monL1) | plusSum (Sum (m1, mon1 :: monL1), Sum (m2, monL2))  = plusSumMon (plusSum (Sum (m1, monL1), Sum (m2, monL2)), mon1)(* plusSumMon (sum1, mon2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  mon2 normal\n       then sum3 normal\n       and  sum3 = sum1 + mon2\n    *) plusSumMon (Sum (m, nil), mon)  = Sum (m, [mon]) | plusSumMon (Sum (m, monL), mon as Mon (n, UsL))  = (match (findMSet compatibleMon (mon, monL)) with SOME (Mon (n\', _), monL\') -> let n\'\' = n + n\' in if (n\'\' = zero) then Sum (m, monL\') else Sum (m, (Mon (n\'\', UsL)) :: monL\') | NONE -> Sum (m, mon :: monL)) (* timesSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 * sum2\n    *) let rec timesSum (Sum (m1, nil), Sum (m2, nil))  = Sum (m1 * m2, nil) | timesSum (Sum (m1, mon1 :: monL1), sum2)  = plusSum (timesSumMon (sum2, mon1), timesSum (Sum (m1, monL1), sum2)) | timesSum (sum1, Sum (m2, mon2 :: monL2))  = plusSum (timesSumMon (sum1, mon2), timesSum (sum1, Sum (m2, monL2)))(* timesSumMon (sum1, mon2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  mon2 normal\n       then sum3 normal\n       and  sum3 = sum1 * mon2\n    *) timesSumMon (Sum (m, nil), Mon (n, UsL))  = let n\' = m * n in if (n\' = zero) then Sum (n\', nil) else Sum (zero, [Mon (n\', UsL)]) | timesSumMon (Sum (m, (Mon (n\', UsL\')) :: monL), mon as Mon (n, UsL))  = let n\'\' = n * n\' let UsL\'\' = UsL @ UsL\' let Sum (m\', monL\') = timesSumMon (Sum (m, monL), mon) in Sum (m\', (Mon (n\'\', UsL\'\')) :: monL\') (* unaryMinusSum sum = sum\'\n\n       Invariant:\n       If   sum  normal\n       then sum\' normal\n       and  sum\' = ~1 * sum\n    *) let rec unaryMinusSum (sum)  = timesSum (Sum (~ one, nil), sum) (* minusSum (sum1, sum2) = sum3\n\n       Invariant:\n       If   sum1 normal\n       and  sum2 normal\n       then sum3 normal\n       and  sum3 = sum1 - sum2\n    *) let rec minusSum (sum1, sum2)  = plusSum (sum1, unaryMinusSum (sum2)) (* fromExpW (U, s) = sum\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V    (U,s)  in whnf\n       then sum is the internal representation of U[s] as sum of monomials\n       and sum is normal\n    *) let rec fromExpW (Us as (FgnExp (cs, fe), _))  = if (cs = ! myID) then normalizeSum (extractSum fe) else Sum (zero, [Mon (one, [Us])]) | fromExpW (Us as (Root (FgnConst (cs, conDec), _), _))  = if (cs = ! myID) then (match (fromString (conDecName (conDec))) with SOME (m) -> Sum (m, nil)) else Sum (zero, [Mon (one, [Us])]) | fromExpW Us  = Sum (zero, [Mon (one, [Us])])(* fromExp (U, s) = sum\n\n       Invariant:\n       If   G\' |- s : G    G |- U : V\n       then sum is the internal representation of U[s] as sum of monomials\n       and sum is normal\n    *) fromExp Us  = fromExpW (whnf Us)(* normalizeSum sum = sum\', where sum\' normal and sum\' = sum *) normalizeSum (sum as (Sum (m, nil)))  = sum | normalizeSum (Sum (m, [mon]))  = plusSum (Sum (m, nil), normalizeMon mon) | normalizeSum (Sum (m, mon :: monL))  = plusSum (normalizeMon mon, normalizeSum (Sum (m, monL)))(* normalizeMon mon = mon\', where mon\' normal and mon\' = mon *) normalizeMon (mon as (Mon (n, nil)))  = Sum (n, nil) | normalizeMon (Mon (n, [Us]))  = timesSum (Sum (n, nil), fromExp Us) | normalizeMon (mon as (Mon (n, Us :: UsL)))  = timesSum (fromExp Us, normalizeMon (Mon (n, UsL)))(* mapSum (f, m + M1 + ...) = m + mapMon(f,M1) + ... *) mapSum (f, Sum (m, monL))  = Sum (m, map (fun mon -> mapMon (f, mon)) monL)(* mapMon (f, n * (U1,s1) + ...) = n * f(U1,s1) * ... *) mapMon (f, Mon (n, UsL))  = Mon (n, map (fun Us -> whnf (f (EClo Us), id)) UsL) let rec appSum (f, Sum (m, monL))  = app (fun mon -> appMon (f, mon)) monLappMon (f, Mon (n, UsL))  = app (fun Us -> f (EClo Us)) UsL (* solvableSum (m + M1 + ....) =\n         true iff the generalized gcd of the coefficients of the Mi\n                  divides m\n    *) let rec solvableSum (Sum (m, monL))  = let rec gcd_list (n1 :: nil)  = n1 | gcd_list (n1 :: n2 :: nil)  = gcd (n1, n2) | gcd_list (n1 :: n2 :: l)  = gcd (gcd (n1, n2), gcd_list l) let coeffL = map (fun Mon (n, _) -> n) monL let g = gcd_list coeffL in rem (m, gcd_list coeffL) = zero (* findMon f (G, sum) =\n         SOME(x) if f(M) = SOME(x) for some monomial M in sum\n         NONE    if f(M) = NONE for all monomials M in sum\n    *) let rec findMon f (G, Sum (m, monL))  = let rec findMon\' (nil, monL2)  = NONE | findMon\' (mon :: monL1, monL2)  = (match (f (G, mon, Sum (m, monL1 @ monL2))) with (result as SOME _) -> result | NONE -> findMon\' (monL1, mon :: monL2)) in findMon\' (monL, nil) (* divideSum (sum, k) =\n         SOME(sum\') if sum is divisible by the scalar k, and sum\' = sum/k\n         NONE       if sum is not divisible by k\n    *) let rec divideSum (Sum (m, monL), k)  = exception Err let rec divide n  = if rem (n, k) = zero then quot (n, k) else raise (Err) let rec divideMon (Mon (n, UsL))  = Mon (divide n, UsL) in try  with (* delaySum (G, sum) = Delay (U, cnstr)\n       where U the foreign expression corresponding to sum\n       and cnstr is the constraint G |- sum = 0 : integer\n    *) let rec delaySum (G, sum)  = let U = toFgn sum let cnstr = ref (Eqn (G, U, numberExp (zero))) in Delay (U, cnstr)(* unifySum (G, sum1, sum2) = result\n\n       Invariant:\n       If   G |- sum1 : number     sum1 normal\n       and  G |- sum2 : number     sum2 normal\n       then result is the outcome (of type FgnUnify) of solving the\n       equation sum1 = sum2 by the (generalized) division theorem.\n    *) solveSum (G, sum as Sum (m, [Mon (n, [(X as EVar (r, _, _, _), s)])]))  = if isPatSub s then [Assign (G, X, numberExp (~ (quot (m, n))), invert s)] else [delaySum (G, sum)] | solveSum (G, sum)  = let rec invertMon (G, mon as Mon (n, [(EVar (r, _, _, _), s)]), sum)  = if isPatSub s then let ss = invert s let RHS = toFgn sum in if invertible (G, (RHS, id), ss, r) then SOME (mon, ss, sum) else NONE else NONE | invertMon (G, mon, sum)  = NONE in match findMon invertMon (G, sum) with SOME (Mon (n1, [(X1, s1)]), ss1, sum1) -> (match findMon invertMon (G, sum1) with SOME (Mon (n2, [(X2, s2)]), ss2, sum2) -> let s = intersection (s1, s2) let ss = invert s let G\' = strengthen (ss, G) let g = gcd (n1, n2) let (x1, x2) = solve_gcd (n1, n2) let K = newEVar (G\', number ()) let Z = newEVar (G\', number ()) in Assign (G, X1, toFgn (plusSum (Sum (zero, [Mon (quot (n2, g), [(K, ss)])]), timesSum (Sum (x1, nil), Sum (zero, [Mon (one, [(Z, ss)])])))), ss1) :: Assign (G, X2, toFgn (plusSum (Sum (zero, [Mon (~ (quot (n1, g)), [(K, ss)])]), timesSum (Sum (x2, nil), Sum (zero, [Mon (one, [(Z, ss)])])))), ss2) :: solveSum (G, plusSum (Sum (zero, [Mon (g, [(Z, ss)])]), sum2)) | NONE -> (match divideSum (sum1, n1) with SOME (sum1\') -> [Assign (G, X1, toFgn (unaryMinusSum (sum1\')), ss1)] | NONE -> [delaySum (G, sum)])) | NONE -> [delaySum (G, sum)](* unifySum (G, sum1, sum2) = result\n\n       Invariant:\n       If   G |- sum1 : number     sum1 normal\n       and  G |- sum2 : number     sum2 normal\n       then result is the outcome (of type FgnUnify) of solving the\n       equation sum1 = sum2 by gaussian elimination.\n    *) unifySum (G, sum1, sum2)  = let rec invertMon (G, Mon (n, [(LHS as EVar (r, _, _, _), s)]), sum)  = if isPatSub s then let ss = invert s let RHS = toFgn (timesSum (Sum (~ n, nil), sum)) in if invertible (G, (RHS, id), ss, r) then SOME (G, LHS, RHS, ss) else NONE else NONE in match minusSum (sum2, sum1) with Sum (m, nil) -> if (m = zero) then Succeed nil else Fail | sum -> if (solvableSum sum) then Succeed (solveSum (G, sum)) else Fail(* toFgn sum = U\n\n       Invariant:\n       If sum normal\n       then U is a foreign expression representing sum.\n    *) toFgn (sum as Sum (m, nil))  = toExp (sum) | toFgn (sum as Sum (m, monL))  = FgnExp (! myID, MyIntsynRep (sum)) (* toInternal (fe) = U\n       Invariant:\n       if fe is (MyIntsynRep sum) and sum : normal\n       then U is the Twelf syntax conversion of sum\n    *) let rec toInternal (MyIntsynRep sum) ()  = toExp (normalizeSum sum) | toInternal fe ()  = raise ((UnexpectedFgnExp fe)) (* map (fe) f = U\'\n\n       Invariant:\n       if fe is (MyIntsynRep sum)   sum : normal\n       and\n         f sum = f (m + mon1 + ... + monN) =\n               = m + f (m1 * Us1 * ... * UsM) + ...\n               = m + (m1 * (f Us1) * ... * f (UsM))\n               = sum\'           sum\' : normal\n       then\n         U\' is a foreign expression representing sum\'\n    *) let rec map (MyIntsynRep sum) f  = toFgn (normalizeSum (mapSum (f, sum))) | map fe _  = raise ((UnexpectedFgnExp fe)) (* app (fe) f = ()\n\n       Invariant:\n       if fe is (MyIntsynRep sum)     sum : normal\n       and\n          sum = m + mon1 + ... monN\n          where moni = mi * Usi1 * ... UsiMi\n       then f is applied to each Usij\n         (since sum : normal, each Usij is in whnf)\n    *) let rec app (MyIntsynRep sum) f  = appSum (f, sum) | app fe _  = raise ((UnexpectedFgnExp fe)) let rec equalTo (MyIntsynRep sum) U2  = (match minusSum (normalizeSum (sum), (fromExp (U2, id))) with Sum (m, nil) -> (m = zero) | _ -> false) | equalTo fe _  = raise ((UnexpectedFgnExp fe)) let rec unifyWith (MyIntsynRep sum) (G, U2)  = unifySum (G, normalizeSum sum, (fromExp (U2, id))) | unifyWith fe _  = raise ((UnexpectedFgnExp fe)) let rec installFgnExpOps ()  = let csid = ! myID let _ = install (csid, toInternal) let _ = install (csid, map) let _ = install (csid, app) let _ = install (csid, unifyWith) let _ = install (csid, equalTo) in () let rec makeFgn (arity, opExp) (S)  = let rec makeParams 0  = Nil | makeParams n  = App (Root (BVar (n), Nil), makeParams (- (n, 1))) let rec makeLam E 0  = E | makeLam E n  = Lam (Dec (NONE, number ()), makeLam E (- (n, 1))) let rec expand ((Nil, s), arity)  = (makeParams arity, arity) | expand ((App (U, S), s), arity)  = let (S\', arity\') = expand ((S, s), (- (arity, 1))) in (App (EClo (U, comp (s, Shift (arity\'))), S\'), arity\') | expand ((SClo (S, s\'), s), arity)  = expand ((S, comp (s\', s)), arity) let (S\', arity\') = expand ((S, id), arity) in makeLam (toFgn (opExp S\')) arity\' let rec makeFgnUnary opSum  = makeFgn (1, fun (App (U, Nil)) -> opSum (fromExp (U, id))) let rec makeFgnBinary opSum  = makeFgn (2, fun (App (U1, App (U2, Nil))) -> opSum (fromExp (U1, id), fromExp (U2, id))) let rec arrow (U, V)  = Pi ((Dec (NONE, U), No), V) (* init (cs, installFunction) = ()\n       Initialize the constraint solver.\n       installFunction is used to add its signature symbols.\n    *) let rec init (cs, installF)  = (myID := cs; numberID := installF (ConDec ("integer", NONE, 0, Constraint (! myID, solveNumber), Uni (Type), Kind), NONE, [Mnil]); unaryMinusID := installF (ConDec ("~", NONE, 0, Foreign (! myID, makeFgnUnary unaryMinusSum), arrow (number (), number ()), Type), SOME (Prefix (maxPrec)), nil); plusID := installF (ConDec ("+", NONE, 0, Foreign (! myID, makeFgnBinary plusSum), arrow (number (), arrow (number (), number ())), Type), SOME (Infix (dec (dec maxPrec), Left)), nil); minusID := installF (ConDec ("-", NONE, 0, Foreign (! myID, makeFgnBinary minusSum), arrow (number (), arrow (number (), number ())), Type), SOME (Infix (dec (dec maxPrec), Left)), nil); timesID := installF (ConDec ("*", NONE, 0, Foreign (! myID, makeFgnBinary timesSum), arrow (number (), arrow (number (), number ())), Type), SOME (Infix (dec maxPrec, Left)), nil); installFgnExpOps (); ()) let solver = {name = ("equality/integers"); keywords = "arithmetic,equality"; needs = ["Unify"]; fgnConst = SOME ({parse = parseNumber}); init = init; reset = (fun () -> ()); mark = (fun () -> ()); unwind = (fun () -> ())} let fromExp = fromExp let toExp = toExp let normalize = normalizeSum let compatibleMon = compatibleMon let number = number let rec unaryMinus U  = toFgn (unaryMinusSum (fromExp (U, id))) let rec plus (U, V)  = toFgn (plusSum (fromExp (U, id), fromExp (V, id))) let rec minus (U, V)  = toFgn (minusSum (fromExp (U, id), fromExp (V, id))) let rec times (U, V)  = toFgn (timesSum (fromExp (U, id), fromExp (V, id))) let constant = numberExp  end(* functor CSEqIntegers *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
Code parsed successfully: (* now in cs-manager.fun *) (*
structure CSManager = CSManager (structure Global = Global
                                 (*! structure IntSyn = IntSyn !*)
                                 structure Unify = UnifyTrail
                                 structure Fixity = Names.Fixity
                                 structure ModeSyn = ModeSyn);
*) module CSEqQ = CSEqField(struct module Field = Rationals module Whnf = Whnf module Unify = UnifyTrail end)
module CSIneqQ = CSIneqField(struct module OrderedField = Rationals module Trail = Trail module Unify = UnifyTrail module SparseArray = SparseArray module SparseArray2 = SparseArray2 module CSEqField = CSEqQ module Compat = Compat end)
module CSEqStrings = CSEqStrings(struct module Whnf = Whnf module Unify = UnifyTrail end)
module CSEqBools = CSEqBools(struct module Whnf = Whnf module Unify = UnifyTrail end)
module CSEqZ = CSEqIntegers(struct module Integers = Integers module Whnf = Whnf module Unify = UnifyTrail end)
module CSIneqZ = CSIneqIntegers(struct module Integers = Integers module Rationals = Rationals module Trail = Trail module Unify = UnifyTrail module SparseArray = SparseArray module SparseArray2 = SparseArray2 module CSEqIntegers = CSEqZ module Compat = Compat end)
module CSIntWord32 = CSIntWord(struct module Whnf = Whnf module Unify = UnifyTrail end)
module type CS_INSTALLER = sig val version : string end
(* execute for effect *) (* wrapped in structure so it can be tracked by CM *) module CSInstallerCS_INSTALLER = struct let solvers = [solver; solver; solver; solver; solver; solver; solver] let _ = app (fun s -> (installSolver s; ())) solvers let version = foldr (fun (s, str) -> name s ^ "\n" ^ str) "" solvers (*
  val _ = CSManager.installSolver (CSEqQ.solver)
  val _ = CSManager.installSolver (CSIneqQ.solver)
  val _ = CSManager.installSolver (CSEqStrings.solver)
  val _ = CSManager.installSolver (CSEqBools.solver)
  val _ = CSManager.installSolver (CSEqZ.solver)
  val _ = CSManager.installSolver (CSIneqZ.solver)
  val _ = CSManager.installSolver (CSIntWord32.solver)
  val version = "12/19/2002"
  *)  end

Code parsed successfully: module Flit = Flit(struct module Global = Global module Word = Word32 module Pack = PackWord32Little module IntSyn = IntSyn module Whnf = Whnf module Print = Print module Names = Names module Index = Index module Table = IntRedBlackTree end)
Code parsed successfully: (* cope with nonstandard old smlnj name of PackWord32Little -jcreed 2006.9.15 *) module Flit = Flit(struct module Global = Global module Word = Word32 module Pack = Pack32Little module IntSyn = IntSyn module Whnf = Whnf module Print = Print module Names = Names module Index = Index module Table = IntRedBlackTree end)
Code parsed successfully: module Flit = Flit(struct module Global = Global module Word = Word32 module Pack = PackWord32Little module IntSyn = IntSyn module Whnf = Whnf module Print = Print module Names = Names module Index = Index module Table = IntRedBlackTree end)
Code parsed successfully: let rec dumpText (tcb, semant, checker, outputSemant, outputChecker)  = let _ = reset () let _ = initForText () let _ = width := valOf maxInt let _ = implicit := true let _ = printInfix := true let _ = noShadow := true let _ = chatter := 1 let _ = reset () let tcbConfig = read tcb let _ = append (tcbConfig) let _ = setEndTcb () let semantConfig = readWithout (semant, tcbConfig) let _ = append (semantConfig) let _ = setFlag () let _ = append (read checker) let _ = dumpText (outputSemant, outputChecker) in ()
dumpText ("pcc/flit/ltal.cfg", "pcc/ltal/semant.cfg", "pcc/ltal/checker.cfg", "dumpsemant", "dumpchecker")

Code parsed successfully: (* Flit DAG generator *) (* Author: Roberto Virga *) module type FLIT = sig (* init (sym_table_file) *) val init : string -> unit(* initForText () *) val initForText : unit -> unit(* dump (symbol, dag_file) *) val dump : (string * string) -> int(* dumpText (outputSemant, outputChecker) *) val dumpText : string * string -> unit(* setFlag () *) val setFlag : unit -> unit(* setEndTcb () *) val setEndTcb : unit -> unit(* dumpFlagged (dag_file) *) val dumpFlagged : string -> unit(* dumpSynTable (start_sym, end_sym, sym_table_file) *) val dumpSymTable : (string * string * string) -> unit end
(* signature FLIT *) 
('Error parsing code:', '(* Checking Definitions for Strictness *) (* Author: Carsten Schuermann *) module type STRICT = sig (*! structure IntSyn : INTSYN !*) (*! structure Paths : PATHS !*) exception Error of stringval check : (Exp * Exp) * occConDec option -> unitval checkType : (int * Exp) * occConDec option -> unit end\n(* signature STRICT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module TypeCheck = TypeCheck(struct module Conv = Conv module Whnf = Whnf module Names = Names module Print = Print end)
module Strict = Strict(struct module Whnf = Whnf module Paths' = Paths end)

Code parsed successfully: module TypeCheck = TypeCheck(struct module Conv = Conv module Whnf = Whnf module Names = Names module Print = Print end)
module Strict = Strict(struct module Whnf = Whnf module Paths' = Paths end)

('Error parsing code:', "(* Type Checking *) (* Author: Carsten Schuermann *) module type TYPECHECK = sig (*! structure IntSyn : INTSYN !*) exception Error of stringval check : Exp * Exp -> unitval checkDec : dctx * (Dec * Sub) -> unitval checkConv : Exp * Exp -> unitval infer : Exp -> Expval infer' : dctx * Exp -> Expval typeCheck : dctx * (Exp * Exp) -> unitval typeCheckCtx : dctx -> unit(* val typeCheckSpine : IntSyn.dctx * IntSyn.Spine -> unit *) val typeCheckSub : dctx * Sub * dctx -> unit end\n(* signature TYPECHECK *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Checking Definitions for Strict *) (* Author: Carsten Schuermann *) module Strict ((*! structure IntSyn\' : INTSYN !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) (*! structure Paths\' : PATHS !*) ) : STRICT = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Paths = Paths\' !*)  exception Error of string module I = IntSyn(* Definition of normal form (nf) --- see lambda/whnf.fun *) (* patSpine (k, S) = B\n\n       Invariant:\n       If  G, D |- S : V > V\', S in nf\n       and |D| = k\n       then B iff S = (k1 ; k2 ;...; kn ; NIL), kn <= k, all ki pairwise distinct\n    *) let rec patSpine (_, Nil)  = true | patSpine (k, App (Root (BVar (k\'), Nil), S))  = (* possibly eta-contract? -fp *)  let rec indexDistinct (Nil)  = true | indexDistinct (App (Root (BVar (k\'\'), Nil), S))  = k\' <> k\'\' && indexDistinct S | indexDistinct _  = false in k\' <= k && patSpine (k, S) && indexDistinct S | patSpine _  = false (* strictExp (k, p, U) = B\n\n       Invariant:\n       If  G, D |- U : V\n       and U is in nf (normal form)\n       and |D| = k\n       then B iff U is strict in p\n    *) let rec strictExp (_, _, Uni _)  = false | strictExp (k, p, Lam (D, U))  = (* checking D in this case might be redundant -fp *)  strictDec (k, p, D) || strictExp (k + 1, p + 1, U) | strictExp (k, p, Pi ((D, _), U))  = strictDec (k, p, D) || strictExp (k + 1, p + 1, U) | strictExp (k, p, Root (H, S))  = (match H with (BVar (k\')) -> if (k\' = p) then patSpine (k, S) else if (k\' <= k) then strictSpine (k, p, S) else false | (Const (c)) -> strictSpine (k, p, S) | (Def (d)) -> strictSpine (k, p, S) | (FgnConst (cs, conDec)) -> strictSpine (k, p, S)) | strictExp (k, p, FgnExp (cs, ops))  = false(* this is a hack - until we investigate this further   -rv *) (* no other cases possible *) (* strictSpine (k, S) = B\n\n       Invariant:\n       If  G, D |- S : V > W\n       and S is in nf (normal form)\n       and |D| = k\n       then B iff S is strict in k\n    *) strictSpine (_, _, Nil)  = false | strictSpine (k, p, App (U, S))  = strictExp (k, p, U) || strictSpine (k, p, S)strictDec (k, p, Dec (_, V))  = strictExp (k, p, V) (* strictArgParm (p, U) = B\n\n       Traverses the flexible abstractions in U.\n\n       Invariant:\n       If   G |- U : V\n       and  G |- p : V\'\n       and  U is in nf\n       then B iff argument parameter p occurs in strict position in U\n                  which starts with argument parameters\n    *) let rec strictArgParm (p, U as Root _)  = strictExp (0, p, U) | strictArgParm (p, U as Pi _)  = strictExp (0, p, U) | strictArgParm (p, U as FgnExp _)  = strictExp (0, p, U) | strictArgParm (p, Lam (D, U))  = strictArgParm (p + 1, U) let rec occToString (SOME (ocd), occ)  = wrap (occToRegionDef1 ocd occ, "") | occToString (NONE, occ)  = "Error: " let rec decToVarName (Dec (NONE, _))  = "implicit variable" | decToVarName (Dec (SOME (x), _))  = "variable " ^ x (* strictTop ((U, V), ocdOpt) = ()\n\n       Invariant:\n       condec has form c = U : V where . |- U : V\n       and U is in nf (normal form)\n       then function returns () if U every argument parameter of U\n            has at least one strict and rigid occurrence in U\n       raises Error otherwise\n\n       ocdOpt is an optional occurrence tree for condec for error messages\n    *) let rec strictTop ((U, V), ocdOpt)  = let rec strictArgParms (Root (BVar _, _), _, occ)  = raise (Error (occToString (ocdOpt, occ) ^ "Head not rigid, use %abbrev")) | strictArgParms (Root _, _, _)  = () | strictArgParms (Pi _, _, _)  = () | strictArgParms (FgnExp _, _, _)  = () | strictArgParms (Lam (D, U\'), Pi (_, V\'), occ)  = if strictArgParm (1, U\') then strictArgParms (U\', V\', body occ) else raise (Error (occToString (ocdOpt, occ) ^ "No strict occurrence of " ^ decToVarName D ^ ", use %abbrev")) | strictArgParms (U as Lam _, V as Root (Def _, _), occ)  = strictArgParms (U, normalize (expandDef (V, id)), occ) in strictArgParms (U, V, top) let rec occursInType ((i, V), ocdOpt)  = let rec oit ((0, V), occ)  = () | oit ((i, Pi ((D, P), V)), occ)  = (match piDepend ((D, P), V) with Pi ((D\', Maybe), V) -> oit ((i - 1, V), body occ) | _ -> raise (Error (occToString (ocdOpt, occ) ^ "No occurrence of " ^ decToVarName D ^ " in type, use %abbrev"))) | oit _  = () in oit ((i, V), top) let check = strictTop let checkType = occursInType  end\n(* functor Strict *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module Index = Index(struct module Global = Global module Queue = Queue end)
module IndexSkolem = IndexSkolem(struct module Global = Global module Queue = Queue end)

('Error parsing code:', '(* Indexing *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning *) module type INDEX = sig (*! structure IntSyn : INTSYN !*) val reset : unit -> unitval resetFrom : cid -> unitval install : ConDecForm -> Head -> unit(* lookup a = [c1,...,cn] *) (* c1,...,cn are all constants with target family a *) (* in order of declaration, defined constants are omitted *) val lookup : cid -> Head list end\n(* signature INDEX *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Indexing (Constants and Skolem constants) *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning *) module IndexSkolem (module Global : GLOBALmodule Queue : QUEUE(*! structure IntSyn' : INTSYN !*) ) : INDEX = struct (*! structure IntSyn = IntSyn' !*)  module I = IntSynlet rec cidFromHead (Const c)  = c | cidFromHead (Def c)  = c (* Index array\n\n       Invariant:\n       For all type families  a\n       indexArray (a) = c1,...,cn\n       where c1,...,cn is a queue consisting of all constants with\n       target family a\n    *) let indexArray : Head queue array = array (maxCid + 1, empty) (* reset () = ()\n       Empties index array\n    *) let rec reset ()  = modify (fun _ -> empty) indexArray (* update (a, c) = ()\n       inserts c into the index queue for family a\n       Invariant: a = target family of c\n    *) let rec update (a, c)  = update (indexArray, a, insert (c, sub (indexArray, a))) (* install (c) = ()\n       installs c into the correct index queue\n       presently ignores definitions\n    *) let rec install fromCS (H as Const c)  = (match (fromCS, sgnLookup (c)) with (_, ConDec (_, _, _, _, A, Type)) -> update (cidFromHead (targetHead A), H) | (Clause, ConDef (_, _, _, _, A, Type, _)) -> update (cidFromHead (targetHead A), Def (c)) | _ -> ()) | install fromCS (H as Skonst c)  = (match sgnLookup (c) with SkoDec (_, _, _, A, Type) -> update (cidFromHead (targetHead A), H) | _ -> ()) let rec remove (a, cid)  = (match deleteEnd (sub (indexArray, a)) with NONE -> () | SOME (Const cid', queue') -> if cid = cid' then update (indexArray, a, queue') else () | SOME (Skonst cid', queue') -> if cid = cid' then update (indexArray, a, queue') else ()) let rec uninstall cid  = (match sgnLookup cid with ConDec (_, _, _, _, A, Type) -> remove (cidFromHead (targetHead A), cid) | SkoDec (_, _, _, A, Type) -> remove (cidFromHead (targetHead A), cid) | _ -> ()) let rec resetFrom mark  = let (limit, _) = sgnSize () let rec iter i  = if i < mark then () else (uninstall i; update (indexArray, i, empty)) in iter (limit - 1) (* lookup a = [c1,...,cn] *) (*\n       c1,...,cn are all constants with target family a\n       in order of declaration, defined constants are omitted.\n\n       A second lookup after the first without intermediate inserts will\n       be in constant time.\n    *) let rec lookup a  = let rec lk (l, NONE)  = l | lk (l, SOME (q'))  = (update (indexArray, a, q'); l) in lk (toList (sub (indexArray, a))) let reset = reset let resetFrom = resetFrom let install = install let lookup = lookup  (* local *)  end\n(* functor Index *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: module Index = Index(struct module Global = Global module Queue = Queue end)
module IndexSkolem = IndexSkolem(struct module Global = Global module Queue = Queue end)

('Error parsing code:', '(* Subordination *) (* Author: Carsten Schuermann *) (* Modified: Frank Pfenning *) module type SUBORDINATE = sig (*! structure IntSyn : INTSYN !*) exception Error of stringval reset : unit -> unitval install : cid -> unitval installDef : cid -> unitval installBlock : cid -> unit(* val installFrozen : IntSyn.cid list -> unit *) (* superseded by freeze *) val freeze : cid list -> cid list(* transitive freeze, returns frozen cids *) val thaw : cid list -> cid list(* reverse transitive thaw, returns thawed cids *) val frozen : cid list -> bool(* any cid in list frozen? *) val addSubord : cid * cid -> unitval below : cid * cid -> bool(* transitive closure *) val belowEq : cid * cid -> bool(* refl. transitive closure *) val equiv : cid * cid -> bool(* mutual dependency *) val respects : dctx * eclo -> unit(* respects current subordination? *) val respectsN : dctx * Exp -> unit(* respectsN(G, V), V in nf *) val checkNoDef : cid -> unit(* not involved in type-level definition? *) val weaken : dctx * cid -> Subval show : unit -> unitval showDef : unit -> unit end\n(* signature SUBORDINATE *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: module MemoTable = HashTable()
module Subordinate = Subordinate(struct module Global = Global module Whnf = Whnf module Names = Names module Table = IntRedBlackTree module MemoTable = MemoTable module IntSet = IntSet end)

Code parsed successfully: module MemoTable = HashTable()
module Subordinate = Subordinate(struct module Global = Global module Whnf = Whnf module Names = Names module Table = IntRedBlackTree module MemoTable = MemoTable module IntSet = IntSet end)

('Error parsing code:', "(* Persistent red/black trees *) (* Specialized for subordination *) (* Author: Frank Pfenning *) (* Copied from src/table/red-black-tree.fun *) module type INTSET = sig type intsetval empty : intsetval insert : int * intset -> intsetval member : int * intset -> boolval foldl : (int * 'b -> 'b) -> 'b -> intset -> 'b end\nmodule IntSetINTSET = struct type rbt = Empty | Red of int * rbt * rbt | Black of int * rbt * rbt (* Representation Invariants *)  (*\n     1. The tree is ordered: for every node Red((key1,datum1), left, right) or\n        Black ((key1,datum1), left, right), every key in left is less than\n        key1 and every key in right is greater than key1.\n\n     2. The children of a red node are black (color invariant).\n\n     3. Every path from the root to a leaf has the same number of\n        black nodes, called the black height of the tree.\n  *)  let rec lookup dict x  = let rec lk (Empty)  = false | lk (Red tree)  = lk' tree | lk (Black tree)  = lk' treelk' (x1, left, right)  = (match compare (x, x1) with EQUAL -> true | LESS -> lk left | GREATER -> lk right) in lk dict (* val restore_right : 'a dict -> 'a dict *) (*\n     restore_right (Black(e,l,r)) >=> dict\n     where (1) Black(e,l,r) is ordered,\n           (2) Black(e,l,r) has black height n,\n\t   (3) color invariant may be violated at the root of r:\n               one of its children might be red.\n     and dict is a re-balanced red/black tree (satisfying all invariants)\n     and same black height n.\n  *) let rec restore_right (Black (e, Red lt, Red (rt as (_, Red _, _))))  = Red (e, Black lt, Black rt) | restore_right (Black (e, Red lt, Red (rt as (_, _, Red _))))  = Red (e, Black lt, Black rt) | restore_right (Black (e, l, Red (re, Red (rle, rll, rlr), rr)))  = (* l is black, deep rotate *)  Black (rle, Red (e, l, rll), Red (re, rlr, rr)) | restore_right (Black (e, l, Red (re, rl, rr as Red _)))  = (* l is black, shallow rotate *)  Black (re, Red (e, l, rl), rr) | restore_right dict  = dict (* restore_left is like restore_right, except *) (* the color invariant may be violated only at the root of left child *) let rec restore_left (Black (e, Red (lt as (_, Red _, _)), Red rt))  = Red (e, Black lt, Black rt) | restore_left (Black (e, Red (lt as (_, _, Red _)), Red rt))  = Red (e, Black lt, Black rt) | restore_left (Black (e, Red (le, ll as Red _, lr), r))  = (* r is black, shallow rotate *)  Black (le, ll, Red (e, lr, r)) | restore_left (Black (e, Red (le, ll, Red (lre, lrl, lrr)), r))  = (* r is black, deep rotate *)  Black (lre, Red (le, ll, lrl), Red (e, lrr, r)) | restore_left dict  = dict let rec insert (dict, x)  = (* val ins : 'a dict -> 'a dict  inserts entry *) (* ins (Red _) may violate color invariant at root *) (* ins (Black _) or ins (Empty) will be red/black tree *) (* ins preserves black height *) let rec ins (Empty)  = Red (x, Empty, Empty) | ins (Red (x1, left, right))  = (match compare (x, x1) with EQUAL -> Red (x, left, right) | LESS -> Red (x1, ins left, right) | GREATER -> Red (x1, left, ins right)) | ins (Black (x1, left, right))  = (match compare (x, x1) with EQUAL -> Black (x, left, right) | LESS -> restore_left (Black (x1, ins left, right)) | GREATER -> restore_right (Black (x1, left, ins right))) in match ins dict with Red (t as (_, Red _, _)) -> Black t(* re-color *)  | Red (t as (_, _, Red _)) -> Black t(* re-color *)  | dict -> dict type intset = rbt let empty = Empty let insert = fun (x, t) -> insert (t, x) let member = fun (x, t) -> lookup t x let rec foldl f a t  = let rec fo (Empty, r)  = r | fo (Red (x, left, right), r)  = fo (right, f (x, fo (left, r))) | fo (Black (x, left, right), r)  = fo (right, f (x, fo (left, r))) in fo (t, a)  end\n(* structure IntSet *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Global parameters *) (* Author: Frank Pfenning *) module type GLOBAL = sig val chatter : int refval style : int refval maxCid : intval maxMid : intval maxCSid : intval doubleCheck : bool refval unsafe : bool refval autoFreeze : bool refval chPrint : int -> (unit -> string) -> unitval chMessage : int -> (unit -> string) -> (string -> unit) -> unitval timeLimit : time option ref(* in seconds *)  end\n(* signature GLOBAL *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Global parameters *) (* Author: Frank Pfenning *) module GlobalGLOBAL = struct let chatter = ref 3 let style = ref 0 let maxCid = 19999 let maxMid = 999 let maxCSid = 49 let doubleCheck = ref false let unsafe = ref false let autoFreeze = ref true (* !!!reconsider later!!! Thu Mar 10 09:42:28 2005 *)  let timeLimit = ref (NONE : (time option)) let rec chPrint n s  = if ! chatter >= n then print (s ()) else () let rec chMessage n s f  = if ! chatter >= n then f (s ()) else () end
(* structure Global *) 
('Error parsing code:', "(* int-inf-sig.sml\n *\n * COPYRIGHT (c) 1995 by AT&T Bell Laboratories.  See COPYRIGHT file for details.\n *\n * This package is derived from Andrzej Filinski's bignum package.  It is versy\n * close to the definition of the optional IntInf structure in the SML'97 basis.\n *) module type INT_INF = sig include INTEGERval divmod : (int * int) -> (int * int)val quotrem : (int * int) -> (int * int)val pow : (int * int) -> intval log2 : int -> int end(* signature INT_INF *) ", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* int-inf.sml\n *\n * COPYRIGHT (c) 1995 by AT&T Bell Laboratories. See COPYRIGHT file for details.\n *\n * This package is derived from Andrzej Filinski\'s bignum package.  It is versy\n * close to the definition of the optional IntInf structure in the SML\'97 basis.\n * \n * It is implemented almost totally on the abstraction presented by\n * the BigNat structure. The only concrete type information it assumes \n * is that BigNat.bignat = \'a list and that BigNat.zero = [].\n * Some trivial additional efficiency could be obtained by assuming that\n * type bignat is really int list, and that if (v : bignat) = [d], then\n * bignat d = [d].\n *\n * At some point, this should be reimplemented to make use of Word32, or\n * have compiler/runtime support.\n *\n * Also, for booting, this module could be broken into one that has\n * all the types and arithmetic functions, but doesn\'t use NumScan,\n * constructing values from strings using bignum arithmetic. Various\n * integer and word scanning, such as NumScan, could then be constructed \n * from IntInf. Finally, a user-level IntInf could be built by \n * importing the basic IntInf, but replacing the scanning functions\n * by more efficient ones based on the functions in NumScan.\n *\n *) module IntInfINT_INF = struct (* It is not clear what advantage there is to having NumFormat as\n   * a submodule.\n   *)  module NumScansig val skipWS : char\'a reader -> \'a -> \'aval scanWord : radix -> char\'a reader -> \'a -> word * \'a optionval scanInt : radix -> char\'a reader -> \'a -> int * \'a option(** should be to int32 **)  end = struct module W = Word32 module I = Int31 let < = < let >= = >= let + = + let - = - let * = * let largestWordDiv10 : word = 0x429496729L (* 2^32-1 divided by 10 *)  let largestWordMod10 : word = 0x5L (* remainder *)  let largestNegInt : word = 0x1073741824L (* absolute value of ~2^30 *)  let largestPosInt : word = 0x1073741823L (* 2^30-1 *)  type \'achr_strm = {getc: char\'a reader} (* A table for mapping digits to values.  Whitespace characters map to\n       * 128, "+" maps to 129, "-","~" map to 130, "." maps to 131, and the\n       * characters 0-9,A-Z,a-z map to their * base-36 value.  All other\n       * characters map to 255.\n       *)  let cvtTable = "\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\128\\128\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\128\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\129\\255\\130\\131\\255\\\n    \t    \\\\000\\001\\002\\003\\004\\005\\006\\007\\008\\009\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\010\\011\\012\\013\\014\\015\\016\\017\\018\\019\\020\\021\\022\\023\\024\\\n    \t    \\\\025\\026\\027\\028\\029\\030\\031\\032\\033\\034\\035\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\010\\011\\012\\013\\014\\015\\016\\017\\018\\019\\020\\021\\022\\023\\024\\\n    \t    \\\\025\\026\\027\\028\\029\\030\\031\\032\\033\\034\\035\\255\\255\\255\\130\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t    \\\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \t  \\" let ord = ord let rec code (c : char)  = fromInt (ord (sub (cvtTable, ord c))) let wsCode : word = 0x128L let plusCode : word = 0x129L let minusCode : word = 0x130L  (* local *)  let rec skipWS (getc : char\'a reader) cs  = let rec skip cs  = (match (getc cs) with NONE -> cs | (SOME (c, cs\')) -> if (code c = wsCode) then skip cs\' else cs(* end case *) ) in skip cs (* skip leading whitespace and any sign (+, -, or ~) *)  let rec scanPrefix (getc : char\'a reader) cs  = let rec skipWS cs  = (match (getc cs) with NONE -> NONE | (SOME (c, cs\')) -> let c\' = code c in if (c\' = wsCode) then skipWS cs\' else SOME (c\', cs\')(* end case *) ) let rec getNext (neg, cs)  = (match (getc cs) with NONE -> NONE | (SOME (c, cs)) -> SOME {neg = neg; next = code c; rest = cs}(* end case *) ) in match (skipWS cs) with NONE -> NONE | (SOME (c, cs\')) -> if (c = plusCode) then getNext (false, cs\') else if (c = minusCode) then getNext (true, cs\') else SOME {neg = false; next = c; rest = cs\'}(* end case *) (* for power of 2 bases (2, 8 & 16), we can check for overflow by looking\n       * at the hi (1, 3 or 4) bits.\n       *)  let rec chkOverflow mask w  = if (andb (mask, w) = 0x0L) then () else raise (Overflow) let rec scanBin (getc : char\'a reader) cs  = (match (scanPrefix getc cs) with NONE -> NONE | (SOME {neg; next; rest}) -> let rec isDigit (d : word)  = (d < 0x2L) let chkOverflow = chkOverflow 0xx80000000L let rec cvt (w, rest)  = (match (getc rest) with NONE -> SOME {neg = neg; word = w; rest = rest} | SOME (c, rest\') -> let d = code c in if (isDigit d) then (chkOverflow w; cvt (+ (<< (w, 0x1L), d), rest\')) else SOME {neg = neg; word = w; rest = rest}(* end case *) ) in if (isDigit next) then cvt (next, rest) else NONE(* end case *) ) let rec scanOct getc cs  = (match (scanPrefix getc cs) with NONE -> NONE | (SOME {neg; next; rest}) -> let rec isDigit (d : word)  = (d < 0x8L) let chkOverflow = chkOverflow 0xxE0000000L let rec cvt (w, rest)  = (match (getc rest) with NONE -> SOME {neg = neg; word = w; rest = rest} | SOME (c, rest\') -> let d = code c in if (isDigit d) then (chkOverflow w; cvt (+ (<< (w, 0x3L), d), rest\')) else SOME {neg = neg; word = w; rest = rest}(* end case *) ) in if (isDigit next) then cvt (next, rest) else NONE(* end case *) ) let rec scanDec getc cs  = (match (scanPrefix getc cs) with NONE -> NONE | (SOME {neg; next; rest}) -> let rec isDigit (d : word)  = (d < 0x10L) let rec cvt (w, rest)  = (match (getc rest) with NONE -> SOME {neg = neg; word = w; rest = rest} | SOME (c, rest\') -> let d = code c in if (isDigit d) then (if ((w >= largestWordDiv10) && ((largestWordDiv10 < w) || (largestWordMod10 < d))) then raise (Overflow) else (); cvt (0x10L * w + d, rest\')) else SOME {neg = neg; word = w; rest = rest}(* end case *) ) in if (isDigit next) then cvt (next, rest) else NONE(* end case *) ) let rec scanHex getc cs  = (match (scanPrefix getc cs) with NONE -> NONE | (SOME {neg; next; rest}) -> let rec isDigit (d : word)  = (d < 0x16L) let chkOverflow = chkOverflow 0xxF0000000L let rec cvt (w, rest)  = (match (getc rest) with NONE -> SOME {neg = neg; word = w; rest = rest} | SOME (c, rest\') -> let d = code c in if (isDigit d) then (chkOverflow w; cvt (+ (<< (w, 0x4L), d), rest\')) else SOME {neg = neg; word = w; rest = rest}(* end case *) ) in if (isDigit next) then cvt (next, rest) else NONE(* end case *) ) let rec finalWord scanFn getc cs  = (match (scanFn getc cs) with NONE -> NONE | (SOME {neg = true; _}) -> NONE | (SOME {neg = false; word; rest}) -> SOME (word, rest)(* end case *) ) let rec scanWord BIN  = finalWord scanBin | scanWord OCT  = finalWord scanOct | scanWord DEC  = finalWord scanDec | scanWord HEX  = finalWord scanHex let rec finalInt scanFn getc cs  = (match (scanFn getc cs) with NONE -> NONE | (SOME {neg = true; word; rest}) -> if (largestNegInt < word) then raise (Overflow) else SOME (~ (toInt word), rest) | (SOME {word; rest; _}) -> if (largestPosInt < word) then raise (Overflow) else SOME (toInt word, rest)(* end case *) ) let rec scanInt BIN  = finalInt scanBin | scanInt OCT  = finalInt scanOct | scanInt DEC  = finalInt scanDec | scanInt HEX  = finalInt scanHex end (* structure NumScan *)  module NumFormatsig val fmtWord : radix -> word -> stringval fmtInt : radix -> int -> string(** should be int32 **)  end = struct module W = Word32 module I = Int let < = < let - = - let * = * let div = div let rec mkDigit (w : word)  = sub ("0123456789abcdef", toInt w) let rec wordToBin w  = let rec mkBit w  = if (andb (w, 0x1L) = 0x0L) then \'0\' else \'1\' let rec f (0x0L, n, l)  = (+ (n, 1), \'0\' :: l) | f (0x1L, n, l)  = (+ (n, 1), \'1\' :: l) | f (w, n, l)  = f (>> (w, 0x1L), + (n, 1), (mkBit w) :: l) in f (w, 0, []) let rec wordToOct w  = let rec f (w, n, l)  = if (w < 0x8L) then (+ (n, 1), (mkDigit w) :: l) else f (>> (w, 0x3L), + (n, 1), mkDigit (andb (w, 0x7L)) :: l) in f (w, 0, []) let rec wordToDec w  = let rec f (w, n, l)  = if (w < 0x10L) then (+ (n, 1), (mkDigit w) :: l) else let j = w div 0x10L in f (j, + (n, 1), mkDigit (w - 0x10L * j) :: l) in f (w, 0, []) let rec wordToHex w  = let rec f (w, n, l)  = if (w < 0x16L) then (+ (n, 1), (mkDigit w) :: l) else f (>> (w, 0x4L), + (n, 1), mkDigit (andb (w, 0x15L)) :: l) in f (w, 0, []) let rec fmtW BIN  = 2 o wordToBin | fmtW OCT  = 2 o wordToOct | fmtW DEC  = 2 o wordToDec | fmtW HEX  = 2 o wordToHex let rec fmtWord radix  = implode o (fmtW radix) (** NOTE: this currently uses 31-bit integers, but really should use 32-bit\n     ** ints (once they are supported).\n     **)  let rec fmtInt radix  = let fmtW = fmtW radix let itow = fromInt let rec fmt i  = if < (i, 0) then try  with  else implode (fmtW (itow i)) in fmt end (* structure NumFormat *)  module BigNat = struct exception Negative let itow = fromInt let wtoi = toIntX let lgBase = 30 (* No. of bits per digit; must be even *)  let nbase = ~0x40000000 (* = ~2^lgBase *)  let maxDigit = ~ (nbase + 1) let realBase = (real maxDigit) + 1.0 let lgHBase = quot (lgBase, 2) (* half digits *)  let hbase = << (0x1L, itow lgHBase) let hmask = hbase - 0x1L let rec quotrem (i, j)  = (quot (i, j), rem (i, j)) let rec scale i  = if i = maxDigit then 1 else nbase div (~ (i + 1)) type bignat = int list (* least significant digit first *)  let zero = [] let one = [1] let rec bignat 0  = zero | bignat i  = let notNbase = notb (itow nbase) let rec bn 0x0L  = [] | bn i  = let rec dmbase n  = (>> (n, itow lgBase), andb (n, notNbase)) let (q, r) = dmbase i in (wtoi r) :: (bn q) in if i > 0 then if i <= maxDigit then [i] else bn (itow i) else raise (Negative) let rec int []  = 0 | int [d]  = d | int [d; e]  = ~ (nbase * e) + d | int (d :: r)  = ~ (nbase * int r) + d let rec consd (0, [])  = [] | consd (d, r)  = d :: r let rec hl i  = let w = itow i in (wtoi (~>> (w, itow lgHBase)), (* MUST sign-extend *) , wtoi (andb (w, hmask))) let rec sh i  = wtoi (<< (itow i, itow lgHBase)) let rec addOne []  = [1] | addOne (m :: rm)  = let c = nbase + m + 1 in if c < 0 then (c - nbase) :: rm else c :: (addOne rm) let rec add ([], digits)  = digits | add (digits, [])  = digits | add (dm :: rm, dn :: rn)  = addd (nbase + dm + dn, rm, rn)addd (s, m, n)  = if s < 0 then (s - nbase) :: add (m, n) else (s :: addc (m, n))addc (m, [])  = addOne m | addc ([], n)  = addOne n | addc (dm :: rm, dn :: rn)  = addd (nbase + dm + dn + 1, rm, rn) let rec subtOne (0 :: mr)  = maxDigit :: (subtOne mr) | subtOne [1]  = [] | subtOne (n :: mr)  = (n - 1) :: mr | subtOne []  = raise (Fail "") let rec subt (m, [])  = m | subt ([], n)  = raise (Negative) | subt (dm :: rm, dn :: rn)  = subd (dm - dn, rm, rn)subb ([], n)  = raise (Negative) | subb (dm :: rm, [])  = subd (dm - 1, rm, []) | subb (dm :: rm, dn :: rn)  = subd (dm - dn - 1, rm, rn)subd (d, m, n)  = if d >= 0 then consd (d, subt (m, n)) else consd (d - nbase, subb (m, n)) (* multiply 2 digits *)  let rec mul2 (m, n)  = (* x-y+z = mh*nl + ml*nh *) (* can\'t overflow *) let (mh, ml) = hl m let (nh, nl) = hl n let x = mh * nh let y = (mh - ml) * (nh - nl) let z = ml * nl let (zh, zl) = hl z let (uh, ul) = hl (nbase + x + z - y + zh) in (x + uh + wtoi hbase, sh ul + zl) (* multiply bigint by digit *)  let rec muld (m, 0)  = [] | muld (m, 1)  = m | muld (m, i)  = let rec muldc ([], 0)  = [] | muldc ([], c)  = [c] | muldc (d :: r, c)  = let (h, l) = mul2 (d, i) let l1 = l + nbase + c in if l1 >= 0 then l1 :: muldc (r, h + 1) else (l1 - nbase) :: muldc (r, h) in muldc (m, 0) let rec mult (m, [])  = [] | mult (m, [d])  = muld (m, d) | mult (m, 0 :: r)  = consd (0, mult (m, r)) | mult (m, n)  = let rec muln []  = [] | muln (d :: r)  = add (muld (n, d), consd (0, muln r)) in muln m (* divide DP number by digit; assumes u < i , i >= base/2 *)  let rec divmod2 ((u, v), i)  = let (vh, vl) = hl v let (ih, il) = hl i let rec adj (q, r)  = if r < 0 then adj (q - 1, r + i) else (q, r) let (q1, r1) = quotrem (u, ih) let (q1, r1) = adj (q1, sh r1 + vh - q1 * il) let (q0, r0) = quotrem (r1, ih) let (q0, r0) = adj (q0, sh r0 + vl - q0 * il) in (sh q1 + q0, r0) (* divide bignat by digit>0 *)  let rec divmodd (m, 1)  = (m, 0) | divmodd (m, i)  = let scale = scale i let i\' = i * scale let m\' = muld (m, scale) let rec dmi []  = ([], 0) | dmi (d :: r)  = let (qt, rm) = dmi r let (q1, r1) = divmod2 ((rm, d), i\') in (consd (q1, qt), r1) let (q, r) = dmi m\' in (q, r div scale) (* From Knuth Vol II, 4.3.1, but without opt. in step D3 *)  let rec divmod (m, [])  = raise (Div) | divmod ([], n)  = ([], []) | divmod (d :: r, 0 :: s)  = let (qt, rm) = divmod (r, s) in (qt, consd (d, rm)) | divmod (m, [d])  = let (qt, rm) = divmodd (m, d) in (qt, if rm = 0 then [] else [rm]) | divmod (m, n)  = (* >= 2 *) (* >= base/2 *) let ln = length n let scale = scale (nth (n, ln - 1)) let m\' = muld (m, scale) let n\' = muld (n, scale) let n1 = nth (n\', ln - 1) let rec divl []  = ([], []) | divl (d :: r)  = let (qt, rm) = divl r let m = consd (d, rm) let rec msds ([], _)  = (0, 0) | msds ([d], 1)  = (0, d) | msds ([d2; d1], 1)  = (d1, d2) | msds (d :: r, i)  = msds (r, i - 1) let (m1, m2) = msds (m, ln) let tq = if m1 = n1 then maxDigit else 1 (divmod2 ((m1, m2), n1)) let rec try (q, qn\')  = try  with let (q, rr) = try (tq, muld (n\', tq)) in (consd (q, qt), rr) let (qt, rm\') = divl m\' let (rm, _, (*0*) ) = divmodd (rm\', scale) in (qt, rm) let rec cmp ([], [])  = EQUAL | cmp (_, [])  = GREATER | cmp ([], _)  = LESS | cmp ((i : int) :: ri, j :: rj)  = match cmp (ri, rj) with EQUAL -> if i = j then EQUAL else if i < j then LESS else GREATER | c -> c let rec exp (_, 0)  = one | exp ([], n)  = if n > 0 then zero else raise (Div) | exp (m, n)  = if n < 0 then zero else let rec expm 0  = [1] | expm 1  = m | expm i  = let r = expm (i div 2) let r2 = mult (r, r) in if i mod 2 = 0 then r2 else mult (r2, m) in expm n let rec try n  = if n >= lgHBase then n else try (2 * n) let pow2lgHBase = try 1 let rec log2 []  = raise (Domain) | log2 (h :: t)  = let rec qlog (x, 0)  = 0 | qlog (x, b)  = if x >= wtoi (<< (0x1L, itow b)) then b + qlog (wtoi (>> (itow x, itow b)), b div 2) else qlog (x, b div 2) let rec loop (d, [], lg)  = lg + qlog (d, pow2lgHBase) | loop (_, h :: t, lg)  = loop (h, t, lg + lgBase) in loop (h, t, 0)  (* local *)  (* find maximal maxpow s.t. radix^maxpow < base \n             * basepow = radix^maxpow\n             *)  let rec mkPowers radix  = let powers = let bnd = quot (nbase, (~ radix)) let rec try (tp, l)  = try  with in fromList (rev (try (radix, [1]))) let maxpow = length powers - 1 in (maxpow, sub (powers, maxpow), powers) let powers2 = mkPowers 2 let powers8 = mkPowers 8 let powers10 = mkPowers 10 let powers16 = mkPowers 16 let rec fmt (pow, radpow, puti) n  = let pad = padLeft \'0\' pow let rec ms0 (0, a)  = (pad "") :: a | ms0 (i, a)  = (pad (puti i)) :: a let rec ml (n, a)  = match divmodd (n, radpow) with ([], d) -> (puti d) :: a | (q, d) -> ml (q, ms0 (d, a)) in concat (ml (n, [])) let fmt2 = fmt (1 powers2, 2 powers2, fmtInt BIN) let fmt8 = fmt (1 powers8, 2 powers8, fmtInt OCT) let fmt10 = fmt (1 powers10, 2 powers10, fmtInt DEC) let fmt16 = fmt (1 powers16, 2 powers16, fmtInt HEX) let rec scan (bound, powers, geti) getc cs  = let rec get (l, cs)  = if l = bound then NONE else match getc cs with NONE -> NONE | SOME (c, cs\') -> SOME (c, (l + 1, cs\')) let rec loop (acc, cs)  = match geti get (0, cs) with NONE -> (acc, cs) | SOME (0, (sh, cs\')) -> loop (add (muld (acc, sub (powers, sh)), []), cs\') | SOME (i, (sh, cs\')) -> loop (add (muld (acc, sub (powers, sh)), [i]), cs\') in match geti get (0, cs) with NONE -> NONE | SOME (0, (_, cs\')) -> SOME (loop ([], cs\')) | SOME (i, (_, cs\')) -> SOME (loop ([i], cs\')) let rec scan2 getc  = scan (1 powers2, 3 powers2, scanInt BIN) getc let rec scan8 getc  = scan (1 powers8, 3 powers8, scanInt OCT) getc let rec scan10 getc  = scan (1 powers10, 3 powers10, scanInt DEC) getc let rec scan16 getc  = scan (1 powers16, 3 powers16, scanInt HEX) getc end (* structure BigNat *)  module BN = BigNat type sign = POS | NEG type int = BI of {sign: sign; digits: bignat} let zero = BI {sign = POS; digits = zero} let one = BI {sign = POS; digits = one} let minus_one = BI {sign = NEG; digits = one} let rec posi digits  = BI {sign = POS; digits = digits} let rec negi digits  = BI {sign = NEG; digits = digits} let rec zneg []  = zero | zneg digits  = BI {sign = NEG; digits = digits} let minNeg = valOf minInt let bigNatMinNeg = addOne (bignat (~ (minNeg + 1))) let bigIntMinNeg = negi bigNatMinNeg let rec toInt (BI {digits = []; _})  = 0 | toInt (BI {sign = POS; digits})  = int digits | toInt (BI {sign = NEG; digits})  = try  with let rec fromInt 0  = zero | fromInt i  = if i < 0 then if (i = minNeg) then bigIntMinNeg else BI {sign = NEG; digits = bignat (~ i)} else BI {sign = POS; digits = bignat i}  (* local *)  (* The following assumes LargeInt = Int32.\n       * If IntInf is provided, it will be LargeInt and toLarge and fromLarge\n       * will be the identity function.\n       *)  let minNeg = valOf minInt let maxDigit = fromInt maxDigit let nbase = fromInt nbase let lgBase = fromInt lgBase let notNbase = notb (fromInt nbase) let rec largeNat (0 : int)  = [] | largeNat i  = let rec bn (0x0L : word)  = [] | bn i  = let rec dmbase n  = (>> (n, lgBase), andb (n, notNbase)) let (q, r) = dmbase i in (toInt r) :: (bn q) in if i <= maxDigit then [toInt i] else bn (fromLargeInt i) let rec large []  = 0 | large [d]  = fromInt d | large [d; e]  = ~ (nbase * (fromInt e)) + (fromInt d) | large (d :: r)  = ~ (nbase * large r) + (fromInt d) let bigNatMinNeg = addOne (largeNat (~ (minNeg + 1))) let bigIntMinNeg = negi bigNatMinNeg let rec toLarge (BI {digits = []; _})  = 0 | toLarge (BI {sign = POS; digits})  = large digits | toLarge (BI {sign = NEG; digits})  = try  with let rec fromLarge 0  = zero | fromLarge i  = if i < 0 then if (i = minNeg) then bigIntMinNeg else BI {sign = NEG; digits = largeNat (~ i)} else BI {sign = POS; digits = largeNat i}  (* local *)  let rec negSign POS  = NEG | negSign NEG  = POS let rec subtNat (m, [])  = {sign = POS; digits = m} | subtNat ([], n)  = {sign = NEG; digits = n} | subtNat (m, n)  = try  with let precision = NONE let minInt = NONE let maxInt = NONE let rec ~ (i as BI {digits = []; _})  = i | ~ (BI {sign = POS; digits})  = BI {sign = NEG; digits = digits} | ~ (BI {sign = NEG; digits})  = BI {sign = POS; digits = digits} let rec  * (_, BI {digits = []; _})  = zero |  * (BI {digits = []; _}, _)  = zero |  * (BI {sign = POS; digits = d1}, BI {sign = NEG; digits = d2})  = BI {sign = NEG; digits = mult (d1, d2)} |  * (BI {sign = NEG; digits = d1}, BI {sign = POS; digits = d2})  = BI {sign = NEG; digits = mult (d1, d2)} |  * (BI {digits = d1; _}, BI {digits = d2; _})  = BI {sign = POS; digits = mult (d1, d2)} let rec  + (BI {digits = []; _}, i2)  = i2 |  + (i1, BI {digits = []; _})  = i1 |  + (BI {sign = POS; digits = d1}, BI {sign = NEG; digits = d2})  = BI (subtNat (d1, d2)) |  + (BI {sign = NEG; digits = d1}, BI {sign = POS; digits = d2})  = BI (subtNat (d2, d1)) |  + (BI {sign; digits = d1}, BI {digits = d2; _})  = BI {sign = sign; digits = add (d1, d2)} let rec  - (i1, BI {digits = []; _})  = i1 |  - (BI {digits = []; _}, BI {sign; digits})  = BI {sign = negSign sign; digits = digits} |  - (BI {sign = POS; digits = d1}, BI {sign = POS; digits = d2})  = BI (subtNat (d1, d2)) |  - (BI {sign = NEG; digits = d1}, BI {sign = NEG; digits = d2})  = BI (subtNat (d2, d1)) |  - (BI {sign; digits = d1}, BI {digits = d2; _})  = BI {sign = sign; digits = add (d1, d2)} let rec quotrem (BI {sign = POS; digits = m}, BI {sign = POS; digits = n})  = (match divmod (m, n) with (q, r) -> (posi q, posi r)) | quotrem (BI {sign = POS; digits = m}, BI {sign = NEG; digits = n})  = (match divmod (m, n) with (q, r) -> (zneg q, posi r)) | quotrem (BI {sign = NEG; digits = m}, BI {sign = POS; digits = n})  = (match divmod (m, n) with (q, r) -> (zneg q, zneg r)) | quotrem (BI {sign = NEG; digits = m}, BI {sign = NEG; digits = n})  = (match divmod (m, n) with (q, r) -> (posi q, zneg r)) let rec divmod (BI {sign = POS; digits = m}, BI {sign = POS; digits = n})  = (match divmod (m, n) with (q, r) -> (posi q, posi r)) | divmod (BI {sign = POS; digits = []}, BI {sign = NEG; digits = n})  = (zero, zero) | divmod (BI {sign = POS; digits = m}, BI {sign = NEG; digits = n})  = let (q, r) = divmod (subtOne m, n) in (negi (addOne q), zneg (subtOne (subt (n, r)))) | divmod (BI {sign = NEG; digits = m}, BI {sign = POS; digits = n})  = let (q, r) = divmod (subtOne m, n) in (negi (addOne q), posi (subtOne (subt (n, r)))) | divmod (BI {sign = NEG; digits = m}, BI {sign = NEG; digits = n})  = (match divmod (m, n) with (q, r) -> (posi q, zneg r)) let rec  div arg  = 1 (divmod arg) let rec  mod arg  = 2 (divmod arg) let rec  quot arg  = 1 (quotrem arg) let rec  rem arg  = 2 (quotrem arg) let rec compare (BI {sign = NEG; _}, BI {sign = POS; _})  = LESS | compare (BI {sign = POS; _}, BI {sign = NEG; _})  = GREATER | compare (BI {sign = POS; digits = d}, BI {sign = POS; digits = d\'})  = cmp (d, d\') | compare (BI {sign = NEG; digits = d}, BI {sign = NEG; digits = d\'})  = cmp (d\', d) let rec  < arg  = match compare arg with LESS -> true | _ -> false let rec  > arg  = match compare arg with GREATER -> true | _ -> false let rec  <= arg  = match compare arg with GREATER -> false | _ -> true let rec  >= arg  = match compare arg with LESS -> false | _ -> true let rec abs (BI {sign = NEG; digits})  = BI {sign = POS; digits = digits} | abs i  = i let rec max arg  = match compare arg with GREATER -> 1 arg | _ -> 2 arg let rec min arg  = match compare arg with LESS -> 1 arg | _ -> 2 arg let rec sign (BI {sign = NEG; _})  = ~1 | sign (BI {digits = []; _})  = 0 | sign _  = 1 let rec sameSign (i, j)  = sign i = sign j let rec fmt\' fmtFn i  = match i with (BI {digits = []; _}) -> "0" | (BI {sign = NEG; digits}) -> "~" ^ (fmtFn digits) | (BI {sign = POS; digits}) -> fmtFn digits let rec fmt BIN  = fmt\' (fmt2) | fmt OCT  = fmt\' (fmt8) | fmt DEC  = fmt\' (fmt10) | fmt HEX  = fmt\' (fmt16)  let toString = fmt DEC let rec scan\' scanFn getc cs  = let cs\' = skipWS getc cs let rec cvt (NONE, _)  = NONE | cvt (SOME (i, cs), wr)  = SOME (wr i, cs) in match (getc cs\') with (SOME (\'~\', cs\'\')) -> cvt (scanFn getc cs\'\', zneg) | (SOME (\'-\', cs\'\')) -> cvt (scanFn getc cs\'\', zneg) | (SOME (\'+\', cs\'\')) -> cvt (scanFn getc cs\'\', posi) | (SOME _) -> cvt (scanFn getc cs\', posi) | NONE -> NONE(* end case *) let rec scan BIN  = scan\' (scan2) | scan OCT  = scan\' (scan8) | scan DEC  = scan\' (scan10) | scan HEX  = scan\' (scan16)  let rec fromString s  = scanString (scan DEC) s let rec pow (_, 0)  = one | pow (BI {sign = POS; digits}, n)  = posi (exp (digits, n)) | pow (BI {sign = NEG; digits}, n)  = if mod (n, 2) = 0 then posi (exp (digits, n)) else zneg (exp (digits, n)) let rec log2 (BI {sign = POS; digits})  = log2 digits | log2 _  = raise (Domain) end(* structure IntInf *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
Code parsed successfully: module Integers = Integers()
module Rationals = Rationals()
module IntegersMod7 = IntegersMod()

('Error parsing code:', '(* Rationals *) (* Author: Roberto Virga *) module Rationals (Integers : INTEGERS) : RATIONALS = struct module Integers = Integers let name = "rational" exception DivDiv module I = Integerstype number = Fract of int * int * int (* q := Fract (sign, num, denom) *) let zero = Fract (0, fromInt (0), fromInt (1)) let one = Fract (1, fromInt (1), fromInt (1)) exception Div let rec normalize (Fract (0, _, _))  = zero | normalize (Fract (s, n, d))  = let rec gcd (m, n)  = if (m = fromInt (0)) then n else if (n = fromInt (0)) then m else if > (m, n) then gcd (mod (m, n), n) else gcd (m, mod (n, m)) let g = gcd (n, d) in Fract (s, div (n, g), div (d, g)) let rec  ~ (Fract (s, n, d))  = (Fract (~ (s), n, d)) let rec  + (Fract (s1, n1, d1), Fract (s2, n2, d2))  = let n = + (* (* (fromInt (s1), n1), d2), * (* (fromInt (s2), n2), d1)) in normalize (Fract (sign (n), abs (n), * (d1, d2))) let rec  - (Fract (s1, n1, d1), Fract (s2, n2, d2))  = let n = - (* (* (fromInt (s1), n1), d2), * (* (fromInt (s2), n2), d1)) in normalize (Fract (sign (n), abs (n), * (d1, d2))) let rec  * (Fract (s1, n1, d1), Fract (s2, n2, d2))  = normalize (Fract (* (s1, s2), * (n1, n2), * (d1, d2))) let rec inverse (Fract (0, _, _))  = raise (Div) | inverse (Fract (s, n, d))  = (Fract (s, d, n)) let rec sign (Fract (s, n, d))  = s let rec numerator (Fract (s, n, d))  = n let rec denominator (Fract (s, n, d))  = d let rec abs (Fract (s, n, d))  = (Fract (abs (s), n, d)) let rec compare (Fract (s1, n1, d1), Fract (s2, n2, d2))  = compare (* (* (fromInt (s1), n1), d2), * (* (fromInt (s2), n2), d1)) let rec  > (q1, q2)  = (compare (q1, q2) = GREATER) let rec  < (q1, q2)  = (compare (q1, q2) = LESS) let rec  >= (q1, q2)  = (q1 = q2) || (q1 > q2) let rec  <= (q1, q2)  = (q1 = q2) || (q1 < q2) let rec fromInt (n)  = (Fract (sign (n), fromInt (abs (n)), fromInt (1))) let rec fromString (str)  = let rec check_numerator (chars as (c :: chars\'))  = if (c = \'~\') then (all isDigit chars\') else (all isDigit chars) | check_numerator nil  = false let rec check_denominator (chars)  = (all isDigit chars) let fields = (fields (fun c -> (c = \'/\')) str) in if (length fields = 1) then let numerator = nth (fields, 0) in if (check_numerator (explode (numerator))) then match (fromString (numerator)) with SOME (n) -> SOME (Fract (sign (n), abs (n), fromInt (1))) | _ -> NONE else NONE else if (length fields = 2) then let numerator = nth (fields, 0) let denominator = nth (fields, 1) in if (check_numerator (explode (numerator))) && (check_denominator (explode (denominator))) then match (fromString (numerator), fromString (denominator)) with (SOME (n), SOME (d)) -> SOME (normalize (Fract (sign (n), abs (n), d))) | _ -> NONE else NONE else NONE let rec toString (Fract (s, n, d))  = let nStr = toString (* (fromInt (s), n)) let dStr = toString d in if (d = fromInt (1)) then nStr else (nStr ^ "/" ^ dStr) let rec fromInteger (n)  = Fract (sign (n), abs (n), fromInt (1)) let rec floor (q as Fract (s, n, d))  = if >= (s, 0) then quot (n, d) else ~ (ceiling (~ q))ceiling (q as Fract (s, n, d))  = if >= (s, 0) then quot (+ (n, - (d, fromInt (1))), d) else ~ (floor (~ q)) type number = number let zero = zero let one = one let ~ = ~ let + = + let - = - let * = * let inverse = inverse let fromInt = fromInt let fromString = fromString let toString = toString let sign = sign let abs = abs let > = > let < = < let >= = >= let <= = <= let compare = compare let fromInteger = fromInteger let floor = floor let ceiling = ceiling let numerator = numerator let denominator = denominator  end\n(* structure Rationals *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Ordered Field *) (* Author: Roberto Virga *) module type ORDERED_FIELD = sig include FIELD(* Sign operations *) val sign : number -> intval abs : number -> number(* Comparisons predicates *) val > : number * number -> boolval < : number * number -> boolval >= : number * number -> boolval <= : number * number -> boolval compare : number * number -> order end\n(* signature ORDERED_FIELD *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Integers Modulo a Prime Number *) (* Author: Roberto Virga *) module IntegersMod (val p : int)FIELD = struct let name = "integer" ^ (toString p) type number = int let rec normalize (n)  = n mod p let zero = 0 let one = 1 exception Div let rec  ~ (n)  = - (p, n) let rec  + (m, n)  = normalize (+ (m, n)) let rec  - (m, n)  = normalize (- (m, n)) let rec  * (m, n)  = normalize (* (m, n)) let rec inverse (0)  = raise (Div) | inverse (n)  = (* alternative: compute n^(p-2) *) let rec inverse\' i  = if (normalize (* (n, i)) = 1) then i else inverse\' (+ (i, 1)) in inverse\' 1 let rec fromInt (n)  = normalize (n) let rec fromString (str)  = let check = (all isDigit) in if check (explode str) then (match (fromString (str)) with SOME (n) -> if (n < p) then SOME (n) else NONE | NONE -> NONE) else NONE let toString = toString end\n(* functor IntegersMod *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Field *) (* Author: Roberto Virga *) module type FIELD = sig (* Name of the set *) val name : string(* Main type *) type number(* Non-invertible element *) exception Div(* Constants *) val zero : numberval one : number(* Operators *) val ~ : number -> numberval + : number * number -> numberval - : number * number -> numberval * : number * number -> numberval inverse : number -> number(* raises Div *) (* Conversions *) val fromInt : int -> numberval fromString : string -> number optionval toString : number -> string end\n(* signature FIELD *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Integers *) (* Author: Roberto Virga *) module type INTEGERS = sig include INTEGERval gcd : int * int -> intval lcm : int * int -> intval solve_gcd : int * int -> int * int end\n(* signature INTEGERS *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Rationals *) (* Author: Roberto Virga *) module Integers (Integer : INTEGER) : INTEGERS = struct open Integer let zero = fromInt 0 let one = fromInt 1 let rec solve_gcd (m, n)  = let rec solve' (m, n)  = let q = quot (m, n) let r = rem (m, n) in if (r = zero) then (zero, one) else let (x, y) = solve' (n, r) in (y, x - q * y) let am = abs m let an = abs n let sm = fromInt (sign m) let sn = fromInt (sign n) in if (am > an) then (fun (x, y) -> (sm * x, sn * y)) (solve' (am, an)) else (fun (x, y) -> (sm * y, sn * x)) (solve' (an, am)) let rec gcd (m, n)  = let (x, y) = solve_gcd (m, n) in m * x + n * y let rec lcm (m, n)  = quot (m * n, gcd (m, n)) let rec fromString (str)  = let rec check (chars as (c :: chars'))  = if (c = '~') then (all isDigit chars') else (all isDigit chars) | check nil  = false in if check (explode str) then fromString str else NONE end\n(* structure Integers *) ", 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Rational numbers *) (* Author: Roberto Virga *) module type RATIONALS = sig include ORDERED_FIELDmodule Integers : INTEGERS(* Conversions between rationals and integers *) val fromInteger : int -> numberval floor : number -> intval ceiling : number -> int(* Basic projections *) val numerator : number -> intval denominator : number -> int end\n(* signature RATIONALS *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Trailing Abstract Operations *) (* Author: Roberto Virga *) module type TRAIL = sig type 'atrailval trail : unit -> 'a trailval suspend : 'a trail * ('a -> 'b) -> 'b trailval resume : 'b trail * 'a trail * ('b -> 'a) -> unitval reset : 'a trail -> unitval mark : 'a trail -> unitval unwind : 'a trail * ('a -> unit) -> unitval log : 'a trail * 'a -> unit end\n(* signature TRAIL *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Trailing Abstract Operations *) (* Author: Roberto Virga *) module TrailTRAIL = struct type Trail = Cons of 'a * 'a Trail | Mark of 'a Trail | Nil type 'atrail = 'a Trail ref let rec trail ()  = ref Nil let rec reset trail  = trail := Nil let rec suspend (trail, copy)  = let rec suspend' Nil  = Nil | suspend' (Mark trail)  = (suspend' trail) | suspend' (Cons (action, trail))  = Cons (copy action, suspend' trail) let ftrail = suspend' (! trail) in ref ftrail let rec resume (ftrail, trail, reset)  = let rec resume' Nil  = Nil | resume' (Mark ftrail)  = resume' ftrail | resume' (Cons (faction, ftrail))  = Cons (reset faction, resume' ftrail) let trail' = resume' (! ftrail) in trail := trail' let rec mark trail  = trail := Mark (! trail) let rec unwind (trail, undo)  = let rec unwind' Nil  = Nil | unwind' (Mark trail)  = trail | unwind' (Cons (action, trail))  = (undo action; unwind' trail) in trail := unwind' (! trail) let rec log (trail, action)  = trail := Cons (action, ! trail) type 'atrail = 'a trail let trail = trail let suspend = suspend let resume = resume let reset = reset let mark = mark let unwind = unwind let log = log  (* local ... *)  end\n(* structure Trail *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Not Trailing Abstract Operations *) (* Author: Roberto Virga *) module NoTrailTRAIL = struct type 'atrail = unit let rec trail ()  = () let rec suspend ((), copy)  = () let rec resume ((), (), reset)  = () let rec reset ()  = () let rec mark ()  = () let rec unwind ((), undo)  = () let rec log ((), action)  = () end\n(* structure NoTrail *) ", 'Error matches:', [(0, {})], 'Missing matches:', [])
Code parsed successfully: (* Now in paths.fun *) (*
structure Paths = Paths ();
*) module Origins = Origins(struct module Global = Global module Table = StringHashTable end)

('Error parsing code:', '(* Origins of Declarations *) (* Author: Frank Pfenning *) module Origins (module Global : GLOBALmodule Table : TABLE where keystring(*! structure IntSyn\' : INTSYN !*) (*! structure Paths\' : PATHS !*) ) : ORIGINS = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Paths = Paths\' !*)  let linesInfoTable : linesInfo Table = new (31) let rec reset ()  = clear linesInfoTable let rec install (string, linesInfo)  = insert linesInfoTable (string, linesInfo) let rec lookup (string)  = lookup linesInfoTable string let reset = reset let installLinesInfo = install let linesInfoLookup = lookup  let originArray = array (maxCid + 1, ("", NONE)) : string * occConDec option array let rec installOrigin (cid, fileNameOpt)  = update (originArray, cid, fileNameOpt) let rec originLookup (cid)  = sub (originArray, cid)  end\n(* functor Origins *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Origins of Declarations *) (* Author: Frank Pfenning *) module type ORIGINS = sig (*! structure IntSyn : INTSYN !*) (*! structure Paths : PATHS !*) val reset : unit -> unitval installLinesInfo : string * linesInfo -> unitval linesInfoLookup : string -> linesInfo optionval installOrigin : cid * (string * occConDec option) -> unitval originLookup : cid -> (string * occConDec option) end\n(* signature ORIGINS *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* Now in paths.fun *) (*
structure Paths = Paths ();
*) module Origins = Origins(struct module Global = Global module Table = StringHashTable end)

('Error parsing code:', "(* Paths, Occurrences, and Error Locations *) (* Author: Frank Pfenning *) module type PATHS = sig type regionRegint * int(* r ::= (i,j) is interval [i,j) *) type locationLocstring * region(* loc ::= (filename, region) *) (* line numbering, used when printing regions *) type linesInfo(* mapping from character positions to lines in a file *) val resetLines : unit -> unit(* reset line numbering *) val newLine : int -> unit(* new line starts at character i *) val getLinesInfo : unit -> linesInfo(* get lines info for current file *) val join : region * region -> region(* join(r1,r2) = smallest region enclosing r1 and r2 *) val toString : region -> string(* line1.col1-line2.col2, parsable by Emacs *) val wrap : region * string -> string(* add region to error message, parsable by Emacs *) val wrapLoc : location * string -> string(* add location to error message, also parsable *) val wrapLoc' : location * linesInfo option * string -> string(* add location to error message in line.col format *) (* Paths, occurrences and occurrence trees only work well for normal forms *) (* In the general case, regions only approximate true source location *) (* Follow path through a term to obtain subterm *) type PathLabelPathBodyPathHeadArgint * PathHere(* #, covers Uni, EVar, Redex(?) *) (*\n     Construct an occurrence when traversing a term.\n     The resulting occurrence can be translated to a region\n     via an occurrence tree stored with the term.\n\n     An occurrence is a path in reverse order.\n  *) type occval top : occval label : occ -> occval body : occ -> occval head : occ -> occval arg : int * occ -> occ(*\n     An occurrence tree is a data structure mapping occurrences in a term\n     to regions in an input stream.  Occurrence trees are constructed during parsing.\n  *) type occExp and occSpine(* occurrence tree for s spines *) val leaf : region -> occExp(* could be _ or identifier *) val bind : region * occExp option * occExp -> occExpval root : region * occExp * int * int * occSpine -> occExpval app : occExp * occSpine -> occSpineval nils : occSpinetype occConDec(* occurrence tree for constant declarations *) val dec : int * occExp -> occConDec(* (#implicit, v) in c : V *) val def : int * occExp * occExp option -> occConDec(* (#implicit, u, v) in c : V = U *) val toRegion : occExp -> regionval toRegionSpine : occSpine * region -> regionval posToPath : occExp -> int -> Pathval occToRegionExp : occExp -> occ -> regionval occToRegionDec : occConDec -> occ -> region(* into v for c : V *) val occToRegionDef1 : occConDec -> occ -> region(* into u for c : V = U *) val occToRegionDef2 : occConDec -> occ -> region(* into v for c : V = U *) val occToRegionClause : occConDec -> occ -> region(* into v for c : V ... *)  end\n(* signature PATHS *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module StringHashTable = HashTable()\nmodule IntHashTable = HashTable()\nmodule StringRedBlackTree = RedBlackTree()module IntRedBlackTree = RedBlackTree()module SparseArray = SparseArray(module IntTable = IntHashTable)module SparseArray2 = SparseArray2(module IntTable = IntHashTable)', 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Queues *) (* Author: Frank Pfenning *) (* Standard functional implementation of queues *) (*\n   Since in the typical use `delete' is not of constant amortized time we\n   provide a special `toList' operation which permits constant\n   amortized access under programmer control.\n*) module QueueQUEUE = struct (* Representation invariant:\n     If  q = (inp, out)  then  q == out @ rev(inp)\n  *)  type 'aqueue = 'a list * 'a list let empty = (nil, nil) let rec insert (x, (inp, out))  = (x :: inp, out) let rec delete (nil, nil)  = NONE | delete (inp, x :: out)  = SOME (x, (inp, out)) | delete (inp, nil)  = delete (nil, rev inp) let rec insertFront (x, (inp, out))  = (inp, x :: out) let rec deleteEnd (nil, nil)  = NONE | deleteEnd (x :: inp, out)  = SOME (x, (inp, out)) | deleteEnd (nil, out)  = delete (rev out, nil) (* toList q ==> (l, NONE)  means q == l and toList is constant time *)  (* toList q ==> (l, SOME(q')) means q == l == q' *)  (* and toList q' is constant time *)  let rec toList (nil, out)  = (out, NONE) | toList (inp, out)  = let out' = out @ rev (inp) in (out', SOME (nil, out')) end\n(* structure Queue *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Rings (aka cyclic lists) *) (* Author: Carsten Schuermann *) module type RING = sig exception Emptytype 'aringval init : 'a list -> 'a ringval empty : 'a ring -> boolval insert : 'a ring * 'a -> 'a ringval delete : 'a ring -> 'a ringval current : 'a ring -> 'aval next : 'a ring -> 'a ringval previous : 'a ring -> 'a ringval foldr : ('a * 'b -> 'b) -> 'b -> 'a ring -> 'bval map : ('a -> 'b) -> 'a ring -> 'b ring(* does not necessarily map f in order *)  end\n(* signature RING *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* redblack-set.sml\n *\n * This code is based on Chris Okasaki\'s implementation of\n * red-black trees.  The linear-time tree construction code is\n * based on the paper "Constructing red-black trees" by Hinze,\n * and the delete function is based on the description in Cormen,\n * Leiserson, and Rivest.\n *\n * A red-black tree should satisfy the following two invariants:\n *\n *   Red Invariant: each red node has a black parent.\n *\n *   Black Condition: each path from the root to an empty node has the\n *     same number of black nodes (the tree\'s black height).\n *\n * The Red condition implies that the root is always black and the Black\n * condition implies that any node with only one child will be black and\n * its child will be a red leaf.\n *) module RBSetRBSET = struct type key = int type \'aentry = key * \'a type dict = Empty | Red of \'a entry * \'a dict * \'a dict | Black of \'a entry * \'a dict * \'a dict type set = Set of (int * \'a dict) exception Error of string type \'aordSet = \'a set ref let rec isEmpty (Set (_, Empty))  = true | isEmpty (Set (_, T))  = false let empty = Set (0, Empty) let rec singleton x  = Set (1, Red (x, Empty, Empty)) let compare = compare (* Representation Invariants *)  (*\n     1. The tree is ordered: for every node Red((key1,datum1), left, right) or\n        Black ((key1,datum1), left, right), every key in left is less than\n        key1 and every key in right is greater than key1.\n\n     2. The children of a red node are black (color invariant).\n\n     3. Every path from the root to a leaf has the same number of\n        black nodes, called the black height of the tree.\n  *)  let rec lookup (Set (n, dict)) key  = let rec lk (Empty)  = NONE | lk (Red tree)  = lk\' tree | lk (Black tree)  = lk\' treelk\' ((key1, datum1), left, right)  = (match compare (key, key1) with EQUAL -> SOME (datum1) | LESS -> lk left | GREATER -> lk right) in lk dict let rec last (Set (n, dict))  = (n, valOf (lookup (Set (n, dict)) n)) (* val restore_right : \'a dict -> \'a dict *) (*\n     restore_right (Black(e,l,r)) >=> dict\n     where (1) Black(e,l,r) is ordered,\n           (2) Black(e,l,r) has black height n,\n\t   (3) color invariant may be violated at the root of r:\n               one of its children might be red.\n     and dict is a re-balanced red/black tree (satisfying all invariants)\n     and same black height n.\n  *) let rec restore_right (Black (e, Red lt, Red (rt as (_, Red _, _))))  = Red (e, Black lt, Black rt) | restore_right (Black (e, Red lt, Red (rt as (_, _, Red _))))  = Red (e, Black lt, Black rt) | restore_right (Black (e, l, Red (re, Red (rle, rll, rlr), rr)))  = (* l is black, deep rotate *)  Black (rle, Red (e, l, rll), Red (re, rlr, rr)) | restore_right (Black (e, l, Red (re, rl, rr as Red _)))  = (* l is black, shallow rotate *)  Black (re, Red (e, l, rl), rr) | restore_right dict  = dict (* restore_left is like restore_right, except *) (* the color invariant may be violated only at the root of left child *) let rec restore_left (Black (e, Red (lt as (_, Red _, _)), Red rt))  = Red (e, Black lt, Black rt) | restore_left (Black (e, Red (lt as (_, _, Red _)), Red rt))  = Red (e, Black lt, Black rt) | restore_left (Black (e, Red (le, ll as Red _, lr), r))  = (* r is black, shallow rotate *)  Black (le, ll, Red (e, lr, r)) | restore_left (Black (e, Red (le, ll, Red (lre, lrl, lrr)), r))  = (* r is black, deep rotate *)  Black (lre, Red (le, ll, lrl), Red (e, lrr, r)) | restore_left dict  = dict let rec insert (Set (n, dict), entry as (key, datum))  = (* val ins : \'a dict -> \'a dict  inserts entry *) (* ins (Red _) may violate color invariant at root *) (* ins (Black _) or ins (Empty) will be red/black tree *) (* ins preserves black height *) let nItems = ref n let rec ins (Empty)  = (nItems := n + 1; Red (entry, Empty, Empty)) | ins (Red (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> ((*print ("Found " ^ Int.toString key ^ " already in set -- keep entry--do not overwrite\\n");*) Red (entry1, left, right)) | LESS -> Red (entry1, ins left, right) | GREATER -> Red (entry1, left, ins right)) | ins (Black (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> ((* print ("Found " ^ Int.toString key ^ " already in set -- keep entry--do not overwrite\\n"); *) Black (entry1, left, right)) | LESS -> restore_left (Black (entry1, ins left, right)) | GREATER -> restore_right (Black (entry1, left, ins right))) let dict\' = match ins dict with Red (t as (_, Red _, _)) -> Black t(* re-color *)  | Red (t as (_, _, Red _)) -> Black t(* re-color *)  | dict -> dict in Set (! nItems, dict\') let rec insertList (S, nil)  = S | insertList (S, e :: list)  = insertList (insert (S, e), list) let rec insertLast (Set (n, dict), datum)  = let Set (n\', dic\') = insert (Set (n, dict), (n + 1, datum)) in Set (n\', dic\') (* input: set sc\n     output set s\' *) let rec insertShadow (Set (n, dict), entry as (key, datum))  = (* : \'a entry option ref *) let oldEntry = ref NONE let rec ins (Empty)  = Red (entry, Empty, Empty) | ins (Red (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> (oldEntry := SOME (entry1); Red (entry, left, right)) | LESS -> Red (entry1, ins left, right) | GREATER -> Red (entry1, left, ins right)) | ins (Black (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> (oldEntry := SOME (entry1); Black (entry, left, right)) | LESS -> restore_left (Black (entry1, ins left, right)) | GREATER -> restore_right (Black (entry1, left, ins right))) let (dict\', oldEntry\') = (oldEntry := NONE; ((match ins dict with Red (t as (_, Red _, _)) -> Black t(* re-color *)  | Red (t as (_, _, Red _)) -> Black t(* re-color *)  | dict -> dict), ! oldEntry)) in Set (n, dict\') (* Remove an item.  Raises LibBase.NotFound if not found. *) type color = RedColor | BlackColor type zipper = Top | LeftRed of (\'a entry * \'a dict * \'a zipper) | LeftBlack of (\'a entry * \'a dict * \'a zipper) | RightRed of (\'a dict * \'a entry * \'a zipper) | RightBlack of (\'a dict * \'a entry * \'a zipper) let rec delete (Set (nItems, t), k)  = (* bbZip propagates a black deficit up the tree until either the top\n         * is reached, or the deficit can be covered.  It returns a boolean\n         * that is true if there is still a deficit and the zipped tree.\n         *) let rec zip (Top, t)  = t | zip (LeftRed (x, b, z), a)  = zip (z, Red (x, a, b)) | zip (LeftBlack (x, b, z), a)  = zip (z, Black (x, a, b)) | zip (RightRed (a, x, z), b)  = zip (z, Red (x, a, b)) | zip (RightBlack (a, x, z), b)  = zip (z, Black (x, a, b)) let rec bbZip (Top, t)  = (true, t) | bbZip (LeftBlack (x, Red (y, c, d), z), a)  = (* case 1L *)  bbZip (LeftRed (x, c, LeftBlack (y, d, z)), a) | bbZip (LeftRed (x, Red (y, c, d), z), a)  = (* case 1L *)  bbZip (LeftRed (x, c, LeftBlack (y, d, z)), a) | bbZip (LeftBlack (x, Black (w, Red (y, c, d), e), z), a)  = (* case 3L *)  bbZip (LeftBlack (x, Black (y, c, Red (w, d, e)), z), a) | bbZip (LeftRed (x, Black (w, Red (y, c, d), e), z), a)  = (* case 3L *)  bbZip (LeftRed (x, Black (y, c, Red (w, d, e)), z), a) | bbZip (LeftBlack (x, Black (y, c, Red (w, d, e)), z), a)  = (* case 4L *)  (false, zip (z, Black (y, Black (x, a, c), Black (w, d, e)))) | bbZip (LeftRed (x, Black (y, c, Red (w, d, e)), z), a)  = (* case 4L *)  (false, zip (z, Red (y, Black (x, a, c), Black (w, d, e)))) | bbZip (LeftRed (x, Black (y, c, d), z), a)  = (* case 2L *)  (false, zip (z, Black (x, a, Red (y, c, d)))) | bbZip (LeftBlack (x, Black (y, c, d), z), a)  = (* case 2L *)  bbZip (z, Black (x, a, Red (y, c, d))) | bbZip (RightBlack (Red (y, c, d), x, z), b)  = (* case 1R *)  bbZip (RightRed (d, x, RightBlack (c, y, z)), b) | bbZip (RightRed (Red (y, c, d), x, z), b)  = (* case 1R *)  bbZip (RightRed (d, x, RightBlack (c, y, z)), b) | bbZip (RightBlack (Black (y, Red (w, c, d), e), x, z), b)  = (* case 3R *)  bbZip (RightBlack (Black (w, c, Red (y, d, e)), x, z), b) | bbZip (RightRed (Black (y, Red (w, c, d), e), x, z), b)  = (* case 3R *)  bbZip (RightRed (Black (w, c, Red (y, d, e)), x, z), b) | bbZip (RightBlack (Black (y, c, Red (w, d, e)), x, z), b)  = (* case 4R *)  (false, zip (z, Black (y, c, Black (x, Red (w, d, e), b)))) | bbZip (RightRed (Black (y, c, Red (w, d, e)), x, z), b)  = (* case 4R *)  (false, zip (z, Red (y, c, Black (x, Red (w, d, e), b)))) | bbZip (RightRed (Black (y, c, d), x, z), b)  = (* case 2R *)  (false, zip (z, Black (x, Red (y, c, d), b))) | bbZip (RightBlack (Black (y, c, d), x, z), b)  = (* case 2R *)  bbZip (z, Black (x, Red (y, c, d), b)) | bbZip (z, t)  = (false, zip (z, t)) let rec delMin (Red (y, Empty, b), z)  = (y, (false, zip (z, b))) | delMin (Black (y, Empty, b), z)  = (y, bbZip (z, b)) | delMin (Red (y, a, b), z)  = delMin (a, LeftRed (y, b, z)) | delMin (Black (y, a, b), z)  = delMin (a, LeftBlack (y, b, z)) let rec joinBlack (a, Empty, z)  = 2 (bbZip (z, a)) | joinBlack (Empty, b, z)  = 2 (bbZip (z, b)) | joinBlack (a, b, z)  = let (x, (needB, b\')) = delMin (b, Top) in if needB then 2 (bbZip (z, Black (x, a, b\'))) else zip (z, Black (x, a, b\')) let rec joinRed (Empty, Empty, z)  = zip (z, Empty) | joinRed (a, b, z)  = let (x, (needB, b\')) = delMin (b, Top) in if needB then 2 (bbZip (z, Red (x, a, b\'))) else zip (z, Red (x, a, b\')) let rec del (Empty, z)  = raise (Error "not found\\n") | del (Red (y as (k\', _), a, b), z)  = (match compare (k, k\') with LESS -> del (a, LeftRed (y, b, z)) | EQUAL -> joinRed (a, b, z) | GREATER -> del (b, RightRed (a, y, z))(* end case *) ) | del (Black (y as (k\', _), a, b), z)  = (match compare (k, k\') with LESS -> del (a, LeftBlack (y, b, z)) | EQUAL -> joinBlack (a, b, z) | GREATER -> del (b, RightBlack (a, y, z))(* end case *) ) in Set (nItems - 1, del (t, Top)) (* local *) (* does not apply f to all elements of S in order! *) let rec app f (Set (n, dict))  = let rec ap (Empty)  = () | ap (Red tree)  = ap\' tree | ap (Black tree)  = ap\' treeap\' (entry1 as (_, datum), left, right)  = (ap left; f datum; ap right) in ap dict let rec update f (Set (n, dict))  = let rec upd (Empty)  = Empty | upd (Red tree)  = Red (upd\' tree) | upd (Black tree)  = Black (upd\' tree)upd\' (entry1 as (k, datum), left, right)  = let left\' = upd left let datum\' = f datum let right\' = upd right in ((k, datum\'), left\', right\') in Set (n, upd dict) let rec forall (Set (n, dict)) f  = let rec ap (Empty)  = () | ap (Red tree)  = ap\' tree | ap (Black tree)  = ap\' treeap\' (entry, left, right)  = (ap left; f entry; ap right) in ap dict let rec existsOpt (Set (n, dict)) f  = let rec ap (Empty)  = NONE | ap (Red tree)  = ap\' tree | ap (Black tree)  = ap\' treeap\' (entry as (k, d), left, right)  = (if (f d) then (print "SUCCESS\\n"; SOME (k)) else (print "FAILED\\n"; (match (ap left) with NONE -> ap right | SOME (res) -> SOME (res)))) in ap dict let rec exists (Set (n, dict)) f  = let rec ap (Empty)  = false | ap (Red tree)  = ap\' tree | ap (Black tree)  = ap\' treeap\' (entry, left, right)  = if (f entry) then true else (if (ap left) then true else (ap right)) in ap dict let rec setsize (Set (n, _))  = n (* support for constructing red-black trees in linear time from increasing\n   * ordered sequences (based on a description by R. Hinze).  Note that the\n   * elements in the digits are ordered with the largest on the left, whereas\n   * the elements of the trees are ordered with the largest on the right.\n   *) (* functions for walking the tree while keeping a stack of parents\n   * to be visited.\n   *) let rec next ((t as Red (_, _, b)) :: rest)  = (t, left (b, rest)) | next ((t as Black (_, _, b)) :: rest)  = (t, left (b, rest)) | next _  = (Empty, [])left (Empty, rest)  = rest | left (t as Red (_, a, _), rest)  = left (a, t :: rest) | left (t as Black (_, a, _), rest)  = left (a, t :: rest) let rec start m  = left (m, []) type digit = ZERO | ONE of (\'a entry * \'a dict * \'a digit) | TWO of (\'a entry * \'a dict * \'a entry * \'a dict * \'a digit) (* add an item that is guaranteed to be larger than any in l *) let rec addItem (a, l)  = let rec incr (a, t, ZERO)  = ONE (a, t, ZERO) | incr (a1, t1, ONE (a2, t2, r))  = TWO (a1, t1, a2, t2, r) | incr (a1, t1, TWO (a2, t2, a3, t3, r))  = ONE (a1, t1, incr (a2, Black (a3, t3, t2), r)) in incr (a, Empty, l) (* link the digits into a tree *) let rec linkAll t  = let rec link (t, ZERO)  = t | link (t1, ONE (a, t2, r))  = link (Black (a, t2, t1), r) | link (t, TWO (a1, t1, a2, t2, r))  = link (Black (a1, Red (a2, t2, t1), t), r) in link (Empty, t) let rec getEntry (Red (x, _, _))  = x | getEntry (Black (x, _, _))  = x (* return the union of the two sets *) let rec union (Set (n1, s1), Set (n2, s2))  = let rec ins ((Empty, _), n, result)  = (n, result) | ins ((Red (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) | ins ((Black (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) let rec union\' (t1, t2, n, result)  = (match (next t1, next t2) with ((Empty, _), (Empty, _)) -> (n, result) | ((Empty, _), t2) -> ins (t2, n, result) | (t1, (Empty, _)) -> ins (t1, n, result) | ((tree1, r1), (tree2, r2)) -> let e1 as (x, d1) = getEntry tree1 let e2 as (y, d2) = getEntry tree2 in match compare (x, y) with LESS -> union\' (r1, t2, n + 1, addItem (e1, result)) | EQUAL -> union\' (r1, r2, n + 1, addItem (e1, result)) | GREATER -> union\' (t1, r2, n + 1, addItem (e2, result))) in match s1 with Empty -> Set (n2, s2) | _ -> (match s2 with Empty -> Set (n1, s1) | _ -> let (n, result) = union\' (start s1, start s2, 0, ZERO) in Set (n, linkAll result)) (* return the intersection of the two sets *) let rec intersection (Set (_, s1), Set (_, s2))  = let rec intersect (t1, t2, n, result)  = (match (next t1, next t2) with ((Empty, r), (tree, r\')) -> (n, result) | ((tree, r), (Empty, r\')) -> (n, result) | ((tree1, r1), (tree2, r2)) -> let e1 as (x, d1) = getEntry tree1 let e2 as (y, d2) = getEntry tree2 in match compare (x, y) with LESS -> intersect (r1, t2, n, result) | EQUAL -> intersect (r1, r2, n + 1, addItem (e1, result)) | GREATER -> intersect (t1, r2, n, result)) let (n, result) = intersect (start s1, start s2, 0, ZERO) in Set (n, linkAll result) (* return the set difference  S1 - S2 \n     if there are elements in S2 which do not appear in S1\n     they are ignored !*) let rec difference (Set (_, s1), Set (_, s2))  = let rec ins ((Empty, _), n, result)  = (n, result) | ins ((Red (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) | ins ((Black (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) let rec diff (t1, t2, n, result)  = (match (next t1, next t2) with ((Empty, _), _) -> (n, result) | (t1, (Empty, _)) -> ins (t1, n, result) | ((tree1, r1), (tree2, r2)) -> let e1 as (x, d1) = getEntry tree1 let e2 as (y, d2) = getEntry tree2 in match compare (x, y) with LESS -> diff (r1, t2, n + 1, addItem (e1, result)) | EQUAL -> diff (r1, r2, n, result) | GREATER -> diff (t1, r2, n, result)) let (n, result) = diff (start s1, start s2, 0, ZERO) in Set (n, linkAll result) (* returns difference (d1, d2) where d1 \n     contains all elements occurring in S1 but not in S2\n     and d2 contains all elements occurring in S2 but not in S1\n       *) let rec difference2 (Set (_, s1), Set (_, s2))  = let rec ins ((Empty, _), n, result)  = (n, result) | ins ((Red (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) | ins ((Black (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) let rec diff (t1, t2, (n1, result1), (n2, result2))  = (match (next t1, next t2) with ((Empty, _), t2) -> ((n1, result1), ins (t2, n2, result2)) | (t1, (Empty, _)) -> (ins (t1, n1, result1), (n2, result2)) | ((tree1, r1), (tree2, r2)) -> let e1 as (x, d1) = getEntry tree1 let e2 as (y, d2) = getEntry tree2 in match compare (x, y) with LESS -> diff (r1, t2, (n1 + 1, addItem (e1, result1)), (n2, result2)) | EQUAL -> diff (r1, r2, (n1, result1), (n2, result2)) | GREATER -> diff (t1, r2, (n1, result1), (n2 + 1, addItem (e2, result2)))) let ((n1, result1), (n2, result2)) = diff (start s1, start s2, (0, ZERO), (0, ZERO)) in (Set (n1, linkAll result1), Set (n2, linkAll result2)) (* S1 - S2 = R1 \n      S2 - S1 = R2\n      intersection (S1, S2) requires \n      for all (x, d1) in S1 \n        and (x, d2) in S2, d1 ~ d2\n    *) let rec diffMod F (Set (_, s1), Set (_, s2))  = let rec ins ((Empty, _), n, result)  = (n, result) | ins ((Red (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) | ins ((Black (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) let rec diff (t1, t2, (n1, result1), (n2, result2))  = (match (next t1, next t2) with ((Empty, _), t2) -> ((n1, result1), ins (t2, n2, result2)) | (t1, (Empty, _)) -> (ins (t1, n1, result1), (n2, result2)) | ((tree1, r1), (tree2, r2)) -> let e1 as (x, d1) = getEntry tree1 let e2 as (y, d2) = getEntry tree2 in match compare (x, y) with LESS -> diff (r1, t2, (n1 + 1, addItem (e1, result1)), (n2, result2)) | EQUAL -> ((F d1 d2); diff (r1, r2, (n1, result1), (n2, result2))) | GREATER -> diff (t1, r2, (n1, result1), (n2 + 1, addItem (e2, result2)))) let ((n1, result1), (n2, result2)) = diff (start s1, start s2, (0, ZERO), (0, ZERO)) in (Set (n1, linkAll result1), Set (n2, linkAll result2)) let rec splitSets F (Set (_, s1), Set (_, s2))  = let rec ins ((Empty, _), n, result)  = (n, result) | ins ((Red (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) | ins ((Black (x, _, _), r), n, result)  = ins (next r, n + 1, addItem (x, result)) let rec split (t1, t2, nr as (n, result), nr1 as (n1, result1), nr2 as (n2, result2))  = (match (next t1, next t2) with ((Empty, _), t2) -> (nr, nr1, ins (t2, n2, result2)) | (t1, (Empty, _)) -> (nr, ins (t1, n1, result1), nr2) | ((tree1, r1), (tree2, r2)) -> let e1 as (x, d1) = getEntry tree1 let e2 as (y, d2) = getEntry tree2 in match compare (x, y) with LESS -> split (r1, t2, nr, (n1 + 1, addItem (e1, result1)), nr2) | EQUAL -> (match (F d1 d2) with NONE -> split (r1, r2, nr, (n1 + 1, addItem (e1, result1)), (n2 + 1, addItem (e2, result2))) | SOME (d) -> split (r1, r2, (n + 1, addItem ((x, d), result)), nr1, nr2)) | GREATER -> split (t1, r2, nr, nr1, (n2 + 1, addItem (e2, result2)))) let ((n, r), (n1, r1), (n2, r2)) = split (start s1, start s2, (0, ZERO), (0, ZERO), (0, ZERO)) in (Set (n, linkAll r), Set (n1, linkAll r1), Set (n2, linkAll r2)) let rec new ()  = ref (empty) (* ignore size hint *) let rec copy S  = let S\' = new () in S\' := (! S); S\' let insert = (fun set -> fun entry -> (set := insert (! set, entry))) let insertLast = (fun set -> fun datum -> (set := insertLast (! set, datum))) let insertList = (fun set -> fun list -> (set := insertList (! set, list))) let insertShadow = (fun set -> fun entry -> (set := insertShadow (! set, entry))) let isEmpty = (fun ordSet -> isEmpty (! ordSet)) let last = (fun ordSet -> last (! ordSet)) let lookup = (fun ordSet -> fun key -> lookup (! ordSet) key) let clear = (fun ordSet -> (ordSet := empty)) let app = (fun ordSet -> fun f -> app f (! ordSet)) let update = (fun ordSet -> fun f -> ((ordSet := (update f (! ordSet)); ordSet))) let forall = (fun ordSet -> fun f -> forall (! ordSet) f) let exists = (fun ordSet -> fun f -> exists (! ordSet) f) let existsOpt = (fun ordSet -> fun f -> existsOpt (! ordSet) f) let rec size S  = setsize (! S) let difference = (fun set1 -> fun set2 -> (let set = new () in set := difference (! set1, ! set2); set)) let difference2 = (fun set1 -> fun set2 -> (let r1 = new () let r2 = new () let (rset1, rset2) = difference2 (! set1, ! set2) in r1 := rset1; r2 := rset2; (r1, r2))) let differenceModulo = (fun set1 -> fun set2 -> fun F -> (let r1 = new () let r2 = new () let (rset1, rset2) = diffMod F (! set1, ! set2) in r1 := rset1; r2 := rset2; (r1, r2))) let splitSets = (fun set1 -> fun set2 -> fun F -> (let r1 = new () let r2 = new () let r = new () let (rset, rset1, rset2) = splitSets F (! set1, ! set2) in r := rset; r1 := rset1; r2 := rset2; (r, r1, r2))) let intersection = (fun set1 -> fun set2 -> (let set = new () in set := intersection (! set1, ! set2); set)) let union = (fun set1 -> fun set2 -> (let set = new () in set := union (! set1, ! set2); set))  end\n(* functor RedBlackSet *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Hash Tables *) (* Author: Frank Pfenning *) module HashTable (type key'val hash : key' -> intval eq : key' * key' -> bool)TABLE where keykey' = struct type key = key' type 'aentry = key * 'a (* A hashtable bucket is a linked list of mutable elements *)  (* A hashtable is an array of buckets containing entries paired with hash values *)  type bucket = Nil | Cons of 'a ref * 'a bucket ref type 'aTable = int * 'a entry bucket array * int let rec new (n)  = (array (n, Nil), n) let rec insertShadow (a, n) (e as (key, datum))  = let hashVal = hash key let index = hashVal mod n let bucket = sub (a, index) let rec insertB (Cons (r' as ref (hash', e' as (key', datum')), br'))  = if hashVal = hash' && eq (key, key') then (r' := (hashVal, e); SOME (e')) else insertBR (br')insertBR (br as ref (Nil))  = (br := Cons (ref (hashVal, e), ref Nil); NONE) | insertBR (br)  = insertB (! br) let rec insertA (Nil)  = (update (a, index, Cons (ref (hashVal, e), ref Nil)); NONE) | insertA (bucket)  = insertB (bucket) in insertA bucket let rec insert h e  = (insertShadow h e; ()) let rec lookup (a, n) key  = let hashVal = hash key let rec lookup' (Cons (ref (hash1, (key1, datum1)), br))  = if hashVal = hash1 && eq (key, key1) then SOME (datum1) else lookup' (! br) | lookup' (Nil)  = NONE let bucket = sub (a, hashVal mod n) in lookup' bucket let rec clear (a, n)  = modify (fun _ -> Nil) a let rec appBucket f (Nil)  = () | appBucket f (Cons (ref (_, e), br))  = (f e; appBucket f (! br)) let rec app f (a, n)  = app (appBucket f) a end\n(* functor HashTable *) module type STRING_HASH = sig val stringHash : string -> int end\nmodule StringHashSTRING_HASH = struct let rec stringHash (s)  = (* sample 4 characters from string *)  let rec num (i)  = ord (sub (s, i)) mod 128 let n = size (s) in if n = 0 then 0 else let a = n - 1 let b = n div 2 let c = b div 2 let d = b + c in num (a) + 128 * (num (b) + 128 * (num (c) + 128 * num (d))) end\n(* structure StringHash *) module StringHashTableTABLE where keystring = HashTable()\n", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: (* String Hash Table *) (* Author: Frank Pfenning *) module type STRING_HASH = sig val stringHash : string -> int end

('Error parsing code:', "(* Rings (aka cyclic lists) *) (* Author: Carsten Schuermann *) module RingRING = struct exception Empty type 'aring = 'a list * 'a list (* Representation Invariant:  \n     ([an,...,ai+1], [a1,...,ai]) represents\n     [a1,...,ai,ai+1,...,an] wrapping around\n  *)  (* empty q = true if q = [], false otherwise *)  let rec empty (nil, nil)  = true | empty _  = false (* init l = l (as ring) *)  let rec init l  = (nil, l) (* insert ([], x) = [x]\n     insert ([a1, a2 ... an], x) = [x, a1, a2, ... an]\n  *)  let rec insert ((r, l), y)  = (r, y :: l) (* current [] = raise Empty\n     current [a1, a2 ... an] = a1\n  *)  let rec current (nil, nil)  = raise (Empty) | current (_, x :: _)  = x | current (l, nil)  = current (nil, rev l) (* next [] = raise Empty\n     next [a1, a2 ... an]) = [a2 ... an, a1]\n  *)  let rec next (nil, nil)  = raise (Empty) | next (r, nil)  = next (nil, rev r) | next (r, x :: l)  = (x :: r, l) (* previous [] = ERROR\n     previous [a1, a2 ... an]) = [a2 ... an, a1]\n  *)  let rec previous (nil, nil)  = raise (Empty) | previous (nil, l)  = previous (rev l, nil) | previous (x :: r, l)  = (r, x :: l) (* delete [] = raise Empty\n     delete [a1, a2 ... an] = [a2 ... an]\n  *)  let rec delete (nil, nil)  = raise (Empty) | delete (r, nil)  = delete (nil, rev r) | delete (r, x :: l)  = (r, l) (* foldr is inefficient *)  let rec foldr f i (r, l)  = foldr f i (l @ rev r) (* order of map is undefined.  relevant? *)  let rec map f (r, l)  = (map f r, map f l) end\n(* structure Ring *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Red/Black Trees *) (* Author: Frank Pfenning *) module RedBlackTree (type key'val compare : key' * key' -> order)TABLE where keykey' = struct type key = key' type 'aentry = key * 'a type dict = Empty | Red of 'a entry * 'a dict * 'a dict | Black of 'a entry * 'a dict * 'a dict type 'aTable = 'a dict ref (* Representation Invariants *)  (*\n     1. The tree is ordered: for every node Red((key1,datum1), left, right) or\n        Black ((key1,datum1), left, right), every key in left is less than\n        key1 and every key in right is greater than key1.\n\n     2. The children of a red node are black (color invariant).\n\n     3. Every path from the root to a leaf has the same number of\n        black nodes, called the black height of the tree.\n  *)  let rec lookup dict key  = let rec lk (Empty)  = NONE | lk (Red tree)  = lk' tree | lk (Black tree)  = lk' treelk' ((key1, datum1), left, right)  = (match compare (key, key1) with EQUAL -> SOME (datum1) | LESS -> lk left | GREATER -> lk right) in lk dict (* val restore_right : 'a dict -> 'a dict *) (*\n     restore_right (Black(e,l,r)) >=> dict\n     where (1) Black(e,l,r) is ordered,\n           (2) Black(e,l,r) has black height n,\n\t   (3) color invariant may be violated at the root of r:\n               one of its children might be red.\n     and dict is a re-balanced red/black tree (satisfying all invariants)\n     and same black height n.\n  *) let rec restore_right (Black (e, Red lt, Red (rt as (_, Red _, _))))  = Red (e, Black lt, Black rt) | restore_right (Black (e, Red lt, Red (rt as (_, _, Red _))))  = Red (e, Black lt, Black rt) | restore_right (Black (e, l, Red (re, Red (rle, rll, rlr), rr)))  = (* l is black, deep rotate *)  Black (rle, Red (e, l, rll), Red (re, rlr, rr)) | restore_right (Black (e, l, Red (re, rl, rr as Red _)))  = (* l is black, shallow rotate *)  Black (re, Red (e, l, rl), rr) | restore_right dict  = dict (* restore_left is like restore_right, except *) (* the color invariant may be violated only at the root of left child *) let rec restore_left (Black (e, Red (lt as (_, Red _, _)), Red rt))  = Red (e, Black lt, Black rt) | restore_left (Black (e, Red (lt as (_, _, Red _)), Red rt))  = Red (e, Black lt, Black rt) | restore_left (Black (e, Red (le, ll as Red _, lr), r))  = (* r is black, shallow rotate *)  Black (le, ll, Red (e, lr, r)) | restore_left (Black (e, Red (le, ll, Red (lre, lrl, lrr)), r))  = (* r is black, deep rotate *)  Black (lre, Red (le, ll, lrl), Red (e, lrr, r)) | restore_left dict  = dict let rec insert (dict, entry as (key, datum))  = (* val ins : 'a dict -> 'a dict  inserts entry *) (* ins (Red _) may violate color invariant at root *) (* ins (Black _) or ins (Empty) will be red/black tree *) (* ins preserves black height *) let rec ins (Empty)  = Red (entry, Empty, Empty) | ins (Red (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> Red (entry, left, right) | LESS -> Red (entry1, ins left, right) | GREATER -> Red (entry1, left, ins right)) | ins (Black (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> Black (entry, left, right) | LESS -> restore_left (Black (entry1, ins left, right)) | GREATER -> restore_right (Black (entry1, left, ins right))) in match ins dict with Red (t as (_, Red _, _)) -> Black t(* re-color *)  | Red (t as (_, _, Red _)) -> Black t(* re-color *)  | dict -> dict (* use non-imperative version? *) let rec insertShadow (dict, entry as (key, datum))  = (* : 'a entry option ref *) let oldEntry = ref NONE let rec ins (Empty)  = Red (entry, Empty, Empty) | ins (Red (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> (oldEntry := SOME (entry1); Red (entry, left, right)) | LESS -> Red (entry1, ins left, right) | GREATER -> Red (entry1, left, ins right)) | ins (Black (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> (oldEntry := SOME (entry1); Black (entry, left, right)) | LESS -> restore_left (Black (entry1, ins left, right)) | GREATER -> restore_right (Black (entry1, left, ins right))) in (oldEntry := NONE; ((match ins dict with Red (t as (_, Red _, _)) -> Black t(* re-color *)  | Red (t as (_, _, Red _)) -> Black t(* re-color *)  | dict -> dict), ! oldEntry)) let rec app f dict  = let rec ap (Empty)  = () | ap (Red tree)  = ap' tree | ap (Black tree)  = ap' treeap' (entry1, left, right)  = (ap left; f entry1; ap right) in ap dict let rec new (n)  = ref (Empty) (* ignore size hint *) let insert = (fun table -> fun entry -> (table := insert (! table, entry))) let insertShadow = (fun table -> fun entry -> let (dict, oldEntry) = insertShadow (! table, entry) in (table := dict; oldEntry)) let lookup = (fun table -> fun key -> lookup (! table) key) let clear = (fun table -> (table := Empty)) let app = (fun f -> fun table -> app f (! table))  end\n(* functor RedBlackTree *) module StringRedBlackTree = RedBlackTree()module IntRedBlackTree = RedBlackTree()", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (* String Hash Table *) (* Author: Frank Pfenning *) module StringHashSTRING_HASH = struct let rec stringHash (s)  = (* sample 4 characters from string *)  let rec num (i)  = ord (sub (s, i)) mod 128 let n = size (s) in if n = 0 then 0 else let a = n - 1 let b = n div 2 let c = b div 2 let d = b + c in num (a) + 128 * (num (b) + 128 * (num (c) + 128 * num (d))) end
(* structure StringHash *) 
('Error parsing code:', "(* Sparse 1-Dimensional Arrays *) (* Author: Roberto Virga *) module type SPARSE_ARRAY = sig type 'aarrayval array : 'a -> 'a arrayval sub : ('a array * int) -> 'aval update : ('a array * int * 'a) -> unitval extract : ('a array * int * int) -> 'a vectorval copyVec : {src: 'a vector; si: int; len: int option; dst: 'a array; di: int} -> unitval app : ((int * 'a) -> unit) -> ('a array * int * int) -> unitval foldl : ((int * 'a * 'b) -> 'b) -> 'b -> ('a array * int * int) -> 'bval foldr : ((int * 'a * 'b) -> 'b) -> 'b -> ('a array * int * int) -> 'bval modify : ((int * 'a) -> 'a) -> ('a array * int * int) -> unit end\n(* signature SPARSE_ARRAY *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Sparse 2-Dimensional Arrays *) (* Author: Roberto Virga *) module type SPARSE_ARRAY2 = sig type 'aarraytype 'aregion = {base: 'a array; row: int; col: int; nrows: int; ncols: int}type traversalRowMajorColMajorval array : 'a -> 'a arrayval sub : ('a array * int * int) -> 'aval update : ('a array * int * int * 'a) -> unitval row : ('a array * int * (int * int)) -> 'a vectorval column : ('a array * int * (int * int)) -> 'a vectorval app : traversal -> ((int * int * 'a) -> unit) -> 'a region -> unitval fold : traversal -> ((int * int * 'a * 'b) -> 'b) -> 'b -> 'a region -> 'bval modify : traversal -> ((int * int * 'a) -> 'a) -> 'a region -> unit end\n(* signature SPARSE_ARRAY2 *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Queues *) (* Author: Frank Pfenning *) module type QUEUE = sig type 'aqueueval empty : 'a queueval insert : 'a * 'a queue -> 'a queueval delete : 'a queue -> 'a * 'a queue optionval insertFront : 'a * 'a queue -> 'a queueval deleteEnd : 'a queue -> 'a * 'a queue option(* If  toList (q) ==> (l, SOME(q')) *) (* then q == q' and toList q' is constant time *) val toList : 'a queue -> 'a list * 'a queue option end\n(* signature QUEUE *) ", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Sets *) (* Author: Brigitte Pientka *) (* This provides a common interface to ordered sets *) (* based on red/black trees *) module type RBSET = sig type key = int(* parameter *) type 'aentry = key * 'aexception Error of stringtype 'aordSetval new : unit -> 'a ordSetval copy : 'a ordSet -> 'a ordSetval insert : 'a ordSet -> 'a entry -> unitval insertList : 'a ordSet -> 'a entry list -> unitval insertShadow : 'a ordSet -> 'a entry -> unitval insertLast : 'a ordSet -> 'a -> unit(*  val delete : 'a ordSet -> key -> unit*) val lookup : 'a ordSet -> key -> 'a optionval isEmpty : 'a ordSet -> boolval last : 'a ordSet -> 'a entryval clear : 'a ordSet -> unit(* Applies f:'a -> unit to all entries in the set\n     pre-order traversal *) val app : 'a ordSet -> ('a -> unit) -> unitval update : 'a ordSet -> ('a -> 'a) -> 'a ordSet(* Applies f:'a entry -> unit to all entries in the set\n     pre-order traversal *) val forall : 'a ordSet -> ('a entry -> unit) -> unit(*  val exists : 'a ordSet -> ('a entry -> 'b option) -> ('a entry (* key * 'a *) * 'b) option *) val exists : 'a ordSet -> ('a entry -> bool) -> boolval existsOpt : 'a ordSet -> ('a -> bool) -> int optionval size : 'a ordSet -> intval union : 'a ordSet -> 'a ordSet -> 'a ordSetval difference : 'a ordSet -> 'a ordSet -> 'a ordSetval difference2 : 'a ordSet -> 'a ordSet -> ('a ordSet * 'a ordSet)val differenceModulo : 'a ordSet -> 'b ordSet -> ('a -> 'b -> unit) -> ('a ordSet * 'b ordSet)(* splits two sets into S1, S2, S3 *) val splitSets : 'a ordSet -> 'a ordSet -> ('a -> 'a -> 'a option) -> ('a ordSet * 'a ordSet * 'a ordSet)val intersection : 'a ordSet -> 'a ordSet -> 'a ordSet end\n(* signature RBSET *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Red/Black Trees *) (* Author: Frank Pfenning *) module RedBlackTree (type key'val compare : key' * key' -> order)TABLE where keykey' = struct type key = key' type 'aentry = key * 'a type dict = Empty | Red of 'a entry * 'a dict * 'a dict | Black of 'a entry * 'a dict * 'a dict type 'aTable = 'a dict ref (* Representation Invariants *)  (*\n     1. The tree is ordered: for every node Red((key1,datum1), left, right) or\n        Black ((key1,datum1), left, right), every key in left is less than\n        key1 and every key in right is greater than key1.\n\n     2. The children of a red node are black (color invariant).\n\n     3. Every path from the root to a leaf has the same number of\n        black nodes, called the black height of the tree.\n  *)  let rec lookup dict key  = let rec lk (Empty)  = NONE | lk (Red tree)  = lk' tree | lk (Black tree)  = lk' treelk' ((key1, datum1), left, right)  = (match compare (key, key1) with EQUAL -> SOME (datum1) | LESS -> lk left | GREATER -> lk right) in lk dict (* val restore_right : 'a dict -> 'a dict *) (*\n     restore_right (Black(e,l,r)) >=> dict\n     where (1) Black(e,l,r) is ordered,\n           (2) Black(e,l,r) has black height n,\n           (3) color invariant may be violated at the root of r:\n               one of its children might be red.\n     and dict is a re-balanced red/black tree (satisfying all invariants)\n     and same black height n.\n  *) let rec restore_right (Black (e, Red lt, Red (rt as (_, Red _, _))))  = Red (e, Black lt, Black rt) | restore_right (Black (e, Red lt, Red (rt as (_, _, Red _))))  = Red (e, Black lt, Black rt) | restore_right (Black (e, l, Red (re, Red (rle, rll, rlr), rr)))  = (* l is black, deep rotate *)  Black (rle, Red (e, l, rll), Red (re, rlr, rr)) | restore_right (Black (e, l, Red (re, rl, rr as Red _)))  = (* l is black, shallow rotate *)  Black (re, Red (e, l, rl), rr) | restore_right dict  = dict (* restore_left is like restore_right, except *) (* the color invariant may be violated only at the root of left child *) let rec restore_left (Black (e, Red (lt as (_, Red _, _)), Red rt))  = Red (e, Black lt, Black rt) | restore_left (Black (e, Red (lt as (_, _, Red _)), Red rt))  = Red (e, Black lt, Black rt) | restore_left (Black (e, Red (le, ll as Red _, lr), r))  = (* r is black, shallow rotate *)  Black (le, ll, Red (e, lr, r)) | restore_left (Black (e, Red (le, ll, Red (lre, lrl, lrr)), r))  = (* r is black, deep rotate *)  Black (lre, Red (le, ll, lrl), Red (e, lrr, r)) | restore_left dict  = dict let rec insert (dict, entry as (key, datum))  = (* val ins : 'a dict -> 'a dict  inserts entry *) (* ins (Red _) may violate color invariant at root *) (* ins (Black _) or ins (Empty) will be red/black tree *) (* ins preserves black height *) let rec ins (Empty)  = Red (entry, Empty, Empty) | ins (Red (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> Red (entry, left, right) | LESS -> Red (entry1, ins left, right) | GREATER -> Red (entry1, left, ins right)) | ins (Black (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> Black (entry, left, right) | LESS -> restore_left (Black (entry1, ins left, right)) | GREATER -> restore_right (Black (entry1, left, ins right))) in match ins dict with Red (t as (_, Red _, _)) -> Black t(* re-color *)  | Red (t as (_, _, Red _)) -> Black t(* re-color *)  | dict -> dict (* function below from .../smlnj-lib/Util/int-redblack-set.sml *) (* Need to check and improve some time *) (* Sun Mar 13 08:22:53 2005 -fp *) (* Remove an item.  Returns true if old item found, false otherwise *) exception NotFound type zipper = TOP | LEFTB of ('a entry * 'a dict * 'a zipper) | LEFTR of ('a entry * 'a dict * 'a zipper) | RIGHTB of ('a dict * 'a entry * 'a zipper) | RIGHTR of ('a dict * 'a entry * 'a zipper) let rec delete t key  = (* bbZip propagates a black deficit up the tree until either the top\n         * is reached, or the deficit can be covered.  It returns a boolean\n         * that is true if there is still a deficit and the zipped tree.\n         *) let rec zip (TOP, t)  = t | zip (LEFTB (x, b, z), a)  = zip (z, Black (x, a, b)) | zip (LEFTR (x, b, z), a)  = zip (z, Red (x, a, b)) | zip (RIGHTB (a, x, z), b)  = zip (z, Black (x, a, b)) | zip (RIGHTR (a, x, z), b)  = zip (z, Red (x, a, b)) let rec bbZip (TOP, t)  = (true, t) | bbZip (LEFTB (x, Red (y, c, d), z), a)  = (* case 1L *)  bbZip (LEFTR (x, c, LEFTB (y, d, z)), a) | bbZip (LEFTB (x, Black (w, Red (y, c, d), e), z), a)  = (* case 3L *)  bbZip (LEFTB (x, Black (y, c, Red (w, d, e)), z), a) | bbZip (LEFTR (x, Black (w, Red (y, c, d), e), z), a)  = (* case 3L *)  bbZip (LEFTR (x, Black (y, c, Red (w, d, e)), z), a) | bbZip (LEFTB (x, Black (y, c, Red (w, d, e)), z), a)  = (* case 4L *)  (false, zip (z, Black (y, Black (x, a, c), Black (w, d, e)))) | bbZip (LEFTR (x, Black (y, c, Red (w, d, e)), z), a)  = (* case 4L *)  (false, zip (z, Red (y, Black (x, a, c), Black (w, d, e)))) | bbZip (LEFTR (x, Black (y, c, d), z), a)  = (* case 2L *)  (false, zip (z, Black (x, a, Red (y, c, d)))) | bbZip (LEFTB (x, Black (y, c, d), z), a)  = (* case 2L *)  bbZip (z, Black (x, a, Red (y, c, d))) | bbZip (RIGHTB (Red (y, c, d), x, z), b)  = (* case 1R *)  bbZip (RIGHTR (d, x, RIGHTB (c, y, z)), b) | bbZip (RIGHTR (Red (y, c, d), x, z), b)  = (* case 1R *)  bbZip (RIGHTR (d, x, RIGHTB (c, y, z)), b) | bbZip (RIGHTB (Black (y, Red (w, c, d), e), x, z), b)  = (* case 3R *)  bbZip (RIGHTB (Black (w, c, Red (y, d, e)), x, z), b) | bbZip (RIGHTR (Black (y, Red (w, c, d), e), x, z), b)  = (* case 3R *)  bbZip (RIGHTR (Black (w, c, Red (y, d, e)), x, z), b) | bbZip (RIGHTB (Black (y, c, Red (w, d, e)), x, z), b)  = (* case 4R *)  (false, zip (z, Black (y, c, Black (x, Red (w, d, e), b)))) | bbZip (RIGHTR (Black (y, c, Red (w, d, e)), x, z), b)  = (* case 4R *)  (false, zip (z, Red (y, c, Black (w, Red (w, d, e), b)))) | bbZip (RIGHTR (Black (y, c, d), x, z), b)  = (* case 2R *)  (false, zip (z, Black (x, Red (y, c, d), b))) | bbZip (RIGHTB (Black (y, c, d), x, z), b)  = (* case 2R *)  bbZip (z, Black (x, Red (y, c, d), b)) | bbZip (z, t)  = (false, zip (z, t)) let rec delMin (Red (y, Empty, b), z)  = (y, (false, zip (z, b))) | delMin (Black (y, Empty, b), z)  = (y, bbZip (z, b)) | delMin (Black (y, a, b), z)  = delMin (a, LEFTB (y, b, z)) | delMin (Red (y, a, b), z)  = delMin (a, LEFTR (y, b, z)) | delMin (Empty, _)  = raise (Match) let rec joinRed (Empty, Empty, z)  = zip (z, Empty) | joinRed (a, b, z)  = let (x, (needB, b')) = delMin (b, TOP) in if needB then 2 (bbZip (z, Red (x, a, b'))) else zip (z, Red (x, a, b')) let rec joinBlack (a, Empty, z)  = 2 (bbZip (z, a)) | joinBlack (Empty, b, z)  = 2 (bbZip (z, b)) | joinBlack (a, b, z)  = let (x, (needB, b')) = delMin (b, TOP) in if needB then 2 (bbZip (z, Black (x, a, b'))) else zip (z, Black (x, a, b')) let rec del (Empty, z)  = raise (NotFound) | del (Black (entry1 as (key1, datum1), a, b), z)  = (match compare (key, key1) with EQUAL -> joinBlack (a, b, z) | LESS -> del (a, LEFTB (entry1, b, z)) | GREATER -> del (b, RIGHTB (a, entry1, z))) | del (Red (entry1 as (key1, datum1), a, b), z)  = (match compare (key, key1) with EQUAL -> joinRed (a, b, z) | LESS -> del (a, LEFTR (entry1, b, z)) | GREATER -> del (b, RIGHTR (a, entry1, z))) in try  with (* local *) (* use non-imperative version? *) let rec insertShadow (dict, entry as (key, datum))  = (* : 'a entry option ref *) let oldEntry = ref NONE let rec ins (Empty)  = Red (entry, Empty, Empty) | ins (Red (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> (oldEntry := SOME (entry1); Red (entry, left, right)) | LESS -> Red (entry1, ins left, right) | GREATER -> Red (entry1, left, ins right)) | ins (Black (entry1 as (key1, datum1), left, right))  = (match compare (key, key1) with EQUAL -> (oldEntry := SOME (entry1); Black (entry, left, right)) | LESS -> restore_left (Black (entry1, ins left, right)) | GREATER -> restore_right (Black (entry1, left, ins right))) in (oldEntry := NONE; ((match ins dict with Red (t as (_, Red _, _)) -> Black t(* re-color *)  | Red (t as (_, _, Red _)) -> Black t(* re-color *)  | dict -> dict), ! oldEntry)) let rec app f dict  = let rec ap (Empty)  = () | ap (Red tree)  = ap' tree | ap (Black tree)  = ap' treeap' (entry1, left, right)  = (ap left; f entry1; ap right) in ap dict let rec new (n)  = ref (Empty) (* ignore size hint *) let insert = (fun table -> fun entry -> (table := insert (! table, entry))) let insertShadow = (fun table -> fun entry -> let (dict, oldEntry) = insertShadow (! table, entry) in (table := dict; oldEntry)) let lookup = (fun table -> fun key -> lookup (! table) key) let delete = (fun table -> fun key -> (delete (! table) key; ())) let clear = (fun table -> (table := Empty)) let app = (fun f -> fun table -> app f (! table))  end\n(* functor RedBlackTree *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Hash Tables *) (* Author: Frank Pfenning *) (* Modified: Roberto Virga *) (* This provides a common interface to hash tables *) (* red/black trees and similar data structures *) module type TABLE = sig type key(* parameter *) type 'aentry = key * 'atype 'aTableval new : int -> 'a Table(* size hint for some implementations *) val insert : 'a Table -> 'a entry -> unit(* insert entry, return shadowed entry if there is one *) val insertShadow : 'a Table -> 'a entry -> 'a entry optionval lookup : 'a Table -> key -> 'a optionval delete : 'a Table -> key -> unitval clear : 'a Table -> unit(* Apply function to all entries in unpredictable order *) val app : ('a entry -> unit) -> 'a Table -> unit end\n(* signature TABLE *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Sparse 2-Dimensional Arrays *) (* Author: Roberto Virga *) module SparseArray2 (module IntTable : TABLE where keyint)SPARSE_ARRAY2 = struct type 'aarray = {default: 'a; table: 'a Table} type 'aregion = {base: 'a array; row: int; col: int; nrows: int; ncols: int} type traversal = RowMajor | ColMajor let size = 29 let rec fromInt (code)  = let rec fromInt' r  = let code' = (r + 1) * (r + 2) div 2 in if (code < code') then let diff = code' - code - 1 in (diff, r - diff) else fromInt' (r + 1) in fromInt' 0 let rec toInt (m, n)  = let sum = m + n in sum * (sum + 1) div 2 + n let rec unsafeSub ({table; default}, i, j)  = match (lookup table (toInt (i, j))) with NONE -> default | SOME (v) -> v let rec unsafeUpdate ({table; default}, i, j, v)  = insert table (toInt (i, j), v) let rec checkRegion {base; row; col; nrows; ncols}  = (row >= 0) && (col >= 0) && (nrows >= 0) && (ncols >= 0) let rec array default  = {default = default; table = new size} let rec sub (array, i, j)  = if (i >= 0) && (j >= 0) then unsafeSub (array, i, j) else raise (Subscript) let rec update (array, i, j, v)  = if (i >= 0) && (j >= 0) then unsafeUpdate (array, i, j, v) else raise (Subscript) let rec row (array, i, (j, len))  = if (i >= 0) && (j >= 0) && (len >= 0) then tabulate (len, (fun off -> unsafeSub (array, i, j + off))) else raise (Subscript) let rec column (array, j, (i, len))  = if (j >= 0) && (i >= 0) && (len >= 0) then tabulate (len, (fun off -> unsafeSub (array, i + off, j))) else raise (Subscript) let rec app traversal f (region as {base; row; col; nrows; ncols})  = if checkRegion region then let rmax = row + nrows let cmax = col + ncols let rec appR (row', col')  = if (row' < rmax) then if (col' < cmax) then (f (row', col', unsafeSub (base, row', col')); appR (row', col' + 1)) else appR (row' + 1, col) else () let rec appC (row', col')  = if (col' < cmax) then if (row' < rmax) then (f (row', col', unsafeSub (base, row', col')); appC (row' + 1, col')) else appC (row, col' + 1) else () in match traversal with RowMajor -> appR (row, col) | ColMajor -> appC (row, col) else raise (Subscript) let rec fold traversal f init (region as {base; row; col; nrows; ncols})  = if checkRegion region then let rmax = row + nrows let cmax = col + ncols let rec foldR (row', col')  = if (row' < rmax) then if (col' < cmax) then f (row', col', unsafeSub (base, row', col'), foldR (row', col' + 1)) else foldR (row' + 1, col) else init let rec foldC (row', col')  = if (col' < cmax) then if (row' < rmax) then f (row', col', unsafeSub (base, row', col'), foldC (row' + 1, col')) else foldC (row, col' + 1) else init in match traversal with RowMajor -> foldR (row, col) | ColMajor -> foldC (row, col) else raise (Subscript) let rec modify traversal f (region as {base; row; col; nrows; ncols})  = if checkRegion region then let rmax = row + nrows let cmax = col + ncols let rec modifyR (row', col')  = if (row' < rmax) then if (col' < cmax) then (unsafeUpdate (base, row', col', f (row', col', unsafeSub (base, row', col'))); modifyR (row', col' + 1)) else modifyR (row' + 1, col) else () let rec modifyC (row', col')  = if (col' < cmax) then if (row' < rmax) then (unsafeUpdate (base, row', col', f (row', col', unsafeSub (base, row', col'))); modifyC (row' + 1, col')) else modifyC (row, col' + 1) else () in match traversal with RowMajor -> modifyR (row, col) | ColMajor -> modifyC (row, col) else raise (Subscript) end\n(* structure SparseArray2 *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Sparse 1-Dimensional Arrays *) (* Author: Roberto Virga *) module SparseArray (module IntTable : TABLE where keyint)SPARSE_ARRAY = struct type 'aarray = {default: 'a; table: 'a Table} let size = 29 let rec unsafeSub ({table; default}, i)  = match (lookup table i) with NONE -> default | SOME (v) -> v let rec unsafeUpdate ({table; default}, i, v)  = insert table (i, v) let rec array default  = {default = default; table = new size} let rec sub (array, i)  = if (i >= 0) then unsafeSub (array, i) else raise (Subscript) let rec update (array, i, v)  = if (i >= 0) then unsafeUpdate (array, i, v) else raise (Subscript) let rec extract (array, i, len)  = if (i >= 0) && (len >= 0) then tabulate (len, (fun off -> unsafeSub (array, i + off))) else raise (Subscript) let rec copyVec {src; si; len; dst; di}  = if (di >= 0) then appi (fun (i, v) -> unsafeUpdate (dst, i, v)) (slice (src, si, len)) else raise (Subscript) let rec app f (array, i, len)  = if (i >= 0) && (len >= 0) then let imax = i + len let rec app' i'  = if (i' < imax) then (f (i', unsafeSub (array, i')); app' (i' + 1)) else () in app' i else raise (Subscript) let rec foldl f init (array, i, len)  = if (i >= 0) && (len >= 0) then let rec foldl' i'  = if (i' >= i) then f (i', unsafeSub (array, i'), foldl' (i' - 1)) else init in foldl' (i + len - 1) else raise (Subscript) let rec foldr f init (array, i, len)  = if (i >= 0) && (len >= 0) then let imax = i + len let rec foldr' i'  = if (i' < imax) then f (i', unsafeSub (array, i'), foldr' (i' + 1)) else init in foldr' i else raise (Subscript) let rec modify f (array, i, len)  = if (i >= 0) && (len >= 0) then let imax = i + len let rec modify' i'  = if (i' < imax) then (unsafeUpdate (array, i', f (i', unsafeSub (array, i'))); modify' (i' + 1)) else () in modify' i else raise (Subscript) end\n(* structure SparseArray *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Hash Table *) (* Author: Frank Pfenning *) (* Modified: Roberto Virga *) module HashTable (type key'val hash : key' -> intval eq : key' * key' -> bool)TABLE where keykey' = struct type key = key' type 'aentry = key * 'a (* A hashtable bucket is a linked list of mutable elements *)  (* A hashtable is an array of buckets containing entries paired with hash values *)  type bucket = Nil | Cons of 'a ref * 'a bucket ref type 'aTable = int * 'a entry bucket array * int let rec new (n)  = (array (n, Nil), n) let rec insertShadow (a, n) (e as (key, datum))  = let hashVal = hash key let index = hashVal mod n let bucket = sub (a, index) let rec insertB (Cons (r' as ref (hash', e' as (key', datum')), br'))  = if hashVal = hash' && eq (key, key') then (r' := (hashVal, e); SOME (e')) else insertBR (br')insertBR (br as ref (Nil))  = (br := Cons (ref (hashVal, e), ref Nil); NONE) | insertBR (br)  = insertB (! br) let rec insertA (Nil)  = (update (a, index, Cons (ref (hashVal, e), ref Nil)); NONE) | insertA (bucket)  = insertB (bucket) in insertA bucket let rec insert h e  = (insertShadow h e; ()) let rec lookup (a, n) key  = let hashVal = hash key let rec lookup' (Cons (ref (hash1, (key1, datum1)), br))  = if hashVal = hash1 && eq (key, key1) then SOME (datum1) else lookup' (! br) | lookup' (Nil)  = NONE let bucket = sub (a, hashVal mod n) in lookup' bucket let rec delete (a, n) key  = let hashVal = hash key let index = hashVal mod n let bucket = sub (a, index) let rec deleteBR (br as ref (Cons (ref (hash1, (key1, _)), br1)))  = if hashVal = hash1 && eq (key, key1) then br := ! br1 else deleteBR br1 | deleteBR (br)  = () let rec deleteA (Nil)  = () | deleteA (Cons (ref (hash1, (key1, _)), br1))  = if hashVal = hash1 && eq (key, key1) then update (a, index, ! br1) else deleteBR br1 in deleteA bucket let rec clear (a, n)  = modify (fun _ -> Nil) a let rec appBucket f (Nil)  = () | appBucket f (Cons (ref (_, e), br))  = (f e; appBucket f (! br)) let rec app f (a, n)  = app (appBucket f) a end\n(* functor HashTable *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Unification on Formulas *) (* Author: Carsten Schuermann *) module TomegaUnify ((*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) module Conv : CONV(*! sharing Conv.IntSyn = IntSyn\' !*) module Normalize : NORMALIZE(*! sharing Normalize.IntSyn = IntSyn\' !*) (*! sharing Normalize.Tomega = Tomega\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module TomegaPrint : TOMEGAPRINT(*! sharing TomegaPrint.IntSyn = IntSyn\' !*) (*! sharing TomegaPrint.Tomega = Tomega\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) module Weaken : WEAKEN(*! sharing Weaken.IntSyn = IntSyn\' !*) ) : TOMEGAUNIFY = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  exception Unify of string module I = IntSynmodule T = Tomega(* unifyFor (Psi, F1, F2) = R\n\n       Invariant:\n       If   F1, F2 contain free variables X1 ... Xn\n       and  Psi |- F1 for\n       and  Psi |- F2 for\n       and  there exists an instantiation I for X1 ...Xn such that\n       and  Psi[I] |- F1[I] = F2[I]\n       then R = ()\n       otherwise exception Unify is raised\n    *) let rec unifyFor (Psi, F1, F2)  = unifyForN (Psi, forSub (F1, id), forSub (F2, id))unifyForN (Psi, True, True)  = () | unifyForN (Psi, Ex ((D1, _), F1), Ex ((D2, _), F2))  = (unifyDec (Psi, UDec D1, (UDec D2)); unifyFor (Decl (Psi, UDec D1), F1, F2)) | unifyForN (Psi, All ((D1, _), F1), All ((D2, _), F2))  = (unifyDec (Psi, D1, D2); unifyFor (Decl (Psi, D1), F1, F2)) | unifyForN (Psi, FVar (_, r), F)  = (r := SOME F) | unifyForN (Psi, F, FVar (_, r))  = (r := SOME F) | unifyForN (Psi, _, _)  = raise (Unify "Formula mismatch")(* unifyDec (Psi, D1, D2) = R\n\n       Invariant:\n       If   D1, D2 contain free variables X1 ... Xn\n       and  Psi |- D1 dec\n       and  Psi |- D2 dec\n       and  there exists an instantiation I for X1 ...Xn such that\n       and  Psi[I] |- D1[I] = D2[I]\n       then R = ()\n       otherwise exception Unify is raised\n    *) unifyDec (Psi, UDec D1, UDec D2)  = if convDec ((D1, id), (D2, id)) then () else raise (Unify "Declaration mismatch") | unifyDec (Psi, PDec (_, F1), PDec (_, F2))  = unifyFor (Psi, F1, F2) let unifyFor = unifyFor  end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Normalizer for Delphin meta level *) (* Author: Carsten Schuermann *) module type NORMALIZE = sig module IntSyn : INTSYNmodule Tomega : TOMEGAval normalizeFor : (For * Sub) -> Forval normalizePrg : (Prg * Sub) -> Prgval normalizeSpine : (Spine * Sub) -> Spineval normalizeSub : Sub -> Sub end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Converter from relational representation to a functional\n   representation of proof terms *) (* Author: Carsten Schuermann *) module Converter (module Global : GLOBAL(*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module Abstract : ABSTRACT(*! sharing Abstract.IntSyn = IntSyn\' !*) module ModeTable : MODETABLE(*! sharing ModeSyn.IntSyn = IntSyn\' !*) module Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Unify : UNIFY(*! sharing Unify.IntSyn = IntSyn\' !*) module Whnf : WHNF(*! sharing Whnf.IntSyn = IntSyn\' !*) module Print : PRINT(*! sharing Print.IntSyn = IntSyn\' !*) module TomegaPrint : TOMEGAPRINT(*! sharing TomegaPrint.IntSyn = IntSyn\' !*) (*! sharing TomegaPrint.Tomega = Tomega\' !*) module WorldSyn : WORLDSYN(*! sharing WorldSyn.IntSyn = IntSyn\' !*) (*! sharing WorldSyn.Tomega = Tomega\' !*) module Worldify : WORLDIFY(*! sharing Worldify.IntSyn = IntSyn\' !*) (*! sharing Worldify.Tomega = Tomega\' !*) module TomegaTypeCheck : TOMEGATYPECHECK(*! sharing TomegaTypeCheck.IntSyn = IntSyn\' !*) (*! sharing TomegaTypeCheck.Tomega = Tomega\' !*) module Subordinate : SUBORDINATE(*! sharing Subordinate.IntSyn = IntSyn\' !*) module TypeCheck : TYPECHECK(*! sharing TypeCheck.IntSyn = IntSyn\' !*) module Redundant : REDUNDANTmodule TomegaAbstract : TOMEGAABSTRACT) : CONVERTER = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  exception Error of string exception Error\' of Sub module T = Tomegamodule I = IntSynmodule M = ModeSynmodule S = Subordinatemodule A = Abstractmodule TA = TomegaAbstract(* ABP - 4/20/03, determine if Front is (I.Idx 1) *) let rec isIdx1 (Idx 1)  = true | isIdx1 _  = false let rec modeSpine a  = match modeLookup a with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let rec typeOf a  = match sgnLookup a with ConDec (name, _, _, _, V, Kind) -> V | _ -> raise (Error "Type Constant declaration expected") let rec nameOf a  = match sgnLookup a with ConDec (name, _, _, _, V, Kind) -> name | _ -> raise (Error "Type Constant declaration expected") let rec chatter chlev f  = if ! chatter >= chlev then print ("[tomega] " ^ f ()) else () (* strengthenExp (U, s) = U\'\n\n       Invariant:\n       If   G |- s : G\'\n       and  G |- U : V\n       then G\' |- U\' = U[s^-1] : V [s^-1]\n    *) let rec strengthenExp (U, s)  = normalize (cloInv (U, s), id) let rec strengthenSub (s, t)  = compInv (s, t) (* strengthenDec (x:V, s) = x:V\'\n\n       Invariant:\n       If   G |- s : G\'\n       and  G |- V : L\n       then G\' |- V\' = V[s^-1] : L\n    *) let rec strengthenDec (Dec (name, V), s)  = Dec (name, strengthenExp (V, s)) | strengthenDec (BDec (name, (L, t)), s)  = (* G0 |- t : Gsome *)  (* G0  |- s : G\' *)  (* to show  G\' |- t o s^1 : Gsome *)  BDec (name, (L, strengthenSub (t, s))) (* strengthenCtx (G, s) = (G\', s\')\n\n       If   G0 |- G ctx\n       and  G0 |- w : G1\n       then G1 |- G\' = G[w^-1] ctx\n       and  G0 |- w\' : G1, G\'\n    *) let rec strengthenCtx (Null, s)  = (Null, s) | strengthenCtx (Decl (G, D), s)  = let (G\', s\') = strengthenCtx (G, s) in (Decl (G\', strengthenDec (D, s\')), dot1 s\') (* strengthenFor (F, s) = F\'\n\n       If   Psi0 |- F for\n       and  Psi0 |- s :: Psi1\n       then Psi1 |- F\' = F[s^-1] ctx\n    *) let rec strengthenFor (True, s)  = True | strengthenFor (And (F1, F2), s)  = And (strengthenFor (F1, s), strengthenFor (F2, s)) | strengthenFor (All ((UDec D, Q), F), s)  = All ((UDec (strengthenDec (D, s)), Q), strengthenFor (F, dot1 s)) | strengthenFor (Ex ((D, Q), F), s)  = Ex ((strengthenDec (D, s), Q), strengthenFor (F, dot1 s)) (* strengthenOrder (O, s) = O\'\n\n       If   Psi0 |- O order\n       and  Psi0 |- s :: Psi1\n       then Psi1 |- O\' = O[s^-1] ctx\n    *) let rec strengthenOrder (Arg ((U, s1), (V, s2)), s)  = Arg ((U, strengthenSub (s1, s)), (V, strengthenSub (s2, s))) | strengthenOrder (Simul Os, s)  = Simul (map (fun O -> strengthenOrder (O, s)) Os) | strengthenOrder (Lex Os, s)  = Lex (map (fun O -> strengthenOrder (O, s)) Os) (* strengthenTC (TC, s) = TC\'\n\n       If   Psi0 |- TC : termination condition\n       and  Psi0 |- s :: Psi1\n       then Psi1 |- TC\' = TC[s^-1] ctx\n    *) let rec strengthenTC (Base O, s)  = Base (strengthenOrder (O, s)) | strengthenTC (Conj (TC1, TC2), s)  = Conj (strengthenTC (TC1, s), strengthenTC (TC2, s)) | strengthenTC (Abs (D, TC), s)  = Abs (strengthenDec (D, s), strengthenTC (TC, dot1 s)) let rec strengthenSpine (Nil, t)  = Nil | strengthenSpine (App (U, S), t)  = App (strengthenExp (U, t), strengthenSpine (S, t)) (* strengthenPsi (Psi, s) = (Psi\', s\')\n\n       If   Psi0 |- Psi ctx\n       and  Psi0 |- s :: Psi1\n       then Psi1 |- Psi\' = Psi[s^-1] ctx\n       and  Psi0 |- s\' :: Psi1, Psi\'\n    *) let rec strengthenPsi (Null, s)  = (Null, s) | strengthenPsi (Decl (Psi, UDec D), s)  = let (Psi\', s\') = strengthenPsi (Psi, s) in (Decl (Psi\', UDec (strengthenDec (D, s\'))), dot1 s\') | strengthenPsi (Decl (Psi, PDec (name, F, NONE, NONE)), s)  = let (Psi\', s\') = strengthenPsi (Psi, s) in (Decl (Psi\', PDec (name, strengthenFor (F, s\'), NONE, NONE)), dot1 s\') (* strengthenPsi\' (Psi, s) = (Psi\', s\')\n\n       If   Psi0 |- Psi ctx\n       and  Psi0 |- s : Psi1\n       then Psi1 |- Psi\' = Psi[s^-1] ctx\n       and  Psi0 |- s\' : Psi1, Psi\'  weakening substitution\n    *) let rec strengthenPsi\' (nil, s)  = (nil, s) | strengthenPsi\' (UDec D :: Psi, s)  = let D\' = strengthenDec (D, s) let s\' = dot1 s let (Psi\'\', s\'\') = strengthenPsi\' (Psi, s\') in (UDec D\' :: Psi\'\', s\'\') (* ctxSub (G, s) = (G\', s\')\n\n       Invariant:\n       if   Psi |- G ctx\n       and  Psi\' |- s : Psi\n       then Psi\' |- G\' ctx\n       and  Psi\', G\' |- s\' : G\n       and  G\' = G [s],  declarationwise defined\n    *) let rec ctxSub (Null, s)  = (Null, s) | ctxSub (Decl (G, D), s)  = let (G\', s\') = ctxSub (G, s) in (Decl (G\', decSub (D, s\')), dot1 s) let rec validMode (Mnil)  = () | validMode (Mapp (Marg (Plus, _), mS))  = validMode mS | validMode (Mapp (Marg (Minus, _), mS))  = validMode mS | validMode (Mapp (Marg (Star, _), mS))  = raise (Error "+ or - mode expected, * found") let rec validSig (Psi0, nil)  = () | validSig (Psi0, (G, V) :: Sig)  = let rec append (G, Null)  = G | append (G, Decl (G\', D))  = Decl (append (G, G\'), D) in (typeCheck (coerceCtx (append (Psi0, embedCtx G)), (V, Uni Type)); validSig (Psi0, Sig)) let rec convertOneFor cid  = (* convertFor\' (V, mS, w1, w2, n) = (F\', F\'\')\n\n           Invariant:\n           If   G |- V = {{G\'}} type :kind\n           and  G |- w1 : G+\n           and  G+, G\'+, G- |- w2 : G\n           and  G+, G\'+, G- |- ^n : G+\n           and  mS is a spine for G\'\n           then F\'  is a formula excepting a another formula as argument s.t.\n                If G+, G\'+ |- F formula,\n                then . |- F\' F formula\n           and  G+, G\'+ |- F\'\' formula\n        *) (* shiftPlus (mS) = s\'\n\n         Invariant:\n         s\' = ^(# of +\'s in mS)\n         *) let V = match sgnLookup cid with ConDec (name, _, _, _, V, Kind) -> V | _ -> raise (Error "Type Constant declaration expected") let mS = match modeLookup cid with NONE -> raise (Error "Mode declaration expected") | SOME mS -> mS let _ = validMode mS let rec convertFor\' (Pi ((D, _), V), Mapp (Marg (Plus, _), mS), w1, w2, n)  = let (F\', F\'\') = convertFor\' (V, mS, dot1 w1, Dot (Idx n, w2), n - 1) in (fun F -> All ((UDec (strengthenDec (D, w1)), Explicit), F\' F), F\'\') | convertFor\' (Pi ((D, _), V), Mapp (Marg (Minus, _), mS), w1, w2, n)  = let (F\', F\'\') = convertFor\' (V, mS, comp (w1, shift), dot1 w2, n + 1) in (F\', Ex ((decSub (D, w2), Explicit), F\'\')) | convertFor\' (Uni Type, Mnil, _, _, _)  = (fun F -> F, True) | convertFor\' _  = raise (Error "type family must be +/- moded") let rec shiftPlus mS  = let rec shiftPlus\' (Mnil, n)  = n | shiftPlus\' (Mapp (Marg (Plus, _), mS\'), n)  = shiftPlus\' (mS\', n + 1) | shiftPlus\' (Mapp (Marg (Minus, _), mS\'), n)  = shiftPlus\' (mS\', n) in shiftPlus\' (mS, 0) let n = shiftPlus mS let (F, F\') = convertFor\' (V, mS, id, Shift n, n) in F F\' (* createIH L = (Psi\', P\', F\')\n\n       Invariant:\n       If   L is a list of type families\n       and  Psi is a context\n       then Psi\' extends Psi\' by declarations in L\n       and  F\' is the conjunction of the formuals\n            that corresponds to each type family in L\n       and  Psi\' |- P\' in F\'\n    *) let rec createIH nil  = raise (Error "Empty theorem") | createIH [a]  = let name = conDecName (sgnLookup a) let F = convertOneFor a in (name, F) | createIH (a :: L)  = let name = conDecName (sgnLookup a) let F = convertOneFor a let (name\', F\') = createIH L in (name ^ "/" ^ name\', And (F, F\')) let rec convertFor L  = let (_, F\') = createIH L in F\' (* occursInExpN (k, U) = B,\n\n       Invariant:\n       If    U in nf\n       then  B iff k occurs in U\n    *) let rec occursInExpN (k, Uni _)  = false | occursInExpN (k, Pi (DP, V))  = occursInDecP (k, DP) || occursInExpN (k + 1, V) | occursInExpN (k, Root (H, S))  = occursInHead (k, H) || occursInSpine (k, S) | occursInExpN (k, Lam (D, V))  = occursInDec (k, D) || occursInExpN (k + 1, V) | occursInExpN (k, FgnExp csfe)  = fold csfe (fun (U, DP) -> DP || (occursInExp (k, normalize (U, id)))) false(* no case for Redex, EVar, EClo *) occursInHead (k, BVar (k\'))  = (k = k\') | occursInHead (k, Const _)  = false | occursInHead (k, Def _)  = false | occursInHead (k, FgnConst _)  = false | occursInHead (k, Proj _)  = false(* no case for FVar *) occursInSpine (_, Nil)  = false | occursInSpine (k, App (U, S))  = occursInExpN (k, U) || occursInSpine (k, S)(* no case for SClo *) occursInDec (k, Dec (_, V))  = occursInExpN (k, V)occursInDecP (k, (D, _))  = occursInDec (k, D)occursInExp (k, U)  = occursInExpN (k, normalize (U, id)) (* dot1inv w = w\'\n\n       Invariant:\n       If   G, A |- w : G\', A\n       then G |- w\' : G\'\n       and  w = 1.w\' o ^\n    *) let rec dot1inv (w)  = strengthenSub (comp (shift, w), shift) (* shiftinv (w) = w\'\n\n       Invariant:\n       If   G, A |- w : G\'\n       and  1 does not occur in w\n       then w  = w\' o ^\n    *) let rec shiftinv (w)  = strengthenSub (w, shift) let rec peel w  = if isIdx1 (bvarSub (1, w)) then dot1inv w else shiftinv w let rec peeln (0, w)  = w | peeln (n, w)  = peeln (n - 1, peel w) let rec popn (0, Psi)  = (Psi, Null) | popn (n, Decl (Psi, UDec D))  = let (Psi\', G\') = popn (n - 1, Psi) in (Psi\', Decl (G\', D)) (* domain (G2, w) = n\'\n\n       Invariant:\n       If   G2 |- w: G1   and w weakening substitution\n       then n\' = |G1|\n    *) let rec domain (G, Dot (Idx _, s))  = domain (G, s) + 1 | domain (Null, Shift 0)  = 0 | domain (G as Decl _, Shift 0)  = domain (G, Dot (Idx 1, Shift 1)) | domain (Decl (G, _), Shift n)  = domain (G, Shift (n - 1)) (* strengthen (Psi, (a, S), w, m) = (Psi\', w\')\n\n       This function traverses the spine, and finds\n       all variables in a position input/output position m\n       (hence strenghten might not be a good name for it, because it is to general.)\n\n       Invariant:\n       If   |- Psi ctx\n       and  |- Psi1 ctx      where Psi1 is a subcontext of Psi\n       and  Sigma (a) = {x1:A1} .. {xn:An} type\n       and  Psi |- S : m1{x1:A1} .. mn{xn:An} > type\n       and  Psi |- w : Psi1\n       and  m mode\n       then |- Psi\' ctx\n       and  Psi |- w\' : Psi\'\n       where Psi\' extends Psi1 (but is a subset of Psi?)\n    *) let rec strengthen (Psi, (a, S), w, m)  = (* testBlock (G, (bw, w1)) = (bw\', w\')\n\n           Invariant:\n           If   |- G ctx\n           and  |- G1 ctx\n           and  |- G2 ctx\n           and  G1 |- w1 : G2, G\n           and  bw is a boolean value\n           then there ex. a G1\'\n           s.t. |- G1\' ctx\n           and  G1\' |- w\' : G2\n           and  bw\' = bw or (G1 =/= G1\')\n         *) (* strengthen\' (Psi1, Psi2, S, w1) =  (Psi\', w\')\n\n           Invariant:\n           If   |- Psi1 ctx\n           and  Psi1 |- Psi2 ctx      (Psi2 is a list to maintain order)\n           and  |- Psi3 ctx\n           and  Psi1 |- w1 : Psi3     where w1 is a weakening substitution\n           and  Psi1, Psi2 |- S : V1 > V2\n           then |- Psi\' ctx\n           and  Psi1 |- w\' : Psi\'     where w\' is a weakening substitution\n           where Psi3 < Psi\' < Psi1   (Psi\' contains all variables of Psi3\n                                       and all variables occuring in m\n                                       position in S)\n        *) let mS = modeSpine a let rec args (Nil, Mnil)  = nil | args (App (U, S\'), Mapp (Marg (m\', _), mS))  = let L = args (S\', mS) in (match modeEqual (m, m\') with true -> U :: L | false -> L) let rec strengthenArgs (nil, s)  = nil | strengthenArgs (U :: L, s)  = strengthenExp (U, s) :: strengthenArgs (L, s) let rec occursInArgs (n, nil)  = false | occursInArgs (n, U :: L)  = (occursInExp (n, U) || occursInArgs (n, L)) let rec occursInPsi (n, (nil, L))  = occursInArgs (n, L) | occursInPsi (n, (UDec (Dec (_, V)) :: Psi1, L))  = occursInExp (n, V) || occursInPsi (n + 1, (Psi1, L)) | occursInPsi (n, (UDec (BDec (_, (cid, s))) :: Psi1, L))  = let BlockDec (_, _, G, _) = sgnLookup cid in occursInSub (n, s, G) || occursInPsi (n + 1, (Psi1, L))occursInSub (_, _, Null)  = false | occursInSub (n, Shift k, G)  = occursInSub (n, Dot (Idx (k + 1), Shift (k + 1)), G) | occursInSub (n, Dot (Idx k, s), Decl (G, _))  = (n = k) || occursInSub (n, s, G) | occursInSub (n, Dot (Exp U, s), Decl (G, _))  = occursInExp (n, U) || occursInSub (n, s, G) | occursInSub (n, Dot (Block _, s), Decl (G, _))  = occursInSub (n, s, G)(* is this ok? -- cs *) (* no other cases *) occursInG (n, Null, k)  = k n | occursInG (n, Decl (G, Dec (_, V)), k)  = occursInG (n, G, fun n\' -> occursInExp (n\', V) || k (n\' + 1)) let rec occursBlock (G, (Psi2, L))  = let rec occursBlock (Null, n)  = false | occursBlock (Decl (G, D), n)  = occursInPsi (n, (Psi2, L)) || occursBlock (G, n + 1) in occursBlock (G, 1) let rec inBlock (Null, (bw, w1))  = (bw, w1) | inBlock (Decl (G, D), (bw, w1))  = if isIdx1 (bvarSub (1, w1)) then inBlock (G, (true, dot1inv w1)) else inBlock (G, (bw, strengthenSub (w1, shift))) let rec blockSub (Null, w)  = (Null, w) | blockSub (Decl (G, Dec (name, V)), w)  = let (G\', w\') = blockSub (G, w) let V\' = strengthenExp (V, w\') in (Decl (G\', Dec (name, V\')), dot1 w\') let rec strengthen\' (Null, Psi2, L, w1, (* =  I.id *) )  = (Null, id, id) | strengthen\' (Decl (Psi1, LD as UDec (Dec (name, V))), Psi2, L, w1)  = if isIdx1 (bvarSub (1, w1)) then let w1\' = dot1inv w1 let (Psi1\', w\', z\') = strengthen\' (Psi1, LD :: Psi2, L, w1\') let V\' = strengthenExp (V, w\') in (Decl (Psi1\', UDec (Dec (name, V\'))), dot1 w\', dot1 z\') else if occursInPsi (1, (Psi2, L)) then let w1\' = strengthenSub (w1, shift) let (Psi1\', w\', z\') = strengthen\' (Psi1, LD :: Psi2, L, w1\') let V\' = strengthenExp (V, w\') in (Decl (Psi1\', UDec (Dec (name, V\'))), dot1 w\', comp (z\', shift)) else let w1\' = strengthenSub (w1, shift) let w2 = shift let (Psi2\', w2\') = strengthenPsi\' (Psi2, w2) let L\' = strengthenArgs (L, w2\') let (Psi1\'\', w\', z\') = strengthen\' (Psi1, Psi2\', L\', w1\') in (Psi1\'\', comp (w\', shift), z\') | strengthen\' (Decl (Psi1, D as PDec (name, F, NONE, NONE)), Psi2, L, w1)  = let w1\' = dot1inv w1 let (Psi1\', w\', z\') = strengthen\' (Psi1, D :: Psi2, L, w1\') let F\' = strengthenFor (F, w\') in (Decl (Psi1\', PDec (name, F\', NONE, NONE)), dot1 w\', dot1 z\') | strengthen\' (Decl (Psi1, LD as UDec (BDec (name, (cid, s)))), Psi2, L, w1)  = (* blocks are always used! *) let w1\' = dot1inv w1 let (Psi1\', w\', z\') = strengthen\' (Psi1, LD :: Psi2, L, w1\') let s\' = strengthenSub (s, w\') in (Decl (Psi1\', UDec (BDec (name, (cid, s\')))), dot1 w\', dot1 z\') in strengthen\' (Psi, nil, args (S, mS), w) let rec lookupIH (Psi, L, a)  = let rec lookupIH\' (b :: L, a, k)  = if a = b then k else lookupIH\' (L, a, k - 1) in lookupIH\' (L, a, ctxLength Psi) (* createSub (Psi, L) = t\'\n\n       Invariant:\n       If  |- Psi = Psi0, Psi1 ctx\n       and Psi0 contains all declarations for invariants in L\n       and |Psi0| = n\n       and |L| = k\n       and n = k + m - 1\n       then Psi |- t\' = m, m+1 ... n. ^n :  Psi0\n    *) let rec createIHSub (Psi, L)  = Shift (ctxLength Psi - 1(*List.length L *) ) (* transformInit (Psi, (a, S), w1) = (w\', s\')\n\n       Invariant:\n       If   |- Psi ctx\n       and  Sigma (a) = {x1:A1} .. {xn:An} type\n       and  Psi |- S : m1{x1:A1} .. mn{xn:An} type > type\n       and  Psi |- w1 : Psi+\n       then |- Gamma+ ctx\n       and  Gamma+ = +x(k1):A(k1), ... +x(km):A(km)\n       and  Psi+ |- s\' : Gamma+\n       and  x1:A1 .. xn:An |- w: Gamma+    (w weakening substitution)\n    *) let rec transformInit (Psi, L, (a, S), w1)  = (* transformInit\' ((S, mS), V, (w, s)) = (w\', s\')\n\n           Invariant:\n           If   Psi |- S : V > type\n           and  x1:A1...x(j-1):A(j-1) |- V = mj{xj:Aj} .. mn{xn:An} type : kind\n           and  x1:A1...x(j-1):A(j-1) |- w : +x1:A1... +x(j-1):A(j-1)\n           and  Psi |- w1 : Psi+\n           and  Psi+ |- s : +x1:A1... +x(j-1):A(j-1)\n           then x1:A1...xn:An |- w\' : +x1:A1... +xn:An\n           and  Psi+ |- s\' : +x1:A1 .. +xn:An\n        *) let mS = modeSpine a let V = typeOf a let rec transformInit\' ((Nil, Mnil), Uni Type, (w, s))  = (w, s) | transformInit\' ((App (U, S), Mapp (Marg (Minus, _), mS)), Pi (_, V2), (w, s))  = let w\' = comp (w, shift) let s\' = s in transformInit\' ((S, mS), V2, (w\', s\')) | transformInit\' ((App (U, S), Mapp (Marg (Plus, _), mS)), Pi ((Dec (name, V1), _), V2), (w, s))  = let V1\' = strengthenExp (V1, w) let w\' = dot1 w let U\' = strengthenExp (U, w1) let s\' = dotEta (Exp U\', s) in transformInit\' ((S, mS), V2, (w\', s\')) in transformInit\' ((S, mS), V, (id, createIHSub (Psi, L))) (* transformConc ((a, S), w) = P\n\n       Invariant:\n       If   Sigma (a) = {x1:A1} .. {xn:An} type\n       and  Psi |- S : m1{x1:A1} .. mn{xn:An} type > type\n       and  Psi |- w : PsiAll\n       then P is proof term consisting of all - objects of S,\n            defined in PsiAll\n    *) let rec transformConc ((a, S), w)  = let rec transformConc\' (Nil, Mnil)  = Unit | transformConc\' (App (U, S\'), Mapp (Marg (Plus, _), mS\'))  = transformConc\' (S\', mS\') | transformConc\' (App (U, S\'), Mapp (Marg (Minus, _), mS\'))  = PairExp (strengthenExp (U, w), transformConc\' (S\', mS\')) in transformConc\' (S, modeSpine a) (* renameExp f U = U\'\n\n       Invariant:\n       U\' = U module application of f to any projectoin contained\n       in U.\n    *) let rec renameExp f (U as Uni _)  = U | renameExp f (Pi ((D, DP), V))  = Pi ((renameDec f D, DP), renameExp f V) | renameExp f (Root (H, S))  = Root (renameHead f H, renameSpine f S) | renameExp f (Lam (D, U))  = Lam (renameDec f D, renameExp f U)renameDec f (Dec (x, V))  = Dec (x, renameExp f V)renameHead f (Proj bi)  = f bi | renameHead f H  = HrenameSpine f Nil  = Nil | renameSpine f (App (U, S))  = App (renameExp f U, renameSpine f S) let rec rename (BDec (_, (c, s)), V)  = let (G, L) = constBlock c let rec makeSubst (n, G, s, nil, f)  = (G, f) | makeSubst (n, G, s, (D as Dec (x, V\')) :: L, f)  = if belowEq (targetFam V\', targetFam V) then makeSubst (n + 1, Decl (G, decSub (D, s)), dot1 s, L, f) else makeSubst (n, G, comp (s, shift), L, f) let (G\', f) = makeSubst (1, G, s, L, fun x -> Proj x) in (G, renameExp f V) let rec append (G, Null)  = G | append (G, Decl (G\', D))  = Decl (append (G, G\'), D) (* traverseNeg (L, wmap, projs)  (Psi0, Psi, V) = ([w\', PQ\'], L\')    [] means optional\n\n           Invariant:\n           If   |- Psi0 ctx      (context that contains induction hypotheses)\n           and  Psi0 |- Psi ctx  (context of all assumptions)\n           and  Psi0, Psi |- V : type\n           then L\' list of cases\n           and  Psi0, Psi |- w\' : Psi0, Psi\'\n           and  PQ\'  is a pair that can generate a proof term\n        *) let rec traverseNeg (L, wmap, projs) ((Psi0, Psi), Pi ((D as Dec (_, V1), Maybe), V2), w)  = (match traverseNeg (L, wmap, projs) ((Psi0, Decl (Psi, UDec D)), V2, dot1 w) with (SOME (w\', PQ\')) -> SOME (peel w\', PQ\')) | traverseNeg (L, wmap, projs) ((Psi0, Psi), Pi ((D as Dec (_, V1), No), V2), w)  = (match traverseNeg (L, wmap, projs) ((Psi0, Decl (Psi, UDec D)), V2, comp (w, shift)) with (SOME (w\', PQ\')) -> traversePos (L, wmap, projs) ((Psi0, Psi, Null), V1, SOME (peel w\', PQ\'))) | traverseNeg (L, wmap, projs) ((Psi0, Psi), Root (Const a, S), w)  = (* Psi0, Psi |- w : Psi0, Psi\' *)  (* Sigma (a) = Va *)  (* Psi0, Psi |- S : {G} type > type *)  (* Psi1 = Psi0, Psi *) (* Psi1 |- w0 : Psi0 *) (* |- Psi\' ctx *) (* Psi1 |- w\' : Psi\' *) (* Psi\' |- s\'\' : G+ *) (* G |- w\'\' : G+ *) let Psi1 = append (Psi0, Psi) let w0 = Shift (ctxLength Psi) let (Psi\', w\', _) = strengthen (Psi1, (a, S), w0, Plus) let (w\'\', s\'\') = transformInit (Psi\', L, (a, S), w\') let _ = checkCtx Psi\' in (SOME (w\', (fun P -> (Psi\', s\'\', P), transformConc ((a, S), w))))traversePos (L, wmap, projs) ((Psi0, Psi, G), Pi ((D as BDec (x, (c, s)), _), V), SOME (w1, (P, Q)))  = let c\' = wmap c let n = ctxLength Psi0 + ctxLength G let (Gsome, Lpi) = constBlock c let _ = typeCheckCtx (coerceCtx (append (append (Psi0, Psi), embedCtx G))) let _ = typeCheckSub (coerceCtx (append (append (Psi0, Psi), embedCtx G)), s, Gsome) let (Gsome\', Lpi\') = constBlock c\' let _ = typeCheckCtx (coerceCtx (append (append (Psi0, Psi), embedCtx G))) let _ = typeCheckSub (coerceCtx (append (append (Psi0, Psi), embedCtx G)), s, Gsome\') in traversePos (L, wmap, projs) ((Psi0, Psi, Decl (G, (* T.UDec *) , (BDec (x, (c\', s))))), V, SOME (dot1 w1, (P, Q))) | traversePos (L, wmap, projs) ((Psi0, G, B), V as Root (Const a, S), SOME (w1, (P, Q)))  = (* Psi0 = x1::F1 ... xn::Fn *)  (* |- Psi0 matches L *)  (* Psi0, G, B |- V : type *)  (* Psi0, G, B |- w1 : Psi0, G\', B\' *)  (* Psi1 = Psi0, G, B *) (* n = |Psi0, G\', B\'| *) (* m = |Psi0| *) (* strengthened invariant Psi0 might be empty --cs Fri Apr 11 15:25:32 2003 *) (* apply ((S, mS), F\')= (S\'\', F\'\')\n\n                 Invariant:\n                 Psi0, G, B |- S : V >> type\n                   (mS is the corresponding mode spine)\n                 and  Psi0, G\', B |- F\'  :: for\n                 then Psi0, G\', B |- F\'\' :: for\n                 and  Psi0, G\', B |- S\'\' :: F\' >> F\'\'\n              *) (* Psi0, G\', B\' |- F\'\' :: for *) (* Psi0, G\', B\' |- S\'\' :: F\' >> F\'\' *) (* was T.Root  -cs Sun Jan  5 23:15:06 2003 *) (* Psi0, G\', B\' |- P\'\' :: F\'\' *) (* b = |B| = |B\'| *) (* Psi0, G |- w1\' : Psi0, G\' *) (* |- Psi0, G\', B\' ctx *) (* n\' = |Psi0, G\'| *) (* Psi0, G\' |- GB\' ctx *) (* Psi0, G, B |- w1 : Psi0, G\', B\' *) (* Psi0, G\', GB\'  |- s\' : Psi0, G\', B\' *) (* Psi0, G\', GB\' |- RR for *) (* Psi0, G |- w1\' : Psi0, G\' *) (* Psi0, G\' |- F\'\'\' for *) (* lift (B, (P, F)) = (P\', F\')\n\n                 Invariant:\n                 If   Psi0, G, B |- P :: F\n                 then Psi0, G |- P\'  :: F\'\n                 and  P\' =  (lam B. P)\n                 and  F\' = raiseFor (B, F)\n              *) (* Psi0, G\' |- P\'\'\' :: F\'\'\' *) (* |- Psi0, Psi1\'\' ctx *) (* Psi0, G, B |- w2 : Psi1\'\' *) (* Psi1\'\' = Psi0, G3, B3\' *) (* |B| = |GB\'| *) (* Psi\'\' |-  z2 : Psi0, G\', B\' *) (* Psi0, G, B |- w2 : Psi0, G3, B3\' *) (* Psi0, G |- w3 : Psi0, G3 *) (* Psi0, G3 |-  z3 : Psi0, G\' *) (* Psi2 = Psi0, G3 *) (* Psi0, G3, B3\' |- Pat\' :: For *) (* Psi0, G3 |- F4 for *) (* \' F4 *) (* Psi0, G3 |- Pat :: F4  *) (* Here\'s a commutative diagram\n                                           at work which one has to prove\n                                           correct\n                                        *) (* Psi0, G3 |- t :: Psi0, G\', x :: F4  *) let Psi1 = append (Psi0, append (G, embedCtx B)) let _ = checkCtx (append (append (Psi0, G), embedCtx B)) let n = domain (Psi1, w1) let m = ctxLength Psi0 let rec lookupbase a  = let s = conDecName (sgnLookup a) let l = lemmaName s let ValDec (_, P, F) = lemmaLookup l in (Const l, F) let rec lookup (([b], NONE, F), a)  = if a = b then let P = Var n in (P, F) else lookupbase a | lookup (([b], SOME [lemma], F), a)  = if a = b then let P = Redex (Const lemma, AppPrg (Var n, Nil)) in (P, F) else lookupbase a | lookup ((b :: L, SOME (lemma :: lemmas), And (F1, F2)), a)  = if a = b then let P = Redex (Const lemma, AppPrg (Var n, Nil)) in (P, F1) else lookup ((L, SOME lemmas, F2), a) let (HP, F) = if ctxLength Psi0 > 0 then let PDec (_, F0, _, _) = ctxLookup (Psi0, 1) in lookup ((L, projs, F0), a) else lookupbase a let rec apply ((S, mS), Ft)  = applyW ((S, mS), whnfFor (Ft))applyW ((Nil, Mnil), Ft\')  = (Nil, forSub Ft\') | applyW ((App (U, S), Mapp (Marg (Plus, _), mS)), (All (D, F\'), t\'))  = (* Psi0, G\', B\' |- D = x:V\' : type *)  (* Psi0, G\', B\', x:V\' |- F\' :: for *)  (* Psi0, G\', B\' |- U\' : V\' *) (* Psi0, G\', B\' |- F\'\' :: for *) (* Psi0, G\', B\' |- S\'\' : F\' [t\'] >> F\'\' *) let U\' = strengthenExp (U, w1) let (S\'\', F\'\') = apply ((S, mS), (F\', Dot (Exp U\', t\'))) in (AppExp (U\', S\'\'), F\'\')(* Psi0, G\', B\' |- U\' ; S\'\'\n                                                       : all {x:V\'} F\' >> F\'\' *) | applyW ((App (U, S), Mapp (Marg (Minus, _), mS)), Ft)  = applyW ((S, mS), Ft) let (S\'\', F\'\') = apply ((S, modeSpine a), (F, id)) let _ = checkFor (append (append (Psi0, G), embedCtx B), (forSub (F\'\', embedSub w1))) let P\'\' = Redex (HP, (*T.Var k\' *) , S\'\') let b = ctxLength B let w1\' = peeln (b, w1) let (B\', _) = strengthenCtx (B, w1\') let n\' = n - ctxLength B\' let rec subCtx (Null, s)  = (Null, s) | subCtx (Decl (G, D), s)  = let (G\', s\') = subCtx (G, s) in (Decl (G\', decSub (D, s\')), dot1 s\') let (B\'\', _) = subCtx (B\', w1\') let _ = checkCtx (append (append (Psi0, G), embedCtx B\'\')) let (GB\', iota) = deblockify B\' let _ = try  with  let RR = forSub (F\'\', iota) let F\'\'\' = raiseFor (GB\', (RR, id)) let rec lift (Null, P)  = P | lift (Decl (G, D), P)  = let (Bint, _) = deblockify (Decl (Null, D)) in lift (G, New (Lam (UDec D, P))) let P\'\'\' = lift (B\', P\'\') let _ = checkCtx (append (Psi0, G)) let _ = checkFor (append (Psi0, G), (forSub (F\'\'\', embedSub w1\'))) let (Psi1\'\', w2, z2) = strengthen (Psi1, (a, S), w1, Minus) let w3 = peeln (b, w2) let z3 = peeln (b, z2) let (Psi2, B3\') = popn (b, Psi1\'\') let Pat\' = transformConc ((a, S), w2) let F4 = forSub (F\'\'\', embedSub z3) let _ = checkCtx (Psi1\'\') let _ = checkCtx (append (Psi2, embedCtx B3\')) let _ = try  with  let (B3, sigma3) = deblockify B3\' let Pat\'\' = normalizePrg (Pat\', sigma3) let Pat = raisePrg (B3, Pat\'\', F4) let _ = checkPrg (Psi2, (Pat, F4)) let t = Dot (Prg Pat, embedSub z3) in (SOME (w3, (fun p -> P (Let (PDec (NONE, F\'\'\', NONE, NONE), P\'\'\', Case (Cases [(Psi2, t, p)]))), Q))) (* traverse (Psi0, L, Sig, wmap) = C\'\n\n       Invariant:\n       If   |- Psi0  ctx\n       and  L is a the theorem we would like to transform\n       and  Sig is a signature\n       and  forall (G, V) in Sig the following holds:\n                    Psi0, G |- V : type\n               and  head (V) in L\n       and  wmap is a mapping of old labels L to L\'\n            where L\' is a new label and w\' is a weakensub\n            with the following properties.\n            If   Sig (L) = (Gsome, Lblock)\n            and  Sig (L\') = (Gsome, Lblock\')\n       then C\' is a list of cases (corresponding to each (G, V) in Sig)\n    *) let rec traverse (Psi0, L, Sig, wmap, projs)  = let rec traverseSig\' nil  = nil | traverseSig\' ((G, V) :: Sig)  = (typeCheck (append (coerceCtx Psi0, G), (V, Uni Type)); match traverseNeg (L, wmap, projs) ((Psi0, embedCtx G), V, id) with (SOME (wf, (P\', Q\'))) -> traverseSig\' Sig @ [(P\' Q\')]) in traverseSig\' Sig (* transformWorlds (fams, W) = (W\', wmap)\n\n       Invariant:\n       If   fams is the theorem to be compiled\n       and  W a world with declarations,\n       then W\' is the new world stripped of all dynamic extensions\n       and  wmap is a mapping of old labels L to L\'\n            where L\' is a new label and w\' is a weakensub\n            with the following properties.\n            If   Sig (L) = (Gsome, Lblock)\n            and  Sig (L\') = (Gsome, Lblock\')\n    *) let rec transformWorlds (fams, Worlds cids)  = (* convertList (a, L, w) = L\'\n\n             Invariant:\n             If   G0 |- G, L : ctx\n             and  G0, G |- w : G0, G\'\n             then G0 |- G\', L\' ctx\n          *) let rec transformList (nil, w)  = nil | transformList ((D as Dec (x, V)) :: L, w)  = if foldr (fun (a, b) -> b && belowEq (a, targetFam V)) true fams then transformList (L, comp (w, shift)) else let L\' = transformList (L, dot1 w) in (Dec (x, strengthenExp (V, w))) :: L\' let rec transformWorlds\' (nil)  = (nil, fun c -> raise (Error "World not found")) | transformWorlds\' (cid :: cids\')  = (* Design decision: Let\'s keep all of G *) let BlockDec (s, m, G, L) = sgnLookup cid let L\' = transformList (L, id) let (cids\'\', wmap) = transformWorlds\' (cids\') let cid\' = sgnAdd (BlockDec (s, m, G, L\')) in (cid\' :: cids\'\', fun c -> if c = cid then cid\' else wmap c) let (cids\', wmap) = transformWorlds\' (cids) in (Worlds cids\', wmap) (* dynamicSig (Psi0, fams, W) = Sig\'\n\n       Invariant:\n       If   |- Psi0 ctx\n       and  fams are the typfamilies to be converted\n       and  W is the world in which the translation takes place\n       then Sig\' = (G1;V1) ... (Gn;Vn)\n       and  |- Psi0, Gi ctx\n       and  Psi, Gi |- Vi : type.\n    *) let rec dynamicSig (Psi0, a, Worlds cids)  = (* findDec (G, n, L, s, S) = S\'\n\n             Invariant:\n             If   G |-  L : ctx\n             and  G |- w: G\'\n             then |- G\', L\' ctx\n          *) (* mediateSub G = (G0, s)\n\n             Invariant:\n             If   . |- G ctx\n             then Psi0 |- G0 ctx\n             and  Psi0, G0 |- s : G\n          *) let rec findDec (G, _, nil, w, Sig)  = Sig | findDec (G, n, D :: L, w, Sig)  = let (D\' as Dec (x, V\')) = decSub (D, w) let b = targetFam V\' let Sig\' = if b = a then (G, normalize (V\', id)) :: Sig else Sig in findDec (G, n + 1, L, Dot (Exp (Root (Proj (Bidx 1, n), Nil)), w), Sig\') let rec mediateSub (Null)  = (Null, Shift (ctxLength Psi0)) | mediateSub (Decl (G, D))  = let (G0, s\') = mediateSub G let D\' = decSub (D, s\') in (Decl (G0, D\'), dot1 s\') let rec findDecs\' (nil, Sig)  = Sig | findDecs\' (cid :: cids\', Sig)  = (* G |- L ctx *) (* Psi0, G0 |- s\'\' : G *) (* Psi0, G0 |- D : dec *) (* Psi0, G0, D\' |- s\'\' : G *) let BlockDec (s, m, G, L) = sgnLookup cid let (G0, s\') = mediateSub G let D\' = decName (G0, BDec (NONE, (cid, s\'))) let s\'\' = comp (s\', shift) let Sig\' = findDec (Decl (G0, D\'), 1, L, s\'\', Sig) in findDecs\' (cids\', Sig\') in findDecs\' (cids, nil) (* staticSig Sig = Sig\'\n\n       Invariant:\n       If   |- Psi0 ctx\n       then Sig\' = (c1:V1) ... (cn:Vn)\n       and  . |- Vi : type.\n    *) let rec staticSig (Psi0, nil)  = nil | staticSig (Psi0, ConDec (name, _, _, _, V, Type) :: Sig)  = (Null, normalize (V, Shift (ctxLength Psi0))) :: staticSig (Psi0, Sig) let rec name [a]  = conDecName (sgnLookup a) | name (a :: L)  = conDecName (sgnLookup a) ^ "/" ^ (name L) (* convertPrg L = P\'\n\n       Invariant:\n       If   L is a list of type families\n       then P\' is a conjunction of all programs resulting from converting\n            the relational encoding of the function expressed by each type\n            family in L into functional form\n    *) let rec convertPrg (L, projs)  = let (name, F0) = createIH L let D0 = PDec (SOME name, F0, NONE, NONE) let Psi0 = Decl (Null, D0) let Prec = fun p -> Rec (D0, p) let rec convertWorlds [a]  = (* W describes the world of a *) let W = lookup a in W | convertWorlds (a :: L\')  = (* W describes the world of a *) let W = lookup a let W\' = convertWorlds L\' in if eqWorlds (W, W\') then W\' else raise (Error "Type families different in different worlds") let W = convertWorlds L let (W\', wmap) = transformWorlds (L, W) let rec convertOnePrg (a, F)  = (* Psi0 |- {x1:V1} ... {xn:Vn} type *) (* |- mS : {x1:V1} ... {xn:Vn} > type *) (* Sig in LF(reg)   *) (* init\' F = P\'\n\n               Invariant:\n               If   F = All x1:A1. ... All xn:An. F\'\n               and  f\' does not start with a universal quantifier\n               then P\' P\'\' = Lam x1:A1. ... Lam xn:An P\'\'\n                    for any P\'\'\n            *) (* Psi0, x1:V1, ..., xn:Vn |- C :: F *) let name = nameOf a let V = typeOf a let mS = modeSpine a let Sig = worldify a let dynSig = dynamicSig (Psi0, a, W) let statSig = staticSig (Psi0, Sig) let _ = map (fun (ConDec (_, _, _, _, U, V)) -> check (U, Uni V)) Sig let _ = validSig (Psi0, statSig) let _ = validSig (Psi0, dynSig) let C0 = traverse (Psi0, L, dynSig, wmap, projs) let rec init (All ((D, _), F\'))  = let (F\'\', P\') = init F\' in (F\'\', fun p -> Lam (D, P\' p)) | init F\'  = (F\', fun p -> p) let (F\', Pinit) = init F let C = traverse (Psi0, L, statSig, wmap, projs) in Pinit (Case ((* F\', *) Cases (C0 @ C))) let rec convertPrg\' (nil, _)  = raise (Error "Cannot convert Empty program") | convertPrg\' ([a], F)  = convertOnePrg (a, F) | convertPrg\' (a :: L\', And (F1, F2))  = PairPrg (convertOnePrg (a, F1), convertPrg\' (L\', F2)) let P = Prec (convertPrg\' (L, F0)) in P let rec installFor [cid]  = let F = convertFor [cid] let name = conDecName (sgnLookup cid) let _ = lemmaAdd (ForDec (name, F)) in () let rec depthConj (And (F1, F2))  = 1 + depthConj F2 | depthConj F  = 1 let rec createProjection (Psi, depth, F as And (F1, F2), Pattern)  = createProjection (Decl (Psi, PDec (NONE, F1, NONE, NONE)), depth + 1, forSub (F2, Shift 1), PairPrg (Var (depth + 2), Pattern)) | createProjection (Psi, depth, F, Pattern)  = let Psi\' = Decl (Psi, PDec (NONE, F, NONE, NONE)) let depth\' = depth + 1 in fun k -> let PDec (_, F\', _, _) = ctxDec (Psi\', k) in (Case (Cases [(Psi\', Dot (Prg (Pattern), Shift (depth\')), Var k)]), F\') let rec installProjection (nil, _, F, Proj)  = nil | installProjection (cid :: cids, n, F, Proj)  = let (P\', F\') = Proj n let P = Lam (PDec (NONE, F, NONE, NONE), P\') let F\'\' = All ((PDec (NONE, F, NONE, NONE), Explicit), F\') let name = conDecName (sgnLookup cid) let _ = checkPrg (Null, (P, F\'\')) let lemma = lemmaAdd (ValDec ("#" ^ name, P, F\'\')) in lemma :: installProjection (cids, n - 1, F, Proj) let rec installSelection ([cid], [lemma], F1, main)  = let P = Redex (Const lemma, AppPrg (Const main, Nil)) let name = conDecName (sgnLookup cid) let _ = checkPrg (Null, (P, F1)) let lemma\' = lemmaAdd (ValDec (name, P, F1)) in [lemma\'] | installSelection (cid :: cids, lemma :: lemmas, And (F1, F2), main)  = let P = Redex (Const lemma, AppPrg (Const main, Nil)) let name = conDecName (sgnLookup cid) let _ = checkPrg (Null, (P, F1)) let lemma\' = lemmaAdd (ValDec (name, P, F1)) in lemma\' :: installSelection (cids, lemmas, F2, main) let rec installPrg [cid]  = let F = convertFor [cid] let P = convertPrg ([cid], NONE) let name = conDecName (sgnLookup cid) let _ = checkPrg (Null, (P, F)) let _ = if (! chatter >= 4) then print ("[Redundancy Checker (factoring) ...") else () let factP = convert P let _ = if (! chatter >= 4) then print ("done]\\n") else () let lemma = lemmaAdd (ValDec (name, factP, F)) in (lemma, [], []) | installPrg cids  = let F = convertFor cids let _ = checkFor (Null, F) let Proj = createProjection (Null, 0, F, Var 1) let projs = installProjection (cids, depthConj F, F, Proj) let P = convertPrg (cids, SOME projs) let s = name cids let _ = checkPrg (Null, (P, F)) let _ = if (! chatter >= 4) then print ("[Redundancy Checker (factoring) ...") else () let factP = convert P let _ = if (! chatter >= 4) then print ("done]\\n") else () let lemma = lemmaAdd (ValDec (s, factP, F)) let sels = installSelection (cids, projs, F, lemma) in (lemma, projs, sels) let rec mkResult 0  = Unit | mkResult n  = PairExp (Root (BVar n, Nil), mkResult (n - 1)) let rec convertGoal (G, V)  = let a = targetFam V let W = lookup a let (W\', wmap) = transformWorlds ([a], W) let SOME (_, (P\', Q\')) = traversePos ([], wmap, NONE) ((Null, G, Null), V, SOME (Shift (ctxLength G), (fun P -> (Null, id, P), mkResult (ctxLength G)))) let (_, _, P\'\') = P\' Q\' in P\'\' let convertFor = convertFor let convertPrg = fun L -> convertPrg (L, NONE) let installFor = installFor let installPrg = installPrg let traverse = traverse let convertGoal = convertGoal  end(* functor FunSyn *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', "module TomegaAbstract = TomegaAbstract(struct module Global = Global module Abstract = Abstract module Whnf = Whnf module Subordinate = Subordinate end)\nmodule TomegaPrint = TomegaPrint(struct module Formatter = Formatter module Names = Names module Print = Print end)module TomegaTypeCheck = TomegaTypeCheck(struct module Global = Global module Abstract = Abstract module TypeCheck = TypeCheck module Conv = Conv module Whnf = Whnf module Subordinate = Subordinate module TomegaPrint = TomegaPrint module Print = Print module Weaken = Weaken module TomegaAbstract = TomegaAbstract end)\n(* structure TomegaUnify = TomegaUnify\n  (structure Global = Global\n   (*! structure IntSyn' = IntSyn !*)\n   structure Abstract = Abstract\n   (*! structure Tomega' = Tomega !*)\n   structure TypeCheck = TypeCheck\n   structure Normalize = Normalize\n   structure Conv = Conv\n   structure Whnf = Whnf\n   structure Subordinate = Subordinate\n   structure TomegaPrint = TomegaPrint\n   structure Print = Print\n   structure Weaken = Weaken);\n*) module Opsem = Opsem(struct module Global = Global module IntSyn' = IntSyn module Abstract = Abstract module Tomega' = Tomega module TypeCheck = TypeCheck module Unify = UnifyNoTrail module Conv = Conv module Whnf = Whnf module Print = Print module Subordinate = Subordinate module TomegaPrint = TomegaPrint module TomegaTypeCheck = TomegaTypeCheck module Weaken = Weaken end)\n(*\nstructure Opsem = OpsemCont\n  (structure Global = Global\n   structure IntSyn' = IntSyn\n   structure Abstract = Abstract\n   structure Tomega' = Tomega\n   structure TypeCheck = TypeCheck\n   structure Normalize = Normalize\n   structure Unify = UnifyNoTrail\n   structure Conv = Conv\n   structure Whnf = Whnf\n   structure Print = Print\n   structure Subordinate = Subordinate\n   structure TomegaPrint = TomegaPrint\n   structure TomegaTypeCheck = TomegaTypeCheck\n   structure Weaken = Weaken);\n*) module Redundant = Redundant(module Opsem = Opsem)module Converter = Converter(struct module Global = Global module IntSyn' = IntSyn module Abstract = Abstract module Tomega' = Tomega module Names = Names module ModeTable = ModeTable module TypeCheck = TypeCheck module TomegaAbstract = TomegaAbstract module TomegaTypeCheck = TomegaTypeCheck module Trail = Trail module Unify = UnifyTrail module TomegaPrint = TomegaPrint module Whnf = Whnf module WorldSyn = WorldSyn module Worldify = Worldify module Subordinate = Subordinate module Print = Print module Redundant = Redundant module Weaken = Weaken end)\nmodule TomegaCoverage = TomegaCoverage(struct module Global = Global module IntSyn' = IntSyn module Tomega' = Tomega module TomegaPrint = TomegaPrint module TomegaTypeCheck = TomegaTypeCheck module Cover = Cover end)\n", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Unification on Formulas *) (* Author: Carsten Schuermann *) module type TOMEGACOVERAGE = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) exception Error of stringval coverageCheckPrg : Worlds * Dec Ctx * Prg -> unit end(* Signature TOMEGACOVERAGE *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Unification on Formulas *) (* Author: Carsten Schuermann *) module type TOMEGAUNIFY = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) exception Unify of stringval unifyFor : Dec Ctx * For * For -> unit end(* Signature TOMEGATYPECHECK *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Type checking for Tomega *) (* Author: Carsten Schuermann *) (* Modified: Yu Liao *) module TomegaTypeCheck (module Abstract : ABSTRACTmodule TypeCheck : TYPECHECKmodule Conv : CONVmodule Whnf : WHNFmodule Print : PRINTmodule TomegaPrint : TOMEGAPRINTmodule Subordinate : SUBORDINATEmodule Weaken : WEAKENmodule TomegaAbstract : TOMEGAABSTRACT) : TOMEGATYPECHECK = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  exception Error of string module I = IntSynmodule T = Tomegamodule S = Subordinatemodule TA = TomegaAbstractlet rec chatter chlev f  = if ! chatter >= chlev then print (f ()) else () let rec normalizeHead (Const lemma, t)  = Const lemma | normalizeHead (Var k, t)  = (match varSub (k, t) with Idx (k\') -> Var (k\')) (* no other cases can occur *) (*    (* inferCon (Psi, (H, t)) = (F\', t\')\n\n       Invariant:\n       If   Psi  |- t : Psi1\n       and  Psi1 |- H : F\n       then Psi  |- F\'[t\'] == F[t]\n    *)\n    fun inferCon (Psi, T.Const lemma) = inferLemma lemma\n      | inferCon (Psi, T.Var k) =\n          case T.ctxDec (Psi, k) of T.PDec (_, F\') => F\'\n*) (* inferSpine (Psi, (S, t1), (F, t2)) = (F\', t\')\n\n       Invariant:\n       If   Psi  |- t1 : Psi1\n       and  Psi1 |- S : F\' > F\'\'\n       and  Psi  |- t2 : Psi2\n       and  Psi2 |- F for\n       and  Psi  |- F\'[t1] == F[t2]\n       then Psi  |- F\'\'[t1] == F\'[t\']\n    *) let rec inferSpine (Psi, S, Ft)  = inferSpineW (Psi, S, whnfFor Ft)inferSpineW (Psi, Nil, (F, t))  = (F, t) | inferSpineW (Psi, AppExp (M, S), (All ((UDec (Dec (_, A)), _), F), t))  = let _ = chatter 4 (fun () -> "[appExp") let G = coerceCtx (Psi) let _ = typeCheck (G, (M, EClo (A, coerceSub t))) let _ = chatter 4 (fun () -> "]") in inferSpine (Psi, S, (F, Dot (Exp (M), t))) | inferSpineW (Psi, AppBlock (Bidx k, S), (All ((UDec (BDec (_, (cid, s))), _), F2), t2))  = let UDec (BDec (_, (cid\', s\'))) = ctxDec (Psi, k) let (G\', _) = conDecBlock (sgnLookup cid\') let _ = if (cid <> cid\') then raise (Error ("Block label incompatible")) else () let s\'\' = coerceSub (comp (embedSub s, t2)) let _ = convSub (s\', s\'\') in inferSpine (Psi, S, (F2, Dot (Block (Bidx k), t2))) | inferSpineW (Psi, AppPrg (P, S), (All ((PDec (_, F1, _, _), _), F2), t))  = let _ = checkPrg (Psi, (P, (F1, t))) in inferSpine (Psi, S, (F2, dot1 t)) | inferSpineW (Psi, _, _)  = raise (Error "applied, but not of function type.")inferPrg (Psi, Lam (D, P))  = let F = inferPrg (Decl (Psi, D), P) in All ((D, Explicit), F) | inferPrg (Psi, New P)  = let All ((UDec (D as (BDec _)), _), F) = inferPrg (Psi, P) in raiseF (Decl (Null, D), (F, id)) | inferPrg (Psi, PairExp (U, P))  = let V = infer\' (coerceCtx Psi, U) let F = inferPrg (Psi, P) in Ex ((Dec (NONE, V), Explicit), F) | inferPrg (Psi, PairBlock (Bidx k, P))  = (* Blocks T.Inst, and T.LVar excluded for now *)  let D = ctxLookup (coerceCtx Psi, k) let F = inferPrg (Psi, P) in Ex ((D, Explicit), F) | inferPrg (Psi, PairPrg (P1, P2))  = let F1 = inferPrg (Psi, P1) let F2 = inferPrg (Psi, P2) in And (F1, F2) | inferPrg (Psi, Unit)  = True | inferPrg (Psi, Var k)  = (match ctxDec (Psi, k) with PDec (_, F\', _, _) -> F\') | inferPrg (Psi, Const c)  = inferLemma c | inferPrg (Psi, Redex (P, S))  = let F1 = inferPrg (Psi, P) let F2 = inferSpine (Psi, S, (F1, id)) in forSub F2 | inferPrg (Psi, Rec (D as PDec (_, F, _, _), P))  = let _ = checkPrg (Decl (Psi, D), (P, (F, id))) in F | inferPrg (Psi, Let (D as PDec (_, F1, _, _), P1, P2))  = let _ = checkPrg (Psi, (P1, (F1, id))) let F2 = inferPrg (Decl (Psi, D), P2) in F2(* checkPrg (Psi, P, F) = ()\n\n       Invariant:\n       If   Psi  |- t1 : Psi1\n       and  Psi1 |- P : F\'\n       and  Psi  |- F for     (F in normal form)\n       and  P does not contain any P closures\n       then checkPrg returns () iff F\'[t1] == F[id]\n    *) checkPrg (Psi, (P, Ft))  = checkPrgW (Psi, (P, whnfFor Ft))checkPrgW (_, (Unit, (True, _)))  = let _ = chatter 4 (fun () -> "[true]") in () | checkPrgW (Psi, (Const lemma, (F, t)))  = convFor (Psi, (inferLemma lemma, id), (F, t)) | checkPrgW (Psi, (Var k, (F, t)))  = (match ctxDec (Psi, k) with PDec (_, F\', _, _) -> convFor (Psi, (F\', id), (F, t))) | checkPrgW (Psi, (Lam (D as PDec (x, F1, _, _), P), (All ((PDec (x\', F1\', _, _), _), F2), t)))  = let _ = chatter 4 (fun () -> "[lam[p]") let _ = convFor (Psi, (F1, id), (F1\', t)) let _ = chatter 4 (fun () -> "]") in checkPrg (Decl (Psi, D), (P, (F2, dot1 t))) | checkPrgW (Psi, (Lam (UDec D, P), (All ((UDec D\', _), F), t2)))  = let _ = chatter 4 (fun () -> "[lam[u]") let _ = convDec ((D, id), (D\', coerceSub t2)) let _ = chatter 4 (fun () -> "]") in checkPrg (Decl (Psi, UDec D), (P, (F, dot1 t2))) | checkPrgW (Psi, (PairExp (M, P), (Ex ((Dec (x, A), _), F2), t)))  = let _ = chatter 4 (fun () -> "[pair [e]") let G = coerceCtx Psi let _ = typeCheck (G, (M, EClo (A, coerceSub (t)))) let _ = chatter 4 (fun () -> "]") in checkPrg (Psi, (P, (F2, Dot (Exp M, t)))) | checkPrgW (Psi, (PairBlock (Bidx k, P), (Ex ((BDec (_, (cid, s)), _), F2), t)))  = let UDec (BDec (_, (cid\', s\'))) = ctxDec (Psi, k) let (G\', _) = conDecBlock (sgnLookup cid) let _ = if (cid\' <> cid) then raise (Error ("Block label mismatch")) else () let _ = convSub (Psi, embedSub s\', comp (embedSub (s), t), revCoerceCtx (G\')) in checkPrg (Psi, (P, (F2, Dot (Block (Bidx k), t)))) | checkPrgW (Psi, (PairPrg (P1, P2), (And (F1, F2), t)))  = let _ = chatter 4 (fun () -> "[and") let _ = checkPrg (Psi, (P1, (F1, t))) let _ = chatter 4 (fun () -> "...") let _ = checkPrg (Psi, (P2, (F2, t))) let _ = chatter 4 (fun () -> "]") in () | checkPrgW (Psi, (Case Omega, Ft))  = checkCases (Psi, (Omega, Ft)) | checkPrgW (Psi, (Rec (D as PDec (x, F, _, _), P), (F\', t)))  = let _ = chatter 4 (fun () -> "[rec") let _ = convFor (Psi, (F, id), (F\', t)) let _ = chatter 4 (fun () -> "]\\n") in checkPrg (Decl (Psi, D), (P, (F\', t))) | checkPrgW (Psi, (Let (D as PDec (_, F1, _, _), P1, P2), (F2, t)))  = (* Psi |- let xx :: F1 = P1 in P2 : F2\' *)  (* Psi |- t : Psi\' *)  (* Psi\' |- F2 for *)  (* Psi |- F2\' = F2[t] *)  (* Psi |- F1 :: for *)  (* Psi |- P1 :: F1\' *)  (* Psi, D |- P2 :: (F2\' [^]) *)  (* Psi\' |- F2\' :: for *)  (* Psi, D |- t o ^ :: Psi\' *)  (* Psi |- F1 == F1\' for *) let _ = chatter 4 (fun () -> "[let") let _ = checkPrg (Psi, (P1, (F1, id))) let _ = chatter 4 (fun () -> ".") let _ = checkPrg (Decl (Psi, D), (P2, (F2, comp (t, shift)))) let _ = chatter 4 (fun () -> "]\\n") in () | checkPrgW (Psi, (New (P\' as Lam (UDec (D as BDec (_, (cid, s))), P)), (F, t)))  = (* D\'\' == D *) let _ = chatter 5 (fun () -> "[new1...") let All ((UDec D\'\', _), F\') = inferPrg (Psi, P\') let _ = chatter 5 (fun () -> "][new2...") let F\'\' = raiseF (Decl (Null, D), (F\', id)) in (convFor (Psi, (F\'\', id), (F, t)); chatter 5 (fun () -> "]\\n")) | checkPrgW (Psi, (Redex (P1, S2), (F, t)))  = let F\' = inferPrg (Psi, P1) in checkSpine (Psi, S2, (F\', id), (F, t)) | checkPrgW (Psi, (Box (W, P), (World (W\', F), t)))  = checkPrgW (Psi, (P, (F, t)))(* don\'t forget to check if the worlds match up --cs Mon Apr 21 01:51:58 2003 *) checkSpine (Psi, Nil, (F, t), (F\', t\'))  = convFor (Psi, (F, t), (F\', t\')) | checkSpine (Psi, AppExp (U, S), (All ((UDec (Dec (_, V)), _), F), t), (F\', t\'))  = (typeCheck (coerceCtx Psi, (U, EClo (V, coerceSub t))); checkSpine (Psi, S, (F, Dot (Exp U, t)), (F\', t\'))) | checkSpine (Psi, AppPrg (P, S), (All ((PDec (_, F1, _, _), _), F2), t), (F\', t\'))  = (checkPrgW (Psi, (P, (F1, t))); checkSpine (Psi, S, (F2, Dot (Undef, t)), (F\', t\'))) | checkSpine (Psi, AppExp (U, S), (FClo (F, t1), t), (F\', t\'))  = checkSpine (Psi, AppExp (U, S), (F, comp (t1, t)), (F\', t\'))(* checkCases (Psi, (Omega, (F, t2))) = ()\n       Invariant:\n       and  Psi |- Omega : F\'\n       and  Psi |- F\' for\n       then checkCases returns () iff Psi |- F\' == F [t2] formula\n    *) checkCases (Psi, (Cases nil, (F2, t2)))  = () | checkCases (Psi, (Cases ((Psi\', t\', P) :: Omega), (F2, t2)))  = (* Psi\' |- t\' :: Psi *) let _ = chatter 4 (fun () -> "[case... ") let _ = chatter 4 (fun () -> "sub... ") let _ = checkSub (Psi\', t\', Psi) let _ = chatter 4 (fun () -> "prg... ") let t2\' = comp (t2, t\') let _ = checkCtx Psi let _ = checkCtx Psi\' let _ = chatter 4 (fun () -> "]") let _ = checkPrg (Psi\', (P, (F2, t2\'))) let _ = chatter 4 (fun () -> "]\\n") let _ = checkCases (Psi, ((Cases Omega), (F2, t2))) in ()inferLemma lemma  = (match (lemmaLookup lemma) with ForDec (_, F) -> F | ValDec (_, _, F) -> F)(* convFor (Psi, (F1, t1), (F2, t2)) = ()\n\n       Invariant:\n       If   Psi |- t1 :: Psi1\n       and  Ps1 |- F1 for\n    *) convFor (Psi, Ft1, Ft2)  = convForW (Psi, whnfFor Ft1, whnfFor Ft2)convForW (_, (True, _), (True, _))  = () | convForW (Psi, (All ((D as UDec (Dec (_, A1)), _), F1), t1), (All ((UDec (Dec (_, A2)), _), F2), t2))  = let G = coerceCtx (Psi) let s1 = coerceSub t1 let s2 = coerceSub t2 let _ = conv ((A1, s1), (A2, s2)) let _ = typeCheck (G, (EClo (A1, s1), Uni Type)) let _ = typeCheck (G, (EClo (A2, s2), Uni Type)) let D\' = decSub (D, t1) let _ = convFor (Decl (Psi, D\'), (F1, dot1 t1), (F2, dot1 t2)) in () | convForW (Psi, (All ((D as UDec (BDec (_, (l1, s1))), _), F1), t1), (All ((UDec (BDec (_, (l2, s2))), _), F2), t2))  = let _ = if l1 <> l2 then raise (Error "Contextblock clash") else () let (G\', _) = conDecBlock (sgnLookup l1) let _ = convSub (Psi, comp (embedSub s1, t1), comp (embedSub s2, t2), embedCtx G\') let D\' = decSub (D, t1) let _ = convFor (Decl (Psi, D\'), (F1, dot1 t1), (F2, dot1 t2)) in () | convForW (Psi, (Ex ((D as Dec (_, A1), _), F1), t1), (Ex ((Dec (_, A2), _), F2), t2))  = let G = coerceCtx (Psi) let s1 = coerceSub t1 let s2 = coerceSub t2 let _ = conv ((A1, s1), (A2, s2)) let _ = typeCheck (G, (EClo (A1, s1), Uni Type)) let _ = typeCheck (G, (EClo (A2, s2), Uni Type)) let D\' = decSub (D, s1) let _ = convFor (Decl (Psi, UDec D\'), (F1, dot1 t1), (F2, dot1 t2)) in () | convForW (Psi, (Ex ((D as BDec (name, (l1, s1)), _), F1), t1), (Ex ((BDec (_, (l2, s2)), _), F2), t2))  = let _ = if l1 <> l2 then raise (Error "Contextblock clash") else () let (G\', _) = conDecBlock (sgnLookup l1) let s1 = coerceSub t1 let _ = convSub (Psi, comp (embedSub s1, t1), comp (embedSub s2, t2), embedCtx G\') let D\' = decSub (D, s1) let _ = convFor (Decl (Psi, UDec D\'), (F1, dot1 t1), (F2, dot1 t2)) in () | convForW (Psi, (And (F1, F1\'), t1), (And (F2, F2\'), t2))  = let _ = convFor (Psi, (F1, t1), (F2, t2)) let _ = convFor (Psi, (F1\', t1), (F2\', t2)) in () | convForW (Psi, (All ((D as PDec (_, F1, _, _), _), F1\'), t1), (All ((PDec (_, F2, _, _), _), F2\'), t2))  = let _ = convFor (Psi, (F1, t1), (F2, t2)) let D\' = decSub (D, t1) let _ = convFor (Decl (Psi, D\'), (F1\', dot1 t1), (F2\', dot1 t2)) in () | convForW (Psi, (World (W1, F1), t1), (World (W2, F2), t2))  = (* also check that both worlds are equal -- cs Mon Apr 21 01:28:01 2003 *) let _ = convFor (Psi, (F1, t1), (F2, t2)) in () | convForW _  = raise (Error "Typecheck error")convSub (G, Shift k1, Shift k2, G\')  = if k1 = k2 then () else raise (Error "Sub not equivalent") | convSub (G, Shift k, s2 as Dot _, G\')  = convSub (G, Dot (Idx (k + 1), Shift (k + 1)), s2, G\') | convSub (G, s1 as Dot _, Shift k, G\')  = convSub (G, s1, Dot (Idx (k + 1), Shift (k + 1)), G\') | convSub (G, Dot (Idx k1, s1), Dot (Idx k2, s2), Decl (G\', _))  = if k1 = k2(* For s1==s2, the variables in s1 and s2 must refer to the same cell in the context -- Yu Liao *)  then convSub (G, s1, s2, G\') else raise (Error "Sub not equivalent") | convSub (G, Dot (Exp M1, s1), Dot (Exp M2, s2), Decl (G\', UDec (Dec (_, A))))  = (* checkConv doesn\'t need context G?? -- Yu Liao *) let _ = checkConv (M1, M2) let _ = typeCheck (coerceCtx (G), (M1, A)) in convSub (G, s1, s2, G\') | convSub (G, Dot (Block (Bidx v1), s1), Dot (Block (Bidx v2), s2), Decl (G\', UDec (BDec (_, (l, s)))))  = let UDec (BDec (_, (l1, s11))) = ctxDec (G, v1) let UDec (BDec (_, (l2, s22))) = ctxDec (G, v2) let _ = if l1 = l2 then () else raise (Error "Sub not equivalent") let _ = if l1 = l then () else raise (Error "Sub not equivalent") let (G\'\', _) = conDecBlock (sgnLookup l) let _ = convSub (G, embedSub s11, embedSub s22, revCoerceCtx (G\'\')) let _ = convSub (G, embedSub s11, embedSub s, revCoerceCtx (G\'\')) in convSub (G, s1, s2, G\') | convSub (G, Dot (Prg P1, s1), Dot (Prg P2, s2), Decl (G\', PDec (_, F, _, _)))  = let _ = isValue P1 let _ = isValue P2 let _ = convValue (G, P1, P2, F) in convSub (G, s1, s2, G\') | convSub (G, Dot (Idx k1, s1), Dot (Exp M2, s2), Decl (G\', UDec (Dec (_, A))))  = let _ = checkConv (Root (BVar k1, Nil), M2) let _ = typeCheck (coerceCtx (G), (M2, A)) in convSub (G, s1, s2, G\') | convSub (G, Dot (Exp M1, s1), Dot (Idx k2, s2), Decl (G\', UDec (Dec (_, A))))  = let _ = checkConv (M1, Root (BVar k2, Nil)) let _ = typeCheck (coerceCtx (G), (M1, A)) in convSub (G, s1, s2, G\') | convSub (G, Dot (Idx k1, s1), Dot (Prg P2, s2), Decl (G\', PDec (_, F, _, _)))  = let _ = isValue P2 let _ = convValue (G, Var k1, P2, F) in convSub (G, s1, s2, G\') | convSub (G, Dot (Prg P1, s1), Dot (Idx k2, s2), Decl (G\', PDec (_, F, _, _)))  = let _ = isValue P1 let _ = convValue (G, P1, Var k2, F) in convSub (G, s1, s2, G\')convValue (G, P1, P2, F)  = ()checkFor (Psi, (True, _))  = () | checkFor (Psi, (All ((D as PDec (_, F1, _, _), _), F2), t))  = (checkFor (Psi, (F1, t)); checkFor (Decl (Psi, D), (F2, dot1 t))) | checkFor (Psi, (All ((D\' as UDec D, _), F), t))  = (checkDec (coerceCtx Psi, (D, coerceSub t)); checkFor (Decl (Psi, D\'), (F, dot1 t))) | checkFor (Psi, (Ex ((D, _), F), t))  = (checkDec (coerceCtx Psi, (D, coerceSub t)); checkFor (Decl (Psi, UDec D), (F, dot1 t))) | checkFor (Psi, (And (F1, F2), t))  = (checkFor (Psi, (F1, t)); checkFor (Psi, (F2, t))) | checkFor (Psi, (FClo (F, t\'), t))  = checkFor (Psi, (F, comp (t\', t))) | checkFor (Psi, (World (W, F), t))  = checkFor (Psi, (F, t))checkCtx (Null)  = () | checkCtx (Decl (Psi, UDec D))  = (checkCtx (Psi); checkDec (coerceCtx Psi, (D, id))) | checkCtx (Decl (Psi, PDec (_, F, _, _)))  = (checkCtx (Psi); checkFor (Psi, (F, id)))(* checkSub (Psi, t, Psi\') = ()\n\n       Invariant\n       If Psi |- t: Psi\' then checkSub terminates with ()\n       otherwise exception Error is raised\n    *) checkSub (Null, Shift 0, Null)  = () | checkSub (Decl (G, D), Shift k, Null)  = if k > 0 then checkSub (G, Shift (k - 1), Null) else raise (Error "Sub is not well typed!") | checkSub (G, Shift k, G\')  = checkSub (G, Dot (Idx (k + 1), Shift (k + 1)), G\') | checkSub (G, Dot (Idx k, s\'), Decl (G\', (UDec (Dec (_, A)))))  = let _ = checkSub (G, s\', G\') let UDec (Dec (_, A\')) = ctxDec (G, k) in if conv ((A\', id), (A, coerceSub (s\'))) then () else raise (Error "Sub isn\'t well typed!") | checkSub (G, Dot (Idx k, s\'), Decl (G\', UDec (BDec (l, (_, s)))))  = let _ = checkSub (G, s\', G\') let UDec (BDec (l1, (_, s1))) = ctxDec (G, k) in if (l <> l1) then raise (Error "Sub isn\'t well typed!") else if convSub (comp (s, coerceSub (s\')), s1) then () else raise (Error "Sub isn\'t well typed!") | checkSub (G, Dot (Idx k, s), Decl (G\', PDec (_, F\', _, _)))  = let _ = checkSub (G, s, G\') let PDec (_, F1, _, _) = ctxDec (G, k) in convFor (G, (F1, id), (F\', s)) | checkSub (G, Dot (Exp M, s), Decl (G\', UDec (Dec (_, A))))  = let _ = checkSub (G, s, G\') in typeCheck (coerceCtx G, (M, EClo (A, coerceSub (s)))) | checkSub (Psi, Dot (Prg P, t), Decl (Psi\', PDec (_, F\', _, _)))  = let _ = chatter 4 (fun () -> "$") let _ = checkSub (Psi, t, Psi\') let _ = isValue P in checkPrg (Psi, (P, (F\', t))) | checkSub (Psi, Dot (Block B, t), Decl (Psi\', UDec (BDec (l2, (c, s2)))))  = (* Psi |- t : Psi\' *) (* Psi\' |- s2 : SOME variables of c *) (* Psi |- s2 : G *) let _ = chatter 4 (fun () -> "$") let _ = checkSub (Psi, t, Psi\') let (G, L) = constBlock c let _ = typeCheckSub (coerceCtx Psi\', s2, G) in checkBlock (Psi, (B, (c, comp (s2, coerceSub t)))) | checkSub (Psi, Dot _, Null)  = raise (Error "Sub is not well typed")checkBlock (Psi, (Bidx v, (c2, s2)))  = let UDec (BDec (l1, (c1, s1))) = ctxDec (Psi, v) in if (c1 <> c2) then raise (Error "Sub isn\'t well typed!") else if convSub (s2, s1) then () else raise (Error "Sub isn\'t well typed!") | checkBlock (Psi, (Inst UL, (c2, s2)))  = (* Psi |- s2 : G *) let (G, L) = constBlock c2 let _ = typeCheckSub (coerceCtx Psi, s2, G) in checkInst (Psi, UL, (1, L, s2))(* Invariant:\n\n      If   Psi |- s2 : Psi\'    Psi\' |-  Bn ... Bm\n      and  Psi |- s : [cn :An ... cm:Am]\n      and  Ai == Bi n<= i<=m\n      then checkInst returns () otherwise an exception is raised.\n   *) checkInst (Psi, nil, (_, nil, _))  = () | checkInst (Psi, U :: UL, (n, D :: L, s2))  = let G = coerceCtx Psi let Dec (_, V) = decSub (D, s2) let _ = typeCheck (G, (U, V)) in checkInst (Psi, UL, (n + 1, L, dot1 s2))isValue (Var _)  = () | isValue (PClo (Lam _, _))  = () | isValue (PairExp (M, P))  = isValue P | isValue (PairBlock _)  = () | isValue (PairPrg (P1, P2))  = (isValue P1; isValue P2) | isValue Unit  = () | isValue (Rec _)  = () | isValue (Const lemma)  = (match (lemmaLookup lemma) with ForDec _ -> raise (Error "Lemma isn\'t a value") | ValDec (_, P, _) -> isValue P) | isValue _  = raise (Error "P isn\'t Value!") (*  remove later!\n    and isValue (T.Lam _) = ()\n      | isValue (T.PairExp (M, P)) = isValue P\n      | isValue (T.PairBlock _ ) = ()\n      | isValue (T.PairPrg (P1, P2)) = (isValue P1; isValue P2)\n      | isValue T.Unit = ()\n      | isValue (T.Root ((T.Const lemma), T.Nil)) = (* could lemma be a VALUE? -- Yu Liao *)\n        ( case (T.lemmaLookup lemma) of\n              T.ForDec _ => raise Error "Lemma isn\'t a value"\n            | T.ValDec(_,P,_) => isValue P )\n\n      | isValue (T.Root ((T.Var k), T.Nil)) = ()\n      | isValue (T.Rec _) = ()\n\n      (* ABP 1/23/03 *)\n      | isValue (T.EVar _) = raise Error "It is an EVar"\n\n      | isValue _ = raise Error "P isn\'t Value!"\n*) let rec check (Psi, (P, F))  = checkPrg (Psi, (P, (F, id))) let checkPrg = fun (Psi, (P, F)) -> checkPrg (Psi, (P, (F, id))) let checkSub = checkSub let checkFor = fun (Psi, F) -> checkFor (Psi, (F, id)) let checkCtx = checkCtx  end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Naming *) (* Author: Carsten Schuermann *) module type TOMEGANAMES = sig val decName : Dec Ctx * Dec -> Dec end', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Redundancy remover (factoring) *) (* Author: Adam Poswolsky (ABP) *) module Redundant (module Opsem : OPSEM) : REDUNDANT = struct exception Error of string (*\n     convert:  Tomega.Prg -> Tomega.Prg\n     Attempts to eliminate *redundant* cases.\n     *)  module T = Tomega module I = IntSyn let rec optionRefEqual (r1, r2, func)  = if (r1 = r2) then true else (match (r1, r2) with (ref NONE, ref NONE) -> true | (ref (SOME (P1)), ref (SOME (P2))) -> func (P1, P2) | _ -> false) let rec convert (Lam (D, P))  = Lam (D, convert P) | convert (New P)  = New (convert P) | convert (Choose P)  = Choose (convert P) | convert (PairExp (M, P))  = PairExp (M, convert P) | convert (PairBlock (rho, P))  = PairBlock (rho, convert P) | convert (PairPrg (P1, P2))  = PairPrg (convert P1, convert P2) | convert (Unit)  = Unit | convert (Var x)  = Var x | convert (Const x)  = Const x | convert (Redex (P, S))  = Redex (convert P, convertSpine S) | convert (Rec (D, P))  = Rec (D, convert P) | convert (Case (Cases O))  = Case (Cases (convertCases O)) | convert (Let (D, P1, P2))  = Let (D, convert P1, convert P2)(* No EVARs will occur\n      | convert (T.PClo (P,t)) = raise Error "No PClo should exist" (* T.PClo (convert P, t) *)\n      | convert (T.EVar (D, P as ref NONE, F)) = T.EVar (D, P, F)\n      | convert (T.EVar (D, ref (SOME P), F)) = convert P (* some opsem here *)\n    *) convertSpine (Nil)  = Nil | convertSpine (AppExp (I, S))  = (AppExp (I, convertSpine S)) | convertSpine (AppBlock (I, S))  = (AppBlock (I, convertSpine S)) | convertSpine (AppPrg (P, S))  = (AppPrg (convert P, convertSpine S)) | convertSpine (SClo (S, t))  = raise (Error "SClo should not exist")(* (T.SClo (convertSpine S, t)) *) expEqual (E1, E2)  = conv ((E1, id), (E2, id))IsubEqual (sub1, sub2)  = convSub (sub1, sub2)(* Note that it doesn\'t handle blocks *) blockEqual (Bidx x, Bidx x\')  = (x = x\') | blockEqual (LVar (r, sub1, (cid, sub2)), LVar (r\', sub1\', (cid\', sub2\')))  = optionRefEqual (r, r\', blockEqual) && IsubEqual (sub1, sub1\') && (cid = cid\') && IsubEqual (sub1\', sub2\') | blockEqual _  = falsedecEqual (UDec (D1), (UDec (D2), t2))  = convDec ((D1, id), (D2, coerceSub (t2))) | decEqual (PDec (_, F1, _, _), (PDec (_, F2, _, _), t2))  = convFor ((F1, id), (F2, t2)) | decEqual _  = falsecaseEqual (((Psi1, t1, P1) :: O1), (((Psi2, t2, P2) :: O2), tAfter))  = (* Recall that we (Psi2, t2, P2)[tAfter] = (Psi2, (tAfterInv \\circ t2), P2) *)  (* Note:  (Psi1 |- t1: Psi0) *) (* Psi1 |- t: Psi2 *) (* Psi1 |- t\' : Psi_0 *) let t2\' = comp (invertSub (tAfter), t2) let t = createVarSub (Psi1, Psi2) let t\' = comp (t2\', t) let doMatch = try  with  in if (doMatch) then let newT = normalizeSub t let stillMatch = IsSubRenamingOnly (newT) in (stillMatch && prgEqual (P1, (P2, cleanSub (newT)))) else false | caseEqual (nil, (nil, t2))  = true | caseEqual _  = falsespineEqual ((Nil), (Nil, t2))  = true | spineEqual ((AppExp (E1, S1)), (AppExp (E2, S2), t2))  = (conv ((E1, id), (E2, coerceSub (t2))) && spineEqual (S1, (S2, t2))) | spineEqual ((AppBlock (B1, S1)), (AppBlock (B2, S2), t2))  = (blockEqual (B1, blockSub (B2, coerceSub t2)) && spineEqual (S1, (S2, t2))) | spineEqual ((AppPrg (P1, S1)), (AppPrg (P2, S2), t2))  = (prgEqual (P1, (P2, t2)) && spineEqual (S1, (S2, t2))) | spineEqual (SClo (S, t1), (SClo (s, t2a), t2))  = (* there are no SClo created in converter *)  raise (Error "SClo should not exist!") | spineEqual _  = falseprgEqual ((Lam (D1, P1)), (Lam (D2, P2), t2))  = (decEqual (D1, (D2, t2)) && prgEqual (P1, (P2, dot1 t2))) | prgEqual ((New P1), (New P2, t2))  = prgEqual (P1, (P2, t2)) | prgEqual ((Choose P1), (Choose P2, t2))  = prgEqual (P1, (P2, t2)) | prgEqual ((PairExp (U1, P1)), (PairExp (U2, P2), t2))  = (conv ((U1, id), (U2, (coerceSub t2))) && prgEqual ((P1), (P2, t2))) | prgEqual ((PairBlock (B1, P1)), (PairBlock (B2, P2), t2))  = (blockEqual (B1, (blockSub (B2, coerceSub t2))) && prgEqual (P1, (P2, t2))) | prgEqual ((PairPrg (P1a, P1b)), (PairPrg (P2a, P2b), t2))  = (prgEqual (P1a, (P2a, t2)) && prgEqual (P1b, (P2b, t2))) | prgEqual ((Unit), (Unit, t2))  = true | prgEqual (Const lemma1, (Const lemma2, _))  = (lemma1 = lemma2) | prgEqual (Var x1, (Var x2, t2))  = (match getFrontIndex (varSub (x2, t2)) with NONE -> false | SOME i -> (x1 = i)) | prgEqual ((Redex (P1, S1)), (Redex (P2, S2), t2))  = (prgEqual (P1, (P2, t2)) && spineEqual (S1, (S2, t2))) | prgEqual ((Rec (D1, P1)), (Rec (D2, P2), t2))  = (decEqual (D1, (D2, t2)) && prgEqual (P1, (P2, dot1 t2))) | prgEqual ((Case (Cases O1)), (Case (Cases O2), t2))  = caseEqual (O1, (O2, t2)) | prgEqual ((Let (D1, P1a, P1b)), (Let (D2, P2a, P2b), t2))  = (decEqual (D1, (D2, t2)) && prgEqual (P1a, (P2a, t2))) | prgEqual ((PClo (P1, t1)), (PClo (P2, t2a), t2b))  = (* there are no PClo created in converter *)  raise (Error "PClo should not exist!") | prgEqual ((EVar (Psi1, P1optRef, F1, _, _, _)), (EVar (Psi2, P2optref, F2, _, _, _), t2))  = raise (Error "No EVARs should exist!") | prgEqual _  = false(* convertCases is where the real work comes in *) (* will attempt to merge cases together and call convert\n     * on what happens in each case\n     *) convertCases (A :: C)  = let ((Psi, t, P), C\') = removeRedundancy (A, C) in ((Psi, t, convert (P)) :: convertCases (C\')) | convertCases C  = C(* will be T.Cases nil *) (* Returns a list with C (merged with redundant cases) as the head followed by the rest *) removeRedundancy (C, [])  = (C, []) | removeRedundancy (C, C\' :: rest)  = let (C\'\' :: Cs) = mergeIfNecessary (C, C\') let (C\'\'\', rest\') = removeRedundancy (C\'\', rest) in (C\'\'\', Cs @ rest\')(* returns NONE if not found *) getFrontIndex (Idx k)  = SOME (k) | getFrontIndex (Prg P)  = getPrgIndex (P) | getFrontIndex (Exp U)  = getExpIndex (U) | getFrontIndex (Block B)  = getBlockIndex (B) | getFrontIndex (Undef)  = NONE(* getPrgIndex returns NONE if it is not an index *) getPrgIndex (Var k)  = SOME (k) | getPrgIndex (Redex (P, Nil))  = getPrgIndex (P) | getPrgIndex (PClo (P, t))  = (match getPrgIndex (P) with NONE -> NONE | SOME i -> getFrontIndex (varSub (i, t))) | getPrgIndex _  = NONE(* getExpIndex returns NONE if it is not an index *) getExpIndex (Root (BVar k, Nil))  = SOME (k) | getExpIndex (Redex (U, Nil))  = getExpIndex (U) | getExpIndex (EClo (U, t))  = (match getExpIndex (U) with NONE -> NONE | SOME i -> getFrontIndex (revCoerceFront (bvarSub (i, t)))) | getExpIndex (U as Lam (Dec (_, U1), U2))  = (try  with ) | getExpIndex _  = NONE(* getBlockIndex returns NONE if it is not an index *) getBlockIndex (Bidx k)  = SOME (k) | getBlockIndex _  = NONE(* clean up the renaming substitution,\n       this is to allow T.invertSub to appropriately\n       think it is a pattern substitution\n       *) cleanSub (S as Shift _)  = S | cleanSub (Dot (Ft1, s1))  = (match getFrontIndex (Ft1) with NONE -> Dot (Ft1, cleanSub (s1)) | SOME index -> Dot (Idx index, cleanSub (s1)))(* determine if t is simply a renaming substitution *) IsSubRenamingOnly (Shift (n))  = true | IsSubRenamingOnly (Dot (Ft1, s1))  = (match getFrontIndex (Ft1) with NONE -> false | SOME _ -> true) && IsSubRenamingOnly (s1)(* Note that what we are merging it with will need to go under an extra renaming substitution *) mergeSpines ((Nil), (Nil, t2))  = Nil | mergeSpines ((AppExp (E1, S1)), (AppExp (E2, S2), t2))  = if conv ((E1, id), (E2, coerceSub (t2))) then AppExp (E1, mergeSpines (S1, (S2, t2))) else raise (Error "Spine not equal (AppExp)") | mergeSpines ((AppBlock (B1, S1)), (AppBlock (B2, S2), t2))  = if blockEqual (B1, blockSub (B2, coerceSub t2)) then AppBlock (B1, mergeSpines (S1, (S2, t2))) else raise (Error "Spine not equal (AppBlock)") | mergeSpines ((AppPrg (P1, S1)), (AppPrg (P2, S2), t2))  = if (prgEqual (P1, (P2, t2))) then AppPrg (P1, mergeSpines (S1, (S2, t2))) else raise (Error "Prg (in App) not equal") | mergeSpines (SClo (S, t1), (SClo (s, t2a), t2))  = (* there are no SClo created in converter *)  raise (Error "SClo should not exist!") | mergeSpines _  = raise (Error "Spine are not equivalent")mergePrgs ((Lam (D1, P1)), (Lam (D2, P2), t2))  = if (decEqual (D1, (D2, t2)) && prgEqual (P1, (P2, dot1 t2))) then Lam (D1, P1) else raise (Error "Lambda don\'t match") | mergePrgs ((New P1), (New P2, t2))  = if (prgEqual (P1, (P2, t2))) then New P1 else raise (Error "New don\'t match") | mergePrgs ((Choose P1), (Choose P2, t2))  = if (prgEqual (P1, (P2, t2))) then Choose P1 else raise (Error "Choose don\'t match") | mergePrgs ((PairExp (U1, P1)), (PairExp (U2, P2), t2))  = let t2\' = coerceSub t2 in if (conv ((U1, id), (U2, t2\'))) then PairExp (U1, mergePrgs ((P1), (P2, t2))) else raise (Error "cannot merge PairExp") | mergePrgs ((PairBlock (B1, P1)), (PairBlock (B2, P2), t2))  = let B2\' = blockSub (B2, coerceSub t2) in if (blockEqual (B1, B2\')) then PairBlock (B1, mergePrgs ((P1), (P2, t2))) else raise (Error "cannot merge PairBlock") | mergePrgs ((PairPrg (P1a, P1b)), (PairPrg (P2a, P2b), t2))  = if (prgEqual (P1a, (P2a, t2))) then PairPrg (P1a, (mergePrgs ((P1b), (P2b, t2)))) else raise (Error "cannot merge PairPrg") | mergePrgs ((Unit), (Unit, t2))  = Unit | mergePrgs (Const lemma1, (Const lemma2, _))  = if (lemma1 = lemma2) then Const lemma1 else raise (Error "Constants do not match.") | mergePrgs (Var x1, (Var x2, t2))  = (match getFrontIndex (varSub (x2, t2)) with NONE -> raise (Error "Variables do not match.") | SOME i -> (if (x1 = i) then Var x1 else raise (Error "Variables do not match."))) | mergePrgs ((Redex (P1, S1)), (Redex (P2, S2), t2))  = let newS = mergeSpines (S1, (S2, t2)) in if (prgEqual (P1, (P2, t2))) then Redex (P1, newS) else raise (Error "Redex Prgs don\'t match") | mergePrgs ((Rec (D1, P1)), (Rec (D2, P2), t2))  = if (decEqual (D1, (D2, t2)) && prgEqual (P1, (P2, dot1 t2))) then Rec (D1, P1) else raise (Error "Rec\'s don\'t match") | mergePrgs ((Case (Cases O1)), (Case (Cases [C]), t2))  = (* check the case now *)  (* three possible outcomes -\n                   (1) We merge the cases together\n                   (2) Cases are incompatible (duplicated)\n                   (3) Cases are duplicate but all results are the same\n                       which means we need to continue merging\n                 *)  Case (Cases (mergeCase (O1, (C, t2)))) | mergePrgs ((Case O1), (Case O2, t2))  = raise (Error "Invariant Violated") | mergePrgs ((PClo (P1, t1)), (PClo (P2, t2a), t2b))  = (* there are no PClo created in converter *)  raise (Error "PClo should not exist!") | mergePrgs ((Let (D1, P1a, P1b)), (Let (D2, P2a, P2b), t2))  = if (decEqual (D1, (D2, t2)) && prgEqual (P1a, (P2a, t2))) then Let (D1, P1a, mergePrgs ((P1b), (P2b, dot1 t2))) else raise (Error "Let don\'t match") | mergePrgs ((EVar (Psi1, P1optRef, F1, _, _, _)), (EVar (Psi2, P2optref, F2, _, _, _), t2))  = raise (Error "No EVARs should exist!") | mergePrgs _  = raise (Error "Redundancy in cases could not automatically be removed.")(*\n    (* For debug purposes *)\n    and printCtx(Psi) =\n      let\n        fun printDec ( T.UDec (I.Dec (SOME(s), E)) ) =  (print s ; print ": "; print (Print.expToString (T.coerceCtx Psi, E)); print "\\n" )\n          | printDec ( T.UDec (I.BDec (SOME(s), (cid, sub)))) = (print s ; print ":\\n")\n          | printDec ( T.UDec (I.ADec (SOME(s), i))) = (print s ; print ":(ADec\\n")\n          | printDec ( T.UDec (I.NDec) ) = (print "(NDec)\\n")\n          | printDec ( T.PDec (SOME(s), F)) = (print s ; print ":(PDec)\\n")\n      in\n        case Psi of\n          (I.Null) => (print "Null\\n")\n          | (I.Decl (G, D)) =>  (printCtx(G) ; printDec(D))\n      end\n*) (* invertSub s = s\'\n\n       Invariant:\n       If   G |- s : G\'    (and s patsub)\n       then G\' |- s\' : G\n       s.t. s o s\' = id\n    *) invertSub s  = let rec lookup (n, Shift _, p)  = NONE | lookup (n, Dot (Undef, s\'), p)  = lookup (n + 1, s\', p) | lookup (n, Dot (Ft, s\'), p)  = (match getFrontIndex (Ft) with NONE -> lookup (n + 1, s\', p) | SOME k -> if (k = p) then SOME n else lookup (n + 1, s\', p)) let rec invertSub\'\' (0, si)  = si | invertSub\'\' (p, si)  = (match (lookup (1, s, p)) with SOME k -> invertSub\'\' (p - 1, Dot (Idx k, si)) | NONE -> invertSub\'\' (p - 1, Dot (Undef, si))) let rec invertSub\' (n, Shift p)  = invertSub\'\' (p, Shift n) | invertSub\' (n, Dot (_, s\'))  = invertSub\' (n + 1, s\') in invertSub\' (0, s)(* debug *) printSub (Shift k)  = print ("Shift " ^ toString (k) ^ "\\n") | printSub (Dot (Idx k, s))  = (print ("Idx " ^ toString (k) ^ " (DOT) "); printSub (s)) | printSub (Dot (Prg (EVar _), s))  = (print ("PRG_EVAR (DOT) "); printSub (s)) | printSub (Dot (Exp (EVar _), s))  = (print ("EXP_EVAR (DOT) "); printSub (s)) | printSub (Dot (Prg P, s))  = (print ("PRG (DOT) "); printSub (s)) | printSub (Dot (Exp E, s))  = (print ("EXP (DOT) "); printSub (s)) | printSub (Dot (Block B, s))  = (print ("BLOCK (DOT) "); printSub (s)) | printSub (Dot (Undef, s))  = (print ("UNDEF. (DOT) "); printSub (s))(* We need to return it in terms of the context of the first *) mergeCase ([], C)  = raise (Error "Case incompatible, cannot merge") | mergeCase (L as (Psi1, t1, P1) :: O, C as ((Psi2, t2, P2), tAfter))  = (*\n        val _ = printCtx(Psi1)\n        val _ = printCtx(Psi2)\n          *) (* Psi1 |- P1 : F[t1] *) (* Psi2 |- P2 : F[t2] *) (* Psi1 |- t1 : Psi1\' *) (* Psi2 |- t2 : Psi2\' *) (* By invariant,we assume *) (* Psi1\' |- tAfter: Psi2\' *) (* Psi2\' |- tAfterInv : Psi1\' *) (* So now we have\n         P1 makes sense in Psi1, t1 goes from Psi1\' to Psi1.\n\n         Psi1 |- t1 : Psi1\'\n         Psi2 |- t3 : Psi1\'\n         *) (* Psi1 |- t : Psi2 *) (* Psi1 |- t\' : Psi1\' *) (* If we can get this to match, then Psi1 |- P2[t] *) let tAfterInv = invertSub (tAfter) let t3 = comp (tAfterInv, t2) let t = createVarSub (Psi1, Psi2) let t\' = comp (t3, t) let doMatch = try  with  in if (doMatch) then let newT = normalizeSub t let stillMatch = IsSubRenamingOnly (newT) in if (stillMatch) then (* Since the case matches, lets continue the merge on P1 and P2\n           * Note that removing the redundancy of other case statements\n           * is handled recursively ... see convertCases\n           *) (* Note that tAfter and newT are both renaming substitutions *) (Psi1, t1, mergePrgs (P1, (P2, cleanSub (newT)))) :: O else if (length (O) = 0) then (* We tried all the cases, and we can now add it *) (Psi2, t3, P2) :: L else (* Try other cases *) (Psi1, t1, P1) :: mergeCase (O, C) else if (length (O) = 0) then (* We tried all the cases, and we can now add it *) (Psi2, t3, P2) :: L else (* Try other cases *) (Psi1, t1, P1) :: mergeCase (O, C)(* mergeIfNecessary\n   * Simply see if C is the same case as C\'\n   * If so, try to merge them together and return a list of just the case merged together,\n   * otherwise, return a list of both elements.\n   *) mergeIfNecessary (C as (Psi1, s1, P1), C\' as (Psi2, s2, P2))  = (* Note that s1 is a substitution s.t.  Psi1 |- s1: Psi0\n        and s2 is a substitution s.t.         Psi2 |- s2: Psi0\n\n        It is possible that this property is lost when the case is executed\n        with a different Psi0 which can happen during recursive calls\n        (as the context grows).\n\n        In that case:\n          Psi, Psi1 |- X1...Xn, id{Psi} : Psi, Psi2\n\n        Therefore, the X\'s are not dependent on the extra Psi introduced\n        by recursive calls, which is why they are ignored in matchSub as well.\n\n        We will generate a substitution t s.t. Psi1 |- t: Psi2\n        Therefore  Psi1 |- (s2 o t) : Psi0\n\n        And we are trying to match it with\n                   Psi1 |- s1 : Psi0\n\n      *) (* Psi1 |- t : Psi2 *) (* Now since s1 and t\' go between the same contexts, we see\n      * if we can unify them\n      *) let t = createVarSub (Psi1, Psi2) let t\' = comp (s2, t) let doMatch = try  with  in if (not doMatch) then [C; C\'] else let newT = normalizeSub t in if (IsSubRenamingOnly (newT)) then try  with  else [C; C\'] end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Operational Semantics for Delphin *) (* Author: Carsten Schuermann *) module type OPSEM = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) exception NoMatchval evalPrg : Prg -> Prgval topLevel : Prg -> unitval createVarSub : Dec Ctx * Dec Ctx -> Subval matchSub : Dec Ctx * Sub * Sub -> unit end', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Converter from relational representation to a functional\n   representation of proof terms *) (* Author: Carsten Schuermann *) module TomegaAbstract (module Global : GLOBALmodule Abstract : ABSTRACTmodule Whnf : WHNFmodule Subordinate : SUBORDINATE) : TOMEGAABSTRACT = struct exception Error of string module T = Tomegamodule I = IntSynmodule M = ModeSynmodule S = Subordinatemodule A = Abstractlet rec shiftCtx (Null, t)  = (Null, t) | shiftCtx (Decl (G, D), t)  = let (G', t') = shiftCtx (G, t) in (Decl (G', decSub (D, t')), dot1 t') (* dotn (t, n) = t'\n\n       Invariant:\n       If   Psi0 |- t : Psi\n       and  |G| = n   for any G\n       then Psi0, G[t] |- t : Psi, G\n    *) let rec dotn (t, 0)  = t | dotn (t, n)  = dot1 (dotn (t, n - 1)) let rec strengthenToSpine (Shift _, (* =0 *) , 0, (n, S))  = S | strengthenToSpine (Dot (Idx _, (* = 1 *) , t), l, (n, S))  = let t' = comp (t, invShift) in strengthenToSpine (t', l - 1, (n + 1, App (Root (BVar n, Nil), S))) | strengthenToSpine (Dot (Undef, t), l, (n, S))  = strengthenToSpine (t, l - 1, (n + 1, S)) | strengthenToSpine (Shift k, l, (n, S))  = strengthenToSpine (Dot (Idx (k + 1), Shift (k + 1)), l, (n, S)) (* raiseFor (B, (F, t)) = (P', F'))\n\n       Invariant:\n       If   Psi, B, G |-  F for\n       and  Psi, G', B' |- t : Psi, B, G\n       then Psi, G' |-  F' for\n       and  F' = raise (B', F[t])   (using subordination)\n    *) let rec raiseFor (B', (True, t))  = True | raiseFor (B', (And (F1, F2), t))  = let F1' = raiseFor (B', (F1, t)) let F2' = raiseFor (B', (F2, t)) in And (F1', F2') | raiseFor (B', (Ex ((Dec (x, V), Q), F), t))  = (* Psi, G', B' |- V[t] : type *)  (* Psi, B, G, x:V |- F for *)  (* Psi, G' |- B' ctx  *)  (*        val (w, S) = subweaken (B', 1, I.targetFam V, I.Nil)     *) (* B'  |- w  : B''    *) (* B'' |- iw : B'     *) (* Psi0, G' |- B'' ctx *) (* Psi0, G' |- V' : type *) (* Psi, G', x: V' |- B''' ctx *) (* Psi, G', x: V', B''' |- t'' :   Psi, G', B' *) (* Psi, G', B' |- t : Psi, B, G  *) (* Psi, G', x:V', B''' |- t' : Psi, B, G *) (* Psi, G', x:V', B''' |- w : Psi,G', x:V', B'''' *) (* Psi, G', x:V', B''' |- S : V' [^|B'''|] >> type  *) (* Psi, G', x:V', B''' |- U : V[t'] *) (* Psi, G', x:V', B''' |- t''' :  Psi, B, G, x:V *) (* Psi, G', x:V' |- F' for*) let w = weaken (B', targetFam V) let iw = invert w let B'' = strengthen (iw, B') let V' = raiseType (B'', EClo (V, comp (t, iw))) let (B''', _) = shiftCtx (B', shift) let t'' = dotn (shift, ctxLength B') let t' = comp (t, t'') let S = strengthenToSpine (iw, ctxLength B', (1, Nil)) let U = Root (BVar (ctxLength B''' + 1), S) let t''' = dotEta (Exp U, t') let F' = raiseFor (B''', (F, t''')) in Ex ((Dec (x, V'), Q), F')(* Psi, G', x:V', B''' |- t''' :  Psi, B, G, x:V *) | raiseFor (_, (All _, _))  = raise (Domain) (* raisePrg (G, P, F) = (P', F'))\n\n       Invariant:\n       If   Psi, G |- P in F\n       and  Psi |- G : blockctx\n       then Psi |- P' in F'\n       and  P = raise (G, P')   (using subordination)\n       and  F = raise (G, F')   (using subordination)\n    *) let rec raisePrg (G, (Unit, t), _)  = Unit | raisePrg (G, (PairPrg (P1, P2), t), And (F1, F2))  = let P1' = raisePrg (G, (P1, t), F1) let P2' = raisePrg (G, (P2, t), F2) in PairPrg (P1', P2') | raisePrg (G, (PairExp (U, P), t), Ex ((Dec (_, V), _), F))  = (* G  |- w  : G'    *) (* G' |- iw : G     *) (* Psi0, G' |- B'' ctx *) let w = weaken (G, targetFam V) let iw = invert w let G' = strengthen (iw, G) let U' = raiseTerm (G', EClo (U, comp (t, iw))) let P' = raisePrg (G, (P, t), F) in PairExp (U', P') let rec raiseP (G, P, F)  = (*      val P' = T.normalizePrg (P, s) (* G' |- P' : F' *) *) let (G', s) = deblockify G let F' = forSub (F, s) let P'' = raisePrg (G', (P, coerceSub s), F') in P'' let rec raiseF (G, (F, t))  = let (G', s) = deblockify G let F' = raiseFor (G', (F, comp (t, coerceSub s))) in F' let raisePrg = fun (G, P, F) -> raisePrg (G, (P, id), F) let raiseP = raiseP let raiseFor = raiseFor let raiseF = raiseF  end(* functor TomegaAbstract *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "(* Internal syntax for functional proof term calculus *) (* Author: Carsten Schuermann *) module Normalize (module IntSyn' : INTSYNmodule Tomega' : TOMEGATomega'IntSynIntSyn'module Whnf : WHNFWhnfIntSynIntSyn') : NORMALIZE = struct module IntSyn = IntSyn' module Tomega = Tomega' exception Error of string module I = IntSyn'module T = Tomega'let rec normalizeFor (All (D, F), t)  = All (decSub (D, t), normalizeFor (F, dot1 t)) | normalizeFor (Ex (D, F), t)  = Ex (decSub (D, coerceSub t), normalizeFor (F, dot1 t)) | normalizeFor (And (F1, F2), t)  = And (normalizeFor (F1, t), normalizeFor (F2, t)) | normalizeFor (FClo (F, t1), t2)  = normalizeFor (F, comp (t1, t2)) | normalizeFor (World (W, F), t)  = World (W, normalizeFor (F, t)) | normalizeFor (True, _)  = True (* normalizePrg (P, t) = (P', t')\n\n       Invariant:\n       If   Psi' |- P :: F\n       and  Psi  |- t :: Psi'\n       and  P doesn't contain free EVars\n       then there exists a Psi'', F'\n       s.t. Psi'' |- F' for\n       and  Psi'' |- P' :: F'\n       and  Psi |- t' : Psi''\n       and  Psi |- F [t] == F' [t']\n       and  Psi |- P [t] == P' [t'] : F [t]\n       and  Psi |- P' [t'] :nf: F [t]\n    *) let rec normalizePrg (P as (Root (Const _, _)), t)  = P | normalizePrg ((P as (Root (Var n, _))), t)  = normalizePrg (P, Dot (varSub (n, t), id)) | normalizePrg (Lam (D, P'), t)  = Lam (D, normalizePrg (P', dot1 t)) | normalizePrg (PairExp (U, P'), t)  = PairExp (EClo (whnf ((U, coerceSub t) : eclo)), normalizePrg (P', t)) | normalizePrg (PairPrg (P1, P2), t)  = PairPrg (normalizePrg (P1, t), normalizePrg (P2, t)) | normalizePrg (Unit, _)  = Unit | normalizePrg (Redex (P, S), t)  = Redex (normalizePrg (P, t), normalizeSpine S) | normalizePrg (Rec (D, P), t)  = Rec (D, normalizePrg (P, t)) | normalizePrg (P as Case _, t)  = P | normalizePrg (P as EVar (Psi, ref (SOME P'), _), t)  = normalizePrg (P', t)normalizeSpine Nil  = Nil | normalizeSpine (AppExp (U, S))  = AppExp (U, normalizeSpine S) | normalizeSpine (AppPrg (P, S))  = AppPrg (normalizePrg (P, id), normalizeSpine S) | normalizeSpine (AppBlock (B, S))  = AppBlock (B, normalizeSpine S) (*\n    and normalizeDec (T.UDec D, t) = T.UDec (I.decSub (D, T.coerceSub t))\n(*      | normalizeDec (T.BDec (k, t1), t2) = *)\n      | normalizeDec (T.PDec (n, F), t) = T.PDec (n, (normalizeFor (F, t)))\n*) let rec normalizeSub (s as Shift n)  = s | normalizeSub (Dot (Prg P, s))  = Dot (Prg (normalizePrg (P, id)), normalizeSub s) | normalizeSub (Dot (F, s))  = Dot (F, normalizeSub s) let normalizeFor = normalizeFor let normalizePrg = normalizePrg let normalizeSpine = normalizeSpine let normalizeSub = normalizeSub  end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Coverage checker for programs *) (* Author: Carsten Schuermann *) module TomegaCoverage ((*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) module TomegaPrint : TOMEGAPRINT(*! sharing TomegaPrint.IntSyn = IntSyn\' !*) (*! sharing TomegaPrint.Tomega = Tomega\' !*) module TomegaTypeCheck : TOMEGATYPECHECK(*! sharing TomegaTypeCheck.IntSyn = IntSyn\' !*) (*! sharing TomegaTypeCheck.Tomega = Tomega\' !*) module Cover : COVER(*! sharing Cover.IntSyn = IntSyn\' !*) (*! sharing Cover.Tomega = Tomega\' !*) ) : TOMEGACOVERAGE = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  exception Error of string module I = IntSynmodule T = Tomega(* chatter chlev f = ()\n\n       Invariant:\n       f () returns the string to be printed\n         if current chatter level exceeds chlev\n    *) let rec chatter chlev f  = if ! chatter >= chlev then print ("[coverage] " ^ f ()) else () (* purifyFor ((P, t), (Psi, F), s) = (t\', Psi\', s\')\n\n       Invariant:\n       If    Psi0 |- t : Psi\n       and   Psi0 |- P in F[t]\n       and   Psi |- s : Psi1\n       and   P == <M1, <M2, ... Mn, <>>>>\n       and   F[t] = Ex x1:A1 ... Ex xn:An.true\n       then  Psi\' = Psi, x::A1, .... An\n       and   t\' = Mn...M1.t\n       then  Psi0 |- t\' : Psi\'\n       and   Psi\' |- s\' : Psi1\n    *) let rec purifyFor ((Unit, t), (Psi, True), s)  = (t, Psi, s) | purifyFor ((PairExp (U, P), t), (Psi, Ex ((D, _), F)), s)  = purifyFor ((P, Dot (Exp U, t)), (Decl (Psi, UDec D), F), comp (s, shift)) (*      | purifyFor ((T.Lam _, _), (_, _), _) = raise Domain\n      | purifyFor ((T.New _, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.PairBlock _, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.PairPrg _, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.Unit, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.Root (T.Var k, _), _), (_,  _), _) = raise Domain\n      | purifyFor ((T.Redex _, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.Rec _, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.Case _, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.PClo _, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.Let _, _), (_,  _), _) = raise Domain\n      | purifyFor ((T.EVar _, _), (_,  _), _) = raise Domain\n*) (*  | purifyFor (Psi, T.All (_, F), s) = (Psi, s)\n        cannot occur by invariant Mon Dec  2 18:03:20 2002 -cs *) (* purifyCtx (t, Psi) = (t\', Psi\', s\')\n       If    Psi0 |- t : Psi\n       then  Psi0 |- t\' : Psi\'\n       and   Psi\' |- s\' : Psi\n    *) let rec purifyCtx (t as Shift k, Psi)  = (t, Psi, id) | purifyCtx (Dot (Prg P, t), Decl (Psi, PDec (_, All _, _, _)))  = let (t\', Psi\', s\') = purifyCtx (t, Psi) in (t\', Psi\', Dot (Undef, s\')) | purifyCtx (Dot (Prg (Var _), t), Decl (Psi, PDec (_, _, _, _)))  = let (t\', Psi\', s\') = purifyCtx (t, Psi) in (t\', Psi\', Dot (Undef, s\')) | purifyCtx (Dot (Prg (Const _), t), Decl (Psi, PDec (_, _, _, _)))  = let (t\', Psi\', s\') = purifyCtx (t, Psi) in (t\', Psi\', Dot (Undef, s\')) | purifyCtx (Dot (Prg (PairPrg (_, _)), t), Decl (Psi, PDec (_, _, _, _)))  = (* Mutual recursive predicates\n                                           don\'t have to be checked.\n                                         --cs Fri Jan  3 11:35:09 2003 *)  let (t\', Psi\', s\') = purifyCtx (t, Psi) in (t\', Psi\', Dot (Undef, s\')) | purifyCtx (Dot (Prg P, t), Decl (Psi, PDec (_, F, _, _)))  = let (t\', Psi\', s\') = purifyCtx (t, Psi) let (t\'\', Psi\'\', s\'\') = purifyFor ((P, t\'), (Psi\', forSub (F, s\')), s\') in (t\'\', Psi\'\', Dot (Undef, s\'\')) | purifyCtx (Dot (F, t), Decl (Psi, UDec D))  = let (t\', Psi\', s\') = purifyCtx (t, Psi) in (Dot (F, t\'), Decl (Psi\', UDec (decSub (D, coerceSub s\'))), dot1 s\') let rec purify (Psi0, t, Psi)  = let (t\', Psi\', s\') = purifyCtx (t, Psi) let _ = checkSub (Psi0, t\', Psi\') in (Psi0, t\', Psi\') (* subToSpine (Psi\', t, Psi) *) let rec coverageCheckPrg (W, Psi, Lam (D, P))  = coverageCheckPrg (W, Decl (Psi, D), P) | coverageCheckPrg (W, Psi, New P)  = coverageCheckPrg (W, Psi, P) | coverageCheckPrg (W, Psi, PairExp (U, P))  = coverageCheckPrg (W, Psi, P) | coverageCheckPrg (W, Psi, PairBlock (B, P))  = coverageCheckPrg (W, Psi, P) | coverageCheckPrg (W, Psi, PairPrg (P1, P2))  = (coverageCheckPrg (W, Psi, P1); coverageCheckPrg (W, Psi, P2)) | coverageCheckPrg (W, Psi, Unit)  = () | coverageCheckPrg (W, Psi, Var _)  = () | coverageCheckPrg (W, Psi, Const _)  = () | coverageCheckPrg (W, Psi, Rec (D, P))  = coverageCheckPrg (W, Decl (Psi, D), P) | coverageCheckPrg (W, Psi, Case (Cases Omega))  = coverageCheckCases (W, Psi, Omega, nil) | coverageCheckPrg (W, Psi, P as Let (D, P1, P2))  = (coverageCheckPrg (W, Psi, P1); (* chatter 5 ("fn () => TomegaPrint.prgToString (Psi, P)); *) coverageCheckPrg (W, Decl (Psi, D), P2)) | coverageCheckPrg (W, Psi, Redex (P, S))  = coverageCheckSpine (W, Psi, S)(*    | coverageCheckPrg (Psi, T.EVar) =\n          should not occur by invariant  *) coverageCheckSpine (W, Psi, Nil)  = () | coverageCheckSpine (W, Psi, AppExp (U, S))  = coverageCheckSpine (W, Psi, S) | coverageCheckSpine (W, Psi, AppBlock (B, S))  = coverageCheckSpine (W, Psi, S) | coverageCheckSpine (W, Psi, AppPrg (P, S))  = (coverageCheckPrg (W, Psi, P); coverageCheckSpine (W, Psi, S))(*    | coverageCheckSpine (Psi, T.SClo _) =\n          should not occur by invariant  *) coverageCheckCases (W, Psi, nil, nil)  = () | coverageCheckCases (W, Psi, nil, Cs)  = let _ = chatter 5 (fun () -> toString (length Cs) ^ " cases to be checked\\n") let (Cs\' as (_, _, Psi\') :: _) = map purify Cs let Cs\'\' = map (fun (Psi0, t, _) -> (coerceCtx Psi0, coerceSub t)) Cs\' in coverageCheckCases (W, Cs\'\', coerceCtx Psi\') | coverageCheckCases (W, Psi, (Psi\', t, P) :: Omega, Cs)  = (coverageCheckPrg (W, Psi\', P); coverageCheckCases (W, Psi, Omega, (Psi\', t, Psi) :: Cs)) let coverageCheckPrg = coverageCheckPrg  end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Abstraction mechanisms form programs and formulas *) (* Author: Carsten Schuermann *) module type TOMEGAABSTRACT = sig exception Error of stringval raiseFor : Dec Ctx * (For * Sub) -> Forval raisePrg : Dec Ctx * Prg * For -> Prgval raiseP : Dec Ctx * Prg * For -> Prgval raiseF : Dec Ctx * (For * Sub) -> For end(* Signature TOMEGAABSTRACT *) ', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Naming *) (* Author: Carsten Schuermann *) module TomegaNamesTOMEGANAMES = struct module T = Tomega module I = IntSyn let rec decName (Psi, UDec D)  = UDec (decName (coerceCtx Psi, D)) | decName (Psi, PDec (x, F, TC1, TC2))  = let NDec x' = decName (coerceCtx Psi, NDec x) in PDec (x', F, TC1, TC2) end", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Printing of functional proof terms *) (* Author: Carsten Schuermann *) module TomegaPrint ((*! structure IntSyn\' : INTSYN !*) (*! structure Tomega\' : TOMEGA !*) (*! sharing Tomega\'.IntSyn = IntSyn\' !*) (*   structure Normalize : NORMALIZE *) (*! sharing Normalize.IntSyn = IntSyn\' !*) (*! sharing Normalize.Tomega = Tomega\' !*) module Formatter : FORMATTERmodule Names : NAMES(*! sharing Names.IntSyn = IntSyn\' !*) module Print : PRINTPrintFormatterFormatter(*! sharing Print.IntSyn = IntSyn\' !*) ) : TOMEGAPRINT = struct (*! structure IntSyn = IntSyn\' !*)  (*! structure Tomega = Tomega\' !*)  module Formatter = Formatter exception Error of string (* is just here because we don\'t have a\n     module yet for names. move later\n     --cs Tue Apr 27 12:04:45 2004 *)  module I = IntSynmodule T = Tomegamodule Fmt = Formattermodule P = Print(* Invariant:\n\n       The proof term must satisfy the following conditions:\n       * proof term must have the structure\n           Rec.     Lam ... Lam Case\n                And Lam ... Lam Case\n                ...\n                And Lam ... Lam Case\n         and the body of every case must be of the form\n           (Let Decs in Case ...\n           or\n           Inx ... Inx Unit) *\n         where Decs are always of the form\n           New ... New App .. App Split .. Split Empty\n     *) let evarList : Prg list ref = ref nil let rec evarReset ()  = (evarList := nil) let rec evarName n  = let rec evarName\' nil  = raise (Error "not found") | evarName\' ((Y as EVar (_, _, _, _, _, X as EVar (_, G, r, _))) :: L)  = if evarName (G, X) = n then Y else evarName\' L in evarName\' (! evarList) let rec nameEVar (EVar (_, _, _, _, _, X as EVar (_, G, r, _)))  = evarName (G, X) (* formatCtxBlock (G, (G1, s1)) = (G\', s\', fmts\')\n\n       Invariant:\n       If   |- G ctx\n       and  G |- G1 ctx\n       and  G2 |- s1 : G\n       then G\' = G2, G1 [s1]\n       and  G\' |- s\' : G, G1\n       and  fmts is a format list of G1[s1]\n    *) let rec formatCtxBlock (G, (Null, s))  = (G, s, nil) | formatCtxBlock (G, (Decl (Null, D), s))  = let D\' = decSub (D, s) let fmt = formatDec (G, D\') in (Decl (G, D\'), dot1 s, [fmt]) | formatCtxBlock (G, (Decl (G\', D), s))  = let (G\'\', s\'\', fmts) = formatCtxBlock (G, (G\', s)) let D\'\' = decSub (D, s\'\') let fmt = formatDec (G\'\', D\'\') in (Decl (G\'\', D\'\'), dot1 s\'\', fmts @ [String ","; Break; fmt]) let rec constName c  = conDecName (sgnLookup c) let rec formatWorld nil  = [] | formatWorld [c]  = [String (constName c)] | formatWorld (c :: cids)  = [String (constName c); String ","; Break] @ formatWorld cids (* formatFor\' (G, (F, s)) = fmts\'\n\n       Invariant:\n       If   |- G ctx\n       and  G |- s : Psi\'\n       and  Psi\' |- F formula\n       then fmts\' is a list of formats for F\n    *) let rec formatFor\' (Psi, All ((D, Explicit), F))  = (match D with UDec D -> let G = coerceCtx Psi let D\' = decName (G, D) in [String "all {"; formatDec (G, D\'); String "}"; Break] @ formatFor\' (Decl (Psi, UDec D\'), F)) | formatFor\' (Psi, All ((D, Implicit), F))  = (match D with UDec D -> let G = coerceCtx Psi let D\' = decName (G, D) in [String "all^ {"; formatDec (G, D\'); String "}"; Break] @ formatFor\' (Decl (Psi, UDec D\'), F)) | formatFor\' (Psi, Ex ((D, Explicit), F))  = let G = coerceCtx Psi let D\' = decName (G, D) in [String "exists {"; formatDec (G, D\'); String "}"; Break] @ formatFor\' (Decl (Psi, UDec D\'), F) | formatFor\' (Psi, Ex ((D, Implicit), F))  = let G = coerceCtx Psi let D\' = decName (G, D) in [String "exists^ {"; formatDec (G, D\'); String "}"; Break] @ formatFor\' (Decl (Psi, UDec D\'), F) | formatFor\' (Psi, And (F1, F2))  = [String "("; HVbox (formatFor\' (Psi, F1)); String ")"; Break; String "/\\\\"; Space; String "("; HVbox (formatFor\' (Psi, F2)); String ")"] | formatFor\' (Psi, True)  = [String "true"] | formatFor\' (Psi, World (Worlds L, F))  = [String "world ("; HVbox (formatWorld L); String ")"; Break] @ formatFor\' (Psi, F) let rec formatFor (G, F)  = HVbox (formatFor\' (G, forSub (F, id))) let rec forToString (Psi, F)  = makestring_fmt (formatFor (Psi, F)) (* formatPrg (Psi, P) names = fmt\'\n\n       Invariant:\n       If   |- Psi ctx\n       and  Psi; . |- P = rec x. (P1, P2, .. Pn) in F\n       and  names is a list of n names,\n       then fmt\' is the pretty printed format of P\n    *) (*      fun nameLookup index = List.nth (names, index) *) (* decName (G, LD) = LD\'\n\n           Invariant:\n           If   G1 |- LD lfdec\n           then LD\' = LD modulo new non-conficting variable names.\n        *) let rec decName (G, UDec D)  = UDec (decName (G, D)) | decName (G, PDec (NONE, F, TC1, TC2))  = PDec (SOME "xx", F, TC1, TC2) | decName (G, D)  = D (*      (* numberOfSplits Ds = n\'\n\n           Invariant:\n           If   Psi, Delta |- Ds :: Psi\', Delta\'\n           then n\'= |Psi\'| - |Psi|\n        *)\n        fun numberOfSplits Ds =\n            let\n              fun numberOfSplits\' (T.Empty, n) = n\n                | numberOfSplits\' (T.New (_, Ds), n) = numberOfSplits\' (Ds, n)\n                | numberOfSplits\' (T.App (_, Ds), n) = numberOfSplits\' (Ds, n)\n                | numberOfSplits\' (T.Lemma (_, Ds), n) = numberOfSplits\' (Ds, n)\n                | numberOfSplits\' (T.Split (_, Ds), n) = numberOfSplits\' (Ds, n+1)\n                | numberOfSplits\' (T.Left (_, Ds), n) = numberOfSplits\' (Ds, n)\n                | numberOfSplits\' (T.Right (_, Ds), n) = numberOfSplits\' (Ds, n)\n            in\n              numberOfSplits\' (Ds, 0)\n            end\n*) (* psiName (Psi1, s, Psi2, l) = Psi1\'\n\n           Invariant:\n           If   |- Psi1 ctx\n           and  |- Psi1\' ctx\n           and  |- Psi2 ctx\n           and  Psi2 = Psi2\', Psi2\'\'\n           and  Psi1 |- s : Psi2\n           and  |Psi2\'\'| = l\n           then Psi1\' = Psi1 modulo variable naming\n           and  for all x in Psi2 s.t. s(x) = x in Psi1\'\n        *) let rec psiName (Psi1, s, Psi2, l)  = let rec nameDec (D as Dec (SOME _, _), name)  = D | nameDec (Dec (NONE, V), name)  = Dec (SOME name, V) let rec namePsi (Decl (Psi, UDec D), 1, name)  = Decl (Psi, UDec (nameDec (D, name))) | namePsi (Decl (Psi, LD as UDec D), n, name)  = Decl (namePsi (Psi, n - 1, name), LD)nameG (Psi, Null, n, name, k)  = (k n, Null) | nameG (Psi, Decl (G, D), 1, name, k)  = (Psi, Decl (G, nameDec (D, name))) | nameG (Psi, Decl (G, D), n, name, k)  = let (Psi\', G\') = nameG (Psi, G, n - 1, name, k) in (Psi\', Decl (G\', D)) let rec ignore (s, 0)  = s | ignore (Dot (_, s), k)  = ignore (s, k - 1) | ignore (Shift n, k)  = ignore (Dot (Idx (n + 1), Shift (n + 1)), k - 1) let rec copyNames (Shift n, G as Decl _) Psi1  = copyNames (Dot (Idx (n + 1), Shift (n + 1)), G) Psi1 | copyNames (Dot (Exp _, s), Decl (G, _)) Psi1  = copyNames (s, G) Psi1 | copyNames (Dot (Idx k, s), Decl (G, UDec (Dec (NONE, _)))) Psi1  = copyNames (s, G) Psi1 | copyNames (Dot (Idx k, s), Decl (G, UDec (Dec (SOME name, _)))) Psi1  = let Psi1\' = namePsi (Psi1, k, name) in copyNames (s, G) Psi1\' | copyNames (Dot (Prg k, s), Decl (G, PDec (NONE, _, _, _))) Psi1  = copyNames (s, G) Psi1 | copyNames (Dot (Prg k, s), Decl (G, PDec (SOME name, _, _, _))) Psi1  = copyNames (s, G) Psi1 | copyNames (Shift _, Null) Psi1  = Psi1 let rec psiName\' (Null)  = Null | psiName\' (Decl (Psi, D))  = let Psi\' = psiName\' Psi in Decl (Psi\', decName (coerceCtx Psi\', D)) in psiName\' ((* copyNames  (ignore (s, l),  Psi2) *) Psi1) (*\n\n        (* merge (G1, G2) = G\'\n\n           Invariant:\n           G\' = G1, G2\n        *)\n        fun merge (G1, I.Null) = G1\n          | merge (G1, I.Decl (G2, D)) =\n              I.Decl (merge (G1, G2), D)\n\n        (* formatCtx (Psi, G) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi |- G ctx\n           then fmt\' is a pretty print format of G\n        *)\n        fun formatCtx (Psi, G) =\n          let\n            val G0 = T.makectx Psi\n\n            fun formatCtx\' (I.Null) = nil\n              | formatCtx\' (I.Decl (I.Null, I.Dec (SOME name, V))) =\n                  [Fmt.String name, Fmt.String ":",\n                   Print.formatExp (G0, V)]\n              | formatCtx\' (I.Decl (G, I.Dec (SOME name, V))) =\n                  (formatCtx\' G) @\n                  [Fmt.String ",", Fmt.Break,\n                   Fmt.String name, Fmt.String ":",\n                   Print.formatExp (merge (G0, G), V)]\n          in\n            Fmt.Hbox (Fmt.String "|" :: (formatCtx\' G @ [Fmt.String "|"]))\n          end\n\n        (* formatTuple (Psi, P) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- P = Inx (M1, Inx ... (Mn, Unit))\n           then fmt\' is a pretty print format of (M1, .., Mn)\n        *)\n        fun formatTuple (Psi, P) =\n          let\n            fun formatTuple\' (T.Unit) = nil\n              | formatTuple\' (T.Inx (M, T.Unit)) =\n              [Print.formatExp (T.makectx Psi, M)]\n              | formatTuple\' (T.Inx (M, P\')) =\n              (Print.formatExp (T.makectx Psi, M) ::\n               Fmt.String "," :: Fmt.Break :: formatTuple\' P\')\n          in\n            case P\n              of (T.Inx (_, T.Unit)) => Fmt.Hbox (formatTuple\' P)\n              | _ => Fmt.HVbox0 1 1 1\n                (Fmt.String "(" :: (formatTuple\' P @ [Fmt.String ")"]))\n          end\n\n        (* formatSplitArgs (Psi, L) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  L = (M1, .., Mn)\n           and  Psi |- Mk:Ak for all 1<=k<=n\n           then fmt\' is a pretty print format of (M1, .., Mn)\n        *)\n        fun formatSplitArgs (Psi, L) =\n          let\n            fun formatSplitArgs\' (nil) = nil\n              | formatSplitArgs\' (M :: nil) =\n                  [Print.formatExp (T.makectx Psi, M)]\n              | formatSplitArgs\' (M :: L) =\n                  (Print.formatExp (T.makectx Psi, M) ::\n                   Fmt.String "," :: Fmt.Break :: formatSplitArgs\' L)\n          in\n            if List.length L = 1 then Fmt.Hbox (formatSplitArgs\' L)\n            else Fmt.HVbox0 1 1 1\n              (Fmt.String "(" :: (formatSplitArgs\' L @ [Fmt.String ")"]))\n          end\n\n\n        (* formatDecs1 (Psi, Ds, s, L) = L\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- Ds : Psi\'; Delta\'\n           and  Psi\' = x1:A1 .. xn:An\n           and  Psi\'\' |- s : Psi\n           and  for i<=n\n                L = (M1 .. Mi)\n                s.t   Psi\'\' |- Mi : Ai\n           then L\' extends L\n           s.t. L = (M1 .. Mn)\n                for all i <=n\n                Psi\'\' |- Mi : Ai\n                (and Mi is a splitting of a the result of an inductive call)\n        *)\n        fun formatDecs1 (Psi, T.Split (xx, Ds), I.Dot (Ft, s1), L) =\n              formatDecs1 (Psi, Ds, s1, frontToExp (Ft) :: L)\n          | formatDecs1 (Psi, T.Empty, s1, L) = L\n          | formatDecs1 (Psi, Ds, I.Shift n, L) =\n              formatDecs1 (Psi, Ds, I.Dot (I.Idx (n+1), I.Shift (n+1)), L)\n\n\n        (* formatDecs0 (Psi, Ds) = (Ds\', S\')\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi ; Delta |- Ds : Psi\', Delta\'\n           and  Ds = App M1 ... App Mn Ds\'   (where Ds\' starts with Split)\n           then S\' = (M1, M2 .. Mn)\n           and  Psi1, Delta1 |- Ds\' : Psi1\', Delta1\'\n                (for some Psi1, Delta1, Psi1\', Delta1\')\n        *)\n        fun formatDecs0 (Psi, T.App ((xx, M), Ds)) =\n            let\n              val (Ds\', S) =\n                formatDecs0 (Psi, Ds)\n            in\n              (Ds\', I.App (M, S))\n            end\n          | formatDecs0 (Psi, Ds) = (Ds, I.Nil)\n\n\n        (* formatDecs (index, Psi, Ds, (Psi1, s1)) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- Ds : Psi\'; Delta\'\n           and  Psi1 |- s1 : Psi, Psi\'\n           then fmt\' is a pretty print format of Ds\n        *)\n        fun formatDecs (index, Psi, Ds as T.App ((xx, _), P), (Psi1, s1)) =\n            let\n              val (Ds\', S) = formatDecs0 (Psi, Ds)\n              val L\' = formatDecs1 (Psi, Ds\', s1, nil)\n              val name = nameLookup index\n            in\n              Fmt.Hbox [formatSplitArgs (Psi1, L\'), Fmt.Space,\n                        Fmt.String "=", Fmt.Break,\n                        Fmt.HVbox (Fmt.String name :: Fmt.Break ::\n                                   Print.formatSpine callname (T.makectx Psi, S))]\n            end\n          | formatDecs (index, Psi, T.New (B as T.CtxBlock (_, G), Ds),\n                        (Psi1, s1)) =\n            let\n              val B\' = ctxBlockName (T.makectx Psi, B)\n              val fmt =\n                formatDecs (index, I.Decl (Psi, T.Block B\'), Ds, (Psi1, s1))\n            in\n              Fmt.Vbox [formatCtx (Psi, G), Fmt.Break, fmt]\n            end\n          | formatDecs (index, Psi, T.Lemma (lemma, Ds), (Psi1, s1)) =\n            let\n              val (Ds\', S) = formatDecs0 (Psi, Ds)\n              val L\' = formatDecs1 (Psi, Ds\', s1, nil)\n              val (T.LemmaDec (names, _, _)) = T.lemmaLookup lemma\n            in\n              Fmt.Hbox [formatSplitArgs (Psi1, L\'), Fmt.Space,\n                        Fmt.String "=", Fmt.Break,\n                        Fmt.HVbox (Fmt.String (List.nth (names, index)) :: Fmt.Break ::\n                                   Print.formatSpine callname (T.makectx Psi, S))]\n            end\n          | formatDecs (index, Psi, T.Left (_, Ds), (Psi1, s1)) =\n            let\n              val fmt =\n                formatDecs (index, Psi, Ds, (Psi1, s1))\n            in\n              fmt\n            end\n          | formatDecs (index, Psi, T.Right (_, Ds), (Psi1, s1)) =\n            let\n              val fmt =\n                formatDecs (index+1, Psi, Ds, (Psi1, s1))\n            in\n              fmt\n            end\n\n\n*) (* fmtSpine callname (G, d, l, (S, s)) = fmts\n     format spine S[s] at printing depth d, printing length l, in printing\n     context G which approximates G\', where G\' |- S[s] is valid\n  *) let rec fmtSpine callname (Psi, Nil)  = [] | fmtSpine callname (Psi, AppExp (U, S))  = (* Print.formatExp (T.coerceCtx Psi, U) *)  HVbox (formatSpine (coerceCtx Psi, App (U, Nil))) :: fmtSpine\' callname (Psi, S) | fmtSpine callname (Psi, AppPrg (P, S))  = formatPrg3 callname (Psi, P) :: fmtSpine\' callname (Psi, S)fmtSpine\' callname (Psi, Nil)  = [] | fmtSpine\' callname (Psi, S)  = Break :: fmtSpine callname (Psi, S)(*\n        (* frontToExp (Ft) = U\'\n\n           Invariant:\n           G |- Ft = U\' : V   for a G, V\n        *)\n        and frontToExp (T.Idx k) = I.Root (I.BVar k, I.Nil)\n          | frontToExp (T.Exp (U)) = U\n          | frontToExp (T.Prg (T.PairExp (U, _))) = U    (* this is a patch -cs\n                                                            works only with one exists quantifier\n                                                            we cannot use LF spines, we need to\n                                                            use tomega spines.\n\n                                                            Next step program printer for tomega spines\n                                                            Then change this code. *)\n*) (* argsToSpine (Psi1, s, S) = S\'\n\n           Invariant:\n           If   Psi1 |- s = M1 . M2 .. Mn. ^|Psi1|: Psi2\n           and  Psi1 |- S : V1 > {Psi2} V2\n           then Psi1 |- S\' : V1 > V2\n           and S\' = S, M1 .. Mn\n           where\n           then Fmts is a list of arguments\n        *) argsToSpine (s, 0, S)  = S | argsToSpine (Shift (n), k, S)  = argsToSpine (Dot (Idx (n + 1), Shift (n + 1)), k, S) | argsToSpine (Dot (Idx n, s), k, S)  = argsToSpine (s, k - 1, AppExp (Root (BVar n, Nil), S)) | argsToSpine (Dot (Exp (U), s), k, S)  = argsToSpine (s, k - 1, AppExp (U, S)) | argsToSpine (Dot (Prg P, s), k, S)  = argsToSpine (s, k - 1, AppPrg (P, S))(* Idx will always be expanded into Expressions and never into programs\n                 is this a problem? -- cs *) (* formatTuple (Psi, P) = fmt\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- P = Inx (M1, Inx ... (Mn, Unit))\n           then fmt\' is a pretty print format of (M1, .., Mn)\n        *) formatTuple (Psi, P)  = let rec formatTuple\' (Unit)  = nil | formatTuple\' (PairExp (M, Unit))  = [formatExp (coerceCtx Psi, M)] | formatTuple\' (PairExp (M, P\'))  = (formatExp (coerceCtx Psi, M) :: String "," :: Break :: formatTuple\' P\') in match P with (PairExp (_, Unit)) -> Hbox (formatTuple\' P) | _ -> HVbox0 1 1 1 (String "(" :: (formatTuple\' P @ [String ")"]))formatRedex callname (Psi, Var k, S)  = (* no mutual recursion, recursive call *)  let PDec (SOME name, _, _, _) = ctxLookup (Psi, k) let Fspine = fmtSpine callname (Psi, S) in Hbox [Space; HVbox (String name :: Break :: Fspine)] | formatRedex callname (Psi, Const l, S)  = (* lemma application *)  let ValDec (name, _, _) = lemmaLookup l let Fspine = fmtSpine callname (Psi, S) in Hbox [Space; HVbox (String name :: Break :: Fspine)] | formatRedex callname (Psi, (Redex (Const l, _)), S)  = (* mutual recursion, k is the projection function *)  (* val T.ValDec (name, _, _) = T.lemmaLookup l *) let name = callname l let Fspine = fmtSpine callname (Psi, S) in Hbox [Space; HVbox (String name :: Break :: Fspine)]formatCase callname (max, Psi\', s, Psi)  = let S = argsToSpine (s, ctxLength Psi - max, Nil) let Fspine = fmtSpine callname (Psi\', S) in Hbox [HVbox (Fspine)](* formatCases ((max, index), Psi, L) = fmts\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi |- L a list of cases\n           then fmts\' list of pretty print formats of L\n        *) formatCases (max, Psi, nil, callname)  = nil | formatCases (max, Psi, (Psi\', s, P) :: nil, callname)  = let Psi\'\' = psiName (Psi\', s, Psi, 0) let _ = varReset Null in [HVbox0 1 5 1 [formatCase callname (max, Psi\'\', s, Psi); Space; String "="; Break; formatPrg3 callname (Psi\'\', P)]; Break] | formatCases (max, Psi, (Psi\', s, P) :: O, callname)  = let Psi\'\' = psiName (Psi\', s, Psi, 0) let _ = varReset Null in formatCases (max, Psi, O, callname) @ [HVbox0 1 5 1 [String "|"; Space; formatCase callname (max, Psi\'\', s, Psi); Space; String "="; Break; formatPrg3 callname (Psi\'\', P)]; Break](* formatPrg3 callname  (Psi, P) = fmt\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- P :: F\n           and  P = let .. in .. end | <..,..> | <>\n           then fmt is a pretty print of P\n        *) formatPrg3 callname (Psi, Unit)  = String "<>" | formatPrg3 callname (Psi, PairExp (U, P))  = HVbox [String "<"; formatExp (coerceCtx Psi, U); String ","; Break; formatPrg3 callname (Psi, P); String ">"] | formatPrg3 callname (Psi, P as Let _)  = formatLet callname (Psi, P, nil) | formatPrg3 callname (Psi, P as LetPairExp (D1, D2, P1, P2))  = formatLet callname (Psi, P, nil) | formatPrg3 callname (Psi, P as LetUnit (P1, P2))  = formatLet callname (Psi, P, nil) | formatPrg3 callname (Psi, P as New (Lam (UDec (BDec (l, (c, s))), _)))  = formatNew callname (Psi, P, nil) | formatPrg3 callname (Psi, Redex (P, S))  = formatRedex callname (Psi, P, S) | formatPrg3 callname (Psi, Lam (D as UDec D\', P))  = HVbox [String "lam"; Space; String "("; formatDec (coerceCtx Psi, D\'); String ")"; Space; formatPrg3 callname (Decl (Psi, D), P)] | formatPrg3 callname (Psi, Rec (D as PDec (SOME name, F, NONE, NONE), P))  = HVbox [String "fix*"; Space; String "("; String name; String ":"; formatFor (Psi, F); String ")"; Space; formatPrg3 callname (Decl (Psi, D), P)] | formatPrg3 callname (Psi, Rec (D as PDec (SOME name, F, SOME TC1, SOME TC2), P))  = HVbox [String "fix"; Space; String "("; String name; String ":"; formatFor (Psi, F); String ")"; Space; formatPrg3 callname (Decl (Psi, D), P)] | formatPrg3 callname (Psi, PClo (P, t))  = HVbox [formatPrg3 callname (Psi, P); String "..."] | formatPrg3 callname (Psi, X as EVar (_, ref (SOME P), _, _, _, _))  = formatPrg3 callname (Psi, P) | formatPrg3 callname (Psi, X as EVar (_, ref NONE, _, _, _, _))  = String (nameEVar X) | formatPrg3 callname (Psi, Case (Cases Cs))  = HVbox (String "case" :: Break :: formatCases (1, Psi, Cs, callname) @ [String "."]) | formatPrg3 callname (Psi, Var n)  = let PDec (SOME n, _, _, _) = ctxLookup (Psi, n) in String n | formatPrg3 callname _  = String "missing case"formatNew callname (Psi, New (Lam (UDec (D as BDec (l, (c, s))), P)), fmts)  = let G = coerceCtx Psi let D\' = decName (G, D) in formatNew callname (Decl (Psi, UDec D\'), P, Break :: HVbox [formatDec (G, D\')] :: fmts) | formatNew callname (Psi, P, fmts)  = Vbox0 0 1 ([String "new"; Vbox0 0 1 (fmts); Break; String "in"; Break; Spaces 2; formatPrg3 callname (Psi, P); Break; String "end"])(* formatLet callname (Psi, P, fmts) = fmts\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; Delta |- P = Let . Case P\' :: F\n           and  fmts is a list of pretty print formats of P\n           then fmts\' extends fmts\n           and  fmts also includes a pretty print format for P\'\n        *) formatLet callname (Psi, Let (D, P1, Case (Cases ((Psi1, s1, P2 as Let _) :: nil))), fmts)  = (* was I.ctxLength Psi - max  --cs *) (*            val Fspine =   Print.formatSpine callname (T.coerceCtx Psi1, S) *) let Psi1\' = psiName (Psi1, s1, Psi, 1) let F1 = HVbox [formatPrg3 callname (Psi, P1)] let S = argsToSpine (s1, 1, Nil) let Fspine = fmtSpine callname (Psi1, S) let Fpattern = HVbox [Hbox (Fspine)] let Fbody = HVbox [F1] let fmt = HVbox [HVbox [String "val"; Space; Fpattern; Space; String "="]; Break; Fbody] in formatLet callname (Psi1\', P2, fmts @ [Break; fmt]) | formatLet callname (Psi, Let (D, P1, Case (Cases ((Psi1, s1, P2) :: nil))), fmts)  = (* was I.ctxLength Psi - max  --cs *) (*            val Fspine =   Print.formatSpine callname (T.coerceCtx Psi1, S) *) (*            val fmt = (* formatDecs (0, Psi, Ds, (Psi1\', s1)) *)\n                Fmt.Hbox [Fmt.String " ..." , Fmt.Space, Fmt.String "=",  Fmt.Break, F1] *) let Psi1\' = psiName (Psi1, s1, Psi, 1) let F1 = HVbox [formatPrg3 callname (Psi, P1)] let S = argsToSpine (s1, 1, Nil) let Fspine = fmtSpine callname (Psi1, S) let Fpattern = HVbox [Hbox (Fspine)] let Fbody = HVbox [F1] let fmt = HVbox [HVbox [String "val"; Space; Fpattern; Space; String "="]; Break; Fbody] in Vbox0 0 1 ([String "let"; Vbox0 2 1 (fmts @ [Break; fmt]); Break; String "in"; Break; Spaces 2; formatPrg3 callname (Psi1\', P2); Break; String "end"]) | formatLet callname (Psi, Let (D, P1, Case (Cases L)), nil)  = let rec fmtCaseRest []  = [] | fmtCaseRest ((Psi1, s1, P2) :: L)  = let Psi1\' = psiName (Psi1, s1, Psi, 1) let S = argsToSpine (s1, 1, Nil) let Fspine = fmtSpine callname (Psi1, S) let Fpattern = HVbox [Hbox (Fspine)] in [HVbox [Space; String "|"; Space; Fpattern; Space; String "-->"]; Spaces 2; Vbox0 0 1 [formatPrg3 callname (Psi1\', P2)]; Break] @ fmtCaseRest (L) let rec fmtCase ((Psi1, s1, P2) :: L)  = let Psi1\' = psiName (Psi1, s1, Psi, 1) let S = argsToSpine (s1, 1, Nil) let Fspine = fmtSpine callname (Psi1, S) let Fpattern = HVbox [Hbox (Fspine)] in Vbox0 0 1 ([HVbox [String "of"; Space; Fpattern; Space; String "-->"]; Spaces 2; Vbox0 0 1 [formatPrg3 callname (Psi1\', P2)]; Break] @ fmtCaseRest (L)) let F1 = HVbox [formatPrg3 callname (Psi, P1)] let Fbody = HVbox [F1] let fmt = fmtCase (L) in Vbox0 0 1 ([String "case ("; Fbody; Space(* need space since there is one before Fbody *) ; String ")"; Break; fmt]) | formatLet callname (Psi, R as (Let (D, P1, Case (Cases L))), fmts)  = Vbox0 0 1 ([String "let"; Vbox0 0 1 (fmts @ [Break]); Break; String "in"; Break; Spaces 2; formatLet callname (Psi, R, nil); Break; String "end"]) | formatLet callname (Psi, R as (Let (D as PDec (SOME name, F, _, _), P1, P2)), fmts)  = Vbox0 0 1 ([String "let"; Break; Vbox0 0 1 ([String name; Space; String "="; formatPrg3 callname (Psi, P1)]); Break; String "in"; Break; Spaces 2; formatPrg3 callname (Decl (Psi, D), P2); Break; String "end"]) | formatLet callname (Psi, R as (LetPairExp (D1 as Dec (SOME n1, _), D2 as PDec (SOME n2, F, _, _), P1, P2)), fmts)  = Vbox0 0 1 ([String "let"; Break; Spaces 2; Vbox0 0 1 ([String "("; String n1; String ","; Space; String n2; String ")"; Space; String "="; Space; formatPrg3 callname (Psi, P1)]); Break; String "in"; Break; Spaces 2; formatPrg3 callname (Decl (Decl (Psi, UDec D1), D2), P2); Break; String "end"]) | formatLet callname (Psi, R as (LetUnit (P1, P2)), fmts)  = Vbox0 0 1 ([String "let"; Break; Spaces 2; Vbox0 0 1 ([String "()"; Space; String "="; Space; formatPrg3 callname (Psi, P1)]); Break; String "in"; Break; Spaces 2; formatPrg3 callname (Psi, P2); Break; String "end"])(* formatHead callname (index, Psi1, s, Psi2) = fmt\'\n\n           Invariant:\n           If    Psi1 |- s : Psi2\n           then  fmt is a format of the entire head\n           where index represents the function name\n           and   s the spine.\n        *) formatHead callname (name, (max, index), Psi\', s, Psi)  = (*            val T.PDec (SOME name, _) = I.ctxLookup (Psi, index) *) (*            val Fspine =   Print.formatSpine callname (T.coerceCtx Psi\', S) *) let S = argsToSpine (s, ctxLength Psi - max, Nil) let Fspine = fmtSpine callname (Psi\', S) in Hbox [Space; HVbox (String name :: Break :: Fspine)] (* formatPrg2 ((max, index), Psi, L) = fmts\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi |- L a list of cases\n           then fmts\' list of pretty print formats of L\n        *) let rec formatPrg2 (name, (max, index), Psi, nil, callname)  = nil | formatPrg2 (name, (max, index), Psi, (Psi\', s, P) :: nil, callname)  = let Psi\'\' = psiName (Psi\', s, Psi, 0) let fhead = if index = ctxLength Psi then "fun" else "and" in [HVbox0 1 5 1 [String fhead; formatHead callname (name, (max, index), Psi\'\', s, Psi); Space; String "="; Break; formatPrg3 callname (Psi\'\', P)]; Break] | formatPrg2 (name, (max, index), Psi, (Psi\', s, P) :: O, callname)  = let Psi\'\' = psiName (Psi\', s, Psi, 0) in formatPrg2 (name, (max, index), Psi, O, callname) @ [HVbox0 1 5 1 [String "  |"; formatHead callname (name, (max, index), Psi\'\', s, Psi); Space; String "="; Break; formatPrg3 callname (Psi\'\', P)]; Break] let rec formatPrg11 (name, (max, index), Psi, Lam (D, P), callname)  = formatPrg11 (name, (max, index + 1), Decl (Psi, decName (coerceCtx Psi, D)), P, callname) | formatPrg11 (name, (max, index), Psi, Case (Cases Os), callname)  = formatPrg2 (name, (max, index), Psi, Os, callname) (* formatPrg1 ((max, index), Psi, P) = fmts\'\n\n           Invariant:\n           If   |- Psi ctx\n           and  Psi; . |- P :: F\n           and  P is either a Lam .. | Case ... | Pair ...\n           then fmts\' is alist of pretty print formats of P\n        *) let rec formatPrg1 (name :: names, (max, index), Psi, PairPrg (P1, P2), callname)  = formatPrg11 (name, (max, index), Psi, P1, callname) @ formatPrg1 (names, (max, index - 1), Psi, P2, callname) | formatPrg1 ([name], (max, index), Psi, P, callname)  = formatPrg11 (name, (max, index), Psi, P, callname) (* formatPrg0 (Psi, P) = fmt\'\n           If   |- Psi ctx\n           and  Psi; . |- P :: F\n           then fmt\' is a pretty print format of P\n        *) (*      fun formatPrg0 (T.Rec (T.PDec (SOME _, F),\n                             T.Case (T.Cases [(Psi, t, P)]))) =\n          let\n            val max = I.ctxLength Psi   (* number of ih. *)\n          in\n            Fmt.Vbox0 0 1 (formatPrg1 ((max, max), Psi, P))\n          end\n*) let rec lookup (name :: names, proj :: projs) lemma  = if lemma = proj then name else lookup (names, projs) lemma let rec formatPrg0 ((names, projs), Rec (D as PDec (SOME _, F, _, _), P))  = (* number of ih. *) let max = 1 in Vbox0 0 1 (formatPrg1 (names, (max, max), Decl (Null, D), P, fun lemma -> lookup (names, projs) lemma)) let rec formatFun Args  = (varReset Null; formatPrg0 Args) (*    fun formatLemmaDec (T.LemmaDec (names, P, F)) =\n      Fmt.Vbox0 0 1 [formatFor (I.Null, F) names, Fmt.Break,\n                     formatPrg (I.Null, P) names]\n*) let rec funToString Args  = makestring_fmt (formatFun Args) let rec prgToString Args  = makestring_fmt (formatPrg3 (fun _ -> "?") Args) (*   fun lemmaDecToString Args = Fmt.makestring_fmt (formatLemmaDec Args) *) (*    fun prgToString Args names = "not yet implemented " *) let rec nameCtx Null  = Null | nameCtx (Decl (Psi, UDec D))  = Decl (nameCtx Psi, UDec (decName (coerceCtx Psi, D))) | nameCtx (Decl (Psi, PDec (NONE, F, TC1, TC2)))  = let Psi\' = nameCtx Psi let NDec x = decName (coerceCtx Psi\', NDec NONE) in Decl (Psi\', PDec (x, F, TC1, TC2)) | nameCtx (Decl (Psi, D as PDec (SOME n, F, _, _)))  = Decl (nameCtx Psi, D) let rec flag NONE  = "" | flag (SOME _)  = "*" (* formatCtx (Psi) = fmt\'\n\n       Invariant:\n       If   |- Psi ctx       and Psi is already named\n       then fmt\' is a format describing the context Psi\n    *) let rec formatCtx (Null)  = [] | formatCtx (Decl (Null, UDec D))  = if ! chatter >= 4 then [HVbox ([Break; formatDec (Null, D)])] else [formatDec (Null, D)] | formatCtx (Decl (Null, PDec (SOME s, F, TC1, TC2)))  = if ! chatter >= 4 then [HVbox ([Break; String s; Space; String ("::" ^ flag TC1); Space; formatFor (Null, F)])] else [String s; Space; String ("::" ^ flag TC1); Space; formatFor (Null, F)] | formatCtx (Decl (Psi, UDec D))  = let G = coerceCtx Psi in if ! chatter >= 4 then formatCtx Psi @ [String ","; Break; Break] @ [HVbox ([Break; formatDec (G, D)])] else formatCtx Psi @ [String ","; Break] @ [Break; formatDec (G, D)] | formatCtx (Decl (Psi, PDec (SOME s, F, TC1, TC2)))  = if ! chatter >= 4 then formatCtx Psi @ [String ","; Break; Break] @ [HVbox ([Break; String s; Space; String ("::" ^ flag TC1); Space; formatFor (Psi, F)])] else formatCtx Psi @ [String ","; Break] @ [Break; String s; Space; String ("::" ^ flag TC1); Space; formatFor (Psi, F)] let rec ctxToString Psi  = makestring_fmt (HVbox (formatCtx Psi)) let formatFor = formatFor let forToString = forToString let formatFun = formatFun let formatPrg = formatPrg3 (fun _ -> "?") (*    val formatLemmaDec = formatLemmaDec *) let evarName = evarName let evarReset = evarReset let nameEVar = nameEVar let prgToString = prgToString let funToString = funToString let nameCtx = nameCtx let formatCtx = fun Psi -> HVbox (formatCtx Psi) let ctxToString = ctxToString (*    val lemmaDecToString = lemmaDecToString *)  end\n(* signature FUNPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* Type checking for functional proof term calculus *) (* Author: Carsten Schuermann *) (* Modified: Yu Liao *) module type TOMEGATYPECHECK = sig exception Error of stringval checkCtx : Dec Ctx -> unitval checkFor : Dec Ctx * For -> unitval checkPrg : Dec Ctx * (Prg * For) -> unitval checkSub : Dec Ctx * Sub * Dec Ctx -> unit end(* Signature TOMEGATYPECHECK *) ', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* Converter from relational representation to a functional\n   representation of proof terms *) (* Author: Carsten Schuermann *) module type CONVERTER = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA !*) exception Error of stringexception Error' of Subval convertFor : cid list -> Forval convertPrg : cid list -> Prgval installPrg : cid list -> cid * lemma list(* projections *)  * lemma list(* selections *) val convertGoal : Dec Ctx * Exp -> Prg end(* Signature CONVERTER *) ", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Printing of functional proof terms *) (* Author: Carsten Schuermann *) module type TOMEGAPRINT = sig (*! structure IntSyn : INTSYN !*) (*! structure Tomega : TOMEGA  !*) module Formatter : FORMATTERexception Error of stringval formatFor : Dec Ctx * For -> formatval forToString : Dec Ctx * For -> stringval formatFun : (string list * lemma list) * Prg -> formatval formatPrg : Dec Ctx * Prg -> format(*  val formatLemmaDec: FunSyn.LemmaDec -> Formatter.format *) val funToString : (string list * lemma list) * Prg -> string(* funToString ((names, projs), P)  = s\n     cids is the list of mututal recursive type families.  (could also be names)\n     projs are the projection functions used internally,  They must be in the\n     same order as names.  The nth name corresponds to the nth projection function\n  *) val evarReset : unit -> unitval evarName : string -> Prgval nameEVar : Prg -> stringval prgToString : Dec Ctx * Prg -> stringval nameCtx : Dec Ctx -> Dec Ctxval formatCtx : Dec Ctx -> formatval ctxToString : Dec Ctx -> string(*  val lemmaDecToString : FunSyn.LemmaDec -> string *)  end\n(* signature TOMEGAPRINT *) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module type REDUNDANT = sig exception Error of stringval convert : Prg -> Prg end', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Internal syntax for functional proof term calculus *) (* Author: Carsten Schuermann, Adam Poswolsky *) module Opsem (module Whnf : WHNFmodule Abstract : ABSTRACTmodule Subordinate : SUBORDINATEmodule TomegaTypeCheck : TOMEGATYPECHECKmodule TomegaPrint : TOMEGAPRINTmodule Unify : UNIFY) : OPSEM = struct module T = Tomega module I = IntSyn module S = Subordinate module A = Abstract exception Error of string exception Abort (*  local -- removed ABP 1/19/03 *)  exception NoMatch (*\n matchPrg is used to see if two values can be \'unified\' for\n   purpose of matching case\n\n matchPrg (Psi, P1, P2) = ()\n\n    Invariant:\n    If P1 has no EVARs and P2 possibly does.\n    and Psi  |- P1 :: F\n    and Psi |- P1 value\n    and Psi |- P2 :: F\n    and Psi |- P2 value\n     then if Psi |- P1 == P2 matchPrg terminates\n       otherwise exception NoMatch is raised\n*)  let rec matchPrg (Psi, P1, P2)  = matchVal (Psi, (P1, id), normalizePrg (P2, id))(* ABP -- normalizePrg invariant does not state what happens to non-free EVArs,\n       and there are some embedded under PClo... *) matchVal (Psi, (Unit, _), Unit)  = () | matchVal (Psi, (PairPrg (P1, P1\'), t1), PairPrg (P2, P2\'))  = (matchVal (Psi, (P1, t1), P2); matchVal (Psi, (P1\', t1), P2\')) | matchVal (Psi, (PairBlock (B1, P1), t1), PairBlock (B2, P2))  = (matchVal (Psi, (P1, t1), P2); try  with ) | matchVal (Psi, (PairExp (U1, P1), t1), PairExp (U2, P2))  = (matchVal (Psi, (P1, t1), P2); try  with ) | matchVal (Psi, (PClo (P, t1\'), t1), Pt)  = matchVal (Psi, (P, comp (t1\', t1)), Pt) | matchVal (Psi, (P\', t1), PClo (PClo (P, t2), t3))  = (* ABP -- Do we need this? I added it *)  matchVal (Psi, (P\', t1), PClo (P, comp (t2, t3))) | matchVal (Psi, (P\', t1), PClo (EVar (_, r as ref NONE, _, _, _, _), t2))  = let iw = invertSub t2 in (* ABP -- just make sure this is right *) r := SOME (PClo (P\', comp (t1, iw))) | matchVal (Psi, (P\', t1), EVar (_, r as ref NONE, _, _, _, _))  = r := SOME (PClo (P\', t1)) | matchVal (Psi, (V, t), EVar ((D, r as ref (SOME P), F, _, _, _)))  = (* ABP -- this should never occur, since we normalized it to start *)  matchVal (Psi, (V, t), P) | matchVal _  = raise (NoMatch) let rec append (G1, Null)  = G1 | append (G1, Decl (G2, D))  = Decl (append (G1, G2), D)(* raisePrg is used in handling of NEW construct\n   raisePrg (G, P, F) = (P\', F\'))\n\n       Invariant:\n       If   Psi, G |- P in F\n       and  Psi |- G : blockctx\n       then Psi |- P\' in F\'\n       and  P = raise (G, P\')   (using subordination)\n       and  F = raise (G, F\')   (using subordination)\n*) raisePrg (Psi, G, Unit)  = Unit | raisePrg (Psi, G, PairPrg (P1, P2))  = let P1\' = raisePrg (Psi, G, P1) let P2\' = raisePrg (Psi, G, P2) in PairPrg (P1\', P2\') | raisePrg (Psi, G, PairExp (U, P))  = (* this is a real time sink, it would be much better if we did not have to\n      compute the type information of U,\n      more thought is required\n   *) (* G  |- w  : G\'    *) (* G\' |- iw : G     *) (* Psi0, G\' |- B\'\' ctx *) let V = infer\' (append (coerceCtx Psi, G), U) let w = weaken (G, targetFam V) let iw = invert w let G\' = strengthen (iw, G) let U\' = raiseTerm (G\', EClo (U, iw)) let P\' = raisePrg (Psi, G, P) in PairExp (U\', P\')(* evalPrg (Psi, (P, t)) = V\n\n       Invariant:\n       If   Psi\' |- P :: F\n       and  Psi |- t :: Psi\'\n       and  |- Psi ctx[block]\n       and  Psi |- P :: F\'\n       and  Psi |- P[t] evalsto V\n       and  Psi |- F[t] == F\'\n    *) evalPrg (Psi, (Unit, t))  = Unit | evalPrg (Psi, (PairExp (M, P), t))  = PairExp (EClo (M, coerceSub t), evalPrg (Psi, (P, t))) | evalPrg (Psi, (PairBlock (B, P), t))  = PairBlock (blockSub (B, coerceSub t), evalPrg (Psi, (P, t))) | evalPrg (Psi, (PairPrg (P1, P2), t))  = PairPrg (evalPrg (Psi, (P1, t)), evalPrg (Psi, (P2, t))) | evalPrg (Psi, (Redex (P, S), t))  = evalRedex (Psi, evalPrg (Psi, (P, t)), (S, t)) | evalPrg (Psi, (Var k, t))  = (match varSub (k, t) with Prg P -> evalPrg (Psi, (P, id))) | evalPrg (Psi, (Const lemma, t))  = evalPrg (Psi, (lemmaDef lemma, t)) | evalPrg (Psi, (Lam (D as UDec (BDec _), P), t))  = let D\' = decSub (D, t) in Lam (D\', evalPrg (Decl (Psi, D\'), (P, dot1 t))) | evalPrg (Psi, (Lam (D, P), t))  = Lam (decSub (D, t), PClo (P, dot1 t)) | evalPrg (Psi, (P\' as Rec (D, P), t))  = evalPrg (Psi, (P, Dot (Prg (PClo (P\', t)), t))) | evalPrg (Psi, (PClo (P, t\'), t))  = evalPrg (Psi, (P, comp (t\', t))) | evalPrg (Psi, (Case (Cases O), t\'))  = (* this is ugly.\n           * don\'t do reverse *)  (* reverse list O, so it looks at the\n           cases in the same order it is printed\n           *)  match (Psi, t\', Cases (rev O)) | evalPrg (Psi, (EVar (D, r as ref (SOME P), F, _, _, _), t))  = evalPrg (Psi, (P, t)) | evalPrg (Psi, (Let (D, P1, P2), t))  = let V = evalPrg (Psi, (P1, t)) let V\' = evalPrg (Psi, (P2, Dot (Prg V, t))) in V\' | evalPrg (Psi, (New (Lam (D, P)), t))  = (* unnecessary naming, remove later --cs *) let D\' = decSub (D, t) let UDec (D\'\') = D\' let D\'\'\' = UDec (decName (coerceCtx Psi, D\'\')) let V = evalPrg (Decl (Psi, D\'\'\'), (P, dot1 t)) let B = coerceCtx (Decl (Null, D\'\'\')) let (G, t\') = deblockify B let newP = raisePrg (Psi, G, normalizePrg (V, t\')) in newP | evalPrg (Psi, (Box (W, P), t))  = evalPrg (Psi, (P, t)) | evalPrg (Psi, (Choose P, t))  = (* This function was imported from cover.fun   -- cs Thu Mar 20 11:47:06 2003 *) (* substtospine\' (s, G, T) = S @ T\n                If   G\' |- s : G\n                then G\' |- S : {{G}} a >> a  for arbitrary a\n                    {{G}} erases void declarations in G\n              *) let rec substToSpine\' (Shift (n), Null, T)  = T | substToSpine\' (Shift (n), G as Decl _, T)  = substToSpine\' (Dot (Idx (n + 1), Shift (n + 1)), G, T) | substToSpine\' (Dot (Exp (U), s), Decl (G, V), T)  = substToSpine\' (s, G, AppExp (U, T)) | substToSpine\' (Dot (Idx (n), s), Decl (G, Dec (_, V)), T)  = (* Eta-expand *)  let (Us, _) = whnfEta ((Root (BVar (n), Nil), id), (V, id)) in substToSpine\' (s, G, AppExp (EClo Us, T)) let rec choose (k, Null)  = raise (Abort) | choose (k, Decl (Psi\', PDec _))  = choose (k + 1, Psi\') | choose (k, Decl (Psi\', UDec (Dec _)))  = choose (k + 1, Psi\') | choose (k, Decl (Psi\', UDec (BDec (_, (l1, s1)))))  = let (Gsome, Gpi) = constBlock l1 let S = substToSpine\' (s1, Gsome, AppBlock (Bidx k, Nil)) in try  with in choose (1, Psi)(* other cases should not occur -cs *) (* match is used to handle Case statements\n  match (Psi, t1, O) = V\n\n       Invariant:\n       If   Psi |- t1 :: Psi\'\'\n       and  Psi\'\' |- O :: F\n       and  |- Psi ctx[block]\n       then if t1 matches O then Psi |- t ~ O evalPrgs to W\n            otherwise exception NoMatch is raised.\n    *) match (Psi, t1, Cases ((Psi\', t2, P) :: C))  = (* val I.Null = Psi *) (* Psi |- t : Psi\' *) (* Psi\' |- t2 . shift(k) : Psi\'\' *) let t = createVarSub (Psi, Psi\') let t\' = comp (t2, t) in (* Note that since we are missing the shift(k), it is possible\n           * that t\' has extra DOTs in there that weren\'t removed *) try  with | match (Psi, t1, Cases (nil))  = raise (Abort)(* What do you want to do if it doesn\'t match anything *) (* can\'t happen when total function - ABP *) (* | match (Psi, t1, T.Cases Nil) = raise Domain  *) (* createVarSub (Psi, Psi\') = t\n\n       Invariant:\n       If   |- Psi ctx[block]\n       and  |- Psi\' ctx\n       then Psi |- t :: Psi\'\n    *) createVarSub (Psi, Null)  = Shift (ctxLength (Psi)) | createVarSub (Psi, Psi\'\' as Decl (Psi\', PDec (name, F, NONE, NONE)))  = let t = createVarSub (Psi, Psi\') let t\' = Dot (Prg (newEVarTC (Psi, forSub (F, t), NONE, NONE)), t) in t\' | createVarSub (Psi, Decl (Psi\', UDec (Dec (name, V))))  = let t = createVarSub (Psi, Psi\') in Dot (Exp (EVar (ref NONE, coerceCtx Psi, EClo (V, coerceSub t), ref [])), t) | createVarSub (Psi, Decl (Psi\', UDec (BDec (name, (cid, s)))))  = let t = createVarSub (Psi, Psi\') in Dot (Block (LVar (ref NONE, id, (cid, comp (s, coerceSub t)))), t)(* matchSub (t1, t2) = ()\n\n       Invariant:\n       If   Psi  |- t1 :: Psi\'\n       and  Psi  |- t2 :: Psi\'\n       and  Psi  |- t1 == t2 :: Psi\'\n       and  |- Psi ctx [block]\n       then function returns ()\n            otherwise exception NoMatch is raised\n    *) matchSub (Psi, _, Shift _)  = () | matchSub (Psi, Shift n, t as Dot _)  = matchSub (Psi, Dot (Idx (n + 1), Shift (n + 1)), t) | matchSub (Psi, Dot (Exp U1, t1), Dot (Exp U2, t2))  = (matchSub (Psi, t1, t2); try  with ) | matchSub (Psi, Dot (Exp U1, t1), Dot (Idx k, t2))  = (matchSub (Psi, t1, t2); try  with ) | matchSub (Psi, Dot (Idx k, t1), Dot (Exp U2, t2))  = (matchSub (Psi, t1, t2); try  with ) | matchSub (Psi, Dot (Prg P1, t1), Dot (Prg P2, t2))  = (matchSub (Psi, t1, t2); matchPrg (Psi, P1, P2)) | matchSub (Psi, Dot (Prg P1, t1), Dot (Idx k, t2))  = (matchSub (Psi, t1, t2); matchPrg (Psi, P1, Var k)) | matchSub (Psi, Dot (Idx k, t1), Dot (Prg P2, t2))  = (matchSub (Psi, t1, t2); matchPrg (Psi, Var k, P2)) | matchSub (Psi, Dot (Idx k1, t1), Dot (Idx k2, t2))  = (if k1 = k2 then matchSub (Psi, t1, t2) else raise (NoMatch)) | matchSub (Psi, Dot (Idx k, t1), Dot (Block (LVar (r, s1, (c, s2))), t2))  = let s1\' = invert s1 let _ = r := SOME (blockSub (Bidx k, s1\')) in matchSub (Psi, t1, t2) | matchSub (Psi, Dot (Block (B), t1), Dot (Block (LVar (r, s1, (c, s2))), t2))  = let s1\' = invert s1 let _ = r := SOME (blockSub (B, s1\')) in matchSub (Psi, t1, t2)(* evalRedex (Psi, V, (S, t)) = V\'\n\n       Invariant:\n       If   Psi  |- V :: F1\n       and  Psi\' |- S :: F2 > F3\n       and  Psi  |- t :: Psi\'\n       and  Psi\' |- F1 == F2[t]\n       and  |- Psi ctx[block]\n       and  Psi |- P :: F\'\n       and  Psi |- V . (S[t]) evalsto V\'\'\n       then Psi |- V\' == V\'\' : F3[t]\n    *) evalRedex (Psi, V, (Nil, _))  = V | evalRedex (Psi, V, (SClo (S, t1), t2))  = evalRedex (Psi, V, (S, comp (t1, t2))) | evalRedex (Psi, Lam (UDec (Dec (_, A)), P\'), (AppExp (U, S), t))  = let V = evalPrg (Psi, (P\', Dot (Exp (EClo (U, coerceSub t)), id))) in evalRedex (Psi, V, (S, t)) | evalRedex (Psi, Lam (UDec _, P\'), (AppBlock (B, S), t))  = evalRedex (Psi, evalPrg (Psi, (P\', Dot (Block (blockSub (B, coerceSub t)), id))), (S, t)) | evalRedex (Psi, Lam (PDec _, P\'), (AppPrg (P, S), t))  = let V = evalPrg (Psi, (P, t)) let V\' = evalPrg (Psi, (P\', Dot (Prg V, id))) in evalRedex (Psi, V\', (S, t)) (* topLevel (Psi, d, (P, t))\n\n       Invariant:\n       Psi |- t : Psi\'\n       Psi\' |- P :: F\n       d = | Psi\' |\n\n    *)  let rec topLevel (Psi, d, (Unit, t))  = () | topLevel (Psi, d, (Let (D\', P1, Case Cs), t))  = (* lf value definition *)  (* printLF (G, s, G\') k = ()\n             Invariant:\n             G |- s : G\'\n          *) let rec printLF (_, _, _) 0  = () | printLF (G, Dot (Exp U, s\'), Decl (G\', Dec (SOME name, V))) k  = let _ = printLF (G, s\', G\') (k - 1) in print ("def " ^ name ^ " = " ^ (expToString (G, U)) ^ " : " ^ (expToString (G, EClo (V, s\'))) ^ "\\n") let rec match (Psi, t1, Cases ((Psi\', t2, P) :: C))  = (* Psi |- t : Psi\' *) (* Psi\' |- t2 . shift(k) : Psi\'\' *) (* Psi |- t\'\' : Psi\' *) let t = createVarSub (Psi, Psi\') let t\' = comp (t2, t) let m = ctxLength Psi\' let _ = matchSub (Psi, t1, t\') let t\'\' = (* T.normalizeSub *) t let _ = printLF (coerceCtx Psi, coerceSub t\'\', coerceCtx Psi\') (m - d) in topLevel (Psi, m, (P, t\'\')) let V = evalPrg (Psi, (P1, t)) let V\' = match (Psi, Dot (Prg V, t), Cs) in V\' | topLevel (Psi, d, (Let (D, Lam (D\' as UDec (BDec (SOME name, (cid, s))), P1), P2), t))  = (* new declaration *)  let _ = print ("new " ^ name ^ "\\n") let D\'\' = decSub (D\', t) let _ = topLevel (Decl (Psi, D\'\'), d + 1, (P1, dot1 t)) in () | topLevel (Psi, d, (Let (D, P1, P2), t))  = (* function definition *)  let PDec (SOME name, F, _, _) = D let V = evalPrg (Psi, (P1, t)) let _ = print ("val " ^ name ^ " = " ^ prgToString (Psi, V) ^ " :: " ^ forToString (Psi, F) ^ "\\n") let V\' = topLevel (Psi, d + 1, (P2, Dot (Prg V, t))) in V\' (* in -- removed local *)  let evalPrg = fun P -> evalPrg (Null, (P, id)) let topLevel = fun P -> topLevel (Null, 0, (P, id)) (* end -- removed local *)  end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module type TRANSLATE = sig (** Translate a Twelf declaration to a Flewt declaration. *) val translate_condec : cid * ConDec -> dec(** Translate the currently loaded Twelf signature to Flewt *) val translate_signat : unit -> const * dec list end', 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Changes by Tom 7 in 2003- *) (* Copyright (C) 1999-2002 Henry Cejtin, Matthew Fluet, Suresh\n *    Jagannathan, and Stephen Weeks.\n *\n * MLton is released under the GNU General Public License (GPL).\n * Please see the file MLton-LICENSE for license information.\n *) module type LAYOUT = sig type layout(* layout the objects on separate lines*) val align : layout list -> layoutval alignPrefix : layout list * string -> layoutval array : layout array -> layout(* Whether or not to print things in detail -\n       * routines that create layouts should use this flag to decide\n       * how detailed to print.\n       *) val detailed : bool refval empty : layoutval ignore : \'a -> layoutval isEmpty : layout -> bool(* layout the objects on separate lines, if necessary *) val mayAlign : layout list -> layoutval namedRecord : string * string * layout list -> layout(* indent the entire object *) val indent : int -> layout -> layoutval list : layout list -> layout(* give open, close, sep *) val listex : string -> string -> string -> layout list -> layout(* (* what is this? *)\n      val makeOutput: (\'a -> layout) -> \'a * Outstream0.t -> unit\n      val output: layout * Outstream0.t -> unit\n      val outputl: layout * Outstream0.t -> unit\n      val outputTree: layout * Outstream0.t -> unit\n      val outputWidth: layout * int * Outstream0.t -> unit\n*) val paren : layout -> layout(* print the object *) val print : layout * (string -> unit) -> unitval record : string * layout list -> layout(* give separator, ie "=" or ":" *) val recordex : string -> string * layout list -> layoutval schemeList : layout list -> layout(* put string between elements *) val separate : layout list * string -> layout list(* adds string at beginning of all objects except first *) val separateLeft : layout list * string -> layout list(* adds string at the end of all objects except last *) val separateRight : layout list * string -> layout list(* layout the objects on the same line *) val seq : layout list -> layout(* convert a string to a layout object *) val str : string -> layoutval switch : {detailed: \'a -> layout; normal: \'a -> layout} -> \'a -> layoutval tostring : layout -> string(* give maximum width *) val tostringex : int -> layout -> stringval tuple : layout list -> layoutval tuple2 : (\'a -> layout) * (\'b -> layout) -> \'a * \'b -> layoutval tuple3 : (\'a -> layout) * (\'b -> layout) * (\'c -> layout) -> \'a * \'b * \'c -> layoutval tuple4 : (\'a -> layout) * (\'b -> layout) * (\'c -> layout) * (\'d -> layout) -> \'a * \'b * \'c * \'d -> layoutval tuple5 : (\'a -> layout) * (\'b -> layout) * (\'c -> layout) * (\'d -> layout) * (\'e -> layout) -> (\'a * \'b * \'c * \'d * \'e) -> layoutval vector : layout vector -> layout end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(** Imperative arrays that automatically grow to\n    accomodate new data. The array can have 'holes'\n    where no data are stored, though these are not\n    treated efficiently. *) module type GROWARRAY = sig type 'agrowarrayval growarray : int -> 'a -> 'a growarrayval empty : unit -> 'a growarray(** return actual length *) val length : 'a growarray -> int(** can raise Subscript when out of bounds *) val sub : 'a growarray -> int -> 'a(** only raises subscript if index is negative. *) val update : 'a growarray -> int -> 'a -> unit(** stick an element at the end *) val append : 'a growarray -> 'a -> unit(** true if a position has been set *) val used : 'a growarray -> int -> bool(** \n     after calling this, don't use the growarray\n     any longer, since it may share data with the returned\n     array. \n\n     @exception Subscript if the array has holes.\n*) val finalize : 'a growarray -> 'a array end", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', 'module SyntaxSYNTAX = struct module L = Lib type const = int type uni = Type | Kind type head = Const of const | BVar of int type depend = No | Maybe type exp = Uni of uni | Pi of pi | Lam of lam | Root of head * spine | Redex of exp * spine | EClo of exp * sub and spine = Nil | App of exp * spine | SClo of spine * sub and sub = Dot of exp * sub | Shift of int | Comp of sub * sub type decl = {id: const; name: string; exp: exp; uni: uni} type def = {id: const; name: string; exp: exp; def: exp; height: int; root: const; uni: uni} type abbrev = {id: const; name: string; exp: exp; def: exp; uni: uni} type dec = Decl of decl | Def of def | Abbrev of abbrev (* -------------------------------------------------------------------------- *)  (*  Signatures                                                                *)  (* -------------------------------------------------------------------------- *)  module Signat = struct module T = Table type signat = dec table let global_signat : dec table = table 100000 let rec lookup c  = lookup global_signat c let rec insert (c, d)  = ignore (insert global_signat (c, d)) let rec app f  = appi f global_signat let rec size ()  = size global_signat let rec reset ()  = clear global_signat end module Sig = Signat (* -------------------------------------------------------------------------- *)  (*  Util                                                                      *)  (* -------------------------------------------------------------------------- *)  let expType = Uni Type let expKind = Uni Kind let rec bvar n  = Root (BVar n, Nil) let one = bvar 1 let shift = Shift 1 let id_sub = Shift 0 let rec id (Decl decl)  = id decl | id (Def def)  = id def | id (Abbrev abb)  = id abb let rec name (Decl decl)  = name decl | name (Def def)  = name def | name (Abbrev abb)  = name abb let rec exp (Decl decl)  = exp decl | exp (Def def)  = exp def | exp (Abbrev abb)  = exp abb let rec is_def c  = match lookup c with Def _ -> true | Abbrev _ -> true | Decl _ -> false let rec def c  = match lookup c with Def def -> def def | Abbrev abb -> def abb | Decl _ -> raise (Fail "def: not a def") (* -------------------------------------------------------------------------- *)  (*  Exceptions                                                                *)  (* -------------------------------------------------------------------------- *)  exception Fail_exp of string * exp exception Fail_exp2 of string * exp * exp exception Fail_exp_spine of string * exp * spine exception Fail_spine_exp of string * spine * exp exception Fail_hd_spine of string * head * spine exception Fail_sub_exp of string * sub * exp exception Fail_sub_exp of string * sub * exp (* -------------------------------------------------------------------------- *)  (*  Eta                                                                       *)  (* -------------------------------------------------------------------------- *)  type skel = Base | Arrow of skel * skel let rec card Nil  = 0 | card (App (M, S))  = 1 + card S | card _  = raise (Fail "card: no closures") let rec num_pi_quants (Pi {body; _})  = 1 + num_pi_quants body | num_pi_quants _  = 0 let rec skel_length Base  = 0 | skel_length (Arrow (_, tau))  = 1 + skel_length tau let rec concat (Nil, M)  = App (M, Nil) | concat (App (M, S), M\')  = App (M, concat (S, M\')) | concat (SClo _, _)  = raise (Fail "concat: no closures") let rec skeleton (ctx, Uni Type)  = Base | skeleton (ctx, Root (Const a, S))  = let aty = exp (lookup a) let n = num_pi_quants aty let n\' = card S in if n = n\' then Base else raise (Fail "skeleton: not eta expanded") | skeleton (ctx, Root (BVar i, S))  = let aty = ith (i - 1) ctx let n = skel_length aty let n\' = card S in if n = n\' then Base else raise (Fail "skeleton: not eta expanded") | skeleton (ctx, Pi {arg; body; _})  = let tau1 = skeleton (ctx, arg) let tau2 = skeleton (ctx, body) in Arrow (tau1, tau2) | skeleton (_, exp)  = raise (Fail_exp ("skeleton: bad case", exp)) exception Fail_exp_skel of string * exp * skel let changed = ref false (* A quick implementation of applying a shift substitution. \n       This is just for eta expansion, and we don\'t want this\n       code to be tangled with the different typechecker versions.\n    *) let rec shift_head (lev, con as Const _)  = con | shift_head (lev, var as BVar n)  = if n >= lev then BVar (n + 1) else var let rec shift_spine (lev, Nil)  = Nil | shift_spine (lev, App (M, S))  = App (shift_exp (lev, M), shift_spine (lev, S)) | shift_spine (lev, SClo _)  = raise (Fail "shift_spine: shouldn\'t have closures during eta expansion")shift_exp (lev, uni as (Uni _))  = uni | shift_exp (lev, Pi {var; arg; depend; body})  = Pi {var = var; arg = shift_exp (lev, arg); depend = depend; body = shift_exp (lev + 1, body)} | shift_exp (lev, Lam {var; body})  = Lam {var = var; body = shift_exp (lev + 1, body)} | shift_exp (lev, Root (H, S))  = Root (shift_head (lev, H), shift_spine (lev, S)) | shift_exp _  = raise (Fail "shift_exp: shouldn\'t have redexes or closures during eta expansion") let rec shift_spine\' exp  = shift_spine (0, exp) let rec long_exp (ctx, exp as Uni Type, Base)  = exp | long_exp (ctx, Pi {arg; body; depend; var}, Base)  = let arg\' = long_exp (ctx, arg, Base) let tau = skeleton (ctx, arg\') let body\' = long_exp (tau :: ctx, body, Base) in Pi {arg = arg\'; body = body\'; depend = depend; var = var} | long_exp (ctx, Lam {var; body}, Arrow (tau1, tau2))  = let body\' = long_exp (tau1 :: ctx, body, tau2) in Lam {var = var; body = body\'} | long_exp (ctx, expr as Root (con as Const a, S), Base)  = let tau = skeleton (ctx, exp (lookup a)) in Root (con, long_spine (ctx, S, tau)) | long_exp (ctx, exp as Root (var as BVar i, S), Base)  = (* indices start at 1 *) let tau = ith (i - 1) ctx in Root (var, long_spine (ctx, S, tau)) | long_exp (ctx, Root (con as Const c, S), tau as Arrow (tau1, tau2))  = let S\' = concat (shift_spine\' S, one) in changed := true; long_exp (ctx, Lam {var = NONE; body = Root (con, S\')}, tau) | long_exp (ctx, Root (BVar i, S), tau as Arrow (tau1, tau2))  = let S\' = concat (shift_spine\' S, one) in changed := true; long_exp (ctx, Lam {var = NONE; body = Root (BVar (i + 1), S\')}, tau) | long_exp (_, exp, skel)  = raise (Fail_exp_skel ("long_exp: bad case", exp, skel))long_spine (ctx, Nil, Base)  = Nil | long_spine (ctx, App (M, S), Arrow (tau1, tau2))  = let M\' = long_exp (ctx, M, tau1) let S\' = long_spine (ctx, S, tau2) in App (M\', S\') | long_spine _  = raise (Fail "long_spine: bad case") let rec eta_expand\' (e1, Uni Kind)  = e1 | eta_expand\' (e1, e2)  = let () = changed := false let skel = skeleton ([], e2) let e2\' = long_exp ([], e1, skel) in (*           if !changed then L.warning "expression is not eta long" else (); *) e2\' let rec eta_expand e  = (time eta_normal eta_expand\') e  end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* structure GrowarrayTable : TABLE where type key = int = *) (* struct *) (*   structure L = Lib *) (*   structure A = GrowArray *) (*   type key = int  *) (*   type \'a table = \'a A.growarray *) (*   fun empty _ = A.empty() *) (*   fun size t = A.length t *) (*   fun insert t (n,v) = *) (*       if A.length t > n then raise Fail "insert: signat contains key" *) (*       else (A.update t n v;t) *) (*   fun lookup t n = A.sub t n *) (*   fun iter f : (\'a -> unit) -> \'a table -> unit *) (*   val foldl : (\'a * \'b -> \'b) -> \'b -> \'a table -> b *) (*   val foldr : (\'a * \'b -> \'b) -> \'b -> \'a table -> b *) (* end *) module ArrayTableTABLE where keyint = struct module L = Lib module A = Array type key = int type \'atable = {arr: \'a option array; used: int ref} let rec table n  = {arr = array (n, NONE); used = ref 0} let rec clear {arr; used}  = (used := 0; modify (fun _ -> NONE) arr) let rec insert (t as {arr; used}) (n, v)  = if n < 0 || n > length arr then raise (Subscript) else match sub (arr, n) with NONE -> (update (arr, n, SOME v); if n > ! used then used := n else (); t) | SOME _ -> raise (Fail "insert: key already present") let rec lookup ({arr; _} : \'a table) n  = if n < 0 || n > length arr then raise (Subscript) else match sub (arr, n) with NONE -> raise (Subscript) | SOME v -> v let rec size ({arr; _} : \'a table)  = length arr exception Done let rec app f {arr; used}  = let used\' = ! used let rec f\' (i, x)  = if i >= used\' then raise (Done) else match x with SOME n -> f n | NONE -> () in try  with let rec appi f {arr; used}  = let used\' = ! used let rec f\' (i, x)  = if i >= used\' then raise (Done) else match x with SOME n -> f (i, n) | NONE -> () in try  with endmodule Table = ArrayTable', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', '(* -------------------------------------------------------------------------- *) (*  Printing                                                                  *) (* -------------------------------------------------------------------------- *)  let rec  $ x  = str x let rec  % x  = mayAlign x let rec  %% x  = align x let rec  & x  = seq x let rec paren x  = & [$ "("; x; $ ")"] let rec bracket x  = & [$ "["; x; $ "]"] let rec squiggle x  = & [$ "{"; x; $ "}"] let rec indent x  = indent x let rec uni_to_layout Type  = $ "type" | uni_to_layout Kind  = $ "kind" let rec const_to_string sgn c  = name (lookup sgn c) let rec spine_to_list Nil  = [] | spine_to_list (App (E, S))  = E :: spine_to_list S let rec head_to_layout sgn (Const c)  = $ (const_to_string sgn c) | head_to_layout sgn (BVar n)  = $ (toString n) let rec needs_parens_in_arg_pos (Uni _)  = false | needs_parens_in_arg_pos (Root (_, Nil))  = false | needs_parens_in_arg_pos _  = true let rec needs_sparens_in_arg_pos Nil  = false | needs_sparens_in_arg_pos (App (E, Nil))  = needs_parens_in_arg_pos E | needs_sparens_in_arg_pos _  = true let rec maybe_paren E l  = if needs_parens_in_arg_pos E then paren l else l let rec maybe_sparen S l  = if needs_sparens_in_arg_pos S then paren l else l let rec spine_to_layout sgn S  = %% (map (exp_to_layout sgn) (spine_to_list S))exp_to_layout sgn (Uni lev)  = uni_to_layout lev | exp_to_layout sgn (Pi pi)  = & [$ "PI "; %% [(& [maybe_paren (arg pi) (exp_to_layout sgn (arg pi)); $ ". "]); exp_to_layout sgn (body pi)]] | exp_to_layout sgn (Lam lam)  = & [$ "LAM. "; exp_to_layout sgn (body lam)] | exp_to_layout sgn (Root (H, Nil))  = head_to_layout sgn H | exp_to_layout sgn (Root (H, S))  = & [head_to_layout sgn H; $ " ^ "; maybe_sparen S (spine_to_layout sgn S)] type subelem = SubShift of int | SubExp of exp let rec sub_to_list (sub as Shift n)  = [SubShift n] | sub_to_list (Dot (M, sub))  = SubExp M :: sub_to_list sub | sub_to_list (Comp (s1, s2))  = sub_to_list s1 @ sub_to_list s2 let rec sub_to_layout sgn sub  = let sub\' = sub_to_list sub let rec mapfn (SubShift n)  = $ ("^" ^ toString n) | mapfn (SubExp exp)  = exp_to_layout sgn exp let sub\'\' = map mapfn sub\' in list sub\'\' let rec exp_to_string sgn exp  = tostring (exp_to_layout sgn exp) let rec spine_to_string sgn sp  = tostring (spine_to_layout sgn sp) let rec sub_to_string sgn sub  = tostring (sub_to_layout sgn sub) let rec print_exp sgn exp  = print ("\\n" ^ exp_to_string sgn exp ^ "\\n") let rec print_spine sgn sp  = print ("\\n" ^ spine_to_string sgn sp ^ "\\n") let rec print_sub sgn sub  = print ("\\n" ^ sub_to_string sgn sub ^ "\\n") ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module TranslateTRANSLATE = struct module L = Lib module I = IntSyn module S = Syntax module Sig = SSignat module C = ClausePrint module D = Debug (* -------------------------------------------------------------------------- *)  (*  Exceptions                                                                *)  (* -------------------------------------------------------------------------- *)  exception Translate of string exception Trans1 of const * ConDec exception Fail_exp of string * Exp (* -------------------------------------------------------------------------- *)  (*  Basic Translation                                                         *)  (* -------------------------------------------------------------------------- *)  let rec translate_uni Kind  = Kind | translate_uni Type  = Type let rec translate_head (BVar i)  = BVar i | translate_head (Const c)  = Const c | translate_head (Def c)  = Const c | translate_head _  = raise (Translate "translate_head: bad case") let rec translate_depend No  = No | translate_depend Maybe  = Maybe | translate_depend _  = raise (Fail "translate_depend: bad case")translate_exp (Uni uni)  = Uni (translate_uni uni) | translate_exp (Pi ((Dec (name, U1), depend), U2))  = Pi {var = name; arg = translate_exp U1; depend = translate_depend depend; body = translate_exp U2} | translate_exp (Root (H, S))  = Root (translate_head H, translate_spine S) | translate_exp (Lam (Dec (name, _), U))  = Lam {var = name; body = translate_exp U} | translate_exp E  = raise (Fail_exp ("translate_exp: bad case", E))translate_spine Nil  = Nil | translate_spine (App (U, S))  = App (translate_exp U, translate_spine S) | translate_spine _  = raise (Translate "translate_spine: bad case") let rec translate_condec (cid, ConDec (name, _, _, _, E, U))  = Decl {id = cid; name = name; exp = translate_exp E; uni = translate_uni U} | translate_condec (cid, ConDef (name, _, _, U, V, Type, Anc (ex1, h, exa)))  = Def {id = cid; name = name; exp = translate_exp V; def = translate_exp U; height = h; root = the exa; uni = Type} | translate_condec (cid, AbbrevDef (name, mid, n, U, V, lev))  = Abbrev {id = cid; name = name; exp = translate_exp V; def = translate_exp U; uni = translate_uni lev} | translate_condec cdec  = raise (Trans1 cdec) (*     | translate_condec _ = raise Translate "translate_condec: bad case" *)  let rec can_translate (ConDec _)  = true | can_translate (ConDef _)  = true | can_translate (AbbrevDef _)  = true | can_translate _  = false let rec translate_signat\' ()  = let n = fst (sgnSize ()) let ns = upto (0, n - 1) let cds = map sgnLookup ns let cds\' = filter (fun (id, dec) -> can_translate dec) (zip ns cds) in map (fun (dec as (c, e)) -> (c, translate_condec dec)) cds\' let rec translate_signat ()  = (time translation translate_signat\') () end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module GrowArrayGROWARRAY = struct module A = Array type 'agrowarray = int * 'a option array ref (* start with 16 cells, why not? *)  let rec empty ()  = ref (0, array (16, NONE)) let rec growarray n i  = ref (n, (array (n, SOME i))) let rec sub (ref (used, a)) n  = if n < used && n >= 0 then (match sub (a, n) with NONE -> raise (Subscript) | SOME z -> z) else raise (Subscript) let rec length (ref (l, _))  = l (* grow to accomodate at least n elements *)  let rec accomodate (r as ref (l, a)) n  = if length a >= (n + 1) then () else let rec nextpower x  = if x >= (n + 1) then x else nextpower (x * 2) let ns = nextpower (length a) let na = tabulate (ns, (fun i -> if i < l then sub (a, i) else NONE)) in r := (l, na) let rec update r n x  = if n < 0 then raise (Subscript) else let _ = accomodate r n let (l, a) = ! r in update (a, n, SOME x); (* also update 'used' *) if n >= l then r := (n + 1, a) else () let rec append (r as ref (n, _)) x  = let _ = accomodate r (n + 1) let (_, a) = ! r in update (a, n, SOME x); r := (n + 1, a) let rec used arr n  = try  with let rec finalize (ref (n, a))  = tabulate (n, (fun x -> match sub (a, x) with NONE -> raise (Subscript) | SOME z -> z)) end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
('Error parsing code:', "module ContextCONTEXT = struct module L = Lib type 'actx = 'a list exception Context of string let empty = [] let rec lookup (l, n)  = try  with let rec push (ctx, p)  = p :: ctx let rec list l  = l end", 'Error matches:', [(0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(**\n A library of useful functions for everyday programming.\n*) module type LIB = sig (** Nice for postponing an implementation. *) exception Not_implemented(* -------------------------------------------------------------------------- *) (*  Booleans                                                                  *) (* -------------------------------------------------------------------------- *) (** Curried <code> andalso </code> *) val andalso' : bool -> bool -> bool(** Curried <code> orelse </code> *) val orelse' : bool -> bool -> bool(* -------------------------------------------------------------------------- *) (*  Pairs                                                                     *) (* -------------------------------------------------------------------------- *) (** First element of a pair. *) val fst : 'a * 'b -> 'a(** Second element of a pair. *) val snd : 'a * 'b -> 'b(* -------------------------------------------------------------------------- *) (*  Options                                                                   *) (* -------------------------------------------------------------------------- *) val is_none : 'a option -> boolval is_some : 'a option -> bool(** Get the content of an option type. \n      @exception Fail\n   *) val the : 'a option -> 'a(* ------------------------------------------------------------------------- *) (*  Refs                                                                     *) (* ------------------------------------------------------------------------- *) (** Increment an <code> int ref <\\code> *) val incr : int ref -> unit(** Increment an <code> int ref <\\code> *) val += : int ref * int -> unit(** Decrement an <code> int ref <\\code> *) val -= : int ref * int -> unit(** Decrement an <code> int ref <\\code> *) val decr : int ref -> unit(** Prepend an element to a <code> list </code> *) val ::= : 'a list ref * 'a -> unit(** Append a list at the back of a <code> list </code> *) val @= : 'a list ref * 'a list -> unit(* -------------------------------------------------------------------------- *) (*  Streams                                                                   *) (* -------------------------------------------------------------------------- *) (** Infinite streams. *) type 'astream(** Prefix of a stream, as a list *) val listof_s : int -> 'a stream -> 'a list(** \n     Select an element from a stream\n     @exception Fail if there are not enough elements in the stream.\n   *) val nth_s : int -> 'a stream -> 'a(* ---------------------------------------------------------------------- *) (*  Functions                                                             *) (* ---------------------------------------------------------------------- *) (** Curry a function. *) val curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c(** Uncurry a function. *) val uncurry : ('a -> 'b -> 'c) -> 'a * 'b -> 'c(** Curry a 3 argument function.  Occasionally useful. *) val curry3 : ('a * 'b * 'c -> 'd) -> 'a -> 'b -> 'c -> 'd(** Identity combinator *) val id : 'a -> 'a(** Returns true iff a function application returns a value. *) val can : ('a -> 'b) -> 'a -> bool(** Returns true iff a function application raises an exception. *) val cant : ('a -> 'b) -> 'a -> bool(** Returns true iff a (2 argument) function application returns a value. *) val can2 : ('a -> 'b -> 'c) -> 'a -> 'b -> bool(** Curried equality *) val ceq : ''a -> ''a -> bool(** Swap the arguments of a function. *) val swap : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c(** Explicit application. *) val apply : ('a -> 'b) * 'a -> 'b(** Apply a function a given number of times. *) val repeat : ('a -> 'a) -> int -> 'a -> 'a(* -------------------------------------------------------------------------- *) (*  Ints                                                                      *) (* -------------------------------------------------------------------------- *) (** Add up a list of ints *) val sum : int list -> int(** max of a list of ints *) val max : int list -> int(** upto 3 5 ~~> [3,4,5] *) val upto : int * int -> int list(** @see upto *) val -- : int * int -> int list(** 3 --< 5 ~~> [3,4] *) val --< : int * int -> int list(* -------------------------------------------------------------------------- *) (*  Reals                                                                     *) (* -------------------------------------------------------------------------- *) (** max of a list of reals *) val real_max : real list -> real(** sum of a list of reals *) val real_sum : real list -> real(* ------------------------------------------------------------------------- *) (*  Order                                                                    *) (* ------------------------------------------------------------------------- *) val string_ord : string * string -> orderval int_ord : int * int -> orderval lex_ord : ('a * 'b -> order) -> ('c * 'd -> order) -> ('a * 'c) * ('b * 'd) -> orderval eq_ord : ''a * ''a -> order(* ---------------------------------------------------------------------- *) (*  Debug                                                                 *) (* ---------------------------------------------------------------------- *) val assert : bool -> string -> unit(** !warn = true iff <code> warning s</code> will print \n      <code> s</code> to stdout. *) val warn : bool ref(** Print a warning message to stdout.  \n   @see warn\n   *) val warning : string -> unit(* ---------------------------------------------------------------------- *) (*  Lists                                                                 *) (* ---------------------------------------------------------------------- *) (** Cons. *) val cons : 'a -> 'a list -> 'a list(** Singleton list. *) val list : 'a -> 'a listval itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'bval citlist : ('a * 'b -> 'b) -> 'a list -> 'b -> 'bval ith : int -> 'a list -> 'aval map2 : ('a * 'b -> 'c) -> 'a list -> 'b list -> 'c listval map3 : ('a * 'b * 'c -> 'd) -> 'a list -> 'b list -> 'c list -> 'd listval zip : 'a list -> 'b list -> 'a * 'b listval zip3 : 'a list -> 'b list -> 'c list -> 'a * 'b * 'c listval zip4 : 'a list -> 'b list -> 'c list -> 'd list -> 'a * 'b * 'c * 'd listval zip5 : 'a list -> 'b list -> 'c list -> 'd list -> 'e list -> 'a * 'b * 'c * 'd * 'e listval unzip : 'a * 'b list -> 'a list * 'b listval unzip3 : 'a * 'b * 'c list -> 'a list * 'b list * 'c listval unzip4 : 'a * 'b * 'c * 'd list -> 'a list * 'b list * 'c list * 'd listval ~~ : 'a list * 'b list -> 'a * 'b listval end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'aval end_citlist : ('a * 'a -> 'a) -> 'a list -> 'aval itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'cval rev_itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'bval rev_end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'aval replicate : 'a -> int -> 'a listval exists : ('a -> bool) -> 'a list -> boolval forall : ('a -> bool) -> 'a list -> boolval last : 'a list -> 'aval butlast : 'a list -> 'a listval gen_list_eq : ('a * 'b -> order) -> 'a list -> 'b list -> boolval list_eq : ''a list -> ''a list -> boolval partition : ('a -> bool) -> 'a list -> 'a list * 'a listval filter : ('a -> bool) -> 'a list -> 'a listval sort : ('a * 'a -> order) -> 'a list -> 'a listval uniq : ('a * 'a -> order) -> 'a list -> 'a listval uniq_list : ('a * 'a -> order) -> 'a list -> boolval split_at : int -> 'a list -> 'a list * 'a listval list_prefix : int -> 'a list -> 'a listval list_slice : int -> int -> 'a list -> 'a listval shuffle : 'a list -> 'a list -> 'a listval find_index : ('a -> bool) -> 'a list -> int optionval index : ''a -> ''a list -> int optionval find_last_index : ('a -> bool) -> 'a list -> int optionval last_index : ''a -> ''a list -> int optionval flatten : 'a list list -> 'a listval chop_list : int -> 'a list -> 'a list * 'a listval list_to_string : ('a -> string) -> 'a list -> stringval remove : ('a -> bool) -> 'a list -> 'a * 'a listval do_list : ('a -> 'b) -> 'a list -> unitval exn_index : ('a -> 'b) -> 'a list -> int option(* ------------------------------------------------------------------------- *) (*  Lists as Sets                                                            *) (* ------------------------------------------------------------------------- *) val gen_setify : ('a * 'a -> order) -> 'a list -> 'a listval setify : ''a list -> ''a listval gen_mem : ('a * 'b -> order) -> 'a -> 'b list -> boolval mem : ''a -> ''a list -> boolval insert : ''a -> ''a list -> ''a listval gen_disjoint : ('a * 'b -> order) -> 'a list -> 'b list -> boolval disjoint : ''a list -> ''a list -> boolval gen_pairwise_disjoint : ('a * 'a -> order) -> 'a list list -> boolval pairwise_disjoint : ''a list list -> boolval gen_set_eq : ('a * 'a -> order) -> 'a list -> 'a list -> boolval diff : ''a list -> ''a list -> ''a listval union : ''a list -> ''a list -> ''a listval unions : ''a list list -> ''a listval intersect : ''a list -> ''a list -> ''a listval subtract : ''a list -> ''a list -> ''a listval subset : ''a list -> ''a list -> boolval set_eq : ''a list -> ''a list -> bool(* ------------------------------------------------------------------------- *) (*  Assoc lists                                                              *) (* ------------------------------------------------------------------------- *) val find : ('a -> bool) -> 'a list -> 'a optionval assoc : ''a -> ''a * 'b list -> 'b optionval rev_assoc : ''a -> 'b * ''a list -> 'b option(* -------------------------------------------------------------------------- *) (*  Printing                                                                  *) (* -------------------------------------------------------------------------- *) val printl : string -> unit(*   val bracket : string -> string *) (*   val separate : string -> string list -> string *)  end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module type PRINT = sig val exp_to_string : sgn -> exp -> stringval spine_to_string : sgn -> spine -> stringval sub_to_string : sgn -> sub -> stringval print_exp : sgn -> exp -> unitval print_spine : sgn -> spine -> unitval print_sub : sgn -> sub -> unit end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
Code parsed successfully: (** eager composition of substitutions, and eager application. *) module Typecheck = struct module EE = TypecheckEE (*   structure EL = TypecheckEL *)  (*   structure LE = TypecheckLE *)  (*   structure LL = TypecheckLL *)  end
Code parsed successfully: module TimersTIMERS = struct let centers : center list ref = ref [] let rec add_timer name  = let center = newCenter name in centers := ! centers @ [center]; center let checking = add_timer ("Checking      ") let eta_normal = add_timer ("Eta Normal    ") let printing = add_timer ("Printing      ") let translation = add_timer ("Translation   ") let total = sumCenter ("Total         ", ! centers) let time = time let rec reset ()  = app reset (! centers) let rec check ()  = (app (print o toString) (! centers); print (sumToString total)) let rec show ()  = (check (); reset ()) end
Code parsed successfully: module type TIMERS = sig (* Programming interface *) val checking : center(* redundant type-checking *) val eta_normal : center(* redundant type-checking *) val printing : center(* printing *) val translation : center(* printing *) val total : sum(* total time *) (* time center f x = y
     if f x = y and time of computing f x is added to center.
     If f x raises an exception, it is re-raised.
  *) val time : center -> ('a -> 'b) -> ('a -> 'b)(* External interface *) val reset : unit -> unit(* reset above centers *) val check : unit -> unit(* check timer values *) val show : unit -> unit(* check, then reset *)  end
('Error parsing code:', 'module type DEBUG = sig exception Assert of exn(* general *) val enable : unit -> unitval disable : unit -> unit(* assertions *) val enable_assertions : unit -> unitval disable_assertions : unit -> unitval assert : bool * exn -> unit(* raises Assert *) (* printing *) val enable_printing : unit -> unitval disable_printing : unit -> unitval print : string -> unit end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module TypecheckEL = struct module L = Lib module S = Syntax module Sig = SSignat module C = Context module D = Debug open S let rec check_exp sgn ctx (Uni Type) (Uni Kind)  = () | check_exp sgn ctx (Lam {body = M; _}) (Pi {var; arg = U; body = V; _})  = check_exp sgn (push ctx (var, U)) M V | check_exp sgn ctx (Root (Const con, S)) V  = (* pull some common code out of the following case *) let rec foc exp  = let U = focus sgn ctx S exp in if equiv_exp sgn U V then () else raise (Check "check_exp: exps not equivalent") in match lookup sgn con with Decl decl -> foc (exp decl) | Def def -> foc (exp def)(* why does this fail?*)  | Abbrev abbrev -> raise (Fail "check_exp: abbrev") | check_exp sgn ctx (Root (BVar i, S)) V  = (match lookup ctx (i - 1)(* DeBruijn indices start at 1 *)  with SOME (_, A) -> let U = focus sgn ctx S (apply_exp (Shift i) A) in if equiv_exp sgn U V then () else raise (Fail_exp2 ("check_exp: Root,BVar", U, V)) | NONE -> raise (Check ("focus: var out of bounds"))) | check_exp sgn ctx (Pi {var; arg = A1; body = A2; _}) (uni as Uni _)  = (check_exp sgn ctx A1 expType; check_exp sgn (push ctx (var, A1)) A2 uni) | check_exp _ _ _ _  = raise (Check "check: bad case")focus sgn ctx Nil (ty as Uni Type)  = ty | focus sgn ctx Nil (hd as Root (Const _, _))  = hd | focus sgn ctx (App (M, S)) (Pi {arg = A1; body = A2; _})  = (check_exp sgn ctx M A1; focus sgn ctx S (apply_exp (Dot (M, id_sub)) A2)) | focus _ _ S E  = raise (Fail_spine_exp ("focus: bad case", S, E))check sgn E1 E2  = check_exp sgn empty E1 E2(* -------------------------------------------------------------------------- *) (*  Substitutions                                                             *) (* -------------------------------------------------------------------------- *) apply_exp _ (uni as Uni _)  = uni | apply_exp sub (Pi {var; arg = U; depend; body = V})  = Pi {var = var; arg = apply_exp sub U; depend = depend; body = apply_exp (push_sub sub) V} | apply_exp sub (Lam {var; body = U})  = Lam {var = var; body = apply_exp (push_sub sub) U} | apply_exp sub (exp as Root (H, S))  = let S\' = apply_spine sub S in match H with Const _ -> Root (H, S\') | BVar i -> match apply_var sub i with RetVar j -> Root (BVar j, S\') | RetExp M -> reduce M S\'apply_spine sub Nil  = Nil | apply_spine sub (App (M, S))  = App (apply_exp sub M, apply_spine sub S)apply_var (Dot (M, sub)) i  = if i = 1 then match M with Root (BVar j, Nil) -> RetVar j | _ -> RetExp M else apply_var sub (i - 1) | apply_var (Shift n) i  = RetVar (i + n) | apply_var (Comp (s1, s2)) i  = match apply_var s1 i with RetVar j -> apply_var s2 j | RetExp M -> RetExp (apply_exp s2 M)compose s1 s2  = Comp (s1, s2)push_sub s  = Dot (one, compose s shift)(* -------------------------------------------------------------------------- *) (*  Beta                                                                      *) (* -------------------------------------------------------------------------- *) reduce (exp as Root (_, _)) Nil  = exp | reduce (Lam {body = M; _}) (App (M\', S))  = reduce (apply_exp (Dot (M\', id_sub)) M) S | reduce E S  = raise (Fail_exp_spine ("reduce: bad case: head: ", E, S))(* -------------------------------------------------------------------------- *) (*  Equivalence wrt Definitions                                               *) (* -------------------------------------------------------------------------- *) equiv_exp sgn (Uni u1) (Uni u2)  = u1 = u2 | equiv_exp sgn (Pi {arg = U1; body = V1; _}) (Pi {arg = U2; body = V2; _})  = equiv_exp sgn U1 U2 && equiv_exp sgn V1 V2 | equiv_exp sgn (Lam {body = U; _}) (Lam {body = U\'; _})  = equiv_exp sgn U U\' | equiv_exp sgn (Root (BVar i, S1)) (Root (BVar i\', S2))  = i = i\' && equiv_spine sgn S1 S2 | equiv_exp sgn (exp as Root (Const c, S)) (exp\' as Root (Const c\', S\'))  = if c = c\' then equiv_spine sgn S S\' else (match (lookup sgn c, lookup sgn c\') with (Decl decl, Def def) -> if root def <> id decl then false else equiv_exp sgn exp (reduce (def def) S\') | (Def def, Decl decl) -> if root def <> id decl then false else equiv_exp sgn (reduce (def def) S) exp\' | (Abbrev {def; _}, _) -> equiv_exp sgn (reduce def S) exp\' | (_, Abbrev {def; _}) -> equiv_exp sgn exp (reduce def S\') | (Def {def = def; height = h; root = rc; _}, Def {def = def\'; height = h\'; root = rc\'; _}) -> if rc <> rc\' then false else if h = h\' then equiv_exp sgn (reduce def S) (reduce def\' S\') else if h > h\' then equiv_exp sgn (reduce def S) exp\' else equiv_exp sgn exp (reduce def\' S\') | (_, _) -> raise (Check "equiv_exp: bad case")) | equiv_exp _ _ _  = falseequiv_spine sgn Nil Nil  = true | equiv_spine sgn (App (E, S)) (App (E\', S\'))  = equiv_exp sgn E E\' && equiv_spine sgn S S\' | equiv_spine _ _ _  = false (* -------------------------------------------------------------------------- *)  (*  Signatures                                                                *)  (* -------------------------------------------------------------------------- *)  let rec check_dec (c, Decl {id; name; exp; uni})  = let uni\' = Uni uni let exp\' = eta_expand (exp, uni\') in check exp\' uni\'; insert (id, Decl {id = id; name = name; exp = exp\'; uni = uni}) | check_dec (c, Def {id; name; exp; def; height; root; uni})  = let uni\' = Uni uni let exp\' = eta_expand (exp, uni\') let def\' = eta_expand (def, exp\') in check exp\' uni\'; check def\' exp\'; insert (id, Def {id = id; name = name; exp = exp\'; def = def\'; height = height; root = root; uni = uni}) | check_dec (c, Abbrev {id; name; exp; def; uni})  = (*         val exp\' = eta_expand(exp,uni\') *) (*         val def\' = eta_expand(def,exp\') *) let uni\' = Uni uni let exp\' = exp let def\' = def in check exp\' uni\'; check def\' exp\'; insert (id, Abbrev {id = id; name = name; exp = exp\'; def = def\'; uni = uni}) let rec check_signat\' decs  = app (fun (decl as (c, dec)) -> ((* L.printl ("checking: " ^ name dec ); *) check_dec decl)) decs let rec check_signat decs  = (time checking check_signat\') decs let rec check_signat_clear decs  = (reset (); check_signat decs) end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {})])
Code parsed successfully: module DebugDEBUG = struct exception Assert of exn let assert' = ref true let print' = ref true let rec enable ()  = (assert' := true; print' := true) let rec disable ()  = (assert' := true; print' := true) let rec enable_assertions ()  = assert' := true let rec disable_assertions ()  = assert' := false let rec enable_printing ()  = print' := true let rec disable_printing ()  = print' := false let rec assert (c, exn)  = if ! assert' then if c then () else raise (Assert exn) else () let rec print s  = if ! print' then print (s ^ "\n") else () end
('Error parsing code:', "module type CONTEXT = sig type 'actxexception Context of stringval empty : 'a ctxval lookup : 'a ctx * int -> 'a optionval push : 'a ctx * 'a -> 'a ctxval list : 'a ctx -> 'a list end", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', 'module type SYNTAX = sig type const = inttype uniTypeKindtype headConstconstBVarinttype dependNoMaybetype expUniuniPipiLamlamRoothead * spineRedexexp * spineECloexp * sub and spineNilAppexp * spineSClospine * sub and subDotexp * subShiftintCompsub * sub and type decl = {id: const; name: string; exp: exp; uni: uni}type def = {id: const; name: string; exp: exp; def: exp; height: int; root: const; uni: uni}type abbrev = {id: const; name: string; exp: exp; def: exp; uni: uni}type decDecldeclDefdefAbbrevabbrevmodule Signat : sig type signat(** Lookup. *) val lookup : const -> dec(** Insert. *) val insert : const * dec -> unit(** number of constants *) val size : unit -> int(** iterate a function over the signat *) val app : (const * dec -> unit) -> unit(** clear the signature*) val reset : unit -> unit end(* -------------------------------------------------------------------------- *) (*  Exceptions                                                                *) (* -------------------------------------------------------------------------- *) exception Fail_exp of string * expexception Fail_exp2 of string * exp * expexception Fail_exp_spine of string * exp * spineexception Fail_spine_exp of string * spine * expexception Fail_hd_spine of string * head * spineexception Fail_sub_exp of string * sub * exp(** Eta expand an expression against a type.  \n      Assumes the expressions are already beta-normal. *) val eta_expand : (exp * exp) -> exp(* -------------------------------------------------------------------------- *) (*  Util                                                                      *) (* -------------------------------------------------------------------------- *) val expType : expval expKind : expval bvar : int -> expval one : expval shift : subval id_sub : subval id : dec -> constval name : dec -> stringval exp : dec -> expval is_def : const -> boolval def : const -> exp end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(** \n   A signature should only contain well-typed LF expressions.\n   Thus, we check them before doing an insert.  To avoid copying\n   the signature code, we instead use a phantom type.\n   (See the paper "Phantom Types and Subtyping" by Fluet and Pucella)\n*) module type SIGNAT = sig type \'phantomsgnval empty : unit -> \'phantom sgnval insert : \'phantom sgn -> const * dec -> \'phantom sgnval lookup : \'phantom sgn -> const -> dec(** number of key/value pairs *) val size : \'phantom sgn -> int end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "module type TYPECHECK = sig (** \n     Given a list of const, dec pairs, check_signat typechecks\n     the dec against the decs it's seen so far and installs them\n     in the global signature.\n   *) val check_signat : const * dec list -> unitval check_signat_clear : const * dec list -> unit end", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', 'module LibLIB = struct   exception Not_implemented (* ------------------------------------------------------------------------- *)  (*  Booleans                                                                 *)  (* ------------------------------------------------------------------------- *)  let rec andalso\' x y  = x && y let rec orelse\' x y  = x || y (* ---------------------------------------------------------------------- *)  (*  Pairs                                                                 *)  (* ---------------------------------------------------------------------- *)  let rec fst (x, y)  = x let rec snd (x, y)  = y (* -------------------------------------------------------------------------- *)  (*  Options                                                                   *)  (* -------------------------------------------------------------------------- *)  let rec is_none NONE  = true | is_none (SOME _)  = false let rec is_some NONE  = false | is_some (SOME _)  = true let rec the NONE  = raise (Fail "the") | the (SOME x)  = x (* ------------------------------------------------------------------------- *)  (*  Refs                                                                     *)  (* ------------------------------------------------------------------------- *)  let rec x += n  = x := (! x) + n let rec x -= n  = x := (! x) - n let rec incr x  = x += 1 let rec decr x  = x -= 1 let rec l ::= v  = l := v :: (! l) let rec l @= l\'  = l := (! l) @ l\' (* -------------------------------------------------------------------------- *)  (*  Streams                                                                   *)  (* -------------------------------------------------------------------------- *)  type stream = SNil | SCons of unit -> \'a * \'a stream let rec constant_s x  = SCons (fun () -> (x, (constant_s x))) let rec ones_f n  = SCons (fun () -> (n, (ones_f (n + 1)))) let nat_s = ones_f 0 let rec nth_s n SNil  = raise (Fail "s_nth") | nth_s 0 (SCons f)  = fst (f ()) | nth_s n (SCons f)  = let (_, s\') = f () in nth_s (n - 1) s\' let rec listof_s 0 _  = [] | listof_s n SNil  = raise (Fail "listof_s") | listof_s n (SCons f)  = let (v, s) = f () in v :: listof_s (n - 1) s (* ---------------------------------------------------------------------- *)  (*  Functions                                                             *)  (* ---------------------------------------------------------------------- *)  let rec curry f x y  = f (x, y) let rec uncurry f (x, y)  = f x y let rec curry3 f x y z  = f (x, y, z) let rec id x  = x let rec can f x  = try  with let rec cant f x  = try  with let rec can2 f x y  = try  with let rec ceq x y  = x = y let rec  f oo g  x y  = f (g x y) let rec  f ooo g  x y z  = f (g x y z) let rec  f oooo g  x y z w  = f (g x y z w) let rec swap f x y  = f y x let rec apply (f, x)  = f x let rec repeat f n x  = if n = 0 then x else repeat f (n - 1) (f x) (* -------------------------------------------------------------------------- *)  (*  Ints                                                                      *)  (* -------------------------------------------------------------------------- *)  let rec max xs  = foldr max 0 xs let rec sum ns  = foldr + 0 ns let rec uptoby k m n  = if m > n then [] else m :: (uptoby k (m + k) n) let upto = uncurry (uptoby 1) let -- = upto  let rec x --< y  = x -- (y - 1) let rec pow x n  = match n with 0 -> 1 | n -> if mod (n, 2) = 0 then let n\' = pow x (div (n, 2)) in n\' * n\' else x * pow x (n - 1) let rec log n  = let rec log n even  = match n with 1 -> (0, even) | n -> let (ln, even\') = log (div (n, 2)) even let even\'\' = even\' && (mod (n, 2) = 0) in (1 + ln, even\'\') in log n true (* -------------------------------------------------------------------------- *)  (*  Reals                                                                     *)  (* -------------------------------------------------------------------------- *)  let rec real_max xs  = foldr max 0.0 xs let rec real_sum rs  = foldr + 0.0 rs (* ------------------------------------------------------------------------- *)  (*  Order                                                                    *)  (* ------------------------------------------------------------------------- *)  let rec string_ord (s1 : string, s2)  = if s1 < s2 then LESS else if s1 = s2 then EQUAL else GREATER let rec int_ord (s1 : int, s2)  = if s1 < s2 then LESS else if s1 = s2 then EQUAL else GREATER let rec lex_ord o1 o2 ((x1, y1), (x2, y2))  = match o1 (x1, x2) with EQUAL -> o2 (y1, y2) | x -> x let rec eq_ord (x, y)  = if x = y then EQUAL else LESS (* ---------------------------------------------------------------------- *)  (*  Debug                                                                 *)  (* ---------------------------------------------------------------------- *)  let rec assert b s  = if b then () else raise (Fail ("Assertion Failure: " ^ s)) let warn = ref true let rec warning s  = if ! warn then print ("Warning: " ^ s ^ "\\n") else () (* ---------------------------------------------------------------------- *)  (*  Lists                                                                 *)  (* ---------------------------------------------------------------------- *)  let rec list x  = [x] let rec cons x xs  = x :: xs (* same as foldr *)  let rec itlist f [] b  = b | itlist f (h :: t) b  = f h (itlist f t b) let rec citlist f l b  = itlist (curry f) l b let rec ith i []  = raise (Fail "ith: empty") | ith 0 (h :: t)  = h | ith n (h :: t)  = ith (n - 1) t let rec map2 f [] []  = [] | map2 f (h1 :: t1) (h2 :: t2)  = f (h1, h2) :: map2 f t1 t2 | map2 f _ _  = raise (Fail "map2: length mismatch") let rec map3 f [] [] []  = [] | map3 f (h1 :: t1) (h2 :: t2) (h3 :: t3)  = f (h1, h2, h3) :: map3 f t1 t2 t3 | map3 f _ _ _  = raise (Fail "map3: unequal lengths") let rec map4 f [] [] [] []  = [] | map4 f (h1 :: t1) (h2 :: t2) (h3 :: t3) (h4 :: t4)  = f (h1, h2, h3, h4) :: map4 f t1 t2 t3 t4 | map4 f _ _ _ _  = raise (Fail "map4: unequal lengths") let rec map5 f [] [] [] [] []  = [] | map5 f (h1 :: t1) (h2 :: t2) (h3 :: t3) (h4 :: t4) (h5 :: t5)  = f (h1, h2, h3, h4, h5) :: map5 f t1 t2 t3 t4 t5 | map5 f _ _ _ _ _  = raise (Fail "map5: unequal lengths") let rec zip l1 l2  = map2 id l1 l2 let rec zip3 l1 l2 l3  = map3 id l1 l2 l3 let rec zip4 l1 l2 l3 l4  = map4 id l1 l2 l3 l4 let rec zip5 l1 l2 l3 l4 l5  = map5 id l1 l2 l3 l4 l5 let rec unzip l  = itlist (fun (h1, h2) -> fun (t1, t2) -> (h1 :: t1, h2 :: t2)) l ([], []) let rec unzip3 l  = itlist (fun (h1, h2, h3) -> fun (t1, t2, t3) -> (h1 :: t1, h2 :: t2, h3 :: t3)) l ([], [], []) let rec unzip4 l  = itlist (fun (h1, h2, h3, h4) -> fun (t1, t2, t3, t4) -> (h1 :: t1, h2 :: t2, h3 :: t3, h4 :: t4)) l ([], [], [], []) let rec x ~~ y  = zip x y let rec end_itlist f []  = raise (Fail "end_itlist") | end_itlist f [x]  = x | end_itlist f (h :: t)  = f h (end_itlist f t) let rec end_citlist f l  = end_itlist (curry f) l let rec itlist2 f [] [] b  = b | itlist2 f (h1 :: t1) (h2 :: t2) b  = f h1 h2 (itlist2 f t1 t2 b) | itlist2 _ _ _ _  = raise (Fail "itlist2") (* same as foldl *)  let rec rev_itlist f [] b  = b | rev_itlist f (h :: t) b  = rev_itlist f t (f h b) let rec rev_end_itlist f []  = raise (Fail "rev_end_itlist") | rev_end_itlist f [x]  = x | rev_end_itlist f (h :: t)  = f (rev_end_itlist f t) h let rec replicate x 0  = [] | replicate x n  = if n > 0 then x :: replicate x (n - 1) else [] let rec exists f []  = false | exists f (h :: t)  = f h || exists f t let rec forall f []  = true | forall f (h :: t)  = f h && forall f t let rec last []  = raise (Fail "Last") | last (h :: [])  = h | last (h :: t)  = last t let rec butlast []  = raise (Fail "Butlast") | butlast (h :: [])  = [] | butlast (h :: t)  = h :: butlast t let rec gen_list_eq ord l1 l2  = itlist2 (fun x -> fun y -> fun z -> ord (x, y) = EQUAL && z) l1 l2 true let rec list_eq l1 l2  = gen_list_eq eq_ord l1 l2 let rec partition p []  = ([], []) | partition p (h :: t)  = let (l, r) = partition p t in if p h then (h :: l, r) else (l, h :: r) let rec filter p l  = fst (partition p l) let rec sort ord []  = [] | sort ord (piv :: rest)  = let (l, r) = partition (fun x -> ord (x, piv) = LESS) rest in (sort ord l) @ (piv :: (sort ord r)) let rec uniq ord (x :: (t as y :: _))  = let t\' = uniq ord t in if ord (x, y) = EQUAL then t\' else x :: t\' | uniq _ l  = l let rec uniq_list comp l  = length (uniq comp l) = length l let rec split_at _ []  = raise (Fail "split_at: splitting empty") | split_at 0 l  = ([], l) | split_at n (xs as x :: ys)  = if n < 0 then raise (Fail "split_at: arg out of range") else let (ps, qs) = split_at (n - 1) ys in (x :: ps, qs) let rec list_prefix n l  = try  with let rec list_slice n m l  = let (_, r) = split_at n l let (l\', _) = split_at m r in l\' let rec shuffle [] l2  = l2 | shuffle l1 []  = l1 | shuffle (h1 :: t1) (h2 :: t2)  = h1 :: h2 :: shuffle t1 t2 let rec find_index p  = let rec ind n []  = NONE | ind n (h :: t)  = if p h then SOME n else ind (n + 1) t in ind 0 let rec index x l  = find_index (ceq x) l let rec find_last_index p l  = let n = length l let l\' = rev l in match find_index p l\' with SOME n\' -> SOME (n - n\' - 1) | NONE -> NONE let rec last_index x l  = find_last_index (ceq x) l let rec flatten l  = itlist (curry @) l [] let rec chop_list 0 l  = ([], l) | chop_list n l  = try  with let rec list_to_string f l  = let l\' = map f l in itlist (fun x -> fun y -> x ^ "," ^ y) ("[" :: l\' @ ["]"]) "" let rec remove p []  = raise (Fail "remove") | remove p (h :: t)  = if p h then (h, t) else let (y, n) = remove p t in (y, h :: n) let rec do_list f []  = () | do_list f (h :: t)  = (f h; do_list f t) let rec exn_index f l  = let rec exn_index f [] n  = NONE | exn_index f (h :: t) n  = if can f h then exn_index f t (n + 1) else SOME n in exn_index f l 0 (* ------------------------------------------------------------------------- *)  (*  Lists as Sets                                                            *)  (* ------------------------------------------------------------------------- *)  let rec gen_setify ord s  = uniq ord (sort ord s) let rec setify s  = gen_setify eq_ord s let rec gen_mem ord x []  = false | gen_mem ord x (h :: t)  = if ord (x, h) = EQUAL then true else gen_mem ord x t let rec mem x l  = gen_mem eq_ord x l let rec insert x l  = if mem x l then l else x :: l let rec gen_disjoint ord l1 l2  = forall (fun x -> not (gen_mem ord x l2)) l1 let rec disjoint l  = gen_disjoint eq_ord l let rec gen_pairwise_disjoint p []  = true | gen_pairwise_disjoint p (h :: t)  = forall (gen_disjoint p h) t && gen_pairwise_disjoint p t let rec pairwise_disjoint t  = gen_pairwise_disjoint eq_ord t let rec gen_set_eq ord l1 l2  = gen_list_eq ord (gen_setify ord l1) (gen_setify ord l2) let rec diff [] l  = [] | diff (h :: t) l  = if mem h l then diff t l else h :: diff t l let rec union l1 l2  = itlist insert l1 l2 let rec unions l  = itlist union l [] let rec intersect l1 l2  = filter (fun x -> mem x l2) l1 let rec subtract l1 l2  = filter (fun x -> not (mem x l2)) l1 let rec subset l1 l2  = forall (fun t -> mem t l2) l1 let rec set_eq l1 l2  = subset l1 l2 && subset l2 l1 (* ------------------------------------------------------------------------- *)  (*  Assoc lists                                                              *)  (* ------------------------------------------------------------------------- *)  let rec find p []  = NONE | find p (h :: t)  = if p h then SOME h else find p t let rec assoc x l  = match find (fun p -> fst p = x) l with SOME (x, y) -> SOME y | NONE -> NONE let rec rev_assoc x l  = match find (fun p -> snd p = x) l with SOME (x, y) -> SOME x | NONE -> NONE (* ------------------------------------------------------------------------- *)  (*  Strings                                                                  *)  (* ------------------------------------------------------------------------- *)  let rec char_max c1 c2  = if ord c1 < ord c2 then c1 else c2 let rec string_lt (x : string) y  = x < y let rec collect l  = itlist (curry ^) l "" let rec commas n  = replicate "," n let rec shuffle_commas l  = shuffle l (commas (length l - 1)) let rec semis n  = replicate ";" n let rec parenify x  = collect ["("; x; ")"] let rec postfix n s  = substring (s, size s - n, n) let numeric_chars = "0123456789" let lowercase_chars = "abcdefghijklmnopqrstuvwxyz" let uppercase_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" let alpha_chars = lowercase_chars ^ uppercase_chars let alphanum_chars = alpha_chars ^ numeric_chars let word_sym_chars = "_\'" let word_chars = alphanum_chars ^ word_sym_chars let explode = explode let rec is_legal u s  = forall (fun x -> mem x (explode u)) (explode s) let is_numeric = is_legal numeric_chars let is_lower = is_legal lowercase_chars let is_upper = is_legal uppercase_chars let is_alpha = is_legal alpha_chars let is_alnum = is_legal alphanum_chars let is_word_sym = is_legal word_sym_chars let is_word = is_legal word_chars  let to_lower = translate (toString o toLower) let to_upper = translate (toString o toUpper) let rec capitalize s  = match map toString (explode s) with [] -> "" | h :: t -> concat ([to_upper h] @ (map to_lower t)) let newline = toString \'\\n\' let rec ends_with s e  = try  with let rec starts_with s e  = try  with (* abc.def.ghi -> (abc,def.ghi) *)  let rec strip_path c s  = let n = match index c (explode s) with SOME x -> x | NONE -> raise (Fail "strip_path") let m = substring (s, 0, n) let m\' = substring (s, n + 1, size s - n - 1) in (m, m\') (* abc.def.ghi -> (abc.def,ghi) *)  let rec rev_strip_path c s  = let no = last_index c (explode s) let n = match no with SOME x -> x | NONE -> raise (Fail "rev_strip_path") let m = substring (s, 0, n) let m\' = substring (s, n + 1, size s - n - 1) in (m, m\') (* ------------------------------------------------------------------------- *)  (*  Options                                                                  *)  (* ------------------------------------------------------------------------- *)  let rec the (SOME x)  = x | the _  = raise (Fail "the") let rec is_some (SOME _)  = true | is_some _  = false let rec is_none NONE  = true | is_none _  = false let rec list_of_opt_list []  = [] | list_of_opt_list (NONE :: t)  = list_of_opt_list t | list_of_opt_list (SOME x :: t)  = x :: list_of_opt_list t let rec get_opt (SOME x) _  = x | get_opt NONE err  = raise (Fail err) let rec get_list (SOME l)  = l | get_list NONE  = [] let rec conv_opt f (SOME l)  = SOME (f l) | conv_opt f NONE  = NONE (* ------------------------------------------------------------------------- *)  (*  Timing                                                                   *)  (* ------------------------------------------------------------------------- *)  let rec time f x  = let timer = startCPUTimer () in try  with (* ------------------------------------------------------------------------- *)  (*  IO                                                                       *)  (* ------------------------------------------------------------------------- *)  let rec printl s  = print (s ^ "\\n") let rec read_file file  = let f = openIn file let s = inputAll f let _ = closeIn f in s let rec write_file file s  = let f = openOut file let _ = output (f, s) let _ = closeOut f in () let rec write_file_append file s  = let f = openAppend file let _ = output (f, s) let _ = closeOut f in () let rec all_dir_files dir  = let str = openDir dir let fs = ref [] let f = ref (readDir str) in (while ! f <> NONE do (fs ::= the (! f); f := readDir str) done); ! fs end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(** \n A tabular data structure.\n *) module type TABLE = sig type keytype 'atable(** Give the expected size of the eventual table. \n      Some implementations may grow outside that initial\n      bound if necessary.  Others may raise an exception.\n   *) val table : int -> 'a table(** Insert a key/value pair into the table.  \n      Raise Fail if key is already present. *) val insert : 'a table -> key * 'a -> 'a table(** Lookup a key in the table. Raise Fail if key not present *) val lookup : 'a table -> key -> 'a(** number of key/value pairs *) val size : 'a table -> int(** Iterate a procedure over the table. *) val app : ('a -> unit) -> 'a table -> unit(** Iterate a procedure over the table. *) val appi : (int * 'a -> unit) -> 'a table -> unit(** Clear the table. *) val clear : 'a table -> unit end", 'Error matches:', [(0, {})], 'Missing matches:', [])
('Error parsing code:', 'module TypecheckEETYPECHECK = struct module L = Lib module S = Syntax module Sig = SSignat module C = Context module D = Debug open S type ret = RetExp of exp | RetVar of int (** check a term (type)  against a type (kind) *)  let rec check_exp (ctx, Uni Type, Uni Kind)  = () | check_exp (ctx, Lam {body = M; _}, Pi {var; arg = U; body = V; _})  = check_exp (push (ctx, (var, U)), M, V) | check_exp (ctx, Root (Const con, S), V)  = (* pull some common code out of the following case *) let rec foc exp  = let U = focus (ctx, S, exp) in if equiv_exp (U, V) then () else raise (Fail "check_exp: exps not equivalent") in match lookup con with Decl decl -> foc (exp decl) | Def def -> foc (exp def)(* why does this fail?*)  | Abbrev abbrev -> raise (Fail "check_exp: abbrev") | check_exp (ctx, Root (BVar i, S), V)  = (match lookup (ctx, i - 1)(* DeBruijn indices start at 1 *)  with SOME (_, A) -> let U = focus (ctx, S, apply_exp (Shift i, A)) in if equiv_exp (U, V) then () else raise (Fail_exp2 ("check_exp: Root,BVar", U, V)) | NONE -> raise (Fail ("focus: var out of bounds"))) | check_exp (ctx, Pi {var; arg = A1; body = A2; _}, uni as Uni _)  = (check_exp (ctx, A1, expType); check_exp (push (ctx, (var, A1)), A2, uni)) | check_exp _  = raise (Fail "check: bad case")focus (ctx, Nil, ty as Uni Type)  = ty | focus (ctx, Nil, hd as Root (Const _, _))  = hd | focus (ctx, App (M, S), Pi {arg = A1; body = A2; _})  = (check_exp (ctx, M, A1); focus (ctx, S, apply_exp (Dot (M, id_sub), A2))) | focus (_, S, E)  = raise (Fail_spine_exp ("focus: bad case", S, E))check E1 E2  = (time checking check_exp) (empty, E1, E2)(* -------------------------------------------------------------------------- *) (*  Substitutions                                                             *) (* -------------------------------------------------------------------------- *) apply_exp (_, uni as Uni _)  = uni | apply_exp (sub, Pi {var; arg = U; depend; body = V})  = Pi {var = var; arg = apply_exp (sub, U); depend = depend; body = apply_exp (push_sub sub, V)} | apply_exp (sub, Lam {var; body = U})  = Lam {var = var; body = apply_exp (push_sub sub, U)} | apply_exp (sub, exp as Root (H, S))  = let S\' = apply_spine (sub, S) in match H with Const _ -> Root (H, S\') | BVar i -> match apply_var (sub, i) with RetVar j -> Root (BVar j, S\') | RetExp M -> reduce (M, S\')apply_spine (_, Nil)  = Nil | apply_spine (sub, App (M, S))  = App (apply_exp (sub, M), apply_spine (sub, S))apply_var (Dot (M, sub), i)  = if i = 1 then match M with Root (BVar j, Nil) -> RetVar j | _ -> RetExp M else apply_var (sub, i - 1) | apply_var (Shift n, i)  = RetVar (i + n)compose (Dot (M, sigma), sigma\')  = Dot (apply_exp (sigma\', M), compose (sigma, sigma\')) | compose (Shift n, Shift m)  = Shift (n + m) | compose (Shift 0, sigma)  = sigma | compose (Shift n, Dot (M, sigma))  = compose (Shift (n - 1), sigma)push_sub s  = Dot (one, compose (s, shift))(* -------------------------------------------------------------------------- *) (*  Beta                                                                      *) (* -------------------------------------------------------------------------- *) reduce (exp as Root (_, _), Nil)  = exp | reduce (Lam {body = M; _}, App (M\', S))  = reduce (apply_exp (Dot (M\', id_sub), M), S) | reduce (E, S)  = raise (Fail_exp_spine ("reduce: bad case: head: ", E, S))(* -------------------------------------------------------------------------- *) (*  Equivalence wrt Definitions                                               *) (* -------------------------------------------------------------------------- *) equiv_exp (Uni u1, Uni u2)  = u1 = u2 | equiv_exp (Pi {arg = U1; body = V1; _}, Pi {arg = U2; body = V2; _})  = equiv_exp (U1, U2) && equiv_exp (V1, V2) | equiv_exp (Lam {body = U; _}, Lam {body = U\'; _})  = equiv_exp (U, U\') | equiv_exp (Root (BVar i, S1), Root (BVar i\', S2))  = i = i\' && equiv_spine (S1, S2) | equiv_exp (exp as Root (Const c, S), exp\' as Root (Const c\', S\'))  = if c = c\' then equiv_spine (S, S\') else (match (lookup c, lookup c\') with (Decl decl, Def def) -> if root def <> id decl then false else equiv_exp (exp, reduce (def def, S\')) | (Def def, Decl decl) -> if root def <> id decl then false else equiv_exp (reduce (def def, S), exp\') | (Abbrev {def; _}, _) -> equiv_exp (reduce (def, S), exp\') | (_, Abbrev {def; _}) -> equiv_exp (exp, reduce (def, S\')) | (Def {def = def; height = h; root = rc; _}, Def {def = def\'; height = h\'; root = rc\'; _}) -> if rc <> rc\' then false else if h = h\' then equiv_exp (reduce (def, S), reduce (def\', S\')) else if h > h\' then equiv_exp (reduce (def, S), exp\') else equiv_exp (exp, reduce (def\', S\')) | (_, _) -> raise (Fail "equiv_exp: bad case")) | equiv_exp _  = falseequiv_spine (Nil, Nil)  = true | equiv_spine (App (E, S), App (E\', S\'))  = equiv_exp (E, E\') && equiv_spine (S, S\') | equiv_spine _  = false (* -------------------------------------------------------------------------- *)  (*  Signatures                                                                *)  (* -------------------------------------------------------------------------- *)  let rec check_dec (c, Decl {id; name; exp; uni})  = let uni\' = Uni uni let exp\' = eta_expand (exp, uni\') in check exp\' uni\'; insert (id, Decl {id = id; name = name; exp = exp\'; uni = uni}) | check_dec (c, Def {id; name; exp; def; height; root; uni})  = let uni\' = Uni uni let exp\' = eta_expand (exp, uni\') let def\' = eta_expand (def, exp\') in check exp\' uni\'; check def\' exp\'; insert (id, Def {id = id; name = name; exp = exp\'; def = def\'; height = height; root = root; uni = uni}) | check_dec (c, Abbrev {id; name; exp; def; uni})  = (*         val exp\' = eta_expand(exp,uni\') *) (*         val def\' = eta_expand(def,exp\') *) let uni\' = Uni uni let exp\' = exp let def\' = def in check exp\' uni\'; check def\' exp\'; insert (id, Abbrev {id = id; name = name; exp = exp\'; def = def\'; uni = uni}) let rec check_signat\' decs  = app (fun (decl as (c, dec)) -> ((* L.printl ("checking: " ^ name dec ); *) check_dec decl)) decs let rec check_signat decs  = (time checking check_signat\') decs let rec check_signat_clear decs  = (reset (); check_signat decs) end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {})])
('Error parsing code:', '(* -------------------------------------------------------------------------- *) (*  Printing                                                                  *) (* -------------------------------------------------------------------------- *) printDepth := 50\nprintLength := 1000\nstringDepth := 1000\n(* -------------------------------------------------------------------------- *) (*  Loading                                                                   *) (* -------------------------------------------------------------------------- *) make "sources.cm"\ndoubleCheck := true\nTwelf.Print.depth := SOME 0\nTwelf.Print.length := SOME 0\nTwelf.Timers.reset()let test = "../../../../test/"\nmake (test ^ "talt/sources-chk.cfg")\nmake (test ^ "talt/sources.cfg") make (test ^ "sml-sound/sources.cfg")\nmake (test ^ "princeton/sources.cfg")\nmake (test ^ "misc/sources.cfg")\nTwelf.Timers.check()\nTimers.reset()let signat = try  with \ntry  with \ntry  with \n(* -------------------------------------------------------------------------- *) (*  Debug                                                                     *) (* -------------------------------------------------------------------------- *) module D = Debug\nmodule L = Lib\nmodule T = TranslateEE\nmodule S = TypecheckEE\nmodule Sgn = SSgn\nmodule I = IntSyn\nmodule D = Debug\nmodule C = Context\ntranslate_signature sgnLookup 9 name n = (n, conDecName (sgnLookup n))\nlet rec get x (ConDec (x\', _, _, _, _, _))  = x = x\' | get _ _  = false\nlet (N, _) = sgnSize ()\nlet cs = map sgnLookup (upto (0, N - 1))\nlet n = N - 2\nlet ns = upto (0, n)\nlet cds = map sgnLookup ns\nlet cds\' = filter (fun (id, dec) -> can_translate dec) (zip ns cds)\nlet cds\'\' = map translate_condec cds\'\nlet rec fold_fun (dec, sgn)  = (print ("translating: " ^ conDecName (sgnLookup (id dec)) ^ "\\n"); insert sgn dec)\nlet sgn = foldl fold_fun (empty ()) cds\'\'\nlet t_val = sgnLookup 11let Decl s_val = lookup sgn 10let bug = Def {id = 11; name = "1+"; exp = tm_tm; def = Lam {var = NONE; body = Root (Const 4, App (Root (BVar 1, Nil), Nil))}; height = 1; root = 4; uni = Type} eta_expand sgn (Lam {var = NONE; body = Root (Const 4, App (Root (BVar 1, Nil), Nil))})let rec insert sgn (Decl {id; name; exp; uni})  = let exp\' = eta_expand sgn exp in check sgn exp\' (Uni uni); insert sgn (id, Decl {id = id; name = name; exp = exp\'; uni = uni}) | insert sgn (Def {id; name; exp; def; height; root; uni})  = let exp\' = eta_expand sgn exp let def\' = eta_expand sgn def in check sgn exp\' (Uni uni); check sgn def\' exp\'; insert sgn (id, Def {id = id; name = name; exp = exp\'; def = def\'; height = height; root = root; uni = uni}) | insert sgn (Abbrev {id; name; exp; def; uni})  = let exp\' = eta_expand sgn exp let def\' = eta_expand sgn def in check sgn exp\' (Uni uni); check sgn def\' exp\'; insert sgn (id, Abbrev {id = id; name = name; exp = exp\'; def = def\'; uni = uni}) print_exp sgn t_val print_exp sgn (exp s_val) - PI (PI (PI tm) . tm) . PI (tm - eq ^ (1 ^ (f ^ 1) 1 ^ (f ^ 1))). \n      typeopen Slet f = Const 4let tm_eqi = Const 8let test6 = Const 9let tm = Const 0let tm_eq = Const 6let tm_exp = Root (tm, Nil)let tm_tm = Pi {var = NONE; arg = tm_exp; depend = No; body = tm_exp}let tm_tm_tm = Pi {var = NONE; arg = tm_tm; depend = No; body = tm_exp}let tp = expTypelet one = Root (BVar 1, Nil)let two = Root (BVar 2, Nil)let f1 = Root (f, App (one, Nil))let lam_f1 = Lam {var = NONE; body = f1}let one_lam_f1 = Root (BVar 1, App (lam_f1, Nil))let two_one = Root (BVar 2, App (one, Nil))let lam_21 = Lam {var = NONE; body = two_one}let tm_eqi_1_lam_f1 = Root (tm_eqi, App (one_lam_f1, Nil))let spine0 = App (tm_eqi_1_lam_f1, Nil)let spine1 = App (lam_21, spine0)let test6_args = Root (test6, spine1)let spine2 = App (one_lam_f1, App (one_lam_f1, Nil))let tm_eq_args = Root (tm_eq, spine2)let pi_tm_eq = Pi {var = NONE; arg = tm_eq_args; depend = No; body = tp}let pi_tm_tm_tm = Pi {var = NONE; arg = tm_tm_tm; depend = No; body = pi_tm_eq}let one_sp = App (one, Nil)let ctx = push empty (NONE : string option, tm_tm_tm)let ctx\' = push ctx (NONE : string option, tm_tm) check_exp sgn ctx test6_args tp focus sgn ctx spine1 pi_tm_tm_tm check_exp sgn ctx lam_21 tm_tm_tmlet sub1 = (Dot (lam_21, id_sub)) focus sgn ctx spine0 (apply_exp sub1 pi_tm_eq) apply_exp sub1 tm_eq_args print_exp sgn tm_eq_args apply_spine sub1 spine2 print_spine sgn spine2 apply_exp sub1 one_lam_f1 apply_spine sub1 Nillet RetExp tmp = apply_var sub1 1 print_exp sgn tmp print_exp sgn one_lam_f1 print_sub sgn sub1 and focus sgn ctx Nil E= E | focus sgn ctx (App (M, S)) (Pi {arg = A1; body = A2; _})=\n      (check_exp sgn ctx M A1;\n       focus sgn ctx S (apply_exp (Dot(M,id_sub)) A2)) | focus _ _ S E = raise (Fail_spine_exp ("focus: bad case", S, E) focus sgn ctx\' one tm_tm_tm check_exp sgn ctx\' two_one tm_exp focus sgn ctx\' one_sp tm_tm_tm check_exp sgn ctx\' one tm_tm focus sgn ctx\' Nil tm_tm print (exp_to_string sgn tm_tm_tm))let tbug = the (find (get "bug") cs)\nlet Decl sbug = translate_condec (~1, tbug)\nlet decl = sbug\ncheck sgn (#exp decl) (Uni (#uni decl))let (U1, V1) = (exp decl, Uni (uni decl))let ctx = empty check_exp sgn empty U1 V1let (Pi {var; arg = A1; body = A2; _}, uni as Uni _) = (U1, V1)let ctx = (push ctx (var, A1))let (Root (Const con, S), V) = (A2, uni)let rec foc exp  = let U = focus sgn ctx S exp in if equiv_exp sgn U V then () else raise (Fail_exp2 ("check_exp:0", U, V))inlet Decl decl = Sig.lookup sgn con\nfoc (#exp decl)match lookup sgn con with Decl decl -> foc (exp decl) | Def def -> foc (exp def) | Abbrev abbrev -> raise (Fail "check_exp:1")endlet exp = exp decllet it = ("focus: bad case", Nil, Pi {arg = Root (Const 0, Nil); body = Root (Const 0, Nil); depend = No; var = NONE}) : string * spine * exp (* -------------------------------------------------------------------------- *) (*  Timing                                                                    *) (* -------------------------------------------------------------------------- *) reset ()depth := SOME 0length := SOME 0depth := NONE length := NONE show ()\n(translate_signature()\nraise (Success )\n\nval center = newCenter "checker" disable_printing () time center translate_signature () 1)\nTiming.toString center\n\n(* ========================================================================== *)\n(*  Junk                                                                      *)\n(* ========================================================================== *)\n\n\nDebug.disable_printing()\nDebug.enable_printing()\nval sgn =let it = ("focus: bad case", Nil, Pi {arg = Root (Const 212, Nil); body = Root (Const 212, Nil); depend = No; var = NONE}) : string * spine * exp -let it = (211, "etp") : cid * string -let it = (212, "eterm") : cid * string -let it = (541, "eterm-eq/i") : cid * string -let it = (543, "etp-eq/i") : cid * string -let it = (591, "eterm-resp-bind") : cid * stringlet hsp = try  with \n\n\nhandle Translate.Trans1 x => x\n     | Translate.Fail3 x => xlet s = array sgn\n(* -------------------------------------------------------------------------- *) (*  Debug                                                                     *) (* -------------------------------------------------------------------------- *) let tbug = the (find (get "bug") cds\')let Decl sbug = translate_condec (432, tbug)let decl = sbug enable_printing ()let hsp = try  with let (ctx, E1, E2) = (empty, exp decl, Uni (uni decl)) check_exp sgn empty E1 E2let rec check sgn E1 E2  = check_exp sgn empty E1 E2 name 211 name 212 name 541 name 543 name 591 check printDepth := 40 name 85 name 90 name 431 name 2 name 42module C = ClausePrintmodule Ctx = Contextlet sgn = emptylet dec0 = translate_condec (0, (ith 0 cs))let sgn0 = insert sgn dec0let dec1 = translate_condec (1, (ith 1 cs))let sgn1 = insert sgn0 dec1let dec2 = translate_condec (2, (ith 2 cs))let sgn2 = insert sgn1 dec2let dec3 = translate_condec (3, (ith 3 cs))let sgn3 = insert sgn2 dec3let dec4 = translate_condec (4, (ith 4 cs))let sgn4 = try  with open Slet tm = (ExpLam (ExpApp (HdConst 3, SpCons (ExpApp (HdVar 1, SpNil), SpCons (ExpApp (HdVar 1, SpNil), SpCons (ExpLam (ExpApp (HdVar 1, SpNil)), SpNil))))))let ty = ExpPi (ExpApp (HdConst 0, SpNil), ExpApp (HdConst 2, SpCons (ExpApp (HdConst 1, SpCons (ExpApp (HdVar 1, SpNil), SpCons (ExpApp (HdVar 1, SpNil), SpNil))), SpNil)))exception Success(* -------------------------------------------------------------------------- *) let ctx = emptylet sgn = sgn3let M = tmlet A = ty(* -------------------------------------------------------------------------- *) let (ExpLam M, ExpPi (A1, A2)) = (M, A)let ctx = try  with (* -------------------------------------------------------------------------- *) let ExpApp (HdConst con, S) = Mlet SOME (Dec decl) = try  with (* -------------------------------------------------------------------------- *) let A = exp decllet (SpCons (M, S), ExpPi (A1, A2)) = try  with (* -------------------------------------------------------------------------- *) let A = (apply_exp (SubCons (M, SubId)) A2)let (SpCons (M, S), ExpPi (A1, A2)) = try  with (* -------------------------------------------------------------------------- *) let A = (apply_exp (SubCons (M, SubId)) A2)let (SpCons (M, S), ExpPi (A1, A2)) = try  with let tm1 = ExpLam (ExpApp (HdVar 1, SpNil))let ty1 = ExpPi (ExpApp (HdConst 3, SpCons (ExpApp (HdVar 1, SpNil), SpNil)), ExpApp (HdConst 3, SpCons (ExpApp (HdVar 2, SpNil), SpNil)))let (ExpLam M, ExpPi (A1, A2)) = (tm1, ty1) check\' sgn (push ctx A1) M A2let (ExpApp (HdVar i, S)) = Mlet SOME A = lookup ctx (i - 1) focus sgn (push ctx A1) S A A2 check\' sgn ctx tm1 ty1(* -------------------------------------------------------------------------- *) let A = A2let (SpCons (M, S), ExpPi (A1, A2)) = try  with let (ExpApp (HdConst con, S)) = Mlet SOME (Dec decl) = try  with \nexception Success\ntry  with \ntranslate_signature ()\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* Copyright (C) 1999-2002 Henry Cejtin, Matthew Fluet, Suresh\n *    Jagannathan, and Stephen Weeks.\n *\n * MLton is released under the GNU General Public License (GPL).\n * Please see the file MLton-LICENSE for license information.\n *) module LayoutLAYOUT = struct (*    structure Out = Outstream0   *)  let detailed = ref false let rec switch {detailed = d; normal = n} x  = if ! detailed then d x else n x type t = T of {length: int; tree: tree} and tree = Empty | String of string | Sequence of t list | Align of {force: bool; rows: t list} | Indent of t * int type layout = t let rec length (T {length; _})  = length let empty = T {length = 0; tree = Empty} let rec isEmpty (T {length = 0; _})  = true | isEmpty _  = false let rec str s  = match s with "" -> empty | _ -> T {length = size s; tree = String s} let rec fold (l, b, f)  = foldl f b l let rec seq ts  = let len = fold (ts, 0, fun (t, n) -> n + length t) in match len with 0 -> empty | _ -> T {length = len; tree = Sequence ts} (* XXX mayalign should do \'partial spill\', so that a long list of\n       short elements displays as\n       [1, 2, 3\n        4, 5, 6]\n       \n       instead of\n       \n       [1,\n        2,\n        3,\n        4,\n        5,\n        6] *)  let rec make force ts  = let rec loop ts  = match ts with [] -> (ts, 0) | t :: ts -> let (ts, n) = loop ts in match length t with 0 -> (ts, n) | n\' -> (t :: ts, n + n\' + 1) let (ts, len) = loop ts in match len with 0 -> empty | _ -> T {length = len - 1; tree = Align {force = force; rows = ts}} let align = make true let mayAlign = make false  let rec indent (t, n)  = T {length = length t; tree = Indent (t, n)} let tabSize : int = 8 let rec K x _  = x let rec blanks (n : int)  string  = concat [tabulate (n div tabSize, K \'\\t\'); tabulate (n mod tabSize, K \' \')] (*\n    fun outputTree (t, out) =\n        let val print = Out.outputc out\n            fun loop (T {tree, length}) =\n                (print "(length "\n                 ; print (Int.toString length)\n                 ; print ")"\n                 ; (case tree of\n                        Empty => print "Empty"\n                      | String s => (print "(String "; print s; print ")")\n                      | Sequence ts => loops ("Sequence", ts)\n                      | Align {force, rows} => loops ("Align", rows)\n                      | Indent (t, n) => (print "(Indent "\n                                          ; print (Int.toString n)\n                                          ; print " "\n                                          ; loop t\n                                          ; print ")")))\n            and loops (s, ts) = (print "("\n                                 ; print s\n                                 ; app (fn t => (print " " ; loop t)) ts\n                                 ; print ")")\n        in loop t\n        end\n*)  (* doesn\'t include newlines. new version below - tom *)  (*\n    fun tostring t =\n        let\n            fun loop (T {tree, ...}, accum) =\n                case tree of\n                    Empty => accum\n                  | String s => s :: accum\n                  | Sequence ts => fold (ts, accum, loop)\n                  | Align {rows, ...} =>\n                        (case rows of\n                             [] => accum\n                           | t :: ts =>\n                                 fold (ts, loop (t, accum), fn (t, ac) =>\n                                       loop (t, " " :: ac)))\n                  | Indent (t, _) => loop (t, accum)\n        in\n            String.concat (rev (loop (t, [])))\n        end\n*)  let rec layout_print {treet; printstring -> unit; lineWidthint}  = (*val _ = outputTree (t, out)*) let rec newline ()  = print "\\n" let rec outputCompact (t, {at; printAt})  = let rec loop (T {tree; _})  = match tree with Empty -> () | String s -> print s | Sequence ts -> app loop ts | Indent (t, _) -> loop t | Align {rows; _} -> match rows with [] -> () | t :: ts -> (loop t; app (fun t -> (print " "; loop t)) ts) let at = at + length t in loop t; {at = at; printAt = at} let rec loop (t as T {length; tree}, state as {at; printAt})  = let rec prePrint ()  = if at >= printAt then ()(* can\'t back up *)  else print (blanks (printAt - at)) in (*Out.print (concat ["at ", Int.toString at,\n                * "  printAt ", Int.toString printAt,\n                * "\\n"]);\n                *) (*outputTree (t, Out.error)*) match tree with Empty -> state | Indent (t, n) -> loop (t, {at = at; printAt = printAt + n}) | Sequence ts -> fold (ts, state, loop) | String s -> (prePrint (); print s; let at = printAt + length in {at = at; printAt = at}) | Align {force; rows} -> if not force && printAt + length <= lineWidth then (prePrint (); outputCompact (t, state)) else (match rows with [] -> state | t :: ts -> fold (ts, loop (t, state), fun (t, _) -> (newline (); loop (t, {at = 0; printAt = printAt})))) in loop (tree, {at = 0; printAt = 0}); () let defaultWidth : int = 80 let rec tostringex wid l  = let acc = ref nil : string list ref let rec pr s  = acc := s :: ! acc in layout_print {tree = l; lineWidth = wid; print = pr}; concat (rev (! acc)) let tostring = tostringex defaultWidth (*\n    fun outputWidth (t, width, out) =\n    layout_print {tree = t,\n               lineWidth = width,\n               print = Out.outputc out}\n*)  (*        fun output (t, out) = outputWidth (t, defaultWidth, out) *)  let print = fun (t, p) -> layout_print {tree = t; lineWidth = defaultWidth; print = p} (*\n    fun outputl (t, out) = (output (t, out); Out.newline out)\n*)  (*     fun makeOutput layoutX (x, out) = output (layoutX x, out)\n *)  let rec ignore _  = empty let rec separate (ts, s)  = match ts with [] -> [] | t :: ts -> t :: (let s = str s let rec loop []  = [] | loop (t :: ts)  = s :: t :: (loop ts) in loop ts) let rec separateLeft (ts, s)  = match ts with [] -> [] | [t] -> ts | t :: ts -> t :: (map (fun t -> seq [str s; t]) ts) let rec separateRight (ts, s)  = rev (let ts = rev ts in match ts with [] -> [] | [t] -> ts | t :: ts -> t :: (map (fun t -> seq [t; str s]) ts)) let rec alignPrefix (ts, prefix)  = match ts with [] -> empty | t :: ts -> mayAlign [t; indent (mayAlign (map (fun t -> seq [str prefix; t]) ts), ~ (size prefix))] let rec sequence (start, finish, sep) ts  = seq [str start; mayAlign (separateRight (ts, sep)); str finish] let list = sequence ("[", "]", ",") let rec listex start finish sep  = sequence (start, finish, sep) let schemeList = sequence ("(", ")", " ") let tuple = sequence ("(", ")", ",") let rec record fts  = sequence ("{", "}", ",") (map (fun (f, t) -> seq [str (f ^ " = "); t]) fts) let rec recordex sep fts  = sequence ("{", "}", ",") (map (fun (f, t) -> seq [str (f ^ " " ^ sep ^ " "); t]) fts)  let rec vector v  = tuple (foldr (::) [] v) let rec array x  = list (foldr (::) [] x) let rec namedRecord (name, fields)  = seq [str name; str " "; record fields] let rec paren t  = seq [str "("; t; str ")"] let rec tuple2 (l1, l2) (x1, x2)  = tuple [l1 x1; l2 x2] let rec tuple3 (l1, l2, l3) (x1, x2, x3)  = tuple [l1 x1; l2 x2; l3 x3] let rec tuple4 (l1, l2, l3, l4) (x1, x2, x3, x4)  = tuple [l1 x1; l2 x2; l3 x3; l4 x4] let rec tuple5 (l1, l2, l3, l4, l5) (x1, x2, x3, x4, x5)  = tuple [l1 x1; l2 x2; l3 x3; l4 x4; l5 x5] let indent = fun x -> fun y -> indent (y, x) end', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', 'module type SIGNAT = sig type keytype \'asgnexception Signat of stringval empty : unit -> \'a sgnval insert : \'a sgn -> key * \'a -> \'a sgn(* raises Signat if key is not fresh*) val lookup : \'a sgn -> key -> \'a(* raises Signat if not present *) val size : \'a sgn -> int endmodule ListSignatSIGNAT where keyint = struct module L = Lib type key = int type \'asgn = key * \'a list exception Signat of string let rec empty ()  = [] let rec insert sgn (p as (k, a))  = if exists (fun (k\', _) -> k = k\') sgn then raise (Signat "insert: signat contains key") else p :: sgn let rec lookup sgn x  = match assoc x sgn with SOME y -> y | NONE -> raise (Signat "lookup: no such key") let rec size l  = length l endmodule GrowarraySignatSIGNAT where keyint = struct module L = Lib module G = GrowArray type key = int type \'asgn = {arr: \'a growarray; size: int ref} exception Signat of string let size = ref 0 let rec empty ()  = {arr = empty (); size = ref 0} let rec insert (sgn : (\'a sgn)) (n, v)  = if length (arr sgn) > n then raise (Signat "insert: signat contains key") else (update (arr sgn) n v; (if n > ! (size sgn) then (size sgn) := n else ()); sgn) let rec lookup (sgn : \'a sgn) n  = sub (arr sgn) n let rec size (sgn : \'a sgn)  = ! (size sgn) endmodule Signat = GrowarraySignat', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi \n *\n * $Log: not supported by cvs2svn $\n * Revision 1.1.2.1  2003/01/14 22:46:39  carsten_lf\n * delphin frontend added\n *\n * Revision 1.1  2001/11/12 23:23:09  carsten\n * mlyacc hack included\n *\n * Revision 1.1.1.1  1999/12/03 19:59:22  dbm\n * Import of 110.0.6 src\n *\n * Revision 1.1.1.1  1997/01/14 01:38:04  george\n *   Version 109.24\n *\n * Revision 1.1.1.1  1996/01/31  16:01:42  george\n * Version 109\n * \n *) (* base.sig: Base signature file for SML-Yacc.  This file contains signatures\n   that must be loaded before any of the files produced by ML-Yacc are loaded\n*) (* STREAM: signature for a lazy stream.*) module type STREAMM = sig type 'xastreamval streamify : (unit -> '_a) -> '_a streamval cons : '_a * '_a stream -> '_a streamval get : '_a stream -> '_a * '_a stream end(* LR_TABLE: signature for an LR Table.\n\n   The list of actions and gotos passed to mkLrTable must be ordered by state\n   number. The values for state 0 are the first in the list, the values for\n    state 1 are next, etc.\n*) module type LR_TABLE = sig type 'a'bpairlistEMPTYPAIR'a * 'b * 'a'b pairlisttype stateSTATEinttype termTinttype nontermNTinttype actionSHIFTstateREDUCEintACCEPTERRORtype tableval numStates : table -> intval numRules : table -> intval describeActions : table -> state -> termaction pairlist * actionval describeGoto : table -> state -> nontermstate pairlistval action : table -> state * term -> actionval goto : table -> state * nonterm -> stateval initialState : table -> stateexception Goto of state * nontermval mkLrTable : {actions: termaction pairlist * action array; gotos: nontermstate pairlist array; numStates: int; numRules: int; initialState: state} -> table end(* TOKEN: signature revealing the internal structure of a token. This signature\n   TOKEN distinct from the signature {parser name}_TOKENS produced by ML-Yacc.\n   The {parser name}_TOKENS structures contain some types and functions to\n    construct tokens from values and positions.\n\n   The representation of token was very carefully chosen here to allow the\n   polymorphic parser to work without knowing the types of semantic values\n   or line numbers.\n\n   This has had an impact on the TOKENS structure produced by SML-Yacc, which\n   is a structure parameter to lexer functors.  We would like to have some\n   type 'a token which functions to construct tokens would create.  A\n   constructor function for a integer token might be\n\n\t  INT: int * 'a * 'a -> 'a token.\n \n   This is not possible because we need to have tokens with the representation\n   given below for the polymorphic parser.\n\n   Thus our constructur functions for tokens have the form:\n\n\t  INT: int * 'a * 'a -> (svalue,'a) token\n\n   This in turn has had an impact on the signature that lexers for SML-Yacc\n   must match and the types that a user must declare in the user declarations\n   section of lexers.\n*) module type TOKEN = sig module LrTable : LR_TABLEtype 'a'btokenTOKENterm * ('a * 'b * 'b)val sameToken : 'a'b token * 'a'b token -> bool end(* LR_PARSER: signature for a polymorphic LR parser *) module type LR_PARSER = sig module Streamm : STREAMMmodule LrTable : LR_TABLEmodule Token : TOKENLrTableTokenLrTableexception ParseErrorval parse : {table: table; lexer: '_b'_c token stream; arg: 'arg; saction: int * '_c * state * ('_b * '_c * '_c) list * 'arg -> nonterm * ('_b * '_c * '_c) * (state * ('_b * '_c * '_c) list); void: '_b; ec: {is_keyword: term -> bool; noShift: term -> bool; preferred_change: term list * term list list; errtermvalue: term -> '_b; showTerminal: term -> string; terms: term list; error: string * '_c * '_c -> unit}; lookahead: int; (* max amount of lookahead used in *) ; (* error correction *) } -> '_b * ('_b'_c token stream) end(* LEXERR: a signature that most lexers produced for use with SML-Yacc's\n   output will match.  The user is responsible for declaring type token,\n   type pos, and type svalue in the UserDeclarations section of a lexer.\n\n   Note that type token is abstract in the lexer.  This allows SML-Yacc to\n   create a TOKENS signature for use with lexers produced by ML-Lex that\n   treats the type token abstractly.  Lexers that are functors parametrized by\n   a Tokens structure matching a TOKENS signature cannot examine the structure\n   of tokens.\n*) module type LEXERR = sig module UserDeclarations : sig type 'a'btokentype postype svalue endval makeLexer : (int -> string) -> unit -> svaluepos token end(* ARG_LEXER: the %arg option of ML-Lex allows users to produce lexers which\n   also take an argument before yielding a function from unit to a token\n*) module type ARG_LEXER = sig module UserDeclarations : sig type 'a'btokentype postype svaluetype arg endval makeLexer : (int -> string) -> arg -> unit -> svaluepos token end(* PARSER_DATA: the signature of ParserData structures in {parser name}LrValsFun\n   produced by  SML-Yacc.  All such structures match this signature.  \n\n   The {parser name}LrValsFun produces a structure which contains all the values\n   except for the lexer needed to call the polymorphic parser mentioned\n   before.\n\n*) module type PARSER_DATA = sig (* the type of line numbers *) type pos(* the type of semantic values *) type svalue(* the type of the user-supplied argument to the parser *) type arg(* the intended type of the result of the parser.  This value is\n\t   produced by applying extract from the structure Actions to the\n\t   final semantic value resultiing from a parse.\n\t *) type resultmodule LrTable : LR_TABLEmodule Token : TOKENTokenLrTableLrTable(* structure Actions contains the functions which mantain the\n\t   semantic values stack in the parser.  Void is used to provide\n\t   a default value for the semantic stack.\n\t *) module Actions : sig val actions : int * pos * state * (svalue * pos * pos) list * arg -> nonterm * (svalue * pos * pos) * (state * (svalue * pos * pos) list)val void : svalueval extract : svalue -> result end(* structure EC contains information used to improve error\n\t   recovery in an error-correcting parser *) module EC : sig val is_keyword : term -> boolval noShift : term -> boolval preferred_change : term list * term list listval errtermvalue : term -> svalueval showTerminal : term -> stringval terms : term list end(* table is the LR table for the parser *) val table : table end(* signature PARSER is the signature that most user parsers created by \n   SML-Yacc will match.\n*) module type PARSERR = sig module Token : TOKENmodule Streamm : STREAMMexception ParseError(* type pos is the type of line numbers *) type pos(* type result is the type of the result from the parser *) type result(* the type of the user-supplied argument to the parser *) type arg(* type svalue is the type of semantic values for the semantic value\n\t   stack\n\t *) type svalue(* val makeLexer is used to create a stream of tokens for the parser *) val makeLexer : (int -> string) -> svaluepos token stream(* val parse takes a stream of tokens and a function to print\n\t   errors and returns a value of type result and a stream containing\n\t   the unused tokens\n\t *) val parse : int * (svaluepos token stream) * (string * pos * pos -> unit) * arg -> result * svaluepos token streamval sameToken : svaluepos token * svaluepos token -> bool end(* signature ARG_PARSER is the signature that will be matched by parsers whose\n    lexer takes an additional argument.\n*) module type ARG_PARSER = sig module Token : TOKENmodule Streamm : STREAMMexception ParseErrortype argtype lexargtype postype resulttype svalueval makeLexer : (int -> string) -> lexarg -> svaluepos token streamval parse : int * (svaluepos token stream) * (string * pos * pos -> unit) * arg -> result * svaluepos token streamval sameToken : svaluepos token * svaluepos token -> bool end", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi \n *\n * $Log: not supported by cvs2svn $\n * Revision 1.1.2.1  2003/01/14 22:46:39  carsten_lf\n * delphin frontend added\n *\n * Revision 1.1  2001/11/12 23:23:09  carsten\n * mlyacc hack included\n *\n * Revision 1.1.1.1  1999/12/03 19:59:22  dbm\n * Import of 110.0.6 src\n *\n * Revision 1.2  1997/08/26 19:18:54  jhr\n *   Replaced used of "abstraction" with ":>".\n *\n# Revision 1.1.1.1  1997/01/14  01:38:04  george\n#   Version 109.24\n#\n * Revision 1.3  1996/10/03  03:36:58  jhr\n * Qualified identifiers that are no-longer top-level (quot, rem, min, max).\n *\n * Revision 1.2  1996/02/26  15:02:29  george\n *    print no longer overloaded.\n *    use of makestring has been removed and replaced with Int.toString ..\n *    use of IO replaced with TextIO\n *\n * Revision 1.1.1.1  1996/01/31  16:01:42  george\n * Version 109\n * \n *) (* parser.sml:  This is a parser driver for LR tables with an error-recovery\n   routine added to it.  The routine used is described in detail in this\n   article:\n\n\t\'A Practical Method for LR and LL Syntactic Error Diagnosis and\n\t Recovery\', by M. Burke and G. Fisher, ACM Transactions on\n\t Programming Langauges and Systems, Vol. 9, No. 2, April 1987,\n\t pp. 164-197.\n\n    This program is an implementation is the partial, deferred method discussed\n    in the article.  The algorithm and data structures used in the program\n    are described below.  \n\n    This program assumes that all semantic actions are delayed.  A semantic\n    action should produce a function from unit -> value instead of producing the\n    normal value.  The parser returns the semantic value on the top of the\n    stack when accept is encountered.  The user can deconstruct this value\n    and apply the unit -> value function in it to get the answer.\n\n    It also assumes that the lexer is a lazy stream.\n\n    Data Structures:\n    ----------------\n\t\n\t* The parser:\n\n\t   The state stack has the type\n\n\t\t (state * (semantic value * line # * line #)) list\n\n\t   The parser keeps a queue of (state stack * lexer pair).  A lexer pair\n\t consists of a terminal * value pair and a lexer.  This allows the \n\t parser to reconstruct the states for terminals to the left of a\n\t syntax error, and attempt to make error corrections there.\n\n\t   The queue consists of a pair of lists (x,y).  New additions to\n\t the queue are cons\'ed onto y.  The first element of x is the top\n\t of the queue.  If x is nil, then y is reversed and used\n\t in place of x.\n\n    Algorithm:\n    ----------\n\n\t* The steady-state parser:  \n\n\t    This parser keeps the length of the queue of state stacks at\n\ta steady state by always removing an element from the front when\n\tanother element is placed on the end.\n\n\t    It has these arguments:\n\n\t   stack: current stack\n\t   queue: value of the queue\n\t   lexPair ((terminal,value),lex stream)\n\n\tWhen SHIFT is encountered, the state to shift to and the value are\n\tare pushed onto the state stack.  The state stack and lexPair are\n\tplaced on the queue.  The front element of the queue is removed.\n\n\tWhen REDUCTION is encountered, the rule is applied to the current\n\tstack to yield a triple (nonterm,value,new stack).  A new\n\tstack is formed by adding (goto(top state of stack,nonterm),value)\n\tto the stack.\n\n\tWhen ACCEPT is encountered, the top value from the stack and the\n\tlexer are returned.\n\n\tWhen an ERROR is encountered, fixError is called.  FixError\n\ttakes the arguments to the parser, fixes the error if possible and\n        returns a new set of arguments.\n\n\t* The distance-parser:\n\n\tThis parser includes an additional argument distance.  It pushes\n\telements on the queue until it has parsed distance tokens, or an\n\tACCEPT or ERROR occurs.  It returns a stack, lexer, the number of\n\ttokens left unparsed, a queue, and an action option.\n*) module type FIFO = sig type \'aqueueval empty : \'a queueexception Emptyval get : \'a queue -> \'a * \'a queueval put : \'a * \'a queue -> \'a queue end(* drt (12/15/89) -- the functor should be used in development work, but\n   it wastes space in the release version.\n\nfunctor ParserGen(structure LrTable : LR_TABLE\n\t\t  structure Streamm : STREAMM) : LR_PARSER =\n*) module LrParserLR_PARSER = struct module LrTable = LrTable module Streamm = Streamm module TokenTOKEN = struct module LrTable = LrTable type token = TOKEN of term * (\'a * \'b * \'b) let sameToken = fun (TOKEN (t, _), TOKEN (t\', _)) -> t = t\' end open LrTable open Token let DEBUG1 = false let DEBUG2 = false exception ParseError exception ParseImpossible of int module FifoFIFO = struct type \'aqueue = (\'a list * \'a list) let empty = (nil, nil) exception Empty let rec get (a :: x, y)  = (a, (x, y)) | get (nil, nil)  = raise (Empty) | get (nil, y)  = get (rev y, nil) let rec put (a, (x, y))  = (x, a :: y) end type \'a\'belem = (state * (\'a * \'b * \'b)) type \'a\'bstack = \'a\'b elem list type \'a\'blexv = \'a\'b token type \'a\'blexpair = \'a\'b lexv * (\'a\'b lexv stream) type \'a\'bdistanceParse = \'a\'b lexpair * \'a\'b stack * \'a\'b stack * \'a\'b lexpair queue * int -> \'a\'b lexpair * \'a\'b stack * \'a\'b stack * \'a\'b lexpair queue * int * action option type \'a\'becRecord = {is_keyword: term -> bool; preferred_change: term list * term list list; error: string * \'b * \'b -> unit; errtermvalue: term -> \'a; terms: term list; showTerminal: term -> string; noShift: term -> bool} let print = fun s -> output (stdOut, s) let println = fun s -> (print s; print "\\n") let showState = fun (STATE s) -> "STATE " ^ (toString s) let rec printStack (stack : \'a\'b stack, n : int)  = match stack with (state, _) :: rest -> (print ("\\t" ^ toString n ^ ": "); println (showState state); printStack (rest, n + 1)) | nil -> () let rec prAction showTerminal (stack as (state, _) :: _, next as (TOKEN (term, _), _), action)  = (println "Parse: state stack:"; printStack (stack, 0); print ("       state=" ^ showState state ^ " next=" ^ showTerminal term ^ " action="); match action with SHIFT state -> println ("SHIFT " ^ (showState state)) | REDUCE i -> println ("REDUCE " ^ (toString i)) | ERROR -> println "ERROR" | ACCEPT -> println "ACCEPT") | prAction _ (_, _, action)  = ()  (* ssParse: parser which maintains the queue of (state * lexvalues) in a\n\tsteady-state.  It takes a table, showTerminal function, saction\n\tfunction, and fixError function.  It parses until an ACCEPT is\n\tencountered, or an exception is raised.  When an error is encountered,\n\tfixError is called with the arguments of parseStep (lexv,stack,and\n\tqueue).  It returns the lexv, and a new stack and queue adjusted so\n\tthat the lexv can be parsed *)  let ssParse = fun (table, showTerminal, saction, fixError, arg) -> let prAction = prAction showTerminal let action = action table let goto = goto table let rec parseStep (args as (lexPair as (TOKEN (terminal, value as (_, leftPos, _)), lexer), stack as (state, _) :: _, queue))  = let nextAction = action (state, terminal) let _ = if DEBUG1 then prAction (stack, lexPair, nextAction) else () in match nextAction with SHIFT s -> let newStack = (s, value) :: stack let newLexPair = get lexer let (_, newQueue) = get (put ((newStack, newLexPair), queue)) in parseStep (newLexPair, (s, value) :: stack, newQueue) | REDUCE i -> (match saction (i, leftPos, stack, arg) with (nonterm, value, stack as (state, _) :: _) -> parseStep (lexPair, (goto (state, nonterm), value) :: stack, queue) | _ -> raise ((ParseImpossible 197))) | ERROR -> parseStep (fixError args) | ACCEPT -> (match stack with (_, (topvalue, _, _)) :: _ -> let (token, restLexer) = lexPair in (topvalue, cons (token, restLexer)) | _ -> raise ((ParseImpossible 202))) | parseStep _  = raise ((ParseImpossible 204)) in parseStep (*  distanceParse: parse until n tokens are shifted, or accept or\n\terror are encountered.  Takes a table, showTerminal function, and\n\tsemantic action function.  Returns a parser which takes a lexPair\n\t(lex result * lexer), a state stack, a queue, and a distance\n\t(must be > 0) to parse.  The parser returns a new lex-value, a stack\n\twith the nth token shifted on top, a queue, a distance, and action\n\toption. *)  let distanceParse = fun (table, showTerminal, saction, arg) -> let prAction = prAction showTerminal let action = action table let goto = goto table let rec parseStep (lexPair, stack, queue, 0)  = (lexPair, stack, queue, 0, NONE) | parseStep (lexPair as (TOKEN (terminal, value as (_, leftPos, _)), lexer), stack as (state, _) :: _, queue, distance)  = let nextAction = action (state, terminal) let _ = if DEBUG1 then prAction (stack, lexPair, nextAction) else () in match nextAction with SHIFT s -> let newStack = (s, value) :: stack let newLexPair = get lexer in parseStep (newLexPair, (s, value) :: stack, put ((newStack, newLexPair), queue), distance - 1) | REDUCE i -> (match saction (i, leftPos, stack, arg) with (nonterm, value, stack as (state, _) :: _) -> parseStep (lexPair, (goto (state, nonterm), value) :: stack, queue, distance) | _ -> raise ((ParseImpossible 240))) | ERROR -> (lexPair, stack, queue, distance, SOME nextAction) | ACCEPT -> (lexPair, stack, queue, distance, SOME nextAction) | parseStep _  = raise ((ParseImpossible 242)) in parseStep : \'_a\'_b distanceParse (* mkFixError: function to create fixError function which adjusts parser state\n   so that parse may continue in the presence of an error *)  let rec mkFixError ({is_keyword; terms; errtermvalue; preferred_change; noShift; showTerminal; error; _} : \'_a\'_b ecRecord, distanceParse : \'_a\'_b distanceParse, minAdvance, maxAdvance) (lexv as (TOKEN (term, value as (_, leftPos, _)), _), stack, queue)  = (* pull all the state * lexv elements from the queue *) (* now number elements of stateList, giving distance from\n\t   error token *) (* Represent the set of potential changes as a linked list.\n\n\t   Values of datatype Change hold information about a potential change.\n\n\t   oper = oper to be applied\n\t   pos = the # of the element in stateList that would be altered.\n\t   distance = the number of tokens beyond the error token which the\n\t     change allows us to parse.\n\t   new = new terminal * value pair at that point\n\t   orig = original terminal * value pair at the point being changed.\n\t *) (* parse: given a lexPair, a stack, and the distance from the error\n   token, return the distance past the error token that we are able to parse.*) (* catList: concatenate results of scanning list *) (* tryDelete: Try to delete n terminals.\n              Return single-element [success] or nil.\n\t      Do not delete unshiftable terminals. *) (* tryInsert: try to insert tokens before the current terminal;\n       return a list of the successes  *) (* trySubst: try to substitute tokens for the current terminal;\n       return a list of the successes  *) (* do_delete(toks,lexPair) tries to delete tokens "toks" from "lexPair".\n         If it succeeds, returns SOME(toks\',l,r,lp), where\n\t     toks\' is the actual tokens (with positions and values) deleted,\n\t     (l,r) are the (leftmost,rightmost) position of toks\', \n\t     lp is what remains of the stream after deletion \n     *) (* maxDist: max distance past error taken that we could parse *) (* remove changes which did not parse maxDist tokens past the error token *) let _ = if DEBUG2 then error ("syntax error found at " ^ (showTerminal term), leftPos, leftPos) else () let rec tokAt (t, p)  = TOKEN (t, (errtermvalue t, p, p)) let minDelta = 3 let stateList = let rec f q  = try  with in f queue let (_, numStateList) = foldr (fun (a, (num, r)) -> (num + 1, (a, num) :: r)) (0, []) stateList type change = CHANGE of {pos: int; distance: int; leftPos: \'b; rightPos: \'b; new: \'a\'b lexv list; orig: \'a\'b lexv list} let showTerms = concat o map (fun TOKEN (t, _) -> " " ^ showTerminal t) let printChange = fun c -> let CHANGE {distance; new; orig; pos; _} = c in (print ("{distance= " ^ (toString distance)); print (",orig ="); print (showTerms orig); print (",new ="); print (showTerms new); print (",pos= " ^ (toString pos)); print "}\\n") let printChangeList = app printChange let rec parse (lexPair, stack, queuePos : int)  = match distanceParse (lexPair, stack, empty, queuePos + maxAdvance + 1) with (_, _, _, distance, SOME ACCEPT) -> if maxAdvance - distance - 1 >= 0 then maxAdvance else maxAdvance - distance - 1 | (_, _, _, distance, _) -> maxAdvance - distance - 1 let rec catList l f  = foldr (fun (a, r) -> f a @ r) [] l let rec keywordsDelta new  = if exists (fun (TOKEN (t, _)) -> is_keyword t) new then minDelta else 0 let rec tryChange {lex; stack; pos; leftPos; rightPos; orig; new}  = let lex\' = foldr (fun (t\', p) -> (t\', cons p)) lex new let distance = parse (lex\', stack, pos + length new - length orig) in if distance >= minAdvance + keywordsDelta new then [CHANGE {pos = pos; leftPos = leftPos; rightPos = rightPos; distance = distance; orig = orig; new = new}] else [] let rec tryDelete n ((stack, lexPair as (TOKEN (term, (_, l, r)), _)), qPos)  = let rec del (0, accum, left, right, lexPair)  = tryChange {lex = lexPair; stack = stack; pos = qPos; leftPos = left; rightPos = right; orig = rev accum; new = []} | del (n, accum, left, right, (tok as TOKEN (term, (_, _, r)), lexer))  = if noShift term then [] else del (n - 1, tok :: accum, left, r, get lexer) in del (n, [], l, r, lexPair) let rec tryInsert ((stack, lexPair as (TOKEN (_, (_, l, _)), _)), queuePos)  = catList terms (fun t -> tryChange {lex = lexPair; stack = stack; pos = queuePos; orig = []; new = [tokAt (t, l)]; leftPos = l; rightPos = l}) let rec trySubst ((stack, lexPair as (orig as TOKEN (term, (_, l, r)), lexer)), queuePos)  = if noShift term then [] else catList terms (fun t -> tryChange {lex = get lexer; stack = stack; pos = queuePos; leftPos = l; rightPos = r; orig = [orig]; new = [tokAt (t, r)]}) let rec do_delete (nil, lp as (TOKEN (_, (_, l, _)), _))  = SOME (nil, l, l, lp) | do_delete ([t], (tok as TOKEN (t\', (_, l, r)), lp\'))  = if t = t\' then SOME ([tok], l, r, get lp\') else NONE | do_delete (t :: rest, (tok as TOKEN (t\', (_, l, r)), lp\'))  = if t = t\' then match do_delete (rest, get lp\') with SOME (deleted, l\', r\', lp\'\') -> SOME (tok :: deleted, l, r\', lp\'\') | NONE -> NONE else NONE let rec tryPreferred ((stack, lexPair), queuePos)  = catList preferred_change (fun (delete, insert) -> if exists noShift delete then [](* should give warning at\n\t\t\t\t\t\t parser-generation time *)  else match do_delete (delete, lexPair) with SOME (deleted, l, r, lp) -> tryChange {lex = lp; stack = stack; pos = queuePos; leftPos = l; rightPos = r; orig = deleted; new = map (fun t -> (tokAt (t, r))) insert} | NONE -> []) let changes = catList numStateList tryPreferred @ catList numStateList tryInsert @ catList numStateList trySubst @ catList numStateList (tryDelete 1) @ catList numStateList (tryDelete 2) @ catList numStateList (tryDelete 3) let findMaxDist = fun l -> foldr (fun (CHANGE {distance; _}, high) -> max (distance, high)) 0 l let maxDist = findMaxDist changes let changes = catList changes (fun (c as CHANGE {distance; _}) -> if distance = maxDist then [c] else []) in match changes with (l as change :: _) -> (* findNth: find nth queue entry from the error\n\t\t   entry.  Returns the Nth queue entry and the  portion of\n\t\t   the queue from the beginning to the nth-1 entry.  The\n\t\t   error entry is at the end of the queue.\n\n\t\t   Examples:\n\n\t\t   queue = a b c d e\n\t\t   findNth 0 = (e,a b c d)\n\t\t   findNth 1 =  (d,a b c)\n\t\t   *) let rec print_msg (CHANGE {new; orig; leftPos; rightPos; _})  = let s = match (orig, new) with (_ :: _, []) -> "deleting " ^ (showTerms orig) | ([], _ :: _) -> "inserting " ^ (showTerms new) | _ -> "replacing " ^ (showTerms orig) ^ " with " ^ (showTerms new) in error ("syntax error: " ^ s, leftPos, rightPos) let _ = (if length l > 1 && DEBUG2 then (print "multiple fixes possible; could fix it by:\\n"; app print_msg l; print "chosen correction:\\n") else (); print_msg change) let findNth = fun n -> let rec f (h :: t, 0)  = (h, rev t) | f (h :: t, n)  = f (t, n - 1) | f (nil, _)  = exception FindNth in raise (FindNth) in f (rev stateList, n) let CHANGE {pos; orig; new; _} = change let (last, queueFront) = findNth pos let (stack, lexPair) = last let lp1 = foldl (fun (_, (_, r)) -> get r) lexPair orig let lp2 = foldr (fun (t, r) -> (t, cons r)) lp1 new let restQueue = put ((stack, lp2), foldl put empty queueFront) let (lexPair, stack, queue, _, _) = distanceParse (lp2, stack, restQueue, pos) in (lexPair, stack, queue) | nil -> (error ("syntax error found at " ^ (showTerminal term), leftPos, leftPos); raise (ParseError)) let parse = fun {arg; table; lexer; saction; void; lookahead; ec = ec as {showTerminal; _} : \'_a\'_b ecRecord} -> (* defer distance tokens *) (* must parse at least 1 token past error *) (* max distance for parse check *) let distance = 15 let minAdvance = 1 let maxAdvance = max (lookahead, 0) let lexPair = get lexer let (TOKEN (_, (_, leftPos, _)), _) = lexPair let startStack = [(initialState table, (void, leftPos, leftPos))] let startQueue = put ((startStack, lexPair), empty) let distanceParse = distanceParse (table, showTerminal, saction, arg) let fixError = mkFixError (ec, distanceParse, minAdvance, maxAdvance) let ssParse = ssParse (table, showTerminal, saction, fixError, arg) let rec loop (lexPair, stack, queue, _, SOME ACCEPT)  = ssParse (lexPair, stack, queue) | loop (lexPair, stack, queue, 0, _)  = ssParse (lexPair, stack, queue) | loop (lexPair, stack, queue, distance, SOME ERROR)  = let (lexPair, stack, queue) = fixError (lexPair, stack, queue) in loop (distanceParse (lexPair, stack, queue, distance)) | loop _  = exception ParseInternal in raise (ParseInternal) in loop (distanceParse (lexPair, startStack, startQueue, distance)) end\n(* drt (12/15/89) -- needed only when the code above is functorized\n\nstructure LrParser = ParserGen(structure LrTable=LrTable\n\t\t\t     structure Streamm=Streamm);\n*) ', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [(0, {}), (0, {}), (0, {}), (0, {}), (0, {}), (0, {})])
('Error parsing code:', '(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi \n *\n * $Log: not supported by cvs2svn $\n * Revision 1.1.2.1  2003/01/14 22:46:39  carsten_lf\n * delphin frontend added\n *\n * Revision 1.1  2001/11/12 23:23:09  carsten\n * mlyacc hack included\n *\n * Revision 1.1.1.1  1999/12/03 19:59:22  dbm\n * Import of 110.0.6 src\n *\n * Revision 1.1.1.1  1997/01/14 01:38:04  george\n *   Version 109.24\n *\n * Revision 1.1.1.1  1996/01/31  16:01:42  george\n * Version 109\n * \n *) (* functor Join creates a user parser by putting together a Lexer structure,\n   an LrValues structure, and a polymorphic parser structure.  Note that\n   the Lexer and LrValues structure must share the type pos (i.e. the type\n   of line numbers), the type svalues for semantic values, and the type\n   of tokens.\n*) module Join (module Lex : LEXERRmodule ParserData : PARSER_DATAmodule LrParser : LR_PARSERParserDataLrTableLrParserLrTableParserDataTokenLrParserTokensvaluesvaluepospostokentoken) : PARSERR = struct module Token = ParserDataToken module Streamm = LrParserStreamm exception ParseErrorParseError type arg = arg type pos = pos type result = result type svalue = svalue let makeLexer = streamify o makeLexer let parse = fun (lookahead, lexer, error, arg) -> (fun (a, b) -> (extract a, b)) (parse {table = table; lexer = lexer; lookahead = lookahead; saction = actions; arg = arg; void = void; ec = {is_keyword = is_keyword; noShift = noShift; preferred_change = preferred_change; errtermvalue = errtermvalue; error = error; showTerminal = showTerminal; terms = terms}}) let sameToken = sameToken end(* functor JoinWithArg creates a variant of the parser structure produced \n   above.  In this case, the makeLexer take an additional argument before\n   yielding a value of type unit -> (svalue,pos) token\n *) module JoinWithArg (module Lex : ARG_LEXERmodule ParserData : PARSER_DATAmodule LrParser : LR_PARSERParserDataLrTableLrParserLrTableParserDataTokenLrParserTokensvaluesvaluepospostokentoken) : ARG_PARSER = struct module Token = ParserDataToken module Streamm = LrParserStreamm exception ParseErrorParseError type arg = arg type lexarg = arg type pos = pos type result = result type svalue = svalue let makeLexer = fun s -> fun arg -> streamify (makeLexer s arg) let parse = fun (lookahead, lexer, error, arg) -> (fun (a, b) -> (extract a, b)) (parse {table = table; lexer = lexer; lookahead = lookahead; saction = actions; arg = arg; void = void; ec = {is_keyword = is_keyword; noShift = noShift; preferred_change = preferred_change; errtermvalue = errtermvalue; error = error; showTerminal = showTerminal; terms = terms}}) let sameToken = sameToken end\n', 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', "(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi \n *\n * $Log: not supported by cvs2svn $\n * Revision 1.1.2.1  2003/01/14 22:46:39  carsten_lf\n * delphin frontend added\n *\n * Revision 1.1  2001/11/12 23:23:09  carsten\n * mlyacc hack included\n *\n * Revision 1.1.1.1  1999/12/03 19:59:22  dbm\n * Import of 110.0.6 src\n *\n * Revision 1.1.1.1  1997/01/14 01:38:04  george\n *   Version 109.24\n *\n * Revision 1.1.1.1  1996/01/31  16:01:42  george\n * Version 109\n * \n *) module LrTableLR_TABLE = struct open ArrayList  type pairlist = EMPTY | PAIR of 'a * 'b * 'a'b pairlist type term = T of int type nonterm = NT of int type state = STATE of int type action = SHIFT of state | REDUCE of int | ACCEPT | ERROR exception Goto of state * nonterm type table = {states: int; rules: int; initialState: state; action: termaction pairlist * action array; goto: nontermstate pairlist array} let numStates = fun ({states; _} : table) -> states let numRules = fun ({rules; _} : table) -> rules let describeActions = fun ({action; _} : table) -> fun (STATE s) -> action sub s let describeGoto = fun ({goto; _} : table) -> fun (STATE s) -> goto sub s let rec findTerm (T term, row, default)  = let rec find (PAIR (T key, data, r))  = if key < term then find r else if key = term then data else default | find EMPTY  = default in find row let rec findNonterm (NT nt, row)  = let rec find (PAIR (NT key, data, r))  = if key < nt then find r else if key = nt then SOME data else NONE | find EMPTY  = NONE in find row let action = fun ({action; _} : table) -> fun (STATE state, term) -> let (row, default) = action sub state in findTerm (term, row, default) let goto = fun ({goto; _} : table) -> fun (a as (STATE state, nonterm)) -> match findNonterm (nonterm, goto sub state) with SOME state -> state | NONE -> raise ((Goto a)) let initialState = fun ({initialState; _} : table) -> initialState let mkLrTable = fun {actions; gotos; initialState; numStates; numRules} -> ({action = actions; goto = gotos; states = numStates; rules = numRules; initialState = initialState} : table) end\n", 'Error matches:', [(0, {}), (0, {}), (0, {}), (0, {})], 'Missing matches:', [])
('Error parsing code:', '(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi \n *\n * $Log: not supported by cvs2svn $\n * Revision 1.1.2.1  2003/01/14 22:46:39  carsten_lf\n * delphin frontend added\n *\n * Revision 1.1  2001/11/12 23:23:09  carsten\n * mlyacc hack included\n *\n * Revision 1.1.1.1  1999/12/03 19:59:22  dbm\n * Import of 110.0.6 src\n *\n * Revision 1.2  1997/08/26 19:18:55  jhr\n *   Replaced used of "abstraction" with ":>".\n *\n# Revision 1.1.1.1  1997/01/14  01:38:04  george\n#   Version 109.24\n#\n * Revision 1.1.1.1  1996/01/31  16:01:43  george\n * Version 109\n * \n *) (* Stream: a structure implementing a lazy stream.  The signature STREAM\n   is found in base.sig *) module StreammSTREAMM = struct type str = EVAL of \'a * \'a str ref | UNEVAL of (unit -> \'a) type \'astream = \'a str ref let rec get (ref (EVAL t))  = t | get (s as ref (UNEVAL f))  = let t = (f (), ref (UNEVAL f)) in s := EVAL t; t let rec streamify f  = ref (UNEVAL f) let rec cons (a, s)  = ref (EVAL (a, s)) end\n', 'Error matches:', [(0, {}), (0, {}), (0, {})], 'Missing matches:', [])
