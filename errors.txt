File "lib/trail/trail.ml", line 24, characters 2-30:
Error: The type abbreviation trail is cyclic:
         'a trail = 'a trail ref,
         'a trail ref contains 'a trail
File "lib/int_inf/int_inf_sig.ml", line 10, characters 10-17:
Error: Unbound module type INTEGER
File "lib/compat/word8_vector_slice.ml", line 19, characters 16-27:
Error: Unbound module Word8Vector
File "lib/formatter/formatter.ml", line 105, characters 67-68:
Error: Syntax error: end expected
File "lib/formatter/formatter.ml", line 86, characters 31-37:
  This struct might be unmatched
File "lib/global/global.ml", line 16, characters 18-22:
Error: Unbound module Time
File "lib/heuristic/heuristic.ml", line 10, characters 33-38:
Error: Unbound type constructor order
File "lib/stream/stream.ml", line 107, characters 18-23:
Error: This expression should not be a constructor, the expected type is
       'a BasicStream.front -> 'b BasicStream.front
File "lib/terminate/checking.ml", line 135, characters 57-58:
135 |           | R.Lex L -> F.Hbox [F.String "{"; F.HOVbox0 1 0 1 (fmtOrders L); F.String "}"]
                                                               ^
Error: Syntax error: ] expected
File "lib/terminate/checking.ml", line 135, characters 30-31:
135 |           | R.Lex L -> F.Hbox [F.String "{"; F.HOVbox0 1 0 1 (fmtOrders L); F.String "}"]
                                    ^
  This [ might be unmatched
File "lib/int_inf/int_inf.ml", line 276, characters 10-11:
276 | let rec ~ = function (i) -> i | (BI {sign = POS; digits}) -> BI {sign = NEG; digits = digits} | (BI {sign = NEG; digits}) -> BI {sign = POS; digits = digits}
                ^
Error: Syntax error
File "lib/lambda/approx.ml", line 11, characters 6-10:
11 |   val Type : uni
           ^^^^
Error: Syntax error
File "lib/lambda/fgnopntable.ml", line 18, characters 20-21:
18 |     let exception Cs.CSfunNotInstalled of csid in
                         ^
Error: Syntax error
File "lib/compress/parse.ml", line 16, characters 50-52:
16 | and term ()  = parsefixityadj (alt [wth id (Atm o Id); wth (tick LPAREN >> ( $ ) term << tick RPAREN) Atm; wth (tick LPAREN >> ( $ ) term << tick COLON && ( $ ) term << tick RPAREN) (Atm o Ascribe); wth (tick LBRACKET >> ( $ ) vardec << tick RBRACKET && ( $ ) term) (Atm o Lam); wth (tick LBRACE >> tick STAR >> ( $ ) vardec << tick RBRACE && ( $ ) term) (Atm o piOmit); wth (tick LBRACE >> tick PLUS >> ( $ ) vardec << tick RBRACE && ( $ ) term) (Atm o piPlus); wth (tick LBRACE >> ( $ ) vardec << tick RBRACE && ( $ ) term) (Atm o piMinus); tick TYPE return (Atm Type); tick ARROW return Opr (Infix (Right, 5, Arrow)); tick PLUSARROW return Opr (Infix (Right, 5, PlusArrow)); tick BACKARROW return Opr (Infix (Left, 5, Arrow o swap)); tick STAR return (Atm Omit)]) Left App
                                                       ^^
Error: Syntax error: ) expected
File "lib/compress/parse.ml", line 16, characters 43-44:
16 | and term ()  = parsefixityadj (alt [wth id (Atm o Id); wth (tick LPAREN >> ( $ ) term << tick RPAREN) Atm; wth (tick LPAREN >> ( $ ) term << tick COLON && ( $ ) term << tick RPAREN) (Atm o Ascribe); wth (tick LBRACKET >> ( $ ) vardec << tick RBRACKET && ( $ ) term) (Atm o Lam); wth (tick LBRACE >> tick STAR >> ( $ ) vardec << tick RBRACE && ( $ ) term) (Atm o piOmit); wth (tick LBRACE >> tick PLUS >> ( $ ) vardec << tick RBRACE && ( $ ) term) (Atm o piPlus); wth (tick LBRACE >> ( $ ) vardec << tick RBRACE && ( $ ) term) (Atm o piMinus); tick TYPE return (Atm Type); tick ARROW return Opr (Infix (Right, 5, Arrow)); tick PLUSARROW return Opr (Infix (Right, 5, PlusArrow)); tick BACKARROW return Opr (Infix (Left, 5, Arrow o swap)); tick STAR return (Atm Omit)]) Left App
                                                ^
  This ( might be unmatched
File "lib/table/red_black_set.ml", line 217, characters 677-679:
217 | let rec diffMod F (Set (_, s1), Set (_, s2))  = ( let rec ins = function ((Empty, _), n, result) -> (n, result) | ((Red (x, _, _), r), n, result) -> ins (next r, n + 1, addItem (x, result)) | ((Black (x, _, _), r), n, result) -> ins (next r, n + 1, addItem (x, result)) in let rec diff (t1, t2, (n1, result1), (n2, result2))  = (match (next t1, next t2) with ((Empty, _), t2) -> ((n1, result1), ins (t2, n2, result2)) | (t1, (Empty, _)) -> (ins (t1, n1, result1), (n2, result2)) | ((tree1, r1), (tree2, r2)) -> ( let e1 = getEntry tree1 in let e2 = getEntry tree2 in  match compare (x, y) with Lt -> diff (r1, t2, (n1 + 1, addItem (e1, result1)), (n2, result2)) | Eq -> ((F d1 d2); diff (r1, r2, (n1, result1), (n2, result2))) | Gt -> diff (t1, r2, (n1, result1), (n2 + 1, addItem (e2, result2))) )) in let ((n1, result1), (n2, result2)) = diff (start s1, start s2, (0, ZERO), (0, ZERO)) in  (Set (n1, linkAll result1), Set (n2, linkAll result2)) )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^
Error: Syntax error: ) expected
File "lib/table/red_black_set.ml", line 217, characters 671-672:
217 | let rec diffMod F (Set (_, s1), Set (_, s2))  = ( let rec ins = function ((Empty, _), n, result) -> (n, result) | ((Red (x, _, _), r), n, result) -> ins (next r, n + 1, addItem (x, result)) | ((Black (x, _, _), r), n, result) -> ins (next r, n + 1, addItem (x, result)) in let rec diff (t1, t2, (n1, result1), (n2, result2))  = (match (next t1, next t2) with ((Empty, _), t2) -> ((n1, result1), ins (t2, n2, result2)) | (t1, (Empty, _)) -> (ins (t1, n1, result1), (n2, result2)) | ((tree1, r1), (tree2, r2)) -> ( let e1 = getEntry tree1 in let e2 = getEntry tree2 in  match compare (x, y) with Lt -> diff (r1, t2, (n1 + 1, addItem (e1, result1)), (n2, result2)) | Eq -> ((F d1 d2); diff (r1, r2, (n1, result1), (n2, result2))) | Gt -> diff (t1, r2, (n1, result1), (n2 + 1, addItem (e2, result2))) )) in let ((n1, result1), (n2, result2)) = diff (start s1, start s2, (0, ZERO), (0, ZERO)) in  (Set (n1, linkAll result1), Set (n2, linkAll result2)) )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  This ( might be unmatched
File "lib/modes/modeprint.ml", line 31, characters 59-60:
31 | let rec modesToString mdecs  = F.makestring_fmt (F.Vbox0 0 1 (fmtModeDecs mdecs))
                                                                ^
Error: Syntax error: ) expected
File "lib/modes/modeprint.ml", line 31, characters 48-49:
31 | let rec modesToString mdecs  = F.makestring_fmt (F.Vbox0 0 1 (fmtModeDecs mdecs))
                                                     ^
  This ( might be unmatched
File "lib/solvers/cs_ineq_field.ml", line 11, characters 7-8:
11 |     (Cs.CSEqField : Cs.Cs_eq_field.CS_EQ_FIELD)
            ^
Error: Syntax error
File "lib/print/print.ml", line 395, characters 41-42:
395 | let rec formatCnstr (Cnstr)  = F.Vbox0 0 1 (fmtCnstr Cnstr)
                                               ^
Error: Syntax error: end expected
File "lib/print/print.ml", line 53, characters 195-201:
53 | module Print (Whnf : Whnf.WHNF) (Abstract : Abstract.ABSTRACT) (Constraints : Constraints.CONSTRAINTS) (Names : Names.NAMES) (Formatter' : Formatter.FORMATTER) (Symbol : Symbol.SYMBOL) : PRINT = struct (*! structure IntSyn = IntSyn' !*)
                                                                                                                                                                                                        ^^^^^^
  This struct might be unmatched
File "lib/solvers/cs_ineq_integers.ml", line 12, characters 7-8:
12 |     (Cs.CSEqIntegers : Cs.Cs_eq_integers.CS_EQ_INTEGERS)
            ^
Error: Syntax error
File "lib/terminate/reduces.ml", line 46, characters 51-52:
46 |     | R.Lex L -> F.Hbox [F.String "{"; F.HOVbox0 1 0 1 (fmtOrders L); F.String "}"]
                                                        ^
Error: Syntax error: ] expected
File "lib/terminate/reduces.ml", line 46, characters 24-25:
46 |     | R.Lex L -> F.Hbox [F.String "{"; F.HOVbox0 1 0 1 (fmtOrders L); F.String "}"]
                             ^
  This [ might be unmatched
File "lib/meta/funprint.ml", line 91, characters 375-376:
91 | let rec nameLookup index  = List.nth (names, index) in let rec formatFor1 = function (index, G, (F.And (F1, F2), s)) -> formatFor1 (index, G, (F1, s)) @ [Fmt.Break] @ formatFor1 (index + 1, G, (F2, s)) | (index, G, (F, s)) -> [Fmt.String (nameLookup index); Fmt.Space; Fmt.String "::"; Fmt.Space; Fmt.HVbox (formatFor' (G, (F, s)))] in let rec formatFor0 Args  = Fmt.Vbox0 0 1 (formatFor1 Args) in  (Names.varReset I.Null; formatFor0 (0, F.makectx Psi, (F, I.id))) )
                                                                                                                                                                                                                                                                                                                                                                                            ^
Error: Syntax error
File "lib/opsem/tabled.ml", line 220, characters 124-132:
220 |  with T.NewEntry (answRef) -> matchAtom ((p, s), dp, (fun pskeleton -> match MT.answerCheck (s', answRef, pskeleton) with T.repeated -> () | T.new_ -> (sc pskeleton))) | T.RepeatedEntry (asub, answRef, T.Incomplete) -> if T.noAnswers answRef then (* loop detected
                                                                                                                                  ^^^^^^^^
Error: Syntax error
File "lib/m2/splitting.ml", line 266, characters 50-51:
266 | let rec apply (_, Sl)  = map (fun (Active S) -> S | InActive -> raise (Error "Not applicable: leftover constraints")) Sl
                                                        ^
Error: Syntax error: ) expected
File "lib/m2/splitting.ml", line 266, characters 29-30:
266 | let rec apply (_, Sl)  = map (fun (Active S) -> S | InActive -> raise (Error "Not applicable: leftover constraints")) Sl
                                   ^
  This ( might be unmatched
File "lib/meta/mpi.ml", line 61, characters 347-348:
61 | let rec printFillResult (_, P)  = ( let rec formatTuple (G, P)  = ( let rec formatTuple' = function (F.Unit) -> [] | (F.Inx (M, F.Unit)) -> [Print.formatExp (G, M)] | (F.Inx (M, P')) -> (Print.formatExp (G, M) :: Fmt.String "," :: Fmt.Break :: formatTuple' P') in  match P with (F.Inx (_, F.Unit)) -> Fmt.Hbox (formatTuple' P) | _ -> Fmt.HVbox0 1 1 1 (Fmt.String "(" :: (formatTuple' P @ [Fmt.String ")"])) ) in let S.State (n, (G, B), (IH, OH), d, O, H, F) = current () in  TextIO.print ("Filling successful with proof term:\n" ^ (Formatter.makestring_fmt (formatTuple (G, P))) ^ "\n") )
                                                                                                                                                                                                                                                                                                                                                                ^
Error: Syntax error: ) expected
File "lib/meta/mpi.ml", line 61, characters 66-67:
61 | let rec printFillResult (_, P)  = ( let rec formatTuple (G, P)  = ( let rec formatTuple' = function (F.Unit) -> [] | (F.Inx (M, F.Unit)) -> [Print.formatExp (G, M)] | (F.Inx (M, P')) -> (Print.formatExp (G, M) :: Fmt.String "," :: Fmt.Break :: formatTuple' P') in  match P with (F.Inx (_, F.Unit)) -> Fmt.Hbox (formatTuple' P) | _ -> Fmt.HVbox0 1 1 1 (Fmt.String "(" :: (formatTuple' P @ [Fmt.String ")"])) ) in let S.State (n, (G, B), (IH, OH), d, O, H, F) = current () in  TextIO.print ("Filling successful with proof term:\n" ^ (Formatter.makestring_fmt (formatTuple (G, P))) ^ "\n") )
                                                                       ^
  This ( might be unmatched
File "lib/solvers/cs_integers_word.ml", line 183, characters 180-181:
183 | let rec installFgnCnstrOps ()  = ( let csid = ! myID in let _ = FgnCnstrStd.ToInternal.install (csid, (fun (MyFgnCnstrRepPlus (G, _, U1, U2, U3)) -> toInternalPlus (G, U1, U2, U3) | (MyFgnCnstrRepTimes (G, _, U1, U2, U3)) -> toInternalTimes (G, U1, U2, U3) | (MyFgnCnstrRepQuot (G, _, U1, U2, U3)) -> toInternalQuot (G, U1, U2, U3) | fc -> raise ((UnexpectedFgnCnstr fc)))) in let _ = FgnCnstrStd.Awake.install (csid, (fun (MyFgnCnstrRepPlus (G, proof, U1, U2, U3)) -> awakePlus (G, proof, U1, U2, U3) | (MyFgnCnstrRepTimes (G, proof, U1, U2, U3)) -> awakeTimes (G, proof, U1, U2, U3) | (MyFgnCnstrRepQuot (G, proof, U1, U2, U3)) -> awakeQuot (G, proof, U1, U2, U3) | fc -> raise ((UnexpectedFgnCnstr fc)))) in let _ = FgnCnstrStd.Simplify.install (csid, (fun (MyFgnCnstrRepPlus _) -> (fun () -> false) | (MyFgnCnstrRepTimes _) -> (fun () -> false) | (MyFgnCnstrRepQuot _) -> (fun () -> false) | fc -> raise ((UnexpectedFgnCnstr fc)))) in  () )
                                                                                                                                                                                          ^
Error: Syntax error: ) expected
File "lib/solvers/cs_integers_word.ml", line 183, characters 102-103:
183 | let rec installFgnCnstrOps ()  = ( let csid = ! myID in let _ = FgnCnstrStd.ToInternal.install (csid, (fun (MyFgnCnstrRepPlus (G, _, U1, U2, U3)) -> toInternalPlus (G, U1, U2, U3) | (MyFgnCnstrRepTimes (G, _, U1, U2, U3)) -> toInternalTimes (G, U1, U2, U3) | (MyFgnCnstrRepQuot (G, _, U1, U2, U3)) -> toInternalQuot (G, U1, U2, U3) | fc -> raise ((UnexpectedFgnCnstr fc)))) in let _ = FgnCnstrStd.Awake.install (csid, (fun (MyFgnCnstrRepPlus (G, proof, U1, U2, U3)) -> awakePlus (G, proof, U1, U2, U3) | (MyFgnCnstrRepTimes (G, proof, U1, U2, U3)) -> awakeTimes (G, proof, U1, U2, U3) | (MyFgnCnstrRepQuot (G, proof, U1, U2, U3)) -> awakeQuot (G, proof, U1, U2, U3) | fc -> raise ((UnexpectedFgnCnstr fc)))) in let _ = FgnCnstrStd.Simplify.install (csid, (fun (MyFgnCnstrRepPlus _) -> (fun () -> false) | (MyFgnCnstrRepTimes _) -> (fun () -> false) | (MyFgnCnstrRepQuot _) -> (fun () -> false) | fc -> raise ((UnexpectedFgnCnstr fc)))) in  () )
                                                                                                            ^
  This ( might be unmatched
File "lib/meta/inference.ml", line 61, characters 264-265:
61 | let rec forward = function (G, B, V) -> ( let _ = if ! Global.doubleCheck then TypeCheck.typeCheck (G, (V, I.Uni I.Type)) else () in let (Xs, (V', s')) = createEVars (G, (V, I.id)) in  try (match UniqueSearch.searchEx (2, Xs, fun [] -> [(Whnf.normalize (V', s'))] | _ -> raise (UniqueSearch.Error "Too many solutions")) with [VF''] -> Some VF'' | [] -> None) with UniqueSearch.Error _ -> None ) | (G, B, V) -> None
                                                                                                                                                                                                                                                                             ^
Error: Syntax error: ) expected
File "lib/meta/inference.ml", line 61, characters 218-219:
61 | let rec forward = function (G, B, V) -> ( let _ = if ! Global.doubleCheck then TypeCheck.typeCheck (G, (V, I.Uni I.Type)) else () in let (Xs, (V', s')) = createEVars (G, (V, I.id)) in  try (match UniqueSearch.searchEx (2, Xs, fun [] -> [(Whnf.normalize (V', s'))] | _ -> raise (UniqueSearch.Error "Too many solutions")) with [VF''] -> Some VF'' | [] -> None) with UniqueSearch.Error _ -> None ) | (G, B, V) -> None
                                                                                                                                                                                                                               ^
  This ( might be unmatched
File "lib/meta/prover.ml", line 23, characters 8-9:
23 |     (Mpi.MTPInit : Init.Mpi.MTPINIT)
             ^
Error: Syntax error
File "lib/worldcheck/worldify.ml", line 32, characters 7-8:
32 |     (Cs.CSManager : Cs.Cs_manager.CS_MANAGER)
            ^
Error: Syntax error
File "lib/prover/search.ml", line 39, characters 7-8:
39 |     (Cs.CSManager : Cs.Cs_manager.CS_MANAGER) : SEARCH = struct
            ^
Error: Syntax error
File "lib/prover/stateprint.ml", line 106, characters 63-64:
106 | let rec formatState (S.State (W, Psi, P, F, _))  = Fmt.Vbox0 0 1 [Fmt.String "------------------------"; Fmt.Break; Fmt.String "------------------------"; Fmt.Break; TomegaPrint.formatPrg (Psi, P)]
                                                                     ^
Error: Syntax error: end expected
File "lib/prover/stateprint.ml", line 26, characters 213-219:
26 | module StatePrint (Global : Global.GLOBAL) (State' : State.STATE) (Names : Names.NAMES) (Formatter' : Formatter.FORMATTER) (Print : Print.PRINT) (TomegaPrint : Tomega.Tomegaprint.TOMEGAPRINT) : State.STATEPRINT = struct module Formatter = Formatter'
                                                                                                                                                                                                                          ^^^^^^
  This struct might be unmatched
File "lib/frontend/lexer.ml", line 16, characters 11-12:
16 |     | Paths.PATHSEP
                ^
Error: Syntax error: end expected
File "lib/frontend/lexer.ml", line 5, characters 20-23:
5 | module type LEXER = sig
                        ^^^
  This sig might be unmatched
File "lib/frontend/recon_module.ml", line 33, characters 55-61:
33 |   type structDec = StructDec of string option * ModSyn.module * whereclause list | StructDef of string option * IntSyn.mid
                                                            ^^^^^^
Error: Syntax error
File "lib/frontend/recon_query.ml", line 102, characters 27-28:
102 | let rec finishSolve (solve (nameOpt, tm, r), U, V)  = ( (* is this necessary? -kw *)
                                 ^
Error: Syntax error: ) expected
File "lib/frontend/recon_query.ml", line 102, characters 20-21:
102 | let rec finishSolve (solve (nameOpt, tm, r), U, V)  = ( (* is this necessary? -kw *)
                          ^
  This ( might be unmatched
File "lib/tomega/tomegaprint.ml", line 348, characters 349-350:
348 | and formatTuple (Psi, P)  = ( let rec formatTuple' = function (T.Unit) -> [] | (T.PairExp (M, T.Unit)) -> [Print.formatExp (T.coerceCtx Psi, M)] | (T.PairExp (M, P')) -> (Print.formatExp (T.coerceCtx Psi, M) :: Fmt.String "," :: Fmt.Break :: formatTuple' P') in  match P with (T.PairExp (_, T.Unit)) -> Fmt.Hbox (formatTuple' P) | _ -> Fmt.HVbox0 1 1 1 (Fmt.String "(" :: (formatTuple' P @ [Fmt.String ")"])) )
                                                                                                                                                                                                                                                                                                                                                                   ^
Error: Syntax error: ) expected
File "lib/tomega/tomegaprint.ml", line 348, characters 28-29:
348 | and formatTuple (Psi, P)  = ( let rec formatTuple' = function (T.Unit) -> [] | (T.PairExp (M, T.Unit)) -> [Print.formatExp (T.coerceCtx Psi, M)] | (T.PairExp (M, P')) -> (Print.formatExp (T.coerceCtx Psi, M) :: Fmt.String "," :: Fmt.Break :: formatTuple' P') in  match P with (T.PairExp (_, T.Unit)) -> Fmt.Hbox (formatTuple' P) | _ -> Fmt.HVbox0 1 1 1 (Fmt.String "(" :: (formatTuple' P @ [Fmt.String ")"])) )
                                  ^
  This ( might be unmatched
File "lib/frontend/solve.ml", line 41, characters 13-23:
41 | module Solve ReconQuery.queryParser.ExtQuery.query ReconQuery.solveParser.ExtQuery.solve ReconQuery.defineParser.ExtQuery.define (Global : Global.GLOBAL) (Names : Names.NAMES) (Parser : Parse_prg.Parser.PARSER) (ReconQuery : Recon_query.RECON_QUERY) (Timers : Timers.TIMERS) (Compile : Compile.COMPILE) (CPrint : Cprint.CPRINT) (AbsMachine : Absmachine.ABSMACHINE) (AbsMachineSbt : Absmachine.Absmachine_sbt.ABSMACHINESBT) (PtRecon : Ptrecon.PTRECON) (Tabled : Tabled.Table.TABLED) (Print : Print.PRINT) (Msg : Msg.MSG) : SOLVE = struct (*! structure IntSyn = IntSyn' !*)
                  ^^^^^^^^^^
Error: Syntax error
File "lib/delphin/interface.ml", line 34, characters 33-34:
34 | let rec error (errmsg, line : pos, _)  = TextIO.output (TextIO.stdOut, "Line " ^ (Int.toString (line)) ^ ": " ^ errmsg ^ "\n")
                                      ^
Error: Syntax error: ) expected
File "lib/delphin/interface.ml", line 34, characters 14-15:
34 | let rec error (errmsg, line : pos, _)  = TextIO.output (TextIO.stdOut, "Line " ^ (Int.toString (line)) ^ ": " ^ errmsg ^ "\n")
                   ^
  This ( might be unmatched
File "lib/frontend/unknownexn.ml", line 7, characters 19-22:
7 | module UnknownExn (val exnHistory : exn -> string list) : UNKNOWN_EXN = struct let rec unknownExn exn  = ( let history = rev (exnHistory exn) in let rec wrap1 x  = "  raised at: " ^ x ^ "\n" in let rec wrapn x  = "             " ^ x ^ "\n" in  concat ("Unrecognized exception " :: (exnName exn) :: "\n" :: (match history with [] -> [""] | x :: xs -> (wrap1 x :: map wrapn xs))) )
                       ^^^
Error: Syntax error
File "lib/frontend/twelf.ml", line 218, characters 13-22:
218 | module Twelf ReconTerm.termParser.ExtSyn.term ReconConDec.condecParser.ExtConDec.condec ReconMode.modedecParser.ExtModes.modedec Solve.ExtQuery.queryParser.ExtQuery.query Solve.ExtQuery.defineParser.ExtQuery.define Solve.ExtQuery.solveParser.ExtQuery.solve Fquery.ExtQuery.queryParser.ExtQuery.query Fquery.ExtQuery.defineParser.ExtQuery.define Fquery.ExtQuery.solveParser.ExtQuery.solve ReconThm.tdeclParser.ThmExtSyn.tdecl ReconThm.rdeclParser.ThmExtSyn.rdecl ReconThm.tableddeclParser.ThmExtSyn.tableddecl ReconThm.keepTabledeclParser.ThmExtSyn.keepTabledecl ReconThm.wdeclParser.ThmExtSyn.wdecl ReconThm.theoremParser.ThmExtSyn.theorem ReconThm.theoremdecParser.ThmExtSyn.theoremdec ReconThm.proveParser.ThmExtSyn.prove ReconThm.establishParser.ThmExtSyn.establish ReconThm.assertParser.ThmExtSyn.assert_ml ReconModule.sigdefParser.ModExtSyn.sigdef ReconModule.structdecParser.ModExtSyn.structdec ReconModule.sigexpParser.ModExtSyn.sigexp ReconModule.strexpParser.ModExtSyn.strexp (Global : Global.GLOBAL) (Timers : Timers.TIMERS) (Whnf : Whnf.WHNF) (Print : Print.PRINT) (Names : Names.NAMES) (Origins : Origins.ORIGINS) (Lexer : Lexer.LEXER) (Parser : Parse_prg.Parser.PARSER) (TypeCheck : Typecheck.TYPECHECK) (Strict : Strict.STRICT) (Constraints : Constraints.CONSTRAINTS) (Abstract : Abstract.ABSTRACT) (ReconTerm : Recon_term.RECON_TERM) (ReconConDec : Recon_condec.RECON_CONDEC) (ReconQuery : Recon_query.RECON_QUERY) (ModeTable : Modetable.MODETABLE) (ModeCheck : Modecheck.MODECHECK) (ReconMode : Recon_mode.RECON_MODE) (ModePrint : Modeprint.MODEPRINT) (ModeDec : Modedec.MODEDEC) (StyleCheck : Style.STYLECHECK) (Unique : Unique.UNIQUE) (UniqueTable : Modetable.MODETABLE) (Cover : Cover.COVER) (Converter : Conv.Converter.CONVERTER) (TomegaPrint : Tomega.Tomegaprint.TOMEGAPRINT) (TomegaCoverage : Tomega.Coverage.TOMEGACOVERAGE) (TomegaTypeCheck : Tomega.Typecheck.TOMEGATYPECHECK) (Total : Total.TOTAL) (Reduces : Reduces.REDUCES) (Index : Index.INDEX) (IndexSkolem : Index.INDEX) (Subordinate : Subordinate.SUBORDINATE) (Compile : Compile.COMPILE) (AbsMachine : Absmachine.ABSMACHINE) (Tabled : Tabled.Table.TABLED) (Solve : Solve.SOLVE) (Fquery : Fquery.FQUERY) (ThmSyn : Thm.Thmsyn.THMSYN) (Thm : Thm.THM) (ReconThm : Recon_thm.RECON_THM) (ThmPrint : Thm.Thmprint.THMPRINT) (TabledSyn : Tabled.Table.Tabledsyn.TABLEDSYN) (WorldSyn : Worldsyn.WORLDSYN) (Worldify : Worldify.WORLDIFY) (ModSyn : Modsyn.MODSYN) (ReconModule : Recon_module.RECON_MODULE) (MetaGlobal : Meta_global.METAGLOBAL) (Skolem : Skolem.SKOLEM) (Prover : Prover.PROVER) (ClausePrint : Clause_print.CLAUSEPRINT) (Trace : Trace.TRACE) (PrintTeX : Print.PRINT) (ClausePrintTeX : Clause_print.CLAUSEPRINT) (Cs.CSManager : Cs.Cs_manager.CS_MANAGER) (Cs.CSInstaller : Cs.Solvers.CS_INSTALLER) (Compat : Compat.COMPAT) (UnknownExn : Unknownexn.UNKNOWN_EXN) (Msg : Msg.MSG) : TWELF = struct (*! structure IntSyn = IntSyn' !*)
                   ^^^^^^^^^
Error: Syntax error
File "lib/delphin/parse_prg.ml", line 20, characters 13-20:
20 | module Parse Parserr.argInterface.arg Parserr.posInterface.pos Parserr.resultDextSyn.ast Tokens.tokenParserr.Token.token Tokens.svalueParserr.svalue (DextSyn : Dextsyn.DEXTSYN) (Interface : Interface.INTERFACE) (Parserr : Parser.PARSERR) (Tokens : Delphin_TOKENS) : PARSE = struct module DextSyn = DextSyn
                  ^^^^^^^
Error: Syntax error
File "lib/frontend/recon_term.ml", line 277, characters 46-48:
277 | type bidi = Elim of IntSyn.sub * IntSyn.spine -> IntSyn.exp | Intro of IntSyn.exp
                                                    ^^
Error: Syntax error: end expected
File "lib/frontend/recon_term.ml", line 142, characters 189-195:
142 | module ReconTerm (Names : Names.NAMES) (Approx : Approx.APPROX) (Whnf : Whnf.WHNF) (Unify : Unify.UNIFY) (Abstract : Abstract.ABSTRACT) (Print : Print.PRINT) (Msg : Msg.MSG) : RECON_TERM = struct (*! structure IntSyn = IntSyn' !*)
                                                                                                                                                                                                   ^^^^^^
  This struct might be unmatched
File "lib/compat/path.ml", line 13, characters 23-27:
Error: Unbound record field path
File "lib/compat/array.ml", line 6, characters 38-49:
Error: Unbound type constructor Array.array
File "lib/compat/time_limit.ml", line 4, characters 18-22:
Error: Unbound module Time
File "lib/compat/socket.ml", line 7, characters 38-44:
Error: Unbound module Socket
File "lib/compat/substring.ml", line 6, characters 23-32:
Error: Unbound module Substring
Hint:    Did you mean String?
File "lib/compat/text_io.ml", line 6, characters 18-24:
Error: Unbound module TextIO
File "lib/compat/timer.ml", line 6, characters 22-27:
Error: Unbound module Timer
File "lib/domains/ordered_field.ml", line 17, characters 35-40:
Error: Unbound type constructor order
File "lib/compat/vector.ml", line 6, characters 38-44:
Error: Unbound module Vector
File "lib/domains/integers_mod.ml", line 9, characters 25-37:
Error: Unbound value Int.toString
Hint:   Did you mean Int.to_string?
File "lib/compat/word8_array_slice.ml", line 9, characters 15-25:
Error: Unbound module Word8Array
File "lib/domains/integers.ml", line 6, characters 10-17:
Error: Unbound module type INTEGER
