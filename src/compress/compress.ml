Compress  Global GLOBAL     struct module module module exception exception (* modes are not appropriate for the given I.ConDec *)
let  inlet rec sgnReset() clear ()(* xlate_type : IntSyn.Exp -> Syntax.tp *)
let rec xlate_type(pi ((dec (_,  , e1),  , _),  , e2)) tPi (mINUS,  , xlate_type e1,  , xlate_type e2) xlate_type(root (const cid,  , sp)) tRoot (cid,  , xlate_spine sp) xlate_type(root (def cid,  , sp)) tRoot (cid,  , xlate_spine sp) xlate_type(root (nSDef cid,  , sp)) tRoot (cid,  , xlate_spine sp) xlate_type(lam (_,  , t)) xlate_type t(* for type definitions, simply strip off the lambdas and leave
                                                   the variables free*)
 xlate_spinenil [] xlate_spine(app (e,  , s)) xlate_spinelt e :: xlate_spine s xlate_spinelte elt (xlate_term e) xlate_term(root (const cid,  , sp)) aTerm (aRoot (const cid,  , xlate_spine sp)) xlate_term(root (def cid,  , sp)) aTerm (aRoot (const cid,  , xlate_spine sp)) xlate_term(root (nSDef cid,  , sp)) aTerm (aRoot (const cid,  , xlate_spine sp)) xlate_term(root (bVar vid,  , sp)) aTerm (aRoot (var (vid - 1),  , xlate_spine sp)) xlate_term(lam (_,  , e)) nTerm (lam (xlate_term e))(* xlate_kind : IntSyn.Exp -> Syntax.knd *)
let rec xlate_kind(pi ((dec (_,  , e1),  , _),  , e2)) kPi (mINUS,  , xlate_type e1,  , xlate_kind e2) xlate_kind(uni (type)) typeopen Syntax (* simple skeletal form of types
     omits all dependencies, type constants *)
type Simple_tplet rec simplify_tp(tPi (_,  , t1,  , t2)) arrow (simplify_tp t1,  , simplify_tp t2) simplify_tp(tRoot _) baselet rec simplify_knd(kPi (_,  , t1,  , k2)) arrow (simplify_tp t1,  , simplify_knd k2) simplify_knd(type) base(* hereditarily perform some eta-expansions on
     a (term, type, spine, etc.) in a context
    (and if not synthesizing) at a simple type.

    The only type of eta-expansion performed is when we
    encounter
    x . (M_1, M_2, ... M_n)
    for a variable x, and M_1, ..., M_n have fewer lambda abstractions
    than their (skeletal) type would suggest.

    The complication with doing full eta-expansion is that if
    we were to wrap lambda abstractions around terms that occur
    in a synthesizing position, we would need to add ascriptions,
    and thus carry full types around everywhere.

    Fortunately, this weakened form of eta-expansion is all
    we need to reconcile the discrepancy between what twelf
    maintains as an invariant, and full eta-longness. *)
let rec eta_expand_termg(nTerm t)t nTerm (eta_expand_nterm g t t) eta_expand_termg(aTerm t)t aTerm (eta_expand_aterm g t) eta_expand_ntermg(lam t)(arrow (t1,  , t2)) lam (eta_expand_term (t1 :: g) t t2) eta_expand_ntermg(nRoot (h,  , s))t nRoot (h,  , eta_expand_spine g s t) eta_expand_ntermg(lam t)base raise (syntax "Lambda occurred where term of base type expected") eta_expand_atermg(aRoot (const n,  , s)) let let  in in aRoot (const n,  , eta_expand_spine g s stp) eta_expand_atermg(aRoot (var n,  , s)) let let  in in aRoot (var n,  , eta_expand_var_spine g s stp) eta_expand_atermg(eRoot _) raise (syntax "invariant violated in eta_expand_aterm") eta_expand_tpg(tRoot (n,  , s)) let let  in in tRoot (n,  , eta_expand_spine g s stp) eta_expand_tpg(tPi (m,  , a,  , b)) tPi (m,  , eta_expand_tp g a,  , eta_expand_tp (simplify_tp a :: g) b) eta_expand_kndg(type) type eta_expand_kndg(kPi (m,  , a,  , b)) kPi (m,  , eta_expand_tp g a,  , eta_expand_knd (simplify_tp a :: g) b) eta_expand_spineg[]base [] eta_expand_spineg((elt m) :: tl)(arrow (t1,  , t2)) elt (eta_expand_term g m t1) :: eta_expand_spine g tl t2 eta_expand_spineg((aElt m) :: tl)(arrow (t1,  , t2)) aElt (eta_expand_aterm g m) :: eta_expand_spine g tl t2 eta_expand_spineg((ascribe (m,  , a)) :: tl)(arrow (t1,  , t2)) ascribe (eta_expand_nterm g m t1,  , eta_expand_tp g a) :: eta_expand_spine g tl t2 eta_expand_spineg(omit :: tl)(arrow (t1,  , t2)) omit :: eta_expand_spine g tl t2 eta_expand_spine___ raise (syntax "Can't figure out how to eta expand spine")(* the behavior here is that we are eta-expanding all of the elements of the spine, not the head of *this* spine *)
 eta_expand_var_spineg[]_ [] eta_expand_var_spineg((elt m) :: tl)(arrow (t1,  , t2)) elt (eta_expand_immediate (eta_expand_term g m t1,  , t1)) :: eta_expand_spine g tl t2 eta_expand_var_spine___ raise (syntax "Can't figure out how to eta expand var-headed spine")(* here's where the actual expansion takes place *)
 eta_expand_immediate(m,  , base) m eta_expand_immediate(nTerm (lam m),  , arrow (t1,  , t2)) nTerm (lam (eta_expand_immediate (m,  , t2))) eta_expand_immediate(m,  , arrow (t1,  , t2)) let let  in in nTerm (lam (eta_expand_immediate (apply_to (shift m,  , variable),  , t2))) apply_to(aTerm (aRoot (h,  , s)),  , m) aTerm (aRoot (h,  , s @ [elt m])) apply_to(nTerm (nRoot (h,  , s)),  , m) nTerm (nRoot (h,  , s @ [elt m])) apply_to_ raise (syntax "Invariant violated in apply_to")let  inlet  inexception (* val compress_type : Syntax.tp list -> Syntax.mode list option * Syntax.tp -> Syntax.tp *)
(* the length of the mode list, if there is one, should correspond to the number of pis in the input type.
    however, as indicated in the XXX comment below, it seems necessary to treat SOME of empty list
    as if it were NONE. This doesn't seem right. *)
let rec compress_typegs compress_type' g s(* else  (if !debug = 0 then raise Debug(G, s) else ();
                                debug := !debug - 1; compress_type' G s) *)
 compress_type'g(nONE,  , tPi (_,  , a,  , b)) tPi (mINUS,  , compress_type g (nONE,  , a),  , compress_type (a :: g) (nONE,  , b)) compress_type'g(sOME (m :: ms),  , tPi (_,  , a,  , b)) tPi (m,  , compress_type g (nONE,  , a),  , compress_type (a :: g) (sOME ms,  , b)) compress_type'g(sOME [],  , tRoot (cid,  , sp)) tRoot (cid,  , compress_type_spine g (sp,  , kindOf (o_classifier cid),  , kindOf (classifier cid))) compress_type'g(nONE,  , a as tRoot _) compress_type g (sOME [],  , a) compress_type'g(sOME [],  , a as tPi _) compress_type g (nONE,  , a)(* XXX sketchy *)
(* XXX: optimization: don't compute mstar if omit? *)
 compress_type_spineg([],  , w,  , wstar) [] compress_type_spineg((elt m) :: sp,  , kPi (_,  , a,  , v),  , kPi (mode,  , astar,  , vstar)) let let  inlet  in in match (mode,  , mstar) with (oMIT,  , _) -> omit :: sstar (mINUS,  , _) -> elt mstar :: sstar (pLUS,  , aTerm t) -> aElt t :: sstar (pLUS,  , nTerm t) -> ascribe (t,  , compress_type g (nONE,  , a)) :: sstar compress_spineg([],  , w,  , wstar) [] compress_spineg((elt m) :: sp,  , tPi (_,  , a,  , v),  , tPi (mode,  , astar,  , vstar)) let let  inlet  in in match (mode,  , mstar) with (oMIT,  , _) -> omit :: sstar (mINUS,  , _) -> elt mstar :: sstar (pLUS,  , aTerm t) -> aElt t :: sstar (pLUS,  , nTerm t) -> ascribe (t,  , compress_type g (nONE,  , a)) :: sstar compress_termg(aTerm (aRoot (var n,  , sp)),  , _) let let  inlet  in in aTerm (aRoot (var n,  , compress_spine g (sp,  , a,  , astar))) compress_termg(aTerm (aRoot (const n,  , sp)),  , _) let let  inlet  inlet  in in term_former (const n,  , compress_spine g (sp,  , a,  , astar)) compress_termg(nTerm (lam t),  , tPi (_,  , a,  , b)) nTerm (lam (compress_term (a :: g) (t,  , b)))let rec compress_kindg(nONE,  , kPi (_,  , a,  , k)) kPi (mINUS,  , compress_type g (nONE,  , a),  , compress_kind (a :: g) (nONE,  , k)) compress_kindg(sOME (m :: ms),  , kPi (_,  , a,  , k)) kPi (m,  , compress_type g (nONE,  , a),  , compress_kind (a :: g) (sOME ms,  , k)) compress_kindg(sOME [],  , type) type compress_kindg(nONE,  , type) type(* compress : cid * IntSyn.ConDec -> ConDec *)
let rec compress(cid,  , conDec (name,  , nONE,  , _,  , normal,  , a,  , type)) let let  inlet  inlet  in in condec (name,  , compress_type [] (modes,  , x),  , x) compress(cid,  , conDec (name,  , nONE,  , _,  , normal,  , k,  , kind)) let let  inlet  in in tycondec (name,  , compress_kind [] (modes,  , x),  , x) compress(cid,  , conDef (name,  , nONE,  , _,  , m,  , a,  , type,  , _)) let let  inlet  inlet  inlet  in in defn (name,  , astar,  , a,  , mstar,  , m) compress(cid,  , conDef (name,  , nONE,  , _,  , a,  , k,  , kind,  , _)) let let  inlet  inlet  inlet  in in tydefn (name,  , kstar,  , k,  , astar,  , a) compress(cid,  , abbrevDef (name,  , nONE,  , _,  , m,  , a,  , type)) let let  inlet  inlet  inlet  in in abbrev (name,  , astar,  , a,  , mstar,  , m) compress(cid,  , abbrevDef (name,  , nONE,  , _,  , a,  , k,  , kind)) let let  inlet  inlet  inlet  in in tyabbrev (name,  , kstar,  , k,  , astar,  , a) compress_ raise (unimp)let rec sgnLookup(cid) let let  in in match c with nONE -> let let  inlet  inlet  in in c' sOME x -> x(*  val sgnApp  = IntSyn.sgnApp

  fun sgnCompress () = sgnApp (ignore o sgnLookup) *)
let rec sgnCompressUpTox if x < 0 then () else (sgnCompressUpTo (x - 1); sgnLookup x; ())let  inlet rec extractf (try  with )let  in(* val log : Sgn.sigent list ref = ref [] *)
(* given a cid, pick some vaguely plausible omission modes *)
let rec naiveModescid let let  inlet rec count_args(pi (_,  , ak')) 1 + count_args ak' count_args_ 0let  inlet rec can_omitms let let  inlet  inlet  in(*                val _ = if true then log := !log @ [s] else () *)
let  in(*                val _ = if isValid then print "yup\n" else print "nope\n" *)
 in isValidlet rec optimize'ms[] rev ms optimize'ms(pLUS :: ms') if can_omit ((rev ms) @ (mINUS :: ms')) then optimize' (mINUS :: ms) ms' else optimize' (pLUS :: ms) ms' optimize'ms(mINUS :: ms') if can_omit ((rev ms) @ (oMIT :: ms')) then optimize' (oMIT :: ms) ms' else optimize' (mINUS :: ms) ms'let rec optimizems optimize' [] ms in if uni = kind then tabulate (total_args,  , (fun _ -> mINUS)) else optimize (tabulate (total_args,  , (fun x -> if x < omitted_args then mINUS else pLUS)))(* Given a cid, return the "ideal" modes specified by twelf-
     omitted arguments. It is cheating to really use these for
     compression: the resulting signature will not typecheck. *)
let rec idealModescid let let  inlet rec count_args(pi (_,  , ak')) 1 + count_args ak' count_args_ 0let  in in tabulate (total_args,  , (fun x -> if x < omitted_args then oMIT else mINUS))(* not likely to work if the mode-setting function f actually depends on
   properties of earlier sgn entries *)
let rec setModesUpToxf if x < 0 then () else (setModesUpTo (x - 1) f; set_modes (x,  , f x); ())let rec sgnAutoCompressnf (try  with )let rec sgnAutoCompressUpTo'n0nf if n0 > n then () else let let  in in sgnAutoCompressUpTo' (n0 + 1) n flet rec sgnAutoCompressUpTonf sgnAutoCompressUpTo' 0 n flet  inend