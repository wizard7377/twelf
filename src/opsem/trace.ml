Trace  Names NAMES    Whnf WHNF    Abstract ABSTRACT    Print PRINT     TRACE  struct (*! structure IntSyn = IntSyn' !*)
module module module (* Printing Utilities *)
let rec headToString(g,  , const (c)) qidToString (constQid c) headToString(g,  , def (d)) qidToString (constQid d) headToString(g,  , bVar (k)) bvarName (g,  , k)let rec expToString(gU) expToString (gU) ^ ". "let rec decToString(gD) decToString (gD) ^ ". "let rec eqnToString(g,  , u1,  , u2) expToString (g,  , u1) ^ " = " ^ expToString (g,  , u2) ^ ". "let rec newline() print "\n"let rec printCtx(null) print "No hypotheses or parameters. " printCtx(decl (null,  , d)) print (decToString (null,  , d)) printCtx(decl (g,  , d)) (printCtx (g); newline (); print (decToString (g,  , d)))let rec evarsToString(xnames) let let  inlet  in in match constrOpt with nONE -> inst sOME (constr) -> inst ^ "\nConstraints:\n" ^ constrlet rec varsToEVarInst(nil) nil varsToEVarInst(name :: names) match getEVarOpt name with nONE -> (print ("Trace warning: ignoring unknown variable " ^ name ^ "\n"); varsToEVarInst (names)) sOME (x) -> (x,  , name) :: varsToEVarInst (names)let rec printVars(names) print (evarsToString (varsToEVarInst names))let rec printVarstring(line) printVars (tl (tokens isSpace line))type Speclet  inlet  inlet rec trace(none) traceSpec := none trace(some (names)) traceSpec := some (names) trace(all) traceSpec := alllet rec break(none) breakSpec := none break(some (names)) breakSpec := some (names) break(all) breakSpec := alllet  inlet rec setDetail(nONE) print ("Trace warning: detail is not a valid integer\n") setDetail(sOME (n)) if 0 <= n(* andalso n <= 2 *)
 then detail := n else print ("Trace warning: detail must be positive\n")let  inlet  inlet rec toCids(nil) nil toCids(name :: names) (match stringToQid name with nONE -> (print ("Trace warning: ignoring malformed qualified identifier " ^ name ^ "\n"); toCids names) sOME qid -> (match constLookup qid with nONE -> (print ("Trace warning: ignoring undeclared constant " ^ qidToString qid ^ "\n"); toCids names) sOME cid -> cid :: toCids names))let rec initTrace(none) traceTSpec := none initTrace(some (names)) traceTSpec := some (toCids names) initTrace(all) traceTSpec := alllet rec initBreak(none) breakTSpec := none initBreak(some (names)) breakTSpec := some (toCids names) initBreak(all) breakTSpec := alllet rec printHelp() print "<newline> - continue --- execute with current settings\n\
\n - next --- take a single step\n\
\r - run --- remove all breakpoints and continue\n\
\s - skip --- skip until current subgoals succeeds, is retried, or fails\n\
\s n - skip to n --- skip until goal (n) is considered\n\
\t - trace --- trace all events\n\
\u - untrace --- trace no events\n\
\d n - detail --- set trace detail to n (0, 1, or 2)\n\
\h - hypotheses --- show current hypotheses\n\
\g - goal --- show current goal\n\
\i - instantiation --- show instantiation of variables in current goal\n\
\v X1 ... Xn - variables --- show instantiation of X1 ... Xn\n\
\? for help"let  in(* dummy initialization *)
let  inlet rec setEVarInst(xs) currentEVarInst := map (fun x -> (x,  , evarName (null,  , x))) xslet rec setGoal(g,  , v) (currentGoal := (g,  , v); setEVarInst (collectEVars (g,  , (v,  , id),  , nil)))type GoalTaglet  inlet rec tagGoal() match ! tag with nONE -> nONE sOME (n) -> (tag := sOME (n + 1); ! tag)let  inlet rec initTag() (watchForTag := nONE; match (! traceTSpec,  , ! breakTSpec) with (none,  , none) -> tag := nONE _ -> tag := sOME (0))let rec setWatchForTag(nONE) (watchForTag := ! tag) setWatchForTag(sOME (n)) (watchForTag := sOME (n))let rec breakAction(g) let let  inlet  in in match sub (line,  , 0) with '\n' -> () 'n' -> (breakTSpec := all) 'r' -> (breakTSpec := none) 's' -> (setWatchForTag (fromString (extract (line,  , 1,  , nONE)))) 't' -> (traceTSpec := all; print "% Now tracing all"; breakAction (g)) 'u' -> (traceTSpec := none; print "% Now tracing none"; breakAction (g)) 'd' -> (setDetail (fromString (extract (line,  , 1,  , nONE))); print ("% Trace detail now " ^ toString (! detail)); breakAction (g)) 'h' -> (printCtx g; breakAction (g)) 'g' -> (print (expToString (! currentGoal)); breakAction (g)) 'i' -> (print (evarsToString (rev (! currentEVarInst))); breakAction (g)) 'v' -> (printVarstring (line); breakAction (g)) '?' -> (printHelp (); breakAction (g)) _ -> (print "unrecognized command (? for help)"; breakAction (g))let rec init() (initTrace (! traceSpec); initBreak (! breakSpec); initTag ())type Event(* failure message *)
let rec eventToString(g,  , introHyp (_,  , d)) "% Introducing hypothesis\n" ^ decToString (g,  , d) eventToString(g,  , dischargeHyp (_,  , dec (sOME (x),  , _))) "% Discharging hypothesis " ^ x eventToString(g,  , introParm (_,  , d)) "% Introducing parameter\n" ^ decToString (g,  , d) eventToString(g,  , dischargeParm (_,  , dec (sOME (x),  , _))) "% Discharging parameter " ^ x eventToString(g,  , resolved (hc,  , ha)) "% Resolved with clause " ^ headToString (g,  , hc) ^ "\n" ^ evarsToString (rev (! currentEVarInst)) eventToString(g,  , subgoal ((hc,  , ha),  , msg)) "% Solving subgoal (" ^ toString (msg ()) ^ ") of clause " ^ headToString (g,  , hc) eventToString(g,  , solveGoal (sOME (tag),  , _,  , v)) "% Goal " ^ toString tag ^ ":\n" ^ expToString (g,  , v) eventToString(g,  , succeedGoal (sOME (tag),  , _,  , v)) "% Goal " ^ toString tag ^ " succeeded" eventToString(g,  , commitGoal (sOME (tag),  , _,  , v)) "% Goal " ^ toString tag ^ " committed to first solution" eventToString(g,  , retryGoal (sOME (tag),  , (hc,  , ha),  , v)) "% Backtracking from clause " ^ headToString (g,  , hc) ^ "\n" ^ "% Retrying goal " ^ toString tag ^ ":\n" ^ expToString (g,  , v) eventToString(g,  , failGoal (sOME (tag),  , _,  , v)) "% Failed goal " ^ toString tag eventToString(g,  , unify ((hc,  , ha),  , q,  , p)) "% Trying clause " ^ headToString (g,  , hc) ^ "\n" ^ eqnToString (g,  , q,  , p) eventToString(g,  , failUnify ((hc,  , ha),  , msg)) "% Unification failed with clause " ^ headToString (g,  , hc) ^ ":\n" ^ msglet rec traceEvent(g,  , e) print (eventToString (g,  , e))let rec monitorHead(cids,  , const (c)) exists (fun c' -> c = c') cids monitorHead(cids,  , def (d)) exists (fun c' -> d = c') cids monitorHead(cids,  , bVar (k)) falselet rec monitorHeads(cids,  , (hc,  , ha)) monitorHead (cids,  , hc) || monitorHead (cids,  , ha)let rec monitorEvent(cids,  , introHyp (h,  , _)) monitorHead (cids,  , h) monitorEvent(cids,  , dischargeHyp (h,  , _)) monitorHead (cids,  , h) monitorEvent(cids,  , introParm (h,  , _)) monitorHead (cids,  , h) monitorEvent(cids,  , dischargeParm (h,  , _)) monitorHead (cids,  , h) monitorEvent(cids,  , solveGoal (_,  , h,  , v)) monitorHead (cids,  , h) monitorEvent(cids,  , succeedGoal (_,  , (hc,  , ha),  , _)) monitorHeads (cids,  , (hc,  , ha)) monitorEvent(cids,  , commitGoal (_,  , (hc,  , ha),  , _)) monitorHeads (cids,  , (hc,  , ha)) monitorEvent(cids,  , retryGoal (_,  , (hc,  , ha),  , _)) monitorHeads (cids,  , (hc,  , ha)) monitorEvent(cids,  , failGoal (_,  , h,  , _)) monitorHead (cids,  , h) monitorEvent(cids,  , resolved (hc,  , ha)) monitorHeads (cids,  , (hc,  , ha)) monitorEvent(cids,  , subgoal ((hc,  , ha),  , _)) monitorHeads (cids,  , (hc,  , ha)) monitorEvent(cids,  , unify ((hc,  , ha),  , _,  , _)) monitorHeads (cids,  , (hc,  , ha)) monitorEvent(cids,  , failUnify ((hc,  , ha),  , _)) monitorHeads (cids,  , (hc,  , ha))let rec monitorDetail(unify _) ! detail >= 2 monitorDetail(failUnify _) ! detail >= 2 monitorDetail_ ! detail >= 1(* expensive if tracing Unify! *)
(* but: maintain only if break or trace is on *)
(* may not be sufficient for some information *)
let rec maintain(g,  , solveGoal (_,  , _,  , v)) setGoal (g,  , v) maintain(g,  , retryGoal (_,  , _,  , v)) setGoal (g,  , v) maintain(g,  , failGoal (_,  , _,  , v)) setGoal (g,  , v) maintain(g,  , unify (_,  , q,  , p)) setEVarInst (collectEVars (g,  , (p,  , id),  , collectEVars (g,  , (q,  , id),  , nil))) maintain_ ()let rec monitorBreak(none,  , g,  , e) false monitorBreak(some (cids),  , g,  , e) if monitorEvent (cids,  , e) then (maintain (g,  , e); traceEvent (g,  , e); breakAction (g); true) else false monitorBreak(all,  , g,  , e) (maintain (g,  , e); traceEvent (g,  , e); breakAction (g); true)let rec monitorTrace(none,  , g,  , e) false monitorTrace(some (cids),  , g,  , e) if monitorEvent (cids,  , e) then (maintain (g,  , e); traceEvent (g,  , e); newline (); true) else false monitorTrace(all,  , g,  , e) (maintain (g,  , e); traceEvent (g,  , e); newline (); true)let rec watchFor(e) match ! watchForTag with nONE -> false sOME (t) -> (match e with solveGoal (sOME (t'),  , _,  , _) -> (t' = t) succeedGoal (sOME (t'),  , _,  , _) -> (t' = t) commitGoal (sOME (t'),  , _,  , _) -> (t' = t) retryGoal (sOME (t'),  , _,  , _) -> (t' = t) failGoal (sOME (t'),  , _,  , _) -> (t' = t) _ -> false)let rec skipping() match ! watchForTag with nONE -> false sOME _ -> truelet rec signal(g,  , e) if monitorDetail (e) then if skipping () then if watchFor (e) then (watchForTag := nONE; signal (g,  , e)) else (monitorTrace (! traceTSpec,  , g,  , e); ()) else if monitorBreak (! breakTSpec,  , g,  , e)(* stops, continues after input *)
 then () else (monitorTrace (! traceTSpec,  , g,  , e); ())(* prints trace, continues *)
 else ()let rec showSpec(msg,  , none) print (msg ^ " = None\n") showSpec(msg,  , some (names)) (print (msg ^ " = Some ["); app (fun name -> print (" " ^ name)) names; print "]\n") showSpec(msg,  , all) print (msg ^ " = All\n")let rec tracing() (match (! traceSpec,  , ! breakSpec) with (none,  , none) -> false _ -> true)let rec show() (showSpec ("trace",  , ! traceSpec); showSpec ("break",  , ! breakSpec); print ("detail = " ^ toString (! detail) ^ "\n"))let rec reset() (trace (none); break (none); detail := 1)end