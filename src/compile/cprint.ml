CPrint  Print PRINT    Formatter FORMATTER    Print Formatter  Formatter   Names NAMES     CPRINT  struct (*! structure IntSyn = IntSyn' !*)
(*! structure CompSyn = CompSyn' !*)
open CompSyn let rec compose(null,  , g) g compose(decl (g,  , d),  , g') decl (compose (g,  , g'),  , d)(* goalToString (G, g) where G |- g  goal *)
let rec goalToStringt(g,  , atom (p)) t ^ "SOLVE   " ^ expToString (g,  , p) ^ "\n" goalToStringt(g,  , impl (p,  , a,  , _,  , g)) t ^ "ASSUME  " ^ expToString (g,  , a) ^ "\n" ^ (clauseToString (t ^ "\t") (g,  , p)) ^ goalToString t (decl (g,  , dec (nONE,  , a)),  , g) ^ "\n" goalToStringt(g,  , all (d,  , g)) let let  in in t ^ "ALL     " ^ makestring_fmt (formatDec (g,  , d')) ^ "\n" ^ goalToString t (decl (g,  , d'),  , g) ^ "\n"(* auxToString (G, r) where G |- r auxgoal *)
 auxToStringt(g,  , trivial) "" auxToStringt(g,  , unifyEq (g',  , p1,  , n,  , ga)) t ^ "UNIFYEqn  " ^ expToString (compose (g',  , g),  , p1) ^ " = " ^ expToString (compose (g',  , g),  , n) ^ "\n" ^ auxToString t (g,  , ga)(* clauseToString (G, r) where G |- r  resgoal *)
 clauseToStringt(g,  , eq (p)) t ^ "UNIFY   " ^ expToString (g,  , p) ^ "\n" clauseToStringt(g,  , assign (p,  , ga)) (t ^ "ASSIGN  " ^ (try  with ) ^ "\n" ^ (auxToString t (g,  , ga))) clauseToStringt(g,  , and (r,  , a,  , g)) clauseToString t (decl (g,  , dec (nONE,  , a)),  , r) ^ goalToString t (g,  , g) clauseToStringt(g,  , in (r,  , a,  , g)) let let  in in clauseToString t (decl (g,  , d),  , r) ^ t ^ "META    " ^ decToString (g,  , d) ^ "\n" ^ goalToString t (g,  , g) clauseToStringt(g,  , exists (d,  , r)) let let  in in t ^ "EXISTS  " ^ (try  with ) ^ "\n" ^ clauseToString t (decl (g,  , d'),  , r) clauseToStringt(g,  , axists (d as aDec (sOME (n),  , d),  , r)) let let  in in t ^ "EXISTS'  " ^ (try  with ) ^ "\n" ^ clauseToString t (decl (g,  , d'),  , r)let rec subgoalsToStringt(g,  , true) t ^ "True " subgoalsToStringt(g,  , conjunct (goal,  , a,  , sg)) t ^ goalToString t (decl (g,  , dec (nONE,  , a)),  , goal) ^ " and " ^ subgoalsToString t (g,  , sg)(* conDecToString (c, clause) printed representation of static clause *)
let rec conDecToString(c,  , sClause (r)) let let  inlet  inlet  in in name ^ (if l > 6 then ":\n" else ":") ^ (clauseToString "\t" (null,  , r) ^ "\n") conDecToString(c,  , void) conDecToString (sgnLookup c) ^ "\n\n"(* sProgToString () = printed representation of static program *)
let rec sProgToString() let let  inlet rec ts(cid) if cid < size then conDecToString (cid,  , sProgLookup cid) ^ ts (cid + 1) else "" in ts 0(* dProgToString (G, dProg) = printed representation of dynamic program *)
let rec dProgToString(dProg (null,  , null)) "" dProgToString(dProg (decl (g,  , dec (sOME x,  , _)),  , decl (dPool,  , dec (r,  , _,  , _)))) dProgToString (dProg (g,  , dPool)) ^ "\nClause    " ^ x ^ ":\n" ^ clauseToString "\t" (g,  , r) dProgToString(dProg (decl (g,  , dec (sOME x,  , a)),  , decl (dPool,  , parameter))) dProgToString (dProg (g,  , dPool)) ^ "\nParameter " ^ x ^ ":\t" ^ expToString (g,  , a)(* case for CompSyn.BDec is still missing *)
(* local open ... *)
end