Assign  Whnf WHNF    Unify UNIFY    Print PRINT     ASSIGN  struct (*! structure IntSyn = IntSyn' !*)
exception open IntSyn (*
     templates
           p ::= Root(n, NIL) | Root(c, SP) | EVar (X, V) | AVar A |
                 Lam (D, p)
                   where X is uninstantiated and occurs uniquely
                   any multiple occurrence of X has been renamed to A.

                 any eta-expanded EVar remains an EVar
                 but it may be lowered during whnf (or in the special case here
                 expansion)

          SP ::= p ; SP | NIL

   *)
(* assignExpW (G, (U1, s1), (U2, s2)) = ()

     invariant:
     G |- s1 : G1    G1 |- U1 : V1   (U1, s1) in whnf
     G |- s2 : G2    G2 |- U2 : V2   (U2, s2) is template
  *)
let rec assignExpW(g,  , (uni l1,  , _),  , (uni l2,  , _),  , cnstr) cnstr assignExpW(g,  , us1 as (root (h1,  , s1),  , s1),  , us2 as (root (h2,  , s2),  , s2),  , cnstr) (match (h1,  , h2) with (const (c1),  , const (c2)) -> if (c1 = c2) then assignSpine (g,  , (s1,  , s1),  , (s2,  , s2),  , cnstr) else raise (assignment "Constant clash") (bVar (k1),  , bVar (k2)) -> if (k1 = k2) then assignSpine (g,  , (s1,  , s1),  , (s2,  , s2),  , cnstr) else raise (assignment "Bound variable clash") (skonst (c1),  , skonst (c2)) -> if (c1 = c2) then assignSpine (g,  , (s1,  , s1),  , (s2,  , s2),  , cnstr) else raise (assignment "Skolem constant clash") (def (d1),  , def (d2)) -> (* cannot occur by invariant; all definitions in clause heads have been
               replaced by AVars Tue Jun 18 19:47:39 2002 -bp *)
if (d1 = d2) then (* because of strict *)
assignSpine (g,  , (s1,  , s1),  , (s2,  , s2),  , cnstr) else assignExp (g,  , expandDef (us1),  , expandDef (us2),  , cnstr) (def d1,  , _) -> assignExp (g,  , expandDef us1,  , us2,  , cnstr) (_,  , def (d2)) -> (* cannot occur by invariant; all definitions in clause heads have been
               replaced by AVars Tue Jun 18 19:47:44 2002 -bp *)
assignExp (g,  , us1,  , expandDef us2,  , cnstr) (fgnConst (cs1,  , conDec (n1,  , _,  , _,  , _,  , _,  , _)),  , fgnConst (cs2,  , conDec (n2,  , _,  , _,  , _,  , _,  , _))) -> (* we require unique string representation of external constants *)
if (cs1 = cs2) && (n1 = n2) then cnstr else raise (assignment "Foreign Constant clash") (fgnConst (cs1,  , conDef (n1,  , _,  , _,  , w1,  , _,  , _,  , _)),  , fgnConst (cs2,  , conDef (n2,  , _,  , _,  , v,  , w2,  , _,  , _))) -> (if (cs1 = cs2) && (n1 = n2) then cnstr else assignExp (g,  , (w1,  , s1),  , (w2,  , s2),  , cnstr)) (fgnConst (_,  , conDef (_,  , _,  , _,  , w1,  , _,  , _,  , _)),  , _) -> assignExp (g,  , (w1,  , s1),  , us2,  , cnstr) (_,  , fgnConst (_,  , conDef (_,  , _,  , _,  , w2,  , _,  , _,  , _))) -> assignExp (g,  , us1,  , (w2,  , s2),  , cnstr) _ -> (raise (assignment ("Head mismatch ")))) assignExpW(g,  , (lam (d1,  , u1),  , s1),  , (lam (d2,  , u2),  , s2),  , cnstr) assignExp (decl (g,  , decSub (d1,  , s1)),  , (u1,  , dot1 s1),  , (u2,  , dot1 s2),  , cnstr) assignExpW(g,  , (u1,  , s1),  , (lam (d2,  , u2),  , s2),  , cnstr) assignExp (decl (g,  , decSub (d2,  , s2)),  , (redex (eClo (u1,  , shift),  , app (root (bVar (1),  , nil),  , nil)),  , dot1 s1),  , (u2,  , dot1 s2),  , cnstr) assignExpW(g,  , (pi ((d1 as dec (_,  , v1),  , _),  , u1),  , s1),  , (pi ((d2 as dec (_,  , v2),  , _),  , u2),  , s2),  , cnstr) let let  in in assignExp (decl (g,  , decSub (d1,  , s1)),  , (u1,  , dot1 s1),  , (u2,  , dot1 s2),  , cnstr') assignExpW(g,  , us1 as (u,  , s1),  , us2 as (eVar (r2,  , _,  , _,  , _),  , s2),  , cnstr) (r2 := sOME (eClo (us1)); cnstr) assignExpW(g,  , us1 as (u,  , s1),  , us2 as (aVar (r2),  , s2),  , cnstr) (r2 := sOME (eClo us1); cnstr) assignExpW(g,  , (lam (d1,  , u1),  , s1),  , (u2,  , s2),  , cnstr) assignExp (decl (g,  , decSub (d1,  , s1)),  , (u1,  , dot1 s1),  , (redex (eClo (u2,  , shift),  , app (root (bVar (1),  , nil),  , nil)),  , dot1 s2),  , cnstr) assignExpW(g,  , us1,  , us2 as (eClo (u,  , s'),  , s),  , cnstr) assignExp (g,  , us1,  , (u,  , comp (s',  , s)),  , cnstr) assignExpW(g,  , us1 as (eVar (r,  , _,  , v,  , cnstr),  , s),  , us2,  , cnstr) (eqn (g,  , eClo (us1),  , eClo (us2)) :: cnstr) assignExpW(g,  , us1 as (eClo (u,  , s'),  , s),  , us2,  , cnstr) assignExp (g,  , (u,  , comp (s',  , s)),  , us2,  , cnstr) assignExpW(g,  , us1 as (fgnExp (_,  , fe),  , _),  , us2,  , cnstr) (eqn (g,  , eClo (us1),  , eClo (us2)) :: cnstr) assignExpW(g,  , us1,  , us2 as (fgnExp (_,  , fe),  , _),  , cnstr) (eqn (g,  , eClo (us1),  , eClo (us2)) :: cnstr) assignSpine(g,  , (nil,  , _),  , (nil,  , _),  , cnstr) cnstr assignSpine(g,  , (sClo (s1,  , s1'),  , s1),  , ss,  , cnstr) assignSpine (g,  , (s1,  , comp (s1',  , s1)),  , ss,  , cnstr) assignSpine(g,  , ss,  , (sClo (s2,  , s2'),  , s2),  , cnstr) assignSpine (g,  , ss,  , (s2,  , comp (s2',  , s2)),  , cnstr) assignSpine(g,  , (app (u1,  , s1),  , s1),  , (app (u2,  , s2),  , s2),  , cnstr) let let  in in assignSpine (g,  , (s1,  , s1),  , (s2,  , s2),  , cnstr') assignExp(g,  , us1,  , us2 as (u2,  , s2),  , cnstr) assignExpW (g,  , whnf us1,  , whnf us2,  , cnstr)let rec solveCnstrnil true solveCnstr(eqn (g,  , u1,  , u2) :: cnstr) (unifiable (g,  , (u1,  , id),  , (u2,  , id)) && solveCnstr cnstr)let rec printSub(shift n) print ("Shift " ^ toString n ^ "\n") printSub(dot (idx n,  , s)) (print ("Idx " ^ toString n ^ " . "); printSub s) printSub(dot (exp (eVar (_,  , _,  , _,  , _)),  , s)) (print ("Exp (EVar _ ). "); printSub s) printSub(dot (exp (aVar (_)),  , s)) (print ("Exp (AVar _ ). "); printSub s) printSub(dot (exp (eClo (aVar (_),  , _)),  , s)) (print ("Exp (AVar _ ). "); printSub s) printSub(dot (exp (eClo (_,  , _)),  , s)) (print ("Exp (EClo _ ). "); printSub s) printSub(dot (exp (_),  , s)) (print ("Exp (_ ). "); printSub s) printSub(dot (undef,  , s)) (print ("Undef . "); printSub s)let rec unifyW(g,  , (xs1 as aVar (r as ref nONE),  , s),  , us2) r := sOME (eClo (us2)) unifyW(g,  , xs1,  , us2) unifyW (g,  , xs1,  , us2)let rec unify(g,  , xs1,  , us2) unifyW (g,  , whnf xs1,  , whnf us2)let rec matchW(g,  , (xs1 as aVar (r as ref nONE),  , s),  , us2) r := sOME (eClo (us2)) matchW(g,  , xs1,  , us2) matchW (g,  , xs1,  , us2)let rec match(g,  , xs1,  , us2) matchW (g,  , whnf xs1,  , whnf us2)let  inlet rec unifiable(g,  , us1,  , us2) try  with let rec instance(g,  , us1,  , us2) try  with (*
    fun assign(G, Us1, Us2) = assignExp(G, Us1, Us2, [])
    *)
let rec assignable(g,  , us1,  , uts2) (try  with )let rec firstConstArg(a as root (h as const c,  , s),  , s) let let  in(* #implicit arguments to predicate *)
let rec constExp(u,  , s) constExpW (whnf (u,  , s)) constExpW(lam (d,  , u),  , s) constExp (u,  , s) constExpW(root (h as const cid,  , s),  , s) sOME (cid) constExpW(_,  , _) nONE(* other cases cannot occur during compilation *)
let rec ithElem(k,  , (app (u,  , s),  , s)) if (k = i) then constExp (u,  , s) else ithElem (k + 1,  , (s,  , s)) ithElem(k,  , (nil,  , s)) nONE in ithElem (0,  , (s,  , s))end