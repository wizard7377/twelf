SparseArray2  IntTable TABLE   Key Int     SPARSE_ARRAY2  struct type Arraytype Regiontype Traversallet  inlet rec fromInt(code) let let rec fromInt'r let let  in in if (code < code') then let let  in in (diff,  , r - diff) else fromInt' (r + 1) in fromInt' 0let rec toInt(m,  , n) let let  in in sum * (sum + 1) div 2 + nlet rec unsafeSub({table; default},  , i,  , j) match (lookup table (toInt (i,  , j))) with nONE -> default sOME (v) -> vlet rec unsafeUpdate({table; default},  , i,  , j,  , v) insert table (toInt (i,  , j),  , v)let rec checkRegion{base; row; col; nrows; ncols} (row >= 0) && (col >= 0) && (nrows >= 0) && (ncols >= 0)let rec arraydefault {default =  defaultdefault; table =  new sizenew size}let rec sub(array,  , i,  , j) if (i >= 0) && (j >= 0) then unsafeSub (array,  , i,  , j) else raise (subscript)let rec update(array,  , i,  , j,  , v) if (i >= 0) && (j >= 0) then unsafeUpdate (array,  , i,  , j,  , v) else raise (subscript)let rec row(array,  , i,  , (j,  , len)) if (i >= 0) && (j >= 0) && (len >= 0) then tabulate (len,  , (fun off -> unsafeSub (array,  , i,  , j + off))) else raise (subscript)let rec column(array,  , j,  , (i,  , len)) if (j >= 0) && (i >= 0) && (len >= 0) then tabulate (len,  , (fun off -> unsafeSub (array,  , i + off,  , j))) else raise (subscript)let rec apptraversalf(region as {base; row; col; nrows; ncols}) if checkRegion region then let let  inlet  inlet rec appR(row',  , col') if (row' < rmax) then if (col' < cmax) then (f (row',  , col',  , unsafeSub (base,  , row',  , col')); appR (row',  , col' + 1)) else appR (row' + 1,  , col) else ()let rec appC(row',  , col') if (col' < cmax) then if (row' < rmax) then (f (row',  , col',  , unsafeSub (base,  , row',  , col')); appC (row' + 1,  , col')) else appC (row,  , col' + 1) else () in match traversal with rowMajor -> appR (row,  , col) colMajor -> appC (row,  , col) else raise (subscript)let rec foldtraversalfinit(region as {base; row; col; nrows; ncols}) if checkRegion region then let let  inlet  inlet rec foldR(row',  , col') if (row' < rmax) then if (col' < cmax) then f (row',  , col',  , unsafeSub (base,  , row',  , col'),  , foldR (row',  , col' + 1)) else foldR (row' + 1,  , col) else initlet rec foldC(row',  , col') if (col' < cmax) then if (row' < rmax) then f (row',  , col',  , unsafeSub (base,  , row',  , col'),  , foldC (row' + 1,  , col')) else foldC (row,  , col' + 1) else init in match traversal with rowMajor -> foldR (row,  , col) colMajor -> foldC (row,  , col) else raise (subscript)let rec modifytraversalf(region as {base; row; col; nrows; ncols}) if checkRegion region then let let  inlet  inlet rec modifyR(row',  , col') if (row' < rmax) then if (col' < cmax) then (unsafeUpdate (base,  , row',  , col',  , f (row',  , col',  , unsafeSub (base,  , row',  , col'))); modifyR (row',  , col' + 1)) else modifyR (row' + 1,  , col) else ()let rec modifyC(row',  , col') if (col' < cmax) then if (row' < rmax) then (unsafeUpdate (base,  , row',  , col',  , f (row',  , col',  , unsafeSub (base,  , row',  , col'))); modifyC (row' + 1,  , col')) else modifyC (row,  , col' + 1) else () in match traversal with rowMajor -> modifyR (row,  , col) colMajor -> modifyC (row,  , col) else raise (subscript)end