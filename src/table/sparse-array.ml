SparseArray  IntTable TABLE   Key Int     SPARSE_ARRAY  struct type Arraylet  inlet rec unsafeSub({table; default},  , i) match (lookup table i) with nONE -> default sOME (v) -> vlet rec unsafeUpdate({table; default},  , i,  , v) insert table (i,  , v)let rec arraydefault {default =  defaultdefault; table =  new sizenew size}let rec sub(array,  , i) if (i >= 0) then unsafeSub (array,  , i) else raise (subscript)let rec update(array,  , i,  , v) if (i >= 0) then unsafeUpdate (array,  , i,  , v) else raise (subscript)let rec extract(array,  , i,  , len) if (i >= 0) && (len >= 0) then tabulate (len,  , (fun off -> unsafeSub (array,  , i + off))) else raise (subscript)let rec copyVec{src; si; len; dst; di} if (di >= 0) then appi (fun (i,  , v) -> unsafeUpdate (dst,  , i,  , v)) (slice (src,  , si,  , len)) else raise (subscript)let rec appf(array,  , i,  , len) if (i >= 0) && (len >= 0) then let let  inlet rec app'i' if (i' < imax) then (f (i',  , unsafeSub (array,  , i')); app' (i' + 1)) else () in app' i else raise (subscript)let rec foldlfinit(array,  , i,  , len) if (i >= 0) && (len >= 0) then let let rec foldl'i' if (i' >= i) then f (i',  , unsafeSub (array,  , i'),  , foldl' (i' - 1)) else init in foldl' (i + len - 1) else raise (subscript)let rec foldrfinit(array,  , i,  , len) if (i >= 0) && (len >= 0) then let let  inlet rec foldr'i' if (i' < imax) then f (i',  , unsafeSub (array,  , i'),  , foldr' (i' + 1)) else init in foldr' i else raise (subscript)let rec modifyf(array,  , i,  , len) if (i >= 0) && (len >= 0) then let let  inlet rec modify'i' if (i' < imax) then (unsafeUpdate (array,  , i',  , f (i',  , unsafeSub (array,  , i'))); modify' (i' + 1)) else () in modify' i else raise (subscript)end