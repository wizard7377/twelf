HashTable  Key'   hash Key' -> Int   eq Key' * Key' -> Bool    TABLE   Key Key'  struct type Keytype Entry(* A hashtable bucket is a linked list of mutable elements *)
(* A hashtable is an array of buckets containing entries paired with hash values *)
type Buckettype Tablelet rec new(n) (array (n,  , nil),  , n)let rec insertShadow(a,  , n)(e as (key,  , datum)) let let  inlet  inlet  inlet rec insertB(cons (r' as ref (hash',  , e' as (key',  , datum')),  , br')) if hashVal = hash' && eq (key,  , key') then (r' := (hashVal,  , e); sOME (e')) else insertBR (br') insertBR(br as ref (nil)) (br := cons (ref (hashVal,  , e),  , ref nil); nONE) insertBR(br) insertB (! br)let rec insertA(nil) (update (a,  , index,  , cons (ref (hashVal,  , e),  , ref nil)); nONE) insertA(bucket) insertB (bucket) in insertA bucketlet rec inserthe (insertShadow h e; ())let rec lookup(a,  , n)key let let  inlet rec lookup'(cons (ref (hash1,  , (key1,  , datum1)),  , br)) if hashVal = hash1 && eq (key,  , key1) then sOME (datum1) else lookup' (! br) lookup'(nil) nONElet  in in lookup' bucketlet rec delete(a,  , n)key let let  inlet  inlet  inlet rec deleteBR(br as ref (cons (ref (hash1,  , (key1,  , _)),  , br1))) if hashVal = hash1 && eq (key,  , key1) then br := ! br1 else deleteBR br1 deleteBR(br) ()let rec deleteA(nil) () deleteA(cons (ref (hash1,  , (key1,  , _)),  , br1)) if hashVal = hash1 && eq (key,  , key1) then update (a,  , index,  , ! br1) else deleteBR br1 in deleteA bucketlet rec clear(a,  , n) modify (fun _ -> nil) alet rec appBucketf(nil) () appBucketf(cons (ref (_,  , e),  , br)) (f e; appBucket f (! br))let rec appf(a,  , n) app (appBucket f) aend