MTPi  MTPGlobal MTPGLOBAL    StateSyn' STATESYN    RelFun RELFUN    Formatter FORMATTER    Print PRINT    Print Formatter  Formatter   FunTypeCheck FUNTYPECHECK    FunTypeCheck StateSyn  StateSyn'   MTPData MTPDATA    MTPInit MTPINIT    MTPInit StateSyn  StateSyn'   MTPFilling MTPFILLING    MTPFilling StateSyn  StateSyn'   Inference INFERENCE    Inference StateSyn  StateSyn'   MTPSplitting MTPSPLITTING    MTPSplitting StateSyn  StateSyn'   MTPRecursion MTPRECURSION    MTPRecursion StateSyn  StateSyn'   MTPStrategy MTPSTRATEGY    MTPStrategy StateSyn  StateSyn'   MTPrint MTPRINT    MTPrint StateSyn  StateSyn'   Order ORDER    Names NAMES    Timers TIMERS    Ring RING     MTPI  struct exception (*! structure FunSyn = FunSyn' !*)
module module module module module type MenuItemlet  inlet  inlet  inlet  inlet rec initOpen() open := init []let rec initSolved() solved := init []let rec empty() empty (! open)let rec current() current (! open)let rec delete() open := delete (! open)let rec insertOpens open := insert (! open,  , s)let rec insertSolveds solved := insert (! solved,  , s)let rec inserts insertOpen slet rec collectOpen() foldr  :: nil (! open)let rec collectSolved() foldr  :: nil (! solved)let rec nextOpen() open := next (! open)let rec pushHistory() history := (! open,  , ! solved) :: (! history)let rec popHistory() match (! history) with nil -> raise (error "History stack empty") (open',  , solved') :: history' -> (history := history'; open := open'; solved := solved')let rec aborts (print ("* " ^ s); raise (error s))let rec reset() (initOpen (); initSolved (); history := nil; menu := nONE)let rec cLToString(nil) "" cLToString(c :: nil) (conDecName (sgnLookup c)) cLToString(c :: l) (conDecName (sgnLookup c)) ^ ", " ^ (cLToString l)let rec printFillResult(_,  , p) let let rec formatTuple(g,  , p) let let rec formatTuple'(unit) nil formatTuple'(inx (m,  , unit)) [formatExp (g,  , m)] formatTuple'(inx (m,  , p')) (formatExp (g,  , m) :: string "," :: break :: formatTuple' p') in match p with (inx (_,  , unit)) -> hbox (formatTuple' p) _ -> hVbox0 1 1 1 (string "(" :: (formatTuple' p @ [string ")"]))let  in in print ("Filling successful with proof term:\n" ^ (makestring_fmt (formatTuple (g,  , p))) ^ "\n")let rec splittingToMenu(nil,  , a) a splittingToMenu(o :: l,  , a) splittingToMenu (l,  , splitting o :: a)let rec fillingToMenu(o,  , a) filling o :: alet rec recursionToMenu(o,  , a) recursion o :: alet rec inferenceToMenu(o,  , a) inference o :: alet rec menu() if empty () then menu := nONE else let let  inlet  inlet  inlet  inlet  in in menu := sOME (fillingToMenu (fillO,  , recursionToMenu (recO,  , inferenceToMenu (infO,  , splittingToMenu (splitO,  , nil)))))let rec formatk if k < 10 then (toString k) ^ ".  " else (toString k) ^ ". "let rec menuToString() let let rec menuToString'(k,  , nil,  , (nONE,  , _)) (sOME k,  , "") menuToString'(k,  , nil,  , (kopt' as sOME _,  , _)) (kopt',  , "") menuToString'(k,  , splitting o :: m,  , kOopt' as (nONE,  , nONE)) let let  inlet  in in (kopt,  , if k = k'' then s ^ "\n* " ^ (format k) ^ (menu o) else s ^ "\n  " ^ (format k) ^ (menu o)) menuToString'(k,  , splitting o :: m,  , kOopt' as (sOME k',  , sOME o')) let let  inlet  in in (kopt,  , if k = k'' then s ^ "\n* " ^ (format k) ^ (menu o) else s ^ "\n  " ^ (format k) ^ (menu o)) menuToString'(k,  , filling o :: m,  , kOopt) let let  in in (kopt,  , s ^ "\n  " ^ (format k) ^ (menu o)) menuToString'(k,  , recursion o :: m,  , kOopt) let let  in in (kopt,  , s ^ "\n  " ^ (format k) ^ (menu o)) menuToString'(k,  , inference o :: m,  , kOopt) let let  in in (kopt,  , s ^ "\n  " ^ (format k) ^ (menu o)) in match ! menu with nONE -> raise (error "Menu is empty") sOME m -> let let  in in slet rec printMenu() if empty () then (print "[QED]\n"; print ("Statistics: required Twelf.Prover.maxFill := " ^ (toString (! maxFill)) ^ "\n")) else let let  inlet  in in (print "\n"; print (stateToString s); print "\nSelect from the following menu:\n"; print (menuToString ()); print "\n")let rec contains(nil,  , _) true contains(x :: l,  , l') (exists (fun x' -> x = x') l') && contains (l,  , l')let rec equiv(l1,  , l2) contains (l1,  , l2) && contains (l2,  , l1)let rec transformOrder'(g,  , arg k) let let  inlet  in in arg ((root (bVar k',  , nil),  , id),  , (v,  , id)) transformOrder'(g,  , lex os) lex (map (fun o -> transformOrder' (g,  , o)) os) transformOrder'(g,  , simul os) simul (map (fun o -> transformOrder' (g,  , o)) os)let rec transformOrder(g,  , all (prim d,  , f),  , os) all (d,  , transformOrder (decl (g,  , d),  , f,  , os)) transformOrder(g,  , and (f1,  , f2),  , o :: os) and (transformOrder (g,  , f1,  , [o]),  , transformOrder (g,  , f2,  , os)) transformOrder(g,  , ex _,  , [o]) transformOrder' (g,  , o)let rec selectc (try  with )let rec init(k,  , names) let let  inlet  inlet  inlet  inlet  inlet  inlet  in in (try  with )let rec selectk let let rec select'(k,  , nil) abort ("No such menu item") select'(1,  , splitting o :: _) let let  inlet  inlet  inlet  in in (menu (); printMenu ()) select'(1,  , recursion o :: _) let let  inlet  inlet  inlet  in in (menu (); printMenu ()) select'(1,  , inference o :: _) let let  inlet  inlet  inlet  in in (menu (); printMenu ()) select'(1,  , filling o :: _) let let  inlet  inlet  inlet  inlet  in in (menu (); printMenu ()) select'(k,  , _ :: m) select' (k - 1,  , m) in try  with let rec solve() if empty () then raise (error "Nothing to prove") else let let  inlet  inlet  inlet  inlet  inlet  in in (menu (); printMenu ())let rec check() if empty () then raise (error "Nothing to check") else let let  in in isState slet rec auto() let let  inlet  inlet  inlet  inlet  in in (menu (); printMenu ())let rec next() (nextOpen (); menu (); printMenu ())let rec undo() (popHistory (); menu (); printMenu ())let  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  in(* local *)
end