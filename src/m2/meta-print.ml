MetaPrint  Global GLOBAL    MetaSyn' METASYN    Formatter FORMATTER    Print PRINT    Print Formatter  Formatter   ClausePrint CLAUSEPRINT    ClausePrint Formatter  Formatter    METAPRINT  struct module module module module let rec modeToStringtop "+" modeToStringbot "-"(* depthToString is used to format splitting depth *)
let rec depthToString(b) if b <= 0 then "" else toString blet rec fmtPrefix(gM) let let rec fmtPrefix'(prefix (null,  , null,  , null),  , fmt) fmt fmtPrefix'(prefix (decl (null,  , d),  , decl (null,  , mode),  , decl (null,  , b)),  , fmt) [string (depthToString b); string (modeToString mode); formatDec (null,  , d)] @ fmt fmtPrefix'(prefix (decl (g,  , d),  , decl (m,  , mode),  , decl (b,  , b)),  , fmt) fmtPrefix' (prefix (g,  , m,  , b),  , [string ","; space; break; string (depthToString b); string (modeToString mode); formatDec (g,  , d)] @ fmt) in hVbox (fmtPrefix' (gM,  , []))let rec prefixToStringgM makestring_fmt (fmtPrefix gM)let rec stateToString(state (name,  , gM as prefix (g,  , m,  , b),  , v)) name ^ ":\n" ^ prefixToString gM ^ "\n--------------\n" ^ clauseToString (g,  , v) ^ "\n\n"let rec sgnToString(sgnEmpty) "" sgnToString(conDec (e,  , s)) (if ! chatter >= 4(* use explicitly quantified form *)
 then conDecToString e ^ "\n" else if ! chatter >= 3(* use form without quantifiers, which is reparsable *)
 then conDecToString e ^ "\n" else "") ^ sgnToString slet  inlet  inlet  inlet  in(* local *)
end