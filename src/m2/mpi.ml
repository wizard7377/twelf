Mpi  MetaGlobal METAGLOBAL    MetaSyn' METASYN    Init INIT    Init MetaSyn  MetaSyn'   Filling FILLING    Filling MetaSyn  MetaSyn'   Splitting SPLITTING    Splitting MetaSyn  MetaSyn'   Recursion RECURSION    Recursion MetaSyn  MetaSyn'   Lemma LEMMA    Lemma MetaSyn  MetaSyn'   Strategy STRATEGY    Strategy MetaSyn  MetaSyn'   Qed QED    Qed MetaSyn  MetaSyn'   MetaPrint METAPRINT    MetaPrint MetaSyn  MetaSyn'   Names NAMES    Timers TIMERS    Ring RING     MPI  struct module exception module module type MenuItemlet  inlet  inlet  inlet  inlet rec initOpen() open := init []let rec initSolved() solved := init []let rec empty() empty (! open)let rec current() current (! open)let rec delete() open := delete (! open)let rec insertOpens open := insert (! open,  , s)let rec insertSolveds solved := insert (! solved,  , s)let rec inserts if subgoal s then (insertSolved s; print (stateToString s); print "\n[Subgoal finished]\n"; print "\n") else insertOpen slet rec collectOpen() foldr  :: nil (! open)let rec collectSolved() foldr  :: nil (! solved)let rec nextOpen() open := next (! open)let rec pushHistory() history := (! open,  , ! solved) :: (! history)let rec popHistory() match (! history) with nil -> raise (error "History stack empty") (open',  , solved') :: history' -> (history := history'; open := open'; solved := solved')let rec aborts (print ("* " ^ s); raise (error s))let rec reset() (initOpen (); initSolved (); history := nil; menu := nONE)let rec cLToString(nil) "" cLToString(c :: nil) (conDecName (sgnLookup c)) cLToString(c :: l) (conDecName (sgnLookup c)) ^ ", " ^ (cLToString l)let rec splittingToMenu(nil,  , a) a splittingToMenu(o :: l,  , a) splittingToMenu (l,  , splitting o :: a)let rec fillingToMenu(nil,  , a) a fillingToMenu(o :: l,  , a) fillingToMenu (l,  , filling o :: a)let rec recursionToMenu(nil,  , a) a recursionToMenu(o :: l,  , a) recursionToMenu (l,  , recursion o :: a)let rec menu() if empty () then menu := nONE else let let  inlet  inlet  inlet  in in menu := sOME (fillingToMenu ([fillC],  , fillingToMenu (fillO,  , recursionToMenu (recO,  , splittingToMenu (splitO,  , nil)))))let rec formatk if k < 10 then (toString k) ^ ".  " else (toString k) ^ ". "let rec menuToString() let let rec menuToString'(k,  , nil) "" menuToString'(k,  , splitting o :: m) (menuToString' (k + 1,  , m)) ^ "\n" ^ (format k) ^ (menu o) menuToString'(k,  , filling o :: m) (menuToString' (k + 1,  , m)) ^ "\n" ^ (format k) ^ (menu o) menuToString'(k,  , recursion o :: m) (menuToString' (k + 1,  , m)) ^ "\n" ^ (format k) ^ (menu o) in match ! menu with nONE -> raise (error "Menu is empty") sOME m -> menuToString' (1,  , m)let rec makeConDec(state (name,  , prefix (g,  , m,  , b),  , v)) let let rec makeConDec'(null,  , v,  , k) conDec (name,  , nONE,  , k,  , normal,  , v,  , type) makeConDec'(decl (g,  , d),  , v,  , k) makeConDec' (g,  , pi ((d,  , maybe),  , v),  , k + 1) in (makeConDec' (g,  , v,  , 0))let rec makeSignature(nil) sgnEmpty makeSignature(s :: sL) conDec (makeConDec s,  , makeSignature sL)let rec extract() if empty () then makeSignature (collectSolved ()) else (print "[Error: Proof not completed yet]\n"; sgnEmpty)let rec show() print (sgnToString (extract ()) ^ "\n")let rec printMenu() if empty () then (show (); print "[QED]\n") else let let  in in (print "\n"; print (stateToString s); print "\nSelect from the following menu:\n"; print (menuToString ()); print "\n")let rec contains(nil,  , _) true contains(x :: l,  , l') (exists (fun x' -> x = x') l') && contains (l,  , l')let rec equiv(l1,  , l2) contains (l1,  , l2) && contains (l2,  , l1)let rec init'(k,  , cL as (c :: _)) let let  inlet  inlet  in(* if no termination ordering given! *)
 in if equiv (cL,  , cL') then map (fun s -> insert s) (init cL) else raise (error ("Theorem by simultaneous induction not correctly stated:" ^ "\n            expected: " ^ (cLToString cL')))let rec init(k,  , nL) let let rec cidsnil nil cids(name :: nL) (match stringToQid name with nONE -> raise (error ("Malformed qualified identifier " ^ name)) sOME qid -> (match constLookup qid with nONE -> raise (error ("Type family " ^ qidToString qid ^ " not defined")) sOME cid -> cid :: (cids nL))) in (try  with )let rec selectk let let rec select'(k,  , nil) abort ("No such menu item") select'(1,  , splitting o :: _) let let  inlet  inlet  inlet  in in (menu (); printMenu ()) select'(1,  , recursion o :: _) let let  inlet  inlet  inlet  in in (menu (); printMenu ()) select'(1,  , filling o :: _) let let  in in (menu (); printMenu ()) select'(k,  , _ :: m) select' (k - 1,  , m) in try  with let rec lemmaname if empty () then raise (error "Nothing to prove") else let let  inlet  inlet  inlet  inlet  in in (menu (); printMenu ())let rec solve() if empty () then raise (error "Nothing to prove") else let let  inlet  inlet  inlet  inlet  inlet  in in (menu (); printMenu ())let rec auto() let let  inlet  inlet  inlet  inlet  in in (menu (); printMenu ())let rec next() (nextOpen (); menu (); printMenu ())let rec undo() (popHistory (); menu (); printMenu ())let  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  in(* local *)
end