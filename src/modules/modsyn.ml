ModSyn  Global GLOBAL    Names' NAMES    Origins ORIGINS    Whnf WHNF    Strict STRICT    IntTree TABLE   Key Int    HashTable TABLE   Key String     MODSYN  struct (*! structure IntSyn = IntSyn' !*)
module (*! structure Paths = Paths' !*)
module exception type ConstInfotype StructInfo(* A module consists of:
     1. a map from cids to constant entries containing
          a. a constant declaration entry (IntSyn.ConDec)
          b. the fixity of the constant
          c. the name preference for the constant (if any)
     2. a map from mids to structure entries containing
          a. a structure declaration entry (IntSyn.StrDec)
          b. the namespace of the structure
     3. the top-level namespace of the module *)
type Moduletype Actiontype Transform(* invariant: U in nf, result in nf *)
let rec mapExpConstsfu let open IntSyn let rec trExp(uni l) uni l trExp(pi ((d,  , p),  , v)) pi ((trDec d,  , p),  , trExp v) trExp(root (h,  , s)) root (trHead h,  , trSpine s) trExp(lam (d,  , u)) lam (trDec d,  , trExp u) trExp(u as fgnExp csfe) apply csfe trExp trDec(dec (name,  , v)) dec (name,  , trExp v) trSpinenil nil trSpine(app (u,  , s)) app (trExp u,  , trSpine s) trHead(bVar n) bVar n trHead(const cid) trConst cid trHead(skonst cid) trConst cid trHead(def cid) trConst cid trHead(nSDef cid) trConst cid trHead(fgnConst (csid,  , condec)) fgnConst (csid,  , mapConDecConsts f condec) trConstcid let let  in in match sgnLookup cid' with conDec _ -> const cid' skoDec _ -> skonst cid' conDef _ -> def cid' abbrevDef _ -> nSDef cid' in normalize (trExp u,  , id) mapConDecConstsf(conDec (name,  , parent,  , i,  , status,  , v,  , l)) conDec (name,  , parent,  , i,  , status,  , mapExpConsts f v,  , l) mapConDecConstsf(conDef (name,  , parent,  , i,  , u,  , v,  , l,  , anc)) conDef (name,  , parent,  , i,  , mapExpConsts f u,  , mapExpConsts f v,  , l,  , anc) mapConDecConstsf(abbrevDef (name,  , parent,  , i,  , u,  , v,  , l)) abbrevDef (name,  , parent,  , i,  , mapExpConsts f u,  , mapExpConsts f v,  , l) mapConDecConstsf(skoDec (name,  , parent,  , i,  , v,  , l)) skoDec (name,  , parent,  , i,  , mapExpConsts f v,  , l)let rec mapStrDecParentf(strDec (name,  , parent)) strDec (name,  , f parent)let rec mapConDecParentf(conDec (name,  , parent,  , i,  , status,  , v,  , l)) conDec (name,  , f parent,  , i,  , status,  , v,  , l) mapConDecParentf(conDef (name,  , parent,  , i,  , u,  , v,  , l,  , anc)) conDef (name,  , f parent,  , i,  , u,  , v,  , l,  , anc) mapConDecParentf(abbrevDef (name,  , parent,  , i,  , u,  , v,  , l)) abbrevDef (name,  , f parent,  , i,  , u,  , v,  , l) mapConDecParentf(skoDec (name,  , parent,  , i,  , v,  , l)) skoDec (name,  , f parent,  , i,  , v,  , l)let rec strictify(condec as abbrevDef (name,  , parent,  , i,  , u,  , v,  , type)) (try  with ) strictify(condec as abbrevDef _) condeclet rec abbrevify(cid,  , condec) (match condec with conDec (name,  , parent,  , i,  , _,  , v,  , l) -> let let  in in abbrevDef (name,  , parent,  , i,  , u,  , v,  , l) skoDec (name,  , parent,  , i,  , v,  , l) -> let let  in in abbrevDef (name,  , parent,  , i,  , u,  , v,  , l) conDef (name,  , parent,  , i,  , u,  , v,  , l,  , anc) -> abbrevDef (name,  , parent,  , i,  , u,  , v,  , l) abbrevDef data -> abbrevDef data)(* In order to install a module, we walk through the mids in preorder,
     assigning global mids and building up a translation map from local
     mids to global mids.  Then we walk through the cids in dependency
     order, assigning global cids, building up a translation map from
     local to global cids, and replacing the cids contained in the terms
     with their global equivalents.

     NOTE that a module might not be closed with respect to the local
     cids; that is, it might refer to global cids not defined by the
     module.  It is a global invariant that such cids will still be in
     scope whenever a module that refers to them is installed. *)
let rec installModule((structTable,  , constTable,  , namespace),  , topOpt,  , nsOpt,  , installAction,  , transformConDec) let let  inlet  inlet rec mapStructmid valOf (lookup structMap mid)let rec mapParentnONE topOpt mapParent(sOME parent) sOME (mapStruct parent)let rec mapConstcid (match lookup constMap cid with nONE -> cid sOME cid' -> cid')let rec doStruct(mid,  , structInfo strdec) let let  inlet  inlet  inlet  inlet  inlet  inlet  inlet  in in insert structMap (mid,  , mid')let rec doConst(cid,  , constInfo (condec,  , fixity,  , namePrefOpt,  , origin)) let let  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  in in insert constMap (cid,  , cid') in app doStruct structTableapp doConst constTablelet  inlet rec installStruct(strdec,  , module,  , nsOpt,  , installAction,  , isDef) let let  inlet  inlet  inlet  inlet  inlet  in in installModule (module,  , sOME mid,  , nONE,  , installAction,  , transformConDec)let rec installSig(module,  , nsOpt,  , installAction,  , isDef) let let  in in installModule (module,  , nONE,  , nsOpt,  , installAction,  , transformConDec)let rec abstractModule(namespace,  , topOpt) let let  inlet  inlet  inlet rec doStruct(_,  , mid) let let  inlet  inlet  in in insert structTable (mid,  , structInfo strdec')doNS ns doConst(_,  , cid) let let  inlet  inlet  inlet  inlet  in in insert constTable (cid,  , constInfo (condec',  , fixity,  , namePref,  , origin)) doNSns (appStructs doStruct ns; appConsts doConst ns) in doNS namespace(structTable,  , constTable,  , namespace)let rec instantiateModule(module as (_,  , _,  , namespace),  , transform) let let  inlet  inlet  inlet  inlet  in in abstractModule (ns,  , sOME mid)let  inlet  inlet  inlet rec defsClear() clear defslet  inlet  inlet  inlet rec reset() (defList := nil; defCount := 0; defsClear ())let rec resetFrommark let let rec ct(l,  , i) if i <= mark then l else let let  in in defsDelete hct (t,  , i - 1) in defList := ct (! defList,  , ! defCount)defCount := marklet rec sigDefSize() ! defCountlet rec installSigDef(id,  , module) (match defsInsert (id,  , module) with nONE -> (defList := id :: (! defList); defCount := ! defCount + 1) sOME entry -> (raise (error ("Shadowing: A signature named " ^ id ^ "\nhas already been declared")); defsInsert entry; ()))let  inend