Rationals Integers INTEGERS   RATIONALS  struct module let  inexception module type Number(* q := Fract (sign, num, denom) *)
let  inlet  inexception let rec normalize(fract (0,  , _,  , _)) zero normalize(fract (s,  , n,  , d)) let let rec gcd(m,  , n) if (m = fromInt (0)) then n else if (n = fromInt (0)) then m else if > (m,  , n) then gcd (mod (m,  , n),  , n) else gcd (m,  , mod (n,  , m))let  in in fract (s,  , div (n,  , g),  , div (d,  , g))let rec  ~(fract (s,  , n,  , d)) (fract (~ (s),  , n,  , d))let rec  +(fract (s1,  , n1,  , d1),  , fract (s2,  , n2,  , d2)) let let  in in normalize (fract (sign (n),  , abs (n),  , * (d1,  , d2)))let rec  -(fract (s1,  , n1,  , d1),  , fract (s2,  , n2,  , d2)) let let  in in normalize (fract (sign (n),  , abs (n),  , * (d1,  , d2)))let rec  *(fract (s1,  , n1,  , d1),  , fract (s2,  , n2,  , d2)) normalize (fract (* (s1,  , s2),  , * (n1,  , n2),  , * (d1,  , d2)))let rec inverse(fract (0,  , _,  , _)) raise (div) inverse(fract (s,  , n,  , d)) (fract (s,  , d,  , n))let rec sign(fract (s,  , n,  , d)) slet rec numerator(fract (s,  , n,  , d)) nlet rec denominator(fract (s,  , n,  , d)) dlet rec abs(fract (s,  , n,  , d)) (fract (abs (s),  , n,  , d))let rec compare(fract (s1,  , n1,  , d1),  , fract (s2,  , n2,  , d2)) compare (* (* (fromInt (s1),  , n1),  , d2),  , * (* (fromInt (s2),  , n2),  , d1))let rec  >(q1,  , q2) (compare (q1,  , q2) = gREATER)let rec  <(q1,  , q2) (compare (q1,  , q2) = lESS)let rec  >=(q1,  , q2) (q1 = q2) || (q1 > q2)let rec  <=(q1,  , q2) (q1 = q2) || (q1 < q2)let rec fromInt(n) (fract (sign (n),  , fromInt (abs (n)),  , fromInt (1)))let rec fromString(str) let let rec check_numerator(chars as (c :: chars')) if (c = '~') then (all isDigit chars') else (all isDigit chars) check_numeratornil falselet rec check_denominator(chars) (all isDigit chars)let  in in if (length fields = 1) then let let  in in if (check_numerator (explode (numerator))) then match (fromString (numerator)) with sOME (n) -> sOME (fract (sign (n),  , abs (n),  , fromInt (1))) _ -> nONE else nONE else if (length fields = 2) then let let  inlet  in in if (check_numerator (explode (numerator))) && (check_denominator (explode (denominator))) then match (fromString (numerator),  , fromString (denominator)) with (sOME (n),  , sOME (d)) -> sOME (normalize (fract (sign (n),  , abs (n),  , d))) _ -> nONE else nONE else nONElet rec toString(fract (s,  , n,  , d)) let let  inlet  in in if (d = fromInt (1)) then nStr else (nStr ^ "/" ^ dStr)let rec fromInteger(n) fract (sign (n),  , abs (n),  , fromInt (1))let rec floor(q as fract (s,  , n,  , d)) if >= (s,  , 0) then quot (n,  , d) else ~ (ceiling (~ q)) ceiling(q as fract (s,  , n,  , d)) if >= (s,  , 0) then quot (+ (n,  , - (d,  , fromInt (1))),  , d) else ~ (floor (~ q))type Numberlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  inend