CSManager  Global GLOBAL    Unify UNIFY    Fixity FIXITY     CS_MANAGER  struct module module (* structure ModeSyn = ModeSyn *)
type SigEntrytype FgnConDectype Solverexception (* vacuous solver *)
let  in(* Twelf unification as a constraint solver *)
let  in(* List of installed solvers *)
type Solverlet  inlet  inlet  inlet  in(* Installing function *)
let  inlet rec setInstallFNf (installFN := f)(* install the specified solver *)
let rec installSolver(solver) let (* val _ = print ("Installing constraint domain " ^ #name solver ^ "\n") *)
let  inlet  inlet  inlet  in in cs(* install the unification solver *)
let  inlet  in(* make all the solvers inactive *)
let rec resetSolvers() (appi (fun (cs,  , solver (solver,  , active)) -> if ! active then (active := false;  reset (solver) ()) else ()) (slice (csArray,  , 0,  , sOME (! nextCS))); activeKeywords := nil; useSolver "Unify")(* make the specified solver active *)
 useSolvername let exception let rec findSolvername try  with  in match findSolver name with sOME (cs) -> let let  in in if ! active then () else if exists (fun s -> s =  keywords (solver)) (! activeKeywords) then raise (error ("solver " ^ name ^ " is incompatible with a currently active solver")) else (active := true; activeKeywords :=  keywords (solver) :: (! activeKeywords); app useSolver ( needs (solver));  init (solver) (cs,  , ! installFN)) nONE -> raise (error ("solver " ^ name ^ " not found"))(* ask each active solver to try and parse the given string *)
let rec parsestring let exception let rec parse'(cs,  , solver : Solver) (match  fgnConst (solver) with nONE -> () sOME (fgnConDec) -> (match  parse (fgnConDec) (string) with nONE -> () sOME conDec -> raise (parsed (cs,  , conDec)))) in try  with let  in(* reset the internal status of all the active solvers *)
let rec reset() appi (fun (_,  , solver (solver,  , active)) -> if ! active then (markCount := 0;  reset (solver) ()) else ()) (slice (csArray,  , 0,  , sOME (! nextCS)))(* mark all active solvers *)
let rec mark() (markCount := ! markCount + 1; appi (fun (_,  , solver (solver,  , active)) -> if ! active then  mark (solver) () else ()) (slice (csArray,  , 0,  , sOME (! nextCS))))(* unwind all active solvers *)
let rec unwindtargetCount let let rec unwind'0 (markCount := targetCount) unwind'k (appi (fun (_,  , solver (solver,  , active)) -> if ! active then  unwind (solver) () else ()) (slice (csArray,  , 0,  , sOME (! nextCS))); unwind' (k - 1)) in unwind' (! markCount - targetCount)(* trail the give function *)
let rec trailf let let  inlet  inlet  inlet  in in rlet  inlet  inlet  inlet  inlet  inlet  inlet  inend  module