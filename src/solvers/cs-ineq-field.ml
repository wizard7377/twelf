CSIneqField  OrderedField ORDERED_FIELD    Trail TRAIL    Unify UNIFY    SparseArray SPARSE_ARRAY    SparseArray2 SPARSE_ARRAY2    CSEqField CS_EQ_FIELD    CSEqField Field  OrderedField   Compat COMPAT     CS  struct (*! structure CSManager = CSManager !*)
open IntSyn open OrderedField open CSEqField module module (* CSManager.ModeSyn *)
module module (* solver ID of this solver *)
let  in(* constant IDs of the declared type constants *)
let  inlet  in(* constructors for the declared types *)
let rec gt(u,  , v) root (const (! gtID),  , app (u,  , app (v,  , nil)))let rec geq(u,  , v) root (const (! geqID),  , app (u,  , app (v,  , nil)))(* specialized constructors for the declared types *)
let rec gt0(u) gt (u,  , constant (zero))let rec geq0(u) geq (u,  , constant (zero))(* constant IDs of the declared object constants *)
let  inlet  inlet  inlet  in(* constructors for the declared objects *)
let rec gtAdd(u1,  , u2,  , v,  , w) root (const (! gtAddID),  , app (u1,  , app (u2,  , app (v,  , app (w,  , nil)))))let rec geqAdd(u1,  , u2,  , v,  , w) root (const (! geqAddID),  , app (u1,  , app (u2,  , app (v,  , app (w,  , nil)))))let rec gtGeq(u,  , v,  , w) root (const (! gtGeqID),  , app (u,  , app (v,  , app (w,  , nil))))let rec geq00() root (const (! geq00ID),  , nil)(* constant declaration for the proof object d>0 *)
let rec gtNConDec(d) conDec (toString (d) ^ ">" ^ toString (zero),  , nONE,  , 0,  , normal,  , gt0 (constant (d)),  , type)(* foreign constant for the proof object d>0 *)
let rec gtNExp(d) root (fgnConst (! myID,  , gtNConDec (d)),  , nil)(* specialized constructors for the declared objects *)
let rec geqN0(d) if (d = zero) then geq00 () else gtGeq (constant (d),  , constant (zero),  , gtNExp (d))(* parsing proof objects d>0 *)
let rec parseGtNstring let let  inlet  inlet  inlet  in in if > (stringLen,  , suffixLen) && (substring (string,  , numLen,  , suffixLen) = suffix) then (match fromString (substring (string,  , 0,  , numLen)) with sOME (d) -> if (d > zero) then sOME (gtNConDec (d)) else nONE nONE -> nONE) else nONEtype Positiontype Owner(*   - sum                           *)
type Restriction(*   Restr (G, U, strict)            *)
type Label(* has the row/column already been   *)
(* solved?                           *)
type Operation(* change the owner                  *)
type Tableau(* undo mechanism                    *)
exception (* FgnCnstr representation *)
exception (* Representational invariants:
         rlabels[i] = vacuous
         clabels[j] = vacuous
         const[i] = zero
         coeff[i,j] = zero
       for i >= !nrows or j > !ncols, where "vacuous" is the vacuous label:
          #owner(vacuous) = Exp (Null, Sum (zero, nil))
          #restr(vacuous) = ref NONE
          #dead(vacuous) = ref true
    *)
(* little random generation routine taken from Paulson '91 *)
let   inlet  inlet rec rand(min,  , size) let let rec nextrand() let let  in in (seed := - (t,  , * (m,  , fromInt (floor (t / m)))); - (! seed,  , 1.0) / - (m,  , 1.0)) in + (min,  , floor (* (nextrand (),  , fromInt (size))))(* create a new (empty) tableau *)
let  in(* i-th tableau row label *)
let rec rlabel(i) sub ( rlabels (tableau),  , i)(* j-th tableau column label *)
let rec clabel(j) sub ( clabels (tableau),  , j)(* i-th tableau constant term *)
let rec const(i) sub ( consts (tableau),  , i)(* coefficient in row i, column j *)
let rec coeff(i,  , j) sub ( coeffs (tableau),  , i,  , j)(* number of rows *)
let rec nRows() ! ( nrows (tableau))(* number of columns *)
let rec nCols() ! ( ncols (tableau))(* increase the number of rows, and return the index of the last row *)
let rec incrNRows() let let  in in ( nrows (tableau) := + (old,  , 1); old)(* increase the number of columns, and return the index of the last column *)
let rec incrNCols() let let  in in ( ncols (tableau) := + (old,  , 1); old)(* decrease the number of rows *)
let rec decrNRows()  nrows (tableau) := - (nRows (),  , 1)(* decrease the number of columns *)
let rec decrNCols()  ncols (tableau) := - (nCols (),  , 1)(* increase by the given amount the element i of the array *)
let rec incrArray(array,  , i,  , value) update (array,  , i,  , sub (array,  , i) + value)(* increase by the given amount the element (i, j) of the array *)
let rec incrArray2(array,  , i,  , j,  , value) update (array,  , i,  , j,  , sub (array,  , i,  , j) + value)(* increase by f(j') all the elements (i, j'), with j <= j' < j+len *)
let rec incrArray2Row(array,  , i,  , (j,  , len),  , f) mapi (fun (j,  , value) -> update (array,  , i,  , j,  , value + f (j))) (row (array,  , i,  , (j,  , len)))(* increase by f(i') all the elements (i', j), with i <= i' < i+len *)
let rec incrArray2Col(array,  , j,  , (i,  , len),  , f) mapi (fun (i,  , value) -> update (array,  , i,  , j,  , value + f (i))) (column (array,  , j,  , (i,  , len)))(* set the given row to zero *)
let rec clearArray2Row(array,  , i,  , (j,  , len)) mapi (fun (j,  , value) -> update (array,  , i,  , j,  , zero)) (row (array,  , i,  , (j,  , len)))(* set the given column to zero *)
let rec clearArray2Col(array,  , j,  , (i,  , len)) mapi (fun (i,  , value) -> update (array,  , i,  , j,  , zero)) (column (array,  , j,  , (i,  , len)))(* return the label at the given position (row or column) *)
let rec label(row (i)) rlabel (i) label(col (j)) clabel (j)(* return the restriction on the given label *)
let rec restriction(l : Label) ! ( restr (l))(* is the given label is restricted? *)
let rec restricted(l : Label) (match (restriction (l)) with sOME _ -> true nONE -> false)(* return true iff the given label has been solved *)
let rec dead(l : Label) ! ( dead (l))(* set the ownership of the given position *)
let rec setOwnership(pos,  , owner,  , tag) let let  inlet  in in (match pos with row (i) -> update ( rlabels (tableau),  , i,  , new) col (j) -> update ( clabels (tableau),  , j,  , new))(* return the context of a owner *)
let rec ownerContext(var (g,  , mon)) g ownerContext(exp (g,  , sum)) g(* return the owner as a sum *)
let rec ownerSum(var (g,  , mon)) sum (zero,  , [mon]) ownerSum(exp (g,  , sum)) sum(* debugging code - REMOVE *)
let rec displayPos(row (row)) print ("row " ^ toString (row) ^ "\n") displayPos(col (col)) print ("column " ^ toString (col) ^ "\n")(* debugging code - REMOVE *)
let rec displaySum(sum (m,  , mon (n,  , _) :: monL)) (print (toString n); print " ? + "; displaySum (sum (m,  , monL))) displaySum(sum (m,  , nil)) (print (toString m); print " >= 0\n")(* debugging code - REMOVE *)
let rec display() let let rec printLabel(col,  , l : Label) (print "\t"; (match ( owner (l)) with var _ -> print "V" exp _ -> print "E"); if restricted (l) then print ">" else print "*"; if dead (l) then print "#" else print "")let rec printRow(row,  , l : Label) let let rec printCol(col,  , d : Number) (print "\t"; print (toString d))let  in in ((match ( owner (l)) with var _ -> print "V" exp _ -> print "E"); if restricted (l) then print ">" else print "*"; if dead (l) then print "#" else print ""; print "\t"; mapi printCol vec; print "\t"; print (toString (const (row))); print "\n") in (print "\t"; app printLabel ( clabels (tableau),  , 0,  , nCols ()); print "\n"; app printRow ( rlabels (tableau),  , 0,  , nRows ()); print "Columns:\n"; app (fun (_,  , l : Label) -> displaySum (ownerSum ( owner (l)))) ( clabels (tableau),  , 0,  , nCols ()); print "Rows:\n"; app (fun (_,  , l : Label) -> displaySum (ownerSum ( owner (l)))) ( rlabels (tableau),  , 0,  , nRows ()))(* find the given monomial in the tableau *)
let rec findMon(mon) let exception let rec find(i,  , l : Label) (match ( owner (l)) with (var (g,  , mon')) -> if compatibleMon (mon,  , mon') then raise (found i) else () _ -> ()) in try  with (* return the a position in the tableau of the tagged expression *)
let rec findTag(t) let exception let rec find(i,  , l : Label) if ( tag (l) = t) then raise (found i) else () in try  with (* return true iff the given row is null at all the active columns *)
let rec isConstant(row) foldl (fun (j,  , l,  , rest) -> (dead (l) || (coeff (row,  , j) = zero)) && rest) true ( clabels (tableau),  , 0,  , nCols ())(* return the position of the row/column of the tableau (if any) that makes the
       given row redundant *)
let rec isSubsumed(row) let let  inlet rec isSubsumedByRow() let (* the candidates are those (active) rows with the same constant
                       term *)
let  in(* if j is active, trim the list of candidates to those that have
                       the same coefficient in column j
                    *)
let rec filter(j,  , l,  , nil) nil filter(j,  , l : Label,  , candidates) if not (dead (l)) then filter (fun i -> (coeff (i,  , j) = coeff (row,  , j))) candidates else candidates in (match (foldl filter candidates ( clabels (tableau),  , 0,  , nCols ())) with nil -> nONE (i :: _) -> sOME (i))let rec isSubsumedByCol() if (constRow = zero) then let (* compute the list of non-null coefficients in the row *)
let  in in (match nonNull with [(j,  , value)] -> if (value = one) then sOME (j) else nONE _ -> nONE) else nONE in match isSubsumedByRow () with sOME (i) -> sOME (row (i)) nONE -> (match isSubsumedByCol () with sOME (j) -> sOME (col (j)) nONE -> nONE)(* find the coordinates of the pivot which gives the largest increase in const(row) *)
let rec findPivot(row) let (* extend Field.compare to deal with NONE (= infinity) *)
let rec compareScore(sOME (d),  , sOME (d')) compare (d,  , d') compareScore(sOME (d),  , nONE) lESS compareScore(nONE,  , sOME (d')) gREATER compareScore(nONE,  , nONE) eQUAL(* find the best pivot candidates for the given row *)
let rec findPivotCol(j,  , l : Label,  , result as (score,  , champs)) let let  in(* find the best pivot candidates for the given row and column *)
let rec findPivotRowsgn(i,  , l : Label,  , result as (score,  , champs)) let let  in in if (not (dead (l))) && (i <> row) && restricted (l) && ((fromInt (sgn) * value) < zero) then let let  in in match compareScore (score,  , score')(* always choose the smallest *)
 with gREATER -> (score',  , [(i,  , j)]) eQUAL -> (score,  , (i,  , j) :: champs) lESS -> result else result in if (not (dead (l))) && (value <> zero) && (not (restricted (l)) || (value > zero)) then let let  in in match compareScore (score,  , score')(* always choose the largest *)
 with gREATER -> result eQUAL -> (score,  , champs @ champs') lESS -> result' else result in match (foldl findPivotCol (sOME (zero),  , nil) ( clabels (tableau),  , 0,  , nCols ())) with (_,  , nil) -> nONE (_,  , champs) -> (* choose one randomly to ensure fairness *)
sOME (nth (champs,  , rand (0,  , length (champs))))(* pivot the element at the given coordinates *)
let rec pivot(row,  , col) let let  inlet  inlet rec pRow(j) sub (pRowVector,  , j)let  inlet rec pCol(i) sub (pColVector,  , i)let  inlet  inlet  in in (modify (fun (i,  , value) -> if (i = row) then (* same row as the pivot *)
~ (value * pCoeffInverse) else (* any other row *)
value - (pConst * pCol (i) * pCoeffInverse)) ( consts (tableau),  , 0,  , nRows ()); modify colMajor (fun (i,  , j,  , value) -> (match (i = row,  , j = col) with (true,  , true) -> (* pivot *)
pCoeffInverse (true,  , false) -> (* same row as the pivot *)
~ (value * pCoeffInverse) (false,  , true) -> (* same column as the pivot *)
value * pCoeffInverse (false,  , false) -> (* any other row/column *)
value - (pRow (j) * pCol (i) * pCoeffInverse))) {base =  ( coeffs (tableau))( coeffs (tableau)); row =  00; col =  00; nrows =  nRows ()nRows (); ncols =  nCols ()nCols ()}; update ( rlabels (tableau),  , row,  , pCLabel); update ( clabels (tableau),  , col,  , pRLabel))type MaximizeResult(* manifestly unbounded, pivoting on column col *)
(* maximize the given row by performing pivot operations.
       Return a term of type MaximizeResult.
    *)
let rec maximizeRow(row) let let  in in if (value <= zero) then match findPivot (row) with sOME (i,  , j) -> if (i <> row) then (log ( trail (tableau),  , pivot (i,  , j)); pivot (i,  , j); maximizeRow row) else unbounded j nONE -> maximized value else positive(* delay all terms of a monomial on the given constraint *)
let rec delayMon(mon (n,  , usL),  , cnstr) app (fun us -> delay (us,  , cnstr)) usL(* unify two restrictions *)
let rec unifyRestr(restr (g,  , proof,  , strict),  , proof') if unifiable (g,  , (proof,  , id),  , (proof',  , id)) then () else raise (error)(* unify a sum with a number *)
let rec unifySum(g,  , sum,  , d) if unifiable (g,  , (toExp (sum),  , id),  , (constant (d),  , id)) then () else raise (error)(* decomposition of an expression as the weighted sum of tableau positions *)
type Decomp(* change sign to the given decomposition *)
let rec unaryMinusDecomp((d,  , wposL)) (~ d,  , map (fun (d,  , pos) -> (~ d,  , pos)) wposL)(* decompose a sum in whnf into a weighted sum of tableau positions *)
let rec decomposeSum(g,  , sum (m,  , monL)) let let rec monToWPos(mon as (mon (n,  , usL))) (match findMon (mon) with sOME (pos) -> (n,  , pos) nONE -> let let  inlet  in in (log ( trail (tableau),  , insert (col (new))); delayMon (mon,  , ref (makeCnstr ( tag (l)))); update ( clabels (tableau),  , new,  , l); (n,  , col (new)))) in (m,  , map monToWPos monL)(* insert the given expression in the tableau, labelling it with owner *)
 insertDecomp(decomp as (d,  , wposL),  , owner) let let  inlet rec insertWPos(d,  , pos) (match pos with row (row) -> (incrArray2Row ( coeffs (tableau),  , new,  , (0,  , nCols ()),  , (fun (j) -> d * coeff (row,  , j))); incrArray ( consts (tableau),  , new,  , d * const (row))) col (col) -> incrArray2 ( coeffs (tableau),  , new,  , col,  , d)) in ((* add the decomposition to the newly created row *)
app insertWPos wposL; incrArray ( consts (tableau),  , new,  , d); (* is this row trivial? *)
match isSubsumed (new) with sOME (pos) -> (clearArray2Row ( coeffs (tableau),  , new,  , (0,  , nCols ())); update ( consts (tableau),  , new,  , zero); decrNRows (); pos) nONE -> (setOwnership (row (new),  , owner,  , ref 0);  dead (label (row (new))) := isConstant (new); (* log the creation of this row *)
log ( trail (tableau),  , insert (row (new))); (* return its position *)
row (new)))(* insert the given (unrestricted) expression in the tableau *)
 insert(g,  , us) let let  in in insertDecomp (decomposeSum (g,  , sum),  , exp (g,  , sum))(* minimize a tableau that has been determined non-minimal (but consistent) as a
       consequence of adding the given row.
    *)
 minimize(row) let (* equate the given column to zero if coeff(row, j) <> zero *)
let rec killColumn(j,  , l : Label) if (not (dead (l))) && (coeff (row,  , j) <> zero) then ((* mark the column dead *)
log ( trail (tableau),  , kill (col (j)));  dead (sub ( clabels (tableau),  , j)) := true; (* if restricted, instantiate the proof object to 0>=0 *)
(match restriction (l) with sOME (restr) -> unifyRestr (restr,  , geq00 ()) nONE -> ()); (* if owned by a monomial, unify it with zero *)
(match  owner (l) with (owner as (var _)) -> unifySum (ownerContext (owner),  , ownerSum (owner),  , zero) _ -> ())) else ()(* find out if the given row has been made trivial by killing some
               columns
            *)
let rec killRow(i,  , l : Label) if not (dead (l)) then if isConstant (i) then (* row is now constant and equal to n = const(i) *)
((* mark the row dead *)
log ( trail (tableau),  , kill (row (i)));  dead (sub ( rlabels (tableau),  , i)) := true; (* if restricted, instantiate the proof object to n>=0 *)
(match restriction (l) with sOME (restr) -> unifyRestr (restr,  , geqN0 (const (i))) nONE -> ()); (* if owned by a monomial, unify it with n *)
(match  owner (l) with (owner as (var _)) -> unifySum (ownerContext (owner),  , ownerSum (owner),  , const (i)) _ -> ())) else match isSubsumed (i) with sOME (pos') -> let let  in in (log ( trail (tableau),  , kill (row (i)));  dead (sub ( rlabels (tableau),  , i)) := true; (match (restriction (l),  , restriction (l')) with (sOME (restr),  , sOME (restr (_,  , proof',  , _))) -> unifyRestr (restr,  , proof') (sOME _,  , nONE) -> ((* it is safe to restrict without doing all
                                              the checks in this case, since the two rows
                                              are identical *)
log ( trail (tableau),  , restrict (pos'));  restr (l') := restriction (l)) (nONE,  , _) -> ())) nONE -> () else () in (app killColumn ( clabels (tableau),  , 0,  , nCols ()); app killRow ( rlabels (tableau),  , 0,  , nRows ()))(* restrict the given row/column to be nonnegative *)
 restrict(pos as col (col),  , restr) let let  in in if dead (l) then unifyRestr (restr,  , geq00 ()) else match restriction (l) with sOME (restr (_,  , proof',  , _)) -> unifyRestr (restr,  , proof') nONE -> let (* compute the list of non-null row entries *)
let  in in match nonNull with (row :: _) -> ((* pivot to a row position; this is sound since
                                   the column is unrestricted (see Nelson '81)
                                *)
log ( trail (tableau),  , pivot (row,  , col)); pivot (row,  , col); restrict (row (row),  , restr)) nil -> ((* the column is zero at all the active row
                                   positions, so we can restrict it right away
                                *)
log ( trail (tableau),  , restrict (col (col)));  restr (label (col (col))) := sOME (restr)) restrict(pos as row (row),  , restr) let let  in in if dead (l) then unifyRestr (restr,  , geqN0 (const (row))) else match restriction (l) with sOME (restr (_,  , proof',  , _)) -> unifyRestr (restr,  , proof') nONE -> match maximizeRow row with unbounded col -> (log ( trail (tableau),  , restrict (row (row)));  restr (sub ( rlabels (tableau),  , row)) := sOME (restr); if (const (row) < zero) then (log ( trail (tableau),  , pivot (row,  , col)); pivot (row,  , col)) else ()) positive -> ((* the tableau is satisfiable and minimal *)
log ( trail (tableau),  , restrict (row (row)));  restr (sub ( rlabels (tableau),  , row)) := sOME (restr)) maximized value -> if (value = zero) then ((* the tableau is satisfiable but not minimal*)
log ( trail (tableau),  , restrict (row (row)));  restr (sub ( rlabels (tableau),  , row)) := sOME (restr); minimize (row)) else raise (error)(* insert the equality Var(pos) = Us as two inequalities:
         Var(pos) - Us >= zero
         Us - Var(pos) >= zero
    *)
 insertEqual(g,  , pos,  , sum) let let  inlet  inlet  inlet  inlet  in in ((* the second expression may change position when we
                  restrict the first. We use tags to keep track of it *)
restrict (pos',  , restr (g,  , geq00 (),  , false)); (match findTag (tag'') with sOME (pos'') -> restrict (pos'',  , restr (g,  , geq00 (),  , false))))(* update the tableau upon discovery that Var(pos) = sum *)
 update(g,  , pos,  , sum) let let  in in ((* if the given position has a owner, delete it, since not doing so
                 may violate the invariant *)
log ( trail (tableau),  , updateOwner (pos,  ,  owner (l),  ,  tag (l))); setOwnership (pos,  , exp (g,  , sum),  , ref 0); (* analyze the given position to see exactly how to represent this
                 equality *)
if dead (l) then (match pos with row (row) -> (* find out why it died *)
if isConstant (row) then (* row is dead because constant and equal to n *)
unifySum (g,  , sum,  , const (row)) else (* row is dead because is subsumed by another *)
(match isSubsumed (row) with sOME (pos') -> update (g,  , pos',  , sum)) col (col) -> (* column is dead because = 0 *)
unifySum (g,  , sum,  , zero)) else let let rec isVar(sum (m,  , [mon as mon (n,  , _)])) if (m = zero) && (n = one) then sOME (mon) else nONE isVar(sum) nONE in match isVar (sum) with sOME (mon) -> (* the nf is another variable *)
(match findMon (mon) with sOME _ -> insertEqual (g,  , pos,  , sum) nONE -> let let  in in ((* recycle the current label *)
log ( trail (tableau),  , updateOwner (pos,  ,  owner (l),  ,  tag (l))); setOwnership (pos,  , var (g,  , mon),  , tag); delayMon (mon,  , ref (makeCnstr (tag))))) nONE -> insertEqual (g,  , pos,  , sum))(* returns the list of unsolved constraints associated with the given position *)
 restrictions(pos) let let rec member(x,  , l) exists (fun y -> x = y) llet rec test(l) restricted (l) && not (dead (l))let rec reachable((pos as row (row)) :: candidates,  , tried,  , closure) if member (pos,  , tried) then reachable (candidates,  , tried,  , closure) else let let  inlet  in in reachable (new_candidates @ candidates,  , pos :: tried,  , closure') reachable((pos as col (col)) :: candidates,  , tried,  , closure) if member (pos,  , tried) then reachable (candidates,  , tried,  , closure) else let let  inlet  in in reachable (candidates' @ candidates,  , pos :: tried,  , closure') reachable(nil,  , _,  , closure) closurelet rec restrExp(pos) let let  inlet  inlet  inlet  in in (match restriction (label (pos)) with sOME (restr (_,  , _,  , true)) -> (g,  , gt0 (u)) _ -> (g,  , geq0 (u))) in map restrExp (reachable ([pos],  , nil,  , nil))(* create a foreingn constraint for the given tag *)
 makeCnstr(tag) fgnCnstr (! myID,  , myFgnCnstrRep tag)(* returns the list of unsolved constraints associated with the given tag *)
let rec toInternal(tag)() (match findTag (tag) with nONE -> nil sOME (pos) -> restrictions (pos))(* awake function for tableau constraints *)
let rec awake(tag)() (try  with )(* simplify function for tableau constraints *)
let rec simplify(tag)() (match toInternal (tag) () with nil -> true (_ :: _) -> false)(* undo function for trailing tableau operations *)
let rec undo(insert (row (row))) ( dead (sub ( rlabels (tableau),  , row)) := true; clearArray2Row ( coeffs (tableau),  , row,  , (0,  , nCols ())); update ( consts (tableau),  , row,  , zero); decrNRows ()) undo(insert (col (col))) ( dead (sub ( clabels (tableau),  , col)) := true; clearArray2Col ( coeffs (tableau),  , col,  , (0,  , nRows ())); decrNCols ()) undo(pivot (row,  , col)) pivot (row,  , col) undo(kill (pos))  dead (label (pos)) := false undo(restrict (pos))  restr (label (pos)) := nONE undo(updateOwner (pos,  , owner,  , tag)) setOwnership (pos,  , owner,  , tag)(* reset the internal status of the tableau *)
let rec reset() let let  in in (modify (fun _ -> l) ( rlabels (tableau),  , 0,  , nRows ()); modify (fun _ -> l) ( clabels (tableau),  , 0,  , nCols ()); modify (fun _ -> zero) ( consts (tableau),  , 0,  , nRows ()); modify rowMajor (fun _ -> zero) {base =   coeffs (tableau) coeffs (tableau); row =  00; col =  00; nrows =  nRows ()nRows (); ncols =  nCols ()nCols ()};  nrows (tableau) := 0;  ncols (tableau) := 0; reset ( trail (tableau)))(* trailing functions *)
let rec mark() mark ( trail (tableau))let rec unwind() unwind ( trail (tableau),  , undo)(* fst (S, s) = U1, the first argument in S[s] *)
let rec fst(app (u1,  , _),  , s) (u1,  , s) fst(sClo (s,  , s'),  , s) fst (s,  , comp (s',  , s))(* snd (S, s) = U2, the second argument in S[s] *)
let rec snd(app (u1,  , s),  , s) fst (s,  , s) snd(sClo (s,  , s'),  , s) snd (s,  , comp (s',  , s))(* checks if the given foreign term can be simplified to a constant *)
let rec isConstantExp(u) (match (fromExp (u,  , id)) with (sum (m,  , nil)) -> sOME (m) _ -> nONE)(* checks if the given foreign term can be simplified to zero *)
let rec isZeroExp(u) (match isConstantExp (u) with sOME (d) -> (d = zero) nONE -> false)(* solveGt (G, S, n) tries to find the n-th solution to G |- '>' @ S : type *)
let rec solveGt(g,  , s,  , 0) let let rec solveGt0(w) (match isConstantExp (w) with sOME (d) -> if (d > zero) then gtNExp (d) else raise (error) nONE -> let let  inlet  in in proof)let  inlet  in in try  with  solveGt(g,  , s,  , n) nONE(* solveGeq (G, S, n) tries to find the n-th solution to G |- '>=' @ S : type *)
let rec solveGeq(g,  , s,  , 0) let let rec solveGeq0(w) (match isConstantExp (w) with sOME (d) -> if (d >= zero) then geqN0 (d) else raise (error) nONE -> let let  inlet  in in proof)let  inlet  in in try  with  solveGeq(g,  , s,  , n) nONE(* constructors for higher-order types *)
let rec pi(name,  , u,  , v) pi ((dec (sOME (name),  , u),  , maybe),  , v)let rec arrow(u,  , v) pi ((dec (nONE,  , u),  , no),  , v)let rec installFgnCnstrOps() let let  inlet  inlet  inlet  in in ()(* install the signature *)
let rec init(cs,  , installF) (myID := cs; gtID := installF (conDec (">",  , nONE,  , 0,  , constraint (! myID,  , solveGt),  , arrow (number (),  , arrow (number (),  , uni (type))),  , kind),  , sOME (infix (minPrec,  , none)),  , [mapp (marg (star,  , nONE),  , mapp (marg (star,  , nONE),  , mnil))]); geqID := installF (conDec (">=",  , nONE,  , 0,  , constraint (! myID,  , solveGeq),  , arrow (number (),  , arrow (number (),  , uni (type))),  , kind),  , sOME (infix (minPrec,  , none)),  , [mapp (marg (star,  , nONE),  , mapp (marg (star,  , nONE),  , mnil))]); gtAddID := installF (conDec ("+>",  , nONE,  , 2,  , normal,  , pi ("X",  , number (),  , pi ("Y",  , number (),  , pi ("Z",  , number (),  , arrow (gt (root (bVar 3,  , nil),  , root (bVar 2,  , nil)),  , gt (plus (root (bVar 4,  , nil),  , root (bVar 2,  , nil)),  , plus (root (bVar 3,  , nil),  , root (bVar 2,  , nil))))))),  , type),  , nONE,  , nil); geqAddID := installF (conDec ("+>=",  , nONE,  , 2,  , normal,  , pi ("X",  , number (),  , pi ("Y",  , number (),  , pi ("Z",  , number (),  , arrow (geq (root (bVar 3,  , nil),  , root (bVar 2,  , nil)),  , geq (plus (root (bVar 4,  , nil),  , root (bVar 2,  , nil)),  , plus (root (bVar 3,  , nil),  , root (bVar 2,  , nil))))))),  , type),  , nONE,  , nil); gtGeqID := installF (conDec (">>=",  , nONE,  , 2,  , normal,  , pi ("X",  , number (),  , pi ("Y",  , number (),  , arrow (gt (root (bVar 2,  , nil),  , root (bVar 1,  , nil)),  , geq (root (bVar 3,  , nil),  , root (bVar 2,  , nil))))),  , type),  , nONE,  , nil); geq00ID := installF (conDec ("0>=0",  , nONE,  , 0,  , normal,  , geq0 (constant (zero)),  , type),  , nONE,  , nil); installFgnCnstrOps (); ())let  inend