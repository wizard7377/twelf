ClausePrint  Whnf WHNF    Names NAMES    Formatter' FORMATTER    Print PRINT    Print Formatter  Formatter'   Symbol SYMBOL     CLAUSEPRINT  struct (*! structure IntSyn = IntSyn' !*)
module (* some shorthands *)
module module let  inlet rec str0(s,  , n) string0 n slet rec sym(s) str0 (sym s)let rec parens(fmt) hbox [sym "("; fmt; sym ")"](* assumes NF *)
let rec fmtDQuants(g,  , pi ((d as dec (_,  , v1),  , maybe),  , v2)) let let  in in sym "{" :: formatDec (g,  , d') :: sym "}" :: break :: fmtDQuants (decl (g,  , d'),  , v2) fmtDQuants(g,  , pi ((d as dec (_,  , v1),  , meta),  , v2)) let let  in in sym "{" :: formatDec (g,  , d') :: sym "}" :: break :: fmtDQuants (decl (g,  , d'),  , v2) fmtDQuants(g,  , v as pi _) [hOVbox (fmtDSubGoals (g,  , v,  , nil))] fmtDQuants(g,  , v) [formatExp (g,  , v)] fmtDSubGoals(g,  , pi ((d as dec (_,  , v1),  , no),  , v2),  , acc) fmtDSubGoals (decl (g,  , d),  , v2,  , break :: sym "<-" :: space :: fmtGparens (g,  , v1) :: acc) fmtDSubGoals(g,  , v as pi _,  , acc) parens (hVbox (fmtDQuants (g,  , v))) :: acc fmtDSubGoals(g,  , v,  , acc) formatExp (g,  , v) :: acc fmtDparens(g,  , v as pi _) parens (hVbox (fmtDQuants (g,  , v))) fmtDparens(g,  , v) formatExp (g,  , v) fmtGparens(g,  , v as pi _) parens (hVbox (fmtGQuants (g,  , v))) fmtGparens(g,  , v) formatExp (g,  , v) fmtGQuants(g,  , pi ((d as dec (_,  , v1),  , maybe),  , v2)) let let  in in sym "{" :: formatDec (g,  , d') :: sym "}" :: break :: fmtGQuants (decl (g,  , d'),  , v2) fmtGQuants(g,  , pi ((d as dec (_,  , v1),  , meta),  , v2)) let let  in in sym "{" :: formatDec (g,  , d') :: sym "}" :: break :: fmtGQuants (decl (g,  , d'),  , v2) fmtGQuants(g,  , v) [hOVbox (fmtGHyps (g,  , v))] fmtGHyps(g,  , pi ((d as dec (_,  , v1),  , no),  , v2)) fmtDparens (g,  , v1) :: break :: sym "->" :: space :: fmtGHyps (decl (g,  , d),  , v2) fmtGHyps(g,  , v as pi _) [hVbox (fmtGQuants (g,  , v))] fmtGHyps(g,  , v) [formatExp (g,  , v)]let rec fmtClause(g,  , v) hVbox (fmtDQuants (g,  , v))let rec fmtClauseI(0,  , g,  , v) fmtClause (g,  , v) fmtClauseI(i,  , g,  , pi ((d,  , _),  , v)) fmtClauseI (i - 1,  , decl (g,  , decEName (g,  , d)),  , v)let rec fmtConDec(conDec (id,  , parent,  , i,  , _,  , v,  , type)) let let  inlet  in in hVbox [str0 (const (id)); space; sym ":"; break; vfmt; sym "."] fmtConDec(condec) formatConDec (condec)let rec formatClause(g,  , v) fmtClause (g,  , v)let rec formatConDec(condec) fmtConDec (condec)let rec clauseToString(g,  , v) makestring_fmt (formatClause (g,  , v))let rec conDecToString(condec) makestring_fmt (formatConDec (condec))let rec printSgn() sgnApp (fun (cid) -> (print (conDecToString (sgnLookup cid)); print "\n"))(* local ... *)
end