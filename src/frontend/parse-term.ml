ParseTerm  ExtSyn' EXTSYN    Names NAMES     PARSE_TERM  struct (*! structure Parsing = Parsing' !*)
module (* some shorthands *)
module module (*! structure Paths = Lexer.Paths !*)
module (* Operators and atoms for operator precedence parsing *)
type Operator(* Predeclared infix operators *)
let  in(* juxtaposition *)
let  inlet  inlet  inlet rec infixOp(infixity,  , tm) infix (infixity,  , (fun (tm1,  , tm2) -> app (app (tm,  , tm1),  , tm2)))let rec prefixOp(prec,  , tm) prefix (prec,  , (fun tm1 -> app (tm,  , tm1)))let rec postfixOp(prec,  , tm) postfix (prec,  , (fun tm1 -> app (tm,  , tm1)))let rec idToTerm(lower,  , ids,  , name,  , r) lcid (ids,  , name,  , r) idToTerm(upper,  , ids,  , name,  , r) ucid (ids,  , name,  , r) idToTerm(quoted,  , ids,  , name,  , r) quid (ids,  , name,  , r)let rec isQuoted(quoted) true isQuoted_ falsetype Stacktype Opr(* The next section deals generically with fixity parsing          *)
(* Because of juxtaposition, it is not clear how to turn this      *)
(* into a separate module without passing a juxtaposition operator *)
(* into the shift and resolve functions                            *)
module (* structure P *)
(* parseQualifier' f = (ids, f')
       pre: f begins with L.ID

       Note: precondition for recursive call is enforced by the lexer. *)
let rec parseQualId'(f as cons ((t as iD (_,  , id),  , r),  , s')) (match expose s' with cons ((pATHSEP,  , _),  , s'') -> let let  in in ((id :: ids,  , (t,  , r)),  , f') f' -> ((nil,  , (t,  , r)),  , f'))let rec stripBar(cons ((iD (_,  , "|"),  , r),  , s')) (expose s') stripBar(f as cons ((rPAREN,  , r),  , s')) f stripBar(cons ((t,  , r),  , s')) error (r,  , "Expected `|', found token " ^ toString t)let rec parseQualIds1(ls,  , f as cons ((t as iD (_,  , id),  , r0),  , s')) let let  inlet  inlet  in in parseQualIds1 ((ids,  , name) :: ls,  , f'') parseQualIds1(ls,  , cons ((rPAREN,  , r),  , s')) (ls,  , expose s') parseQualIds1(ls,  , cons ((t,  , r),  , s)) error (r,  , "Expected label, found token " ^ toString t)let rec parseQualIds'(cons ((lPAREN,  , r),  , s')) parseQualIds1 (nil,  , expose s') parseQualIds'(cons ((t,  , r),  , s')) error (r,  , "Expected list of labels, found token " ^ toString t)(* Copied from parse-mode, should probably try to abstract all
       of the strip* functions into a common location - gaw *)
let rec stripRParen(cons ((rPAREN,  , r),  , s')) expose s' stripRParen(cons ((t,  , r),  , s')) error (r,  , "Expected closing `)', found " ^ toString t)let rec parseSubordPair2(f as cons ((iD _,  , _),  , _),  , qid) let let  in in ((qid,  , (ids,  , name)),  , stripRParen f') parseSubordPair2(cons ((t,  , r),  , s'),  , qid) error (r,  , "Expected identifier, found token " ^ toString t)let rec parseSubordPair1(f as cons ((iD _,  , _),  , _)) let let  in in parseSubordPair2 (f',  , (ids,  , name)) parseSubordPair1(cons ((t,  , r),  , s')) error (r,  , "Expected identifier, found token " ^ toString t)let rec parseSubord'(cons ((lPAREN,  , r),  , s'),  , qidpairs) let let  in in parseSubord' (f,  , qidpair :: qidpairs) parseSubord'(f as cons ((dOT,  , _),  , _),  , qidpairs) (rev qidpairs,  , f) parseSubord'(cons ((t,  , r),  , s'),  , qidpairs) error (r,  , "Expected a pair of identifiers, found token " ^ toString t)let rec parseFreeze'(f as cons ((iD _,  , _),  , _),  , qids) let let  in in parseFreeze' (f',  , (ids,  , name) :: qids) parseFreeze'(f as cons ((dOT,  , _),  , _),  , qids) (rev qids,  , f) parseFreeze'(cons ((t,  , r),  , s'),  , qids) error (r,  , "Expected identifier, found token " ^ toString t)let rec parseThaw'(f,  , qids) parseFreeze' (f,  , qids)let rec parseDeterministic'(f as cons ((iD _,  , _),  , _),  , qids) let let  in in parseDeterministic' (f',  , (ids,  , name) :: qids) parseDeterministic'(f as cons ((dOT,  , _),  , _),  , qids) (rev qids,  , f) parseDeterministic'(cons ((t,  , r),  , s'),  , qids) error (r,  , "Expected identifier, found token " ^ toString t)(* ABP 4/4/03 *)
let rec parseCompile'(f as cons ((iD _,  , _),  , _),  , qids) let let  in in parseCompile' (f',  , (ids,  , name) :: qids) parseCompile'(f as cons ((dOT,  , _),  , _),  , qids) (rev qids,  , f) parseCompile'(cons ((t,  , r),  , s'),  , qids) error (r,  , "Expected identifier, found token " ^ toString t)(* val parseExp : (L.token * L.region) LS.stream * <p>
                        -> ExtSyn.term * (L.token * L.region) LS.front *)
let rec parseExp(s,  , p) parseExp' (expose s,  , p) parseExp'(f as cons ((iD _,  , r0),  , _),  , p) let let  inlet  inlet  in in (* Currently, we cannot override fixity status of identifiers *)
(* Thus isQuoted always returns false *)
if isQuoted (idCase) then parseExp' (f',  , shiftAtom (tm,  , p)) else match fixityLookup (qid (ids,  , name)) with nonfix -> parseExp' (f',  , shiftAtom (tm,  , p)) infix infixity -> parseExp' (f',  , resolve (r,  , infixOp (infixity,  , tm),  , p)) prefix (prec) -> parseExp' (f',  , resolve (r,  , prefixOp (prec,  , tm),  , p)) postfix (prec) -> parseExp' (f',  , resolve (r,  , postfixOp (prec,  , tm),  , p)) parseExp'(cons ((uNDERSCORE,  , r),  , s),  , p) parseExp (s,  , shiftAtom (omitted r,  , p)) parseExp'(cons ((tYPE,  , r),  , s),  , p) parseExp (s,  , shiftAtom (typ r,  , p)) parseExp'(cons ((cOLON,  , r),  , s),  , p) parseExp (s,  , resolve (r,  , colonOp,  , p)) parseExp'(cons ((bACKARROW,  , r),  , s),  , p) parseExp (s,  , resolve (r,  , backArrowOp,  , p)) parseExp'(cons ((aRROW,  , r),  , s),  , p) parseExp (s,  , resolve (r,  , arrowOp,  , p)) parseExp'(cons ((lPAREN,  , r),  , s),  , p) decideRParen (r,  , parseExp (s,  , nil),  , p) parseExp'(f as cons ((rPAREN,  , r),  , s),  , p) (reduceAll (r,  , p),  , f) parseExp'(cons ((lBRACE,  , r),  , s),  , p) decideRBrace (r,  , parseDec (s),  , p) parseExp'(f as cons ((rBRACE,  , r),  , s),  , p) (reduceAll (r,  , p),  , f) parseExp'(cons ((lBRACKET,  , r),  , s),  , p) decideRBracket (r,  , parseDec (s),  , p) parseExp'(f as cons ((rBRACKET,  , r),  , s),  , p) (reduceAll (r,  , p),  , f) parseExp'(f as cons ((eQUAL,  , r),  , s),  , p) (reduceAll (r,  , p),  , f) parseExp'(f as cons ((dOT,  , r),  , s),  , p) (reduceAll (r,  , p),  , f) parseExp'(f as cons ((eOF,  , r),  , s),  , p) (reduceAll (r,  , p),  , f) parseExp'(f as cons ((sOLVE,  , r),  , s),  , p) (reduceAll (r,  , p),  , f) parseExp'(f as cons ((dEFINE,  , r),  , s),  , p) (reduceAll (r,  , p),  , f) parseExp'(cons ((sTRING (str),  , r),  , s),  , p) parseExp (s,  , shiftAtom (scon (str,  , r),  , p)) parseExp'(cons ((t,  , r),  , s),  , p) error (r,  , "Unexpected token " ^ toString t ^ " found in expression") parseDec(s) parseDec' (expose s) parseDec'(cons ((iD (quoted,  , name),  , r),  , s')) error (r,  , "Illegal bound quoted identifier " ^ name) parseDec'(cons ((iD (idCase,  , name),  , r),  , s')) (match fixityLookup (qid (nil,  , name)) with nonfix -> parseDec1 (sOME (name),  , expose s') infix _ -> error (r,  , "Cannot bind infix identifier " ^ name) prefix _ -> error (r,  , "Cannot bind prefix identifier " ^ name) postfix _ -> error (r,  , "Cannot bind postfix identifier " ^ name)) parseDec'(cons ((uNDERSCORE,  , r),  , s')) parseDec1 (nONE,  , expose s') parseDec'(cons ((eOF,  , r),  , s')) error (r,  , "Unexpected end of stream in declaration") parseDec'(cons ((t,  , r),  , s')) error (r,  , "Expected variable name, found token " ^ toString t) parseDec1(x,  , cons ((cOLON,  , r),  , s')) let let  in in ((x,  , sOME tm),  , f'') parseDec1(x,  , f as cons ((rBRACE,  , _),  , _)) ((x,  , nONE),  , f) parseDec1(x,  , f as cons ((rBRACKET,  , _),  , _)) ((x,  , nONE),  , f) parseDec1(x,  , cons ((t,  , r),  , s')) error (r,  , "Expected optional type declaration, found token " ^ toString t) decideRParen(r0,  , (tm,  , cons ((rPAREN,  , r),  , s)),  , p) parseExp (s,  , shiftAtom (tm,  , p)) decideRParen(r0,  , (tm,  , cons ((_,  , r),  , s)),  , p) error (join (r0,  , r),  , "Unmatched open parenthesis") decideRBrace(r0,  , ((x,  , yOpt),  , cons ((rBRACE,  , r),  , s)),  , p) let let  inlet  in in parseExp' (f',  , shiftAtom (pi (dec,  , tm),  , p)) decideRBrace(r0,  , (_,  , cons ((_,  , r),  , s)),  , p) error (join (r0,  , r),  , "Unmatched open brace") decideRBracket(r0,  , ((x,  , yOpt),  , cons ((rBRACKET,  , r),  , s)),  , p) let let  inlet  in in parseExp' (f',  , shiftAtom (lam (dec,  , tm),  , p)) decideRBracket(r0,  , (dec,  , cons ((_,  , r),  , s)),  , p) error (join (r0,  , r),  , "Unmatched open bracket")(* Parses contexts of the form  G ::= {id:term} | G, {id:term} *)
let rec stripRBrace(cons ((rBRACE,  , r),  , s')) (expose s',  , r) stripRBrace(cons ((t,  , r),  , _)) error (r,  , "Expected `}', found " ^ toString t)(* parseDec "{id:term} | {id}" *)
 parseBracedDec(r,  , f) let let  inlet  inlet  in in (d,  , f'')(* parseCtx (b, ds, f) = ds'
       if   f is a stream "{x1:V1}...{xn:Vn} s"
       and  b is true if no declarations has been parsed yet
       and  ds is a context of declarations
       then ds' = ds, x1:V1, ..., xn:Vn
    *)
let rec parseCtx(b,  , ds,  , cons (bS as ((lBRACE,  , r),  , s'))) let let  in in parseCtx (false,  , d :: ds,  , f') parseCtx(b,  , ds,  , f as cons ((t,  , r),  , s')) if b then error (r,  , "Expected `{', found " ^ toString t) else (ds,  , f)let  inlet  inlet  inlet  inlet  inlet  inlet  in(* -ABP 4/4/03 *)
let  inlet  inlet  in(* local ... in *)
end