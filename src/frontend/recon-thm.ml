ReconThm  Global GLOBAL    Abstract ABSTRACT    Constraints CONSTRAINTS    Names NAMES    ThmSyn' THMSYN    ThmSyn' Names  Names   ReconTerm' RECON_TERM    Print PRINT     RECON_THM  struct module (*! structure Paths = Paths' !*)
module exception module module module module module let rec error(r,  , msg) raise (error (wrap (r,  , msg)))type Orderlet rec varg(r,  , l) (varg l,  , r)let rec lex(r0,  , l) let let rec lex'nil (nil,  , r0) lex'((o,  , r) :: l) let let  in in (o :: os,  , join (r,  , r'))let  in in (lex os,  , r1)let rec simul(r0,  , l) let let rec simul'nil (nil,  , r0) simul'((o,  , r) :: l) let let  in in (o :: os,  , join (r,  , r'))let  in in (simul os,  , r1)type Callpatslet rec checkArgNumber(0,  , uni (type),  , nil,  , r) () checkArgNumber(0,  , pi (_,  , v2),  , arg :: args,  , r) checkArgNumber (0,  , v2,  , args,  , r) checkArgNumber(0,  , pi (_,  , v2),  , nil,  , r) error (r,  , "Missing arguments in call pattern") checkArgNumber(0,  , uni (type),  , arg :: args,  , r) error (r,  , "Extraneous arguments in call pattern") checkArgNumber(i,  , pi (_,  , v2),  , args,  , r) checkArgNumber (i - 1,  , v2,  , args,  , r)(* everything else should be impossible! *)
let rec checkCallPat(conDec (_,  , _,  , i,  , normal,  , v,  , kind),  , p,  , r) checkArgNumber (i,  , v,  , p,  , r) checkCallPat(conDec (a,  , _,  , _,  , constraint _,  , _,  , _),  , p,  , r) error (r,  , "Illegal constraint constant " ^ a ^ " in call pattern") checkCallPat(conDec (a,  , _,  , _,  , foreign _,  , _,  , _),  , p,  , r) error (r,  , "Illegal foreign constant " ^ a ^ " in call pattern") checkCallPat(conDec (a,  , _,  , _,  , _,  , _,  , type),  , p,  , r) error (r,  , "Constant " ^ a ^ " in call pattern not a type family") checkCallPat(conDef (a,  , _,  , _,  , _,  , _,  , _,  , _),  , p,  , r) error (r,  , "Illegal defined constant " ^ a ^ " in call pattern") checkCallPat(abbrevDef (a,  , _,  , _,  , _,  , _,  , _),  , p,  , r) error (r,  , "Illegal abbreviation " ^ a ^ " in call pattern") checkCallPat(blockDec (a,  , _,  , _,  , _),  , p,  , r) error (r,  , "Illegal block identifier " ^ a ^ " in call pattern") checkCallPat(skoDec (a,  , _,  , _,  , _,  , _),  , p,  , r) error (r,  , "Illegal Skolem constant " ^ a ^ " in call pattern")let rec callpatsl let let rec callpats'nil (nil,  , nil) callpats'((name,  , p,  , r) :: l) let let  inlet  in in (* check whether they are families here? *)
match constLookup qid with nONE -> error (r,  , "Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in call pattern") sOME cid -> (checkCallPat (sgnLookup cid,  , p,  , r); ((cid,  , p) :: cps,  , (r :: rs)))let  in in (callpats (cps),  , rs)type Tdecllet rec tdecl((o,  , r),  , (c,  , rs)) (tDecl (o,  , c),  , (r,  , rs))let rec tdeclTotDeclt t(* -bp *)
(* predicate *)
type Predicatelet rec predicate("LESS",  , r) (less,  , r) predicate("LEQ",  , r) (leq,  , r) predicate("EQUAL",  , r) (eq,  , r)(* reduces declaration *)
type Rdecllet rec rdecl((p,  , r0),  , (o1,  , r1),  , (o2,  , r2),  , (c,  , rs)) let let  in in (rDecl (redOrder (p,  , o1,  , o2),  , c),  , (join (r0,  , r),  , rs))let rec rdeclTorDeclt t(* tabled declaration *)
type Tableddecllet rec tableddecl(name,  , r) let let  in in (* check whether they are families here? *)
match constLookup qid with nONE -> error (r,  , "Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in call pattern") sOME cid -> (tabledDecl cid,  , r)let rec tableddeclTotabledDeclt t(* keepTable declaration *)
type KeepTabledecllet rec keepTabledecl(name,  , r) let let  in in (* check whether they are families here? *)
match constLookup qid with nONE -> error (r,  , "Undeclared identifier " ^ qidToString (valOf (constUndef qid)) ^ " in call pattern") sOME cid -> (keepTableDecl cid,  , r)let rec keepTabledeclToktDeclt t(* Theorem and prove declarations *)
type Provelet rec prove(n,  , (td,  , rrs)) (pDecl (n,  , td),  , rrs)let rec proveToProvep ptype Establishlet rec establish(n,  , (td,  , rrs)) (pDecl (n,  , td),  , rrs)let rec establishToEstablishp ptype Assertlet rec assert(cp,  , rs) (cp,  , rs)let rec assertToAssertp ptype Decslet  inlet  intype Labeldectype Thmtype Theoremtype Theoremdeclet rec dec(name,  , t) (name,  , t)let rec ctxAppend(g,  , null) g ctxAppend(g,  , decl (g',  , d)) decl (ctxAppend (g,  , g'),  , d)let rec ctxMapf(null) null ctxMapf(decl (g,  , d)) decl (ctxMap f g,  , f d)let rec ctxBlockToString(g0,  , (g1,  , g2)) let let  inlet  inlet  inlet  in in ctxToString (null,  , g0') ^ "\n" ^ (match g1' with null -> "" _ -> "some " ^ ctxToString (g0',  , g1') ^ "\n") ^ "pi " ^ ctxToString (ctxAppend (g0',  , g1'),  , g2')let rec checkFreevars(null,  , (g1,  , g2),  , r) () checkFreevars(g0,  , (g1,  , g2),  , r) let let  inlet  inlet  inlet  in in error (r,  , "Free variables in context block after term reconstruction:\n" ^ ctxBlockToString (g0',  , (g1',  , g2')))let rec abstractCtxPair(g1,  , g2) let (* each block reconstructed independent of others *)
let  inlet  inlet  inlet  in in (g1',  , g2')let rec top(gBs,  , g,  , m,  , k) (gBs,  , g,  , m,  , k)let rec exists(g',  , t)(gBs,  , g,  , m,  , k) t (gBs,  , ctxAppend (g,  , g'),  , ctxAppend (m,  , ctxMap (fun _ -> minus) g'),  , k)let rec forall(g',  , t)(gBs,  , g,  , m,  , k) t (gBs,  , ctxAppend (g,  , g'),  , ctxAppend (m,  , ctxMap (fun _ -> plus) g'),  , k)let rec forallStar(g',  , t)(gBs,  , g,  , m,  , _) t (gBs,  , ctxAppend (g,  , g'),  , ctxAppend (m,  , ctxMap (fun _ -> plus) g'),  , ctxLength g')let rec forallG(gbs,  , t : Thm -> Thm)(_ : Thm) Thm t (gbs,  , null,  , null,  , 0)let rec theoremToTheoremt let let  inlet  inlet  inlet  in in thDecl (gBs,  , g,  , m,  , k)let rec theoremDecToTheoremDec(name,  , t) (name,  , theoremToTheorem t)(* World checker *)
let rec abstractWDeclw let let  in in w'type Wdecllet rec wdecl(w,  , (cp,  , rs)) (wDecl (abstractWDecl w,  , cp),  , rs)let rec wdeclTowDeclt t(* avoid this re-copying? -fp *)
type Orderlet  inlet  inlet  intype Callpatslet  intype Tdecllet  in(* -bp *)
type Predicatelet  in(* -bp *)
type Rdecllet  intype Tableddecllet  intype KeepTabledecllet  intype Provelet  intype Establishlet  intype Assertlet  inlet  inlet  inlet  inlet  inlet  inlet  inlet  intype Decslet  inlet  intype Theoremlet  inlet  inlet  inlet  inlet  inlet  intype Theoremdeclet  inlet  intype Wdecllet  inlet  in(* local *)
end