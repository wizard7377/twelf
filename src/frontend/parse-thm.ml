ParseThm  ThmExtSyn' THMEXTSYN    ParseTerm PARSE_TERM    ParseTerm ExtSyn  ThmExtSyn' ExtSyn    PARSE_THM  struct (*! structure Parsing = Parsing' !*)
module module module module module (*--------------------------*)
(* %terminates declarations *)
(*--------------------------*)
(* idToNat (region, (idCase, name)) = n
       where n an natural number indicated by name, which should consist
       of all digits.  Raises error otherwise, or if integer it too large
    *)
let rec idToNat(r,  , name) try  with let rec stripRParen(cons ((rPAREN,  , r),  , s')) expose s' stripRParen(cons ((t,  , r),  , _)) error (r,  , "Expected `)', found " ^ toString t)let rec decideRBrace(r0,  , (orders,  , cons ((rBRACE,  , r),  , s'))) (sOME (lex (r0,  , orders)),  , expose s') decideRBrace(r0,  , (order,  , cons ((t,  , r),  , _))) error (join (r0,  , r),  , "Expected `}', found " ^ toString t)let rec decideRBracket(r0,  , (orders,  , cons ((rBRACKET,  , r),  , s'))) (sOME (simul (r0,  , orders)),  , expose s') decideRBracket(r0,  , (order,  , cons ((t,  , r),  , _))) error (join (r0,  , r),  , "Expected `]', found " ^ toString t)let rec decideRParen(r0,  , (ids,  , cons ((rPAREN,  , r),  , s'))) (sOME (varg (r,  , ids)),  , expose s') decideRParen(r0,  , (order,  , cons ((t,  , r),  , _))) error (join (r0,  , r),  , "Expected `)', found " ^ toString t)(* parseIds "id ... id" = ["id",...,"id"] *)
(* terminated by non-identifier token *)
let rec parseIds(cons ((iD (upper,  , id),  , r),  , s')) let let  in in (id :: ids,  , f') parseIds(cons ((t as iD (_,  , id),  , r),  , s')) error (r,  , "Expecter upper case identifier, found " ^ toString t) parseIdsf (nil,  , f)(* parseArgPat "_id ... _id" = [idOpt,...,idOpt] *)
(* terminated by token different from underscore or id *)
let rec parseArgPat(cons ((iD (upper,  , id),  , r),  , s')) let let  in in (sOME id :: idOpts,  , f') parseArgPat(cons ((iD (_,  , id),  , r),  , s')) error (r,  , "Expected upper case identifier, found " ^ id) parseArgPat(cons ((uNDERSCORE,  , r),  , s')) let let  in in (nONE :: idOpts,  , f') parseArgPatf (nil,  , f)(* parseCallPat "id _id ... _id" = (id, region, [idOpt,...,idOpt]) *)
let rec parseCallPat(cons ((iD (_,  , id),  , r),  , s')) let let  in in ((id,  , idOpts,  , join (r,  , r')),  , f') parseCallPat(cons ((t,  , r),  , s)) error (r,  , "Expected call pattern, found token " ^ toString t)(* parseCallPats "(id _id ... _id)...(id _id ... _id)." *)
let rec parseCallPats(cons ((lPAREN,  , r),  , s')) let let  inlet  in in (cpat :: cpats,  , f'') parseCallPats(f as cons ((dOT,  , r),  , s')) (nil,  , f) parseCallPats(cons ((t,  , r),  , s)) error (r,  , "Expected call patterns, found token " ^ toString t)(* order ::= id | (id ... id)   virtual arguments = subterm ordering
               | {order ... order}  lexicgraphic order
               | [order ... order]  simultaneous order
    *)
(* parseOrderOpt (f) = (SOME(order), f') or (NONE, f) *)
(* returns an optional order and front of remaining stream *)
let rec parseOrderOpt(cons ((lPAREN,  , r),  , s')) decideRParen (r,  , parseIds (expose s')) parseOrderOpt(cons ((lBRACE,  , r),  , s')) decideRBrace (r,  , parseOrders (expose s')) parseOrderOpt(cons ((lBRACKET,  , r),  , s')) decideRBracket (r,  , parseOrders (expose s')) parseOrderOpt(cons ((iD (upper,  , id),  , r),  , s')) (sOME (varg (r,  , [id])),  , expose s') parseOrderOpt(f as cons (_,  , s')) (nONE,  , f)(* parseOrders (f) = ([order1,...,ordern], f') *)
(* returns a sequence of orders and remaining front of stream *)
 parseOrders(f) parseOrders' (parseOrderOpt f) parseOrders'(sOME (order),  , f') let let  in in (order :: orders,  , f'') parseOrders'(nONE,  , f') (nil,  , f')(* parseOrder (f) = (order, f') *)
(* returns an order and front of remaining stream *)
let rec parseOrder(f) parseOrder' (parseOrderOpt f) parseOrder'(sOME (order),  , f') (order,  , f') parseOrder'(nONE,  , cons ((t,  , r),  , s')) error (r,  , "Expected order, found " ^ toString t)(* parseTDecl "order callPats." *)
(* parses Termination Declaration, followed by `.' *)
let rec parseTDeclf let let  inlet  in in (tdecl (order,  , callpats callpats),  , f'')(* parseTerminates' "%terminates tdecl." *)
let rec parseTerminates'(cons ((tERMINATES,  , r),  , s')) parseTDecl (expose s')(* ------------------- *)
(* %total declaration  *)
(* ------------------- *)
(* parseTotal' "%total tdecl." *)
let rec parseTotal'(cons ((tOTAL,  , r),  , s')) parseTDecl (expose s')(* ------------------- *)
(* %prove declarations *)
(* ------------------- *)
(* parsePDecl "id nat order callpats." *)
let rec parsePDecl(cons ((iD (_,  , id),  , r),  , s')) let let  inlet  in in (prove (depth,  , t'),  , f') parsePDecl(cons ((t,  , r),  , s')) error (r,  , "Expected theorem identifier, found " ^ toString t)(* parseProve' "%prove pdecl." *)
let rec parseProve'(cons ((pROVE,  , r),  , s')) parsePDecl (expose s')(* ----------------------- *)
(* %establish declarations *)
(* ----------------------- *)
(* parseEDecl "id nat order callpats." *)
let rec parseEDecl(cons ((iD (_,  , id),  , r),  , s')) let let  inlet  in in (establish (depth,  , t'),  , f') parseEDecl(cons ((t,  , r),  , s')) error (r,  , "Expected theorem identifier, found " ^ toString t)(* parseEstablish' "%establish pdecl." *)
let rec parseEstablish'(cons ((eSTABLISH,  , r),  , s')) parseEDecl (expose s')(* -------------------- *)
(* %assert declarations *)
(* -------------------- *)
(* parseAssert' "%assert cp" *)
let rec parseAssert'(cons ((aSSERT,  , r),  , s')) let let  in in (assert (callpats callpats),  , f'')(* --------------------- *)
(* %theorem declarations *)
(* --------------------- *)
let rec stripRBrace(cons ((rBRACE,  , r),  , s')) (expose s',  , r) stripRBrace(cons ((t,  , r),  , _)) error (r,  , "Expected `}', found " ^ toString t)(* parseDec "{id:term} | {id}" *)
 parseDec(r,  , f) let let  inlet  inlet  in in (dec,  , f'')(* parseDecs' "{id:term}...{id:term}", zero or more, ":term" optional *)
 parseDecs'(drs,  , cons (bS as ((lBRACE,  , r),  , s'))) let let  in in parseDecs' (decl (drs,  , dr),  , f') parseDecs'drs drs(* parseDecs "{id:term}...{id:term}", one ore more, ":term" optional *)
 parseDecs(cons (bS as ((lBRACE,  , r),  , s'))) let let  in in parseDecs' (decl (null,  , dr),  , f') parseDecs(cons ((t,  , r),  , s')) error (r,  , "Expected `{', found " ^ toString t)let rec parsePi(cons ((iD (_,  , "pi"),  , r),  , s')) parseDecs (expose s') parsePi(cons ((t,  , r),  , s')) error (r,  , "Expected `pi', found " ^ toString t)let rec parseSome(gbs,  , cons ((iD (_,  , "some"),  , r),  , s')) let let  inlet  in in parseSome' ((g1,  , g2) :: gbs,  , f'') parseSome(gbs,  , f as cons ((iD (_,  , "pi"),  , r),  , s')) let let  in in parseSome' ((null,  , g2) :: gbs,  , f') parseSome(gbs,  , f as cons ((rPAREN,  , r),  , s')) (gbs,  , f) parseSome(gbs,  , cons ((t,  , r),  , s')) error (r,  , "Expected `some' or `pi', found " ^ toString t) parseSome'(gbs,  , f as cons ((rPAREN,  , r),  , s')) (gbs,  , f) parseSome'(gbs,  , cons ((iD (_,  , "|"),  , r),  , s')) parseSome (gbs,  , expose s') parseSome'(gbs,  , cons ((t,  , r),  , s')) error (r,  , "Expected `)' or `|', found " ^ toString t)let rec stripParen(gbs,  , cons ((rPAREN,  , r),  , s')) (gbs,  , expose s')let rec parseGBs(cons ((lPAREN,  , r),  , s')) stripParen (parseSome (nil,  , expose s')) parseGBs(cons ((t,  , r),  , s')) error (r,  , "Expected `(', found " ^ toString t)let rec forallG((gbs',  , f'),  , r) let let  in in (forallG (gbs',  , t''),  , f'') forallStar((g',  , f'),  , r) let let  in in (forallStar (g',  , t''),  , f'') forall((g',  , f'),  , r) let let  in in (forall (g',  , t''),  , f'') exists((g',  , f'),  , r) let let  in in (exists (g',  , t''),  , f'') top(f',  , r) (top,  , f')(* parseTrue "true" *)
 parseTrue(cons ((iD (_,  , "true"),  , r),  , s')) top (expose s',  , r) parseTrue(cons ((t,  , r),  , s')) error (r,  , "Expected `true', found " ^ toString t)(* parseExists "exists decs mform | mform" *)
 parseExists(cons ((iD (_,  , "exists"),  , r),  , s')) exists (parseDecs (expose s'),  , r) parseExists(cons ((iD (_,  , "true"),  , r),  , s')) top (expose s',  , r) parseExists(cons ((t,  , r),  , s')) error (r,  , "Expected `exists' or `true', found " ^ toString t)(* parseForall "forall decs mform | mform" *)
 parseForall(cons ((iD (_,  , "forall"),  , r),  , s')) forall (parseDecs (expose s'),  , r) parseForall(cons ((iD (_,  , "exists"),  , r),  , s')) exists (parseDecs (expose s'),  , r) parseForall(cons ((iD (_,  , "true"),  , r),  , s')) top (expose s',  , r) parseForall(cons ((t,  , r),  , s')) error (r,  , "Expected `forall', `exists', or `true', found " ^ toString t)(* parseForallStar "forall* decs mform | mform" *)
 parseForallStar(cons ((iD (_,  , "forall*"),  , r),  , s')) forallStar (parseDecs (expose s'),  , r) parseForallStar(cons ((iD (_,  , "forall"),  , r),  , s')) forall (parseDecs (expose s'),  , r) parseForallStar(cons ((iD (_,  , "exists"),  , r),  , s')) exists (parseDecs (expose s'),  , r) parseForallStar(cons ((iD (_,  , "true"),  , r),  , s')) top (expose s',  , r) parseForallStar(cons ((t,  , r),  , s')) error (r,  , "Expected `forall*', `forall', `exists', or `true', found " ^ toString t) parseCtxScheme(cons ((iD (_,  , "forallG"),  , r),  , s')) forallG (parseGBs (expose s'),  , r) parseCtxScheme(cons ((iD (_,  , "forall*"),  , r),  , s')) forallStar (parseDecs (expose s'),  , r) parseCtxScheme(cons ((iD (_,  , "forall"),  , r),  , s')) forall (parseDecs (expose s'),  , r) parseCtxScheme(cons ((iD (_,  , "exists"),  , r),  , s')) exists (parseDecs (expose s'),  , r) parseCtxScheme(cons ((iD (_,  , "true"),  , r),  , s')) top (expose s',  , r) parseCtxScheme(cons ((t,  , r),  , s')) error (r,  , "Expected `forallG', `forall*', `forall', `exists', or `true', found " ^ toString t)(* parseColon ": mform" *)
let rec parseColon(cons ((cOLON,  , r),  , s')) parseCtxScheme (expose s') parseColon(cons ((t,  , r),  , s')) error (r,  , "Expected `:', found " ^ toString t)(* parseThDec "id : mform" *)
let rec parseThDec(cons ((iD (_,  , id),  , r),  , s')) let let  in in (dec (id,  , t'),  , f') parseThDec(cons ((t,  , r),  , s')) error (r,  , "Expected theorem identifier, found " ^ toString t)(* parseTheoremDec' "%theorem thdec." *)
(* We enforce the quantifier alternation restriction syntactically *)
let rec parseTheoremDec'(cons ((tHEOREM,  , r),  , s')) parseThDec (expose s')(*  -bp6/5/99. *)
(* parsePredicate f = (pred, f')               *)
(* parses the reduction predicate, <, <=, =   *)
let rec parsePredicate(cons ((iD (_,  , "<"),  , r),  , s')) (predicate ("LESS",  , r),  , (expose s')) parsePredicate(cons ((iD (_,  , "<="),  , r),  , s')) (predicate ("LEQ",  , r),  , (expose s')) parsePredicate(cons ((eQUAL,  , r),  , s')) (predicate ("EQUAL",  , r),  , (expose s')) parsePredicate(cons ((t,  , r),  , s')) error (r,  , "Expected reduction predicate <, = or <=, found " ^ toString t)(* parseRDecl "order callPats." *)
(* parses Reducer Declaration, followed by `.' *)
let rec parseRDeclf let let  inlet  inlet  inlet  in in (rdecl (p,  , oOut,  , oIn,  , callpats callpats),  , f4)(* parseReduces' "%reduces thedec. " *)
let rec parseReduces'(cons ((rEDUCES,  , r),  , s')) parseRDecl (expose s')let rec parseTabledDecl(f as cons ((iD (_,  , id),  , r),  , s')) (match (expose s') with (f as cons ((dOT,  , r'),  , s)) -> (tableddecl (id,  , r),  , f) _ -> error (r,  , "Expected ."))(* parseTabled' "%tabled thedec. " *)
let rec parseTabled'(cons ((tABLED,  , r),  , s')) parseTabledDecl (expose s')let rec parseKeepTableDecl(f as cons ((iD (_,  , id),  , r),  , s')) (match (expose s') with (f as cons ((dOT,  , r'),  , s)) -> (keepTabledecl (id,  , r),  , f) _ -> error (r,  , "Expected ."))(* parseKeepTable' "%keepTabled thedec. " *)
let rec parseKeepTable'(cons ((kEEPTABLE,  , r),  , s')) parseKeepTableDecl (expose s')let rec parseWDeclf let (*       val (GBs, f1) = parseGBs f *)
let  inlet  in in (wdecl (qids,  , callpats callpats),  , f2)let rec parseWorlds'(cons ((wORLDS,  , r),  , s')) parseWDecl (expose s')let  inlet  inlet  inlet  inlet  inlet  inlet  inlet  in(*  -bp  6/05/99.*)
let  in(*  -bp 20/11/01.*)
let  in(*  -bp 20/11/01.*)
let  in(* local ... in *)
end