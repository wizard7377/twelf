ParseConDec  ExtConDec' EXTCONDEC    ParseTerm PARSE_TERM    ParseTerm ExtSyn  ExtConDec' ExtSyn    PARSE_CONDEC  struct (*! structure Parsing = Parsing' !*)
module module module (* parseConDec3  "U" *)
let rec parseConDec3(optName,  , optTm,  , s) let let  in in (condef (optName,  , tm',  , optTm),  , f')(* parseConDec2  "= U" | "" *)
let rec parseConDec2(optName,  , (tm,  , cons ((eQUAL,  , r),  , s'))) parseConDec3 (optName,  , sOME (tm),  , s') parseConDec2(sOME (name),  , (tm,  , f)) (condec (name,  , tm),  , f) parseConDec2(nONE,  , (tm,  , cons ((t,  , r),  , s'))) error (r,  , "Illegal anonymous declared constant")(* parseConDec1  ": V = U" | "= U" *)
let rec parseConDec1(optName,  , cons ((cOLON,  , r),  , s')) parseConDec2 (optName,  , parseTerm' (expose s')) parseConDec1(optName,  , cons ((eQUAL,  , r),  , s')) parseConDec3 (optName,  , nONE,  , s') parseConDec1(optName,  , cons ((t,  , r),  , s')) error (r,  , "Expected `:' or `=', found " ^ toString t)(* BlockDec parser *)
let rec parseBlock(cons ((iD (_,  , "block"),  , r),  , s')) parseCtx' (expose s') parseBlock(cons ((t,  , r),  , s')) error (r,  , "Expected `block', found " ^ toString t)let rec parseSome(name,  , cons ((iD (_,  , "some"),  , r),  , s')) let let  inlet  in in (blockdec (name,  , g1,  , g2),  , f'') parseSome(name,  , f as cons ((iD (_,  , "block"),  , r),  , s')) let let  in in (blockdec (name,  , nil,  , g2),  , f') parseSome(name,  , cons ((t,  , r),  , s')) error (r,  , "Expected `some' or `block', found " ^ toString t)let rec parseBlockDec1(name,  , cons ((cOLON,  , r),  , s')) parseSome (name,  , expose s') parseBlockDec1(name,  , cons ((eQUAL,  , r),  , s')) let let  in in (blockdef (name,  , g),  , f) parseBlockDec1(name,  , cons ((t,  , r),  , s')) error (r,  , "`:' expected, found token " ^ toString t)let rec parseBlockDec'(cons ((iD (idCase,  , name),  , r),  , s')) parseBlockDec1 (name,  , expose s') parseBlockDec'(cons ((t,  , r),  , s')) error (r,  , "Label identifier expected, found token " ^ toString t)(* parseConDec' : lexResult front -> ExtConDec.ConDec * lexResult front
       Invariant: first token in exposed input stream is an identifier or underscore
    *)
let rec parseConDec'(cons ((iD (idCase,  , name),  , r),  , s')) parseConDec1 (sOME (name),  , expose s') parseConDec'(cons ((uNDERSCORE,  , r),  , s')) parseConDec1 (nONE,  , expose s') parseConDec'(cons ((bLOCK,  , r),  , s')) parseBlockDec' (expose s') parseConDec'(cons ((t,  , r),  , s')) error (r,  , "Constant or block declaration expected, found token " ^ toString t)(* parseConDec --- currently not exported *)
let rec parseConDec(s) parseConDec' (expose s)let rec parseAbbrev'(cons ((aBBREV,  , r),  , s)) parseConDec (s)let rec parseClause'(cons ((cLAUSE,  , r),  , s)) parseConDec (s)(* -fp *)
let  inlet  inlet  in(* local ... in *)
end