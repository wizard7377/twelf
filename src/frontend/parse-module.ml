ParseModule  ModExtSyn' MODEXTSYN    ParseTerm PARSE_TERM    ParseTerm ExtSyn  ModExtSyn' ExtSyn    PARSE_MODULE  struct (*! structure Parsing = Parsing' !*)
module module module module let rec parseStructExp'(f as cons ((iD _,  , r0),  , _)) let let  in in (strexp (ids,  , id,  , join (r0,  , r1)),  , f') parseStructExp'(cons ((t,  , r),  , s')) error (r,  , "Expected structure identifier, found token " ^ toString t)let rec parseColonEqual'(cons ((cOLON,  , r1),  , s')) (match expose s' with cons ((eQUAL,  , _),  , s'') -> ((),  , expose s'') cons ((t,  , r2),  , s'') -> error (r2,  , "Expected `=', found token " ^ toString t)) parseColonEqual'(cons ((t,  , r),  , s')) error (r,  , "Expected `:=', found token " ^ toString t)let rec parseDot'(cons ((dOT,  , r),  , s')) (r,  , expose s') parseDot'(cons ((t,  , r),  , s')) error (r,  , "Expected `.', found token " ^ toString t)let rec parseConInst'(f as cons ((iD _,  , r0),  , _)) let let  inlet  inlet  inlet  in in (coninst ((ids,  , id,  , join (r0,  , r1)),  , tm,  , join (r0,  , r2)),  , f4) parseConInst'(cons ((t,  , r),  , s')) error (r,  , "Expected identifier, found token " ^ toString t)let rec parseStrInst2'(r0,  , f as cons ((iD _,  , r1),  , _)) let let  inlet  inlet  inlet  in in (strinst ((ids,  , id,  , join (r1,  , r2)),  , strexp,  , join (r0,  , r3)),  , f4) parseStrInst2'(r0,  , cons ((t,  , r),  , s')) error (r,  , "Expected structure identifier, found token " ^ toString t)let rec parseStrInst'(cons ((sTRUCT,  , r),  , s')) parseStrInst2' (r,  , expose s') parseStrInst'(cons ((t,  , r),  , s')) error (r,  , "Expected `%struct', found token " ^ toString t)let rec parseInsts'(f as cons ((iD _,  , _),  , _)) let let  inlet  in in (inst :: insts,  , f'') parseInsts'(f as cons ((sTRUCT,  , _),  , _)) let let  inlet  in in (inst :: insts,  , f'') parseInsts'(cons ((rBRACE,  , _),  , s')) (nil,  , expose s') parseInsts'(cons ((t,  , r),  , s')) error (r,  , "Expected identifier or `%struct', found token " ^ toString t)let rec parseInstantiate'(f as cons ((lBRACE,  , _),  , s')) parseInsts' (expose s') parseInstantiate'(cons ((t,  , r),  , s')) error (r,  , "Expected `{', found token " ^ toString t)let rec parseWhereClauses'(f as cons ((wHERE,  , _),  , s'),  , sigexp) let let  in in parseWhereClauses' (f',  , wheresig (sigexp,  , insts)) parseWhereClauses'(f,  , sigexp) (sigexp,  , f)let rec parseSigExp'(cons ((iD (_,  , id),  , r),  , s)) let let  in in (done (sigexp),  , f') parseSigExp'(f as cons ((lBRACE,  , r),  , _)) (continuation (fun f' -> let let  in in (done (sigexp),  , f'')),  , f) parseSigExp'(cons ((t,  , r),  , _)) error (r,  , "Expected signature name or expression, found token " ^ toString t)let rec parseSgEqual'(idOpt,  , cons ((eQUAL,  , r),  , s')) recwith (parseSigExp',  , fun sigexp -> sigdef (idOpt,  , sigexp)) (expose s') parseSgEqual'(idOpt,  , cons ((t,  , r),  , s')) error (r,  , "Expected `=', found token " ^ toString t)let rec parseSgDef'(cons ((iD (_,  , id),  , r),  , s')) parseSgEqual' (sOME (id),  , expose s') parseSgDef'(cons ((uNDERSCORE,  , r),  , s')) parseSgEqual' (nONE,  , expose s') parseSgDef'(cons ((t,  , r),  , s')) error (r,  , "Expected signature identifier, found token " ^ toString t)let rec parseSigDef'(cons ((sIG,  , r),  , s')) parseSgDef' (expose s')let rec parseStrDec2'(idOpt,  , cons ((cOLON,  , r),  , s')) recwith (parseSigExp',  , fun sigexp -> structdec (idOpt,  , sigexp)) (expose s') parseStrDec2'(idOpt,  , cons ((eQUAL,  , r),  , s')) let let  in in (done (structdef (idOpt,  , strexp)),  , f') parseStrDec2'(idOpt,  , cons ((t,  , r),  , s')) error (r,  , "Expected `:' or `=', found token " ^ toString t)let rec parseStrDec'(cons ((iD (_,  , id),  , r),  , s')) parseStrDec2' (sOME id,  , expose s') parseStrDec'(cons ((uNDERSCORE,  , r),  , s')) parseStrDec2' (nONE,  , expose s') parseStrDec'(cons ((t,  , r),  , s')) error (r,  , "Expected structure identifier, found token " ^ toString t)let rec parseStructDec'(cons ((sTRUCT,  , r),  , s')) parseStrDec' (expose s')let rec parseInclude'(cons ((iNCLUDE,  , r),  , s')) parseSigExp' (expose s')let rec parseOpen'(cons ((oPEN,  , r),  , s')) parseStructExp' (expose s')end