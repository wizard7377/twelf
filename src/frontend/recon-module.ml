ReconModule  Global GLOBAL    Names NAMES    ReconTerm' RECON_TERM    ModSyn' MODSYN    ModSyn' Names  Names   IntTree TABLE   Key Int     RECON_MODULE  struct module (*! structure Paths = Paths' !*)
module exception let rec error(r,  , msg) raise (error (wrap (r,  , msg)))type Strexplet rec strexp(ids,  , id,  , r)() let let  in in match structLookup qid with nONE -> error (r,  , "Undeclared structure " ^ qidToString (valOf (structUndef qid))) sOME mid -> (mid,  , r)let rec strexpToStrexp(f : Strexp)  1 (f ())type Insttype Eqntype Instlet rec coninst((ids,  , id,  , r1),  , tm,  , r2)(ns,  , eqns) let let  in in match constLookupIn (ns,  , qid) with nONE -> error (r1,  , "Undeclared identifier " ^ qidToString (valOf (constUndefIn (ns,  , qid)))) sOME cid -> (cid,  , external tm, (* this is wrong because constants in the sig being instantiated might incorrectly appear in tm -kw *)
,  , r2) :: eqnslet rec addStructEqn(rEqns,  , r1,  , r2,  , ids,  , mid1,  , mid2) let let  inlet  inlet rec pusheqn rEqns := eqn :: (! rEqns)let rec doConst(name,  , cid1) match constLookupIn (ns2,  , qid (nil,  , name)) with nONE -> error (r1,  , "Instantiating structure lacks component " ^ qidToString (qid (rev ids,  , name))) sOME cid2 -> push (cid1,  , internal cid2,  , r2)let rec doStruct(name,  , mid1) match structLookupIn (ns2,  , qid (nil,  , name)) with nONE -> error (r1,  , "Instantiating structure lacks component " ^ qidToString (qid (rev ids,  , name))) sOME mid2 -> addStructEqn (rEqns,  , r1,  , r2,  , name :: ids,  , mid1,  , mid2) in appConsts doConst ns1appStructs doStruct ns1let rec strinst((ids,  , id,  , r1),  , strexp,  , r3)(ns,  , eqns) let let  inlet  inlet  inlet  in in addStructEqn (rEqns,  , r2,  , r3,  , nil,  , mid1,  , mid2)! rEqnstype Whereclausetype Sigexplet rec thesig(sOME module) (module,  , nil)let rec sigid(id,  , r)nONE (match lookupSigDef id with nONE -> error (r,  , "Undefined signature " ^ id) sOME module -> (module,  , nil))let rec wheresig(sigexp,  , instList)moduleOpt let let  inlet rec whereclns foldr (fun (inst,  , eqns) -> inst (ns,  , eqns)) nil instList in (module,  , wherecls @ [wherecl])let rec sigexpToSigexp(sigexp,  , moduleOpt) sigexp moduleOpttype Sigdeflet rec sigdef(idOpt,  , sigexp)moduleOpt let let  in in (idOpt,  , module,  , wherecls)let rec sigdefToSigdef(sigdef,  , moduleOpt) sigdef moduleOpttype StructDectype Structdeclet rec structdec(idOpt,  , sigexp)moduleOpt let let  in in structDec (idOpt,  , module,  , inst)let rec structdef(idOpt,  , strexp)nONE let let  in in structDef (idOpt,  , mid)let rec structdecToStructDec(structdec,  , moduleOpt) structdec moduleOpttype EqnTablelet rec applyEqnswhereclnamespace let let  inlet  inlet rec add(cid,  , inst,  , r) (match lookup table cid with nONE -> insert table (cid,  , ref [(inst,  , r)]) sOME rl -> rl := (inst,  , r) :: (! rl))let  inlet rec doInst((internal cid,  , r),  , condec) (try  with ) doInst((external tm,  , r),  , condec) strictify (externalInst (condec,  , tm,  , r))let rec transformConDec(cid,  , condec) (match lookup table cid with nONE -> condec sOME (ref l) -> foldr doInst condec l) in transformConDeclet rec moduleWhere(module,  , wherecl) let let  inlet  inlet  in(* val _ = IntSyn.resetFrom (mark, markStruct) *)
 in module'end