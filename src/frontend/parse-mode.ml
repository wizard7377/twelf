ParseMode  ExtModes' EXTMODES    ParseTerm PARSE_TERM    ParseTerm ExtSyn  ExtModes' ExtSyn    PARSE_MODE  struct (*! structure Parsing = Parsing' !*)
module module module module module (* extract (s, i) = substring of s starting at index i
       Effect: raises Subscript if i > |s|
    *)
let rec extract(s,  , i) if i = size s then nONE else sOME (extract (s,  , i,  , nONE))(* splitModeId (r, id) = (mode, idOpt) where id = "<mode><idOpt>"
       Invariant: id <> ""
    *)
let rec splitModeId(r,  , id) match sub (id,  , 0) with '*' -> (star r,  , extract (id,  , 1)) '-' -> (if (size id > 1 && sub (id,  , 1) = '1') then (minus1 r,  , extract (id,  , 2)) else (minus r,  , extract (id,  , 1))) '+' -> (plus r,  , extract (id,  , 1)) _ -> error (r,  , "Expected mode `+', `-', `*', or `-1'  found " ^ id)let rec validateMArg(r,  , mId as (mode,  , sOME (id))) if isUpper id then mId else error (r,  , "Expected free uppercase variable, found " ^ id) validateMArg(r,  , (_,  , nONE)) error (r,  , "Missing variable following mode")let rec validateMode(r,  , (mode,  , nONE)) mode validateMode(r,  , (_,  , sOME (id))) error (r,  , "Expected simple mode, found mode followed by identifier " ^ id)let rec stripRParen(cons ((rPAREN,  , r),  , s')) (expose s',  , r) stripRParen(cons ((t,  , r),  , s')) error (r,  , "Expected closing `)', found " ^ toString t)let rec stripRBrace(cons ((rBRACE,  , r),  , s')) (expose s',  , r) stripRBrace(cons ((t,  , r),  , _)) error (r,  , "Expected `}', found " ^ toString t)(* parseShortSpine "modeid ... modeid." *)
let rec parseShortSpine(f as cons ((dOT,  , r),  , s')) (mnil r,  , f) parseShortSpine(f as cons ((rPAREN,  , r),  , s')) (mnil r,  , f) parseShortSpine(cons ((iD (_,  , id),  , r),  , s')) let let  inlet  in in (mapp (mId,  , mS'),  , f') parseShortSpine(cons ((t,  , r),  , s')) error (r,  , "Expected mode or `.', found " ^ toString t)(* parseFull "mode {id:term} ... mode {x:term} term" *)
let rec parseFull(cons (t0 as (iD (c,  , id),  , r0),  , s'),  , r1) (match expose s' with cons ((lBRACE,  , r),  , s'') -> (* found quantifier --- id must be mode *)
let let  inlet  inlet  inlet  inlet  inlet  in in (mpi (m,  , dec,  , t'),  , f''') cons tS -> (* no quantifier --- parse atomic type *)
let let  in in (mroot (t',  , join (r,  , r1)),  , f')) parseFull(cons ((lPAREN,  , r0),  , s'),  , r1) let let  inlet  in in (mroot (t',  , join (r',  , r1)),  , f'') parseFull(cons ((t,  , r),  , s'),  , _) error (r,  , "Expected mode or identifier, found " ^ toString t)(* parseMode2 switches between full and short mode declarations *)
(* lexid could be mode or other identifier *)
let rec parseMode2(lexid,  , cons (bS as ((lBRACE,  , r),  , s')),  , r1) let let  in in (toModedec t',  , f') parseMode2((iD (_,  , name),  , r),  , f,  , _) let let  in in (toModedec (mroot (nil,  , name,  , r,  , mS')),  , f')let rec parseModeParen(cons ((iD (_,  , name),  , r0),  , s'),  , r) let let  inlet  in in (toModedec (mroot (nil,  , name,  , join (r,  , r'),  , mS')),  , f'') parseModeParen(cons ((t,  , r),  , s'),  , _) error (r,  , "Expected identifier, found " ^ toString t)(* parseMode1 parses mdecl *)
let rec parseMode1(cons (lexid as (iD _,  , r),  , s')) parseModeNext (parseMode2 (lexid,  , expose s',  , r)) parseMode1(cons ((lPAREN,  , r),  , s')) parseModeNext (parseModeParen (expose s',  , r)) parseMode1(cons ((t,  , r),  , _)) error (r,  , "Expected identifier or mode, found " ^ toString t) parseModeNext(modedec,  , f as cons ((dOT,  , _),  , s')) (modedec :: nil,  , f) parseModeNext(modedec,  , f) let let  in in (modedec :: mdecs,  , f')(* parseMode' : lexResult front -> modedec * lexResult front
       Invariant: exposed input stream starts with MODE
    *)
let rec parseMode'(cons ((mODE,  , r),  , s')) parseMode1 (expose s') parseMode'(cons ((uNIQUE,  , r),  , s')) parseMode1 (expose s') parseMode'(cons ((cOVERS,  , r),  , s')) parseMode1 (expose s')let  in(* local *)
end