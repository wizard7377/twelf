Parser  Stream' STREAM    ExtSyn' EXTSYN    Names' NAMES    ExtConDec' EXTCONDEC    ExtQuery' EXTQUERY    ExtModes' EXTMODES    ThmExtSyn' THMEXTSYN    ModExtSyn' MODEXTSYN    ParseConDec PARSE_CONDEC    ParseConDec ExtConDec  ExtConDec'   ParseQuery PARSE_QUERY    ParseQuery ExtQuery  ExtQuery'   ParseFixity PARSE_FIXITY    ParseFixity Names  Names'   ParseMode PARSE_MODE    ParseMode ExtModes  ExtModes'   ParseThm PARSE_THM    ParseThm ThmExtSyn  ThmExtSyn'   ParseModule PARSE_MODULE    ParseModule ModExtSyn  ModExtSyn'   ParseTerm PARSE_TERM    ParseTerm ExtSyn  ExtSyn'    PARSER  struct (*! structure Parsing = Parsing' !*)
module module module module module module module module type FileParseResult(* Further pragmas to be added later here *)
module module let rec stripDot(cons ((dOT,  , r),  , s)) s stripDot(cons ((rPAREN,  , r),  , s)) error (r,  , "Unexpected right parenthesis") stripDot(cons ((rBRACE,  , r),  , s)) error (r,  , "Unexpected right brace") stripDot(cons ((rBRACKET,  , r),  , s)) error (r,  , "Unexpected right bracket") stripDot(cons ((eOF,  , r),  , s)) error (r,  , "Unexpected end of file") stripDot(cons ((eQUAL,  , r),  , s)) error (r,  , "Unexpected `='") stripDot(cons ((t,  , r),  , s)) error (r,  , "Expected `.', found " ^ toString t)(* Everything else should be impossible *)
(*
    fun stripOptionalDot (LS.Cons ((L.DOT,r), s)) = s
      | stripOptionalDot f = LS.delay (fn () => f)
    *)
let rec parseBound'(cons ((iD (_,  , "*"),  , r),  , s')) (nONE,  , s') parseBound'(cons ((iD (_,  , name),  , r),  , s')) (try  with ) parseBound'(cons ((t,  , r),  , s')) error (r,  , "Expected bound `*' or natural number, found " ^ toString t)(* pass parseStream as theSigParser in order to be able to use
       this function polymorphically in the definition of parseStream *)
let rec recParse(s,  , recparser,  , theSigParser,  , sc) delay (fun () -> recParse' (expose s,  , recparser,  , theSigParser,  , sc)) recParse'(f,  , recparser,  , theSigParser,  , sc) (match recparser f with (done x,  , f') -> sc (x,  , f') (continuation k,  , cons ((lBRACE,  , r1),  , s')) -> let let rec finish(cons ((rBRACE,  , r2),  , s'')) cons ((endSubsig,  , r2),  , recParse (s'',  , k,  , theSigParser,  , sc)) finish(cons ((t,  , r),  , _)) error (r,  , "Expected `}', found " ^ toString t) in cons ((beginSubsig,  , r1),  , theSigParser (s',  , finish)) (continuation _,  , cons ((t,  , r),  , _)) -> error (r,  , "Expected `{', found " ^ toString t))let rec parseStream(s,  , sc) delay (fun () -> parseStream' (expose s,  , sc))(* parseStream' : lexResult front -> fileParseResult front *)
(* parseStream' switches between various specialized parsers *)
 parseStream'(f as cons ((iD (idCase,  , name),  , r0),  , s'),  , sc) parseConDec' (f,  , sc) parseStream'(f as cons ((aBBREV,  , r),  , s'),  , sc) parseAbbrev' (f,  , sc) parseStream'(f as cons ((uNDERSCORE,  , r),  , s'),  , sc) parseConDec' (f,  , sc) parseStream'(f as cons ((iNFIX,  , r),  , s'),  , sc) parseFixity' (f,  , sc) parseStream'(f as cons ((pREFIX,  , r),  , s'),  , sc) parseFixity' (f,  , sc) parseStream'(f as cons ((pOSTFIX,  , r),  , s'),  , sc) parseFixity' (f,  , sc) parseStream'(f as cons ((nAME,  , r1),  , s'),  , sc) let let  inlet  in in cons ((namePref namePref,  , r),  , parseStream (stripDot f',  , sc)) parseStream'(f as cons ((dEFINE,  , r),  , s'),  , sc) parseSolve' (f,  , sc) parseStream'(f as cons ((sOLVE,  , r),  , s'),  , sc) parseSolve' (f,  , sc) parseStream'(cons ((qUERY,  , r0),  , s'),  , sc) let let  inlet  inlet  inlet  in in cons ((query (expected,  , try,  , query),  , r),  , parseStream (stripDot f3,  , sc)) parseStream'(cons ((fQUERY,  , r0),  , s'),  , sc) let let  inlet  in in cons ((fQuery query,  , r),  , parseStream (stripDot f3,  , sc)) parseStream'(cons ((qUERYTABLED,  , r0),  , s'),  , sc) let let  inlet  inlet  inlet  in in cons ((querytabled (numSol,  , try,  , query),  , r),  , parseStream (stripDot f3,  , sc)) parseStream'(f as cons ((mODE,  , r),  , s'),  , sc) parseMode' (f,  , sc) parseStream'(f as cons ((uNIQUE,  , r),  , s'),  , sc) parseUnique' (f,  , sc) parseStream'(f as cons ((cOVERS,  , r),  , s'),  , sc) parseCovers' (f,  , sc) parseStream'(f as cons ((tOTAL,  , r),  , s'),  , sc) parseTotal' (f,  , sc) parseStream'(f as cons ((tERMINATES,  , r),  , s'),  , sc) parseTerminates' (f,  , sc) parseStream'(f as cons ((bLOCK,  , r),  , s'),  , sc) parseConDec' (f,  , sc) parseStream'(f as cons ((wORLDS,  , r),  , s'),  , sc) parseWorlds' (f,  , sc) parseStream'(f as cons ((rEDUCES,  , r),  , s'),  , sc) parseReduces' (f,  , sc) parseStream'(f as cons ((tABLED,  , r),  , s'),  , sc) parseTabled' (f,  , sc) parseStream'(f as cons ((kEEPTABLE,  , r),  , s'),  , sc) parseKeepTable' (f,  , sc) parseStream'(f as cons ((tHEOREM,  , r),  , s'),  , sc) parseTheorem' (f,  , sc) parseStream'(f as cons ((pROVE,  , r),  , s'),  , sc) parseProve' (f,  , sc) parseStream'(f as cons ((eSTABLISH,  , r),  , s'),  , sc) parseEstablish' (f,  , sc) parseStream'(f as cons ((aSSERT,  , r),  , s'),  , sc) parseAssert' (f,  , sc) parseStream'(f as cons ((tRUSTME,  , r),  , s'),  , sc) parseTrustMe' (f,  , sc) parseStream'(f as cons ((fREEZE,  , r),  , s'),  , sc) parseFreeze' (f,  , sc) parseStream'(f as cons ((sUBORD,  , r),  , s'),  , sc) parseSubord' (f,  , sc) parseStream'(f as cons ((tHAW,  , r),  , s'),  , sc) parseThaw' (f,  , sc) parseStream'(f as cons ((dETERMINISTIC,  , r),  , s'),  , sc) parseDeterministic' (f,  , sc) parseStream'(f as cons ((cOMPILE,  , r),  , s'),  , sc) parseCompile' (f,  , sc) parseStream'(f as cons ((cLAUSE,  , r),  , s'),  , sc) parseClause' (f,  , sc) parseStream'(f as cons ((sIG,  , r),  , s'),  , sc) parseSigDef' (f,  , sc) parseStream'(f as cons ((sTRUCT,  , r),  , s'),  , sc) parseStructDec' (f,  , sc) parseStream'(f as cons ((iNCLUDE,  , r),  , s'),  , sc) parseInclude' (f,  , sc) parseStream'(f as cons ((oPEN,  , r),  , s'),  , sc) parseOpen' (f,  , sc) parseStream'(f as cons ((uSE,  , r),  , s'),  , sc) parseUse' (expose s',  , sc) parseStream'(f as cons ((eOF,  , _),  , _),  , sc) sc f parseStream'(f as cons ((rBRACE,  , _),  , _),  , sc) sc f parseStream'(cons ((t,  , r),  , s'),  , sc) error (r,  , "Expected constant name or pragma keyword, found " ^ toString t) parseConDec'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((conDec conDec,  , r),  , parseStream (stripDot f',  , sc)) parseAbbrev'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((abbrevDec conDec,  , r),  , parseStream (stripDot f',  , sc)) parseClause'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((clauseDec conDec,  , r),  , parseStream (stripDot f',  , sc)) parseFixity'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((fixDec fdec,  , r),  , parseStream (stripDot f',  , sc)) parseSolve'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((solve defnssolve,  , r),  , parseStream (stripDot f',  , sc)) parseMode'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((modeDec mdecs,  , r),  , parseStream (stripDot f',  , sc)) parseUnique'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((uniqueDec mdecs,  , r),  , parseStream (stripDot f',  , sc)) parseCovers'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((coversDec mdecs,  , r),  , parseStream (stripDot f',  , sc)) parseTotal'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((totalDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseTerminates'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((terminatesDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseReduces'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((reducesDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseTabled'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((tabledDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseKeepTable'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((keepTableDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseWorlds'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((worldDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseTheorem'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((theoremDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseProve'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((proveDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseEstablish'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((establishDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseAssert'(f as cons ((_,  , r0),  , _),  , sc) let let  inlet  in in cons ((assertDec ldec,  , r),  , parseStream (stripDot f',  , sc)) parseTrustMe'(f as cons ((_,  , r0),  , s),  , sc) let let rec parseNextDec'(cons ((dec,  , r),  , s')) cons ((trustMe (dec,  , r),  , r0),  , s') parseNextDec'(empty) error (r0,  , "No declaration after `%trustme'") in parseNextDec' (parseStream' (expose s,  , sc)) parseSubord'(f as cons ((_,  , r0),  , s),  , sc) let let  inlet  inlet  in in cons ((subordDec qidpairs,  , r),  , parseStream (stripDot f',  , sc)) parseFreeze'(f as cons ((_,  , r0),  , s),  , sc) let let  inlet  inlet  in in cons ((freezeDec qids,  , r),  , parseStream (stripDot f',  , sc)) parseThaw'(f as cons ((_,  , r0),  , s),  , sc) let let  inlet  inlet  in in cons ((thawDec qids,  , r),  , parseStream (stripDot f',  , sc)) parseDeterministic'(f as cons ((_,  , r0),  , s),  , sc) let let  inlet  inlet  in in cons ((deterministicDec qids,  , r),  , parseStream (stripDot f',  , sc))(* ABP 4/4/03 *)
 parseCompile'(f as cons ((_,  , r0),  , s),  , sc) let let  inlet  inlet  in in cons ((compile qids,  , r),  , parseStream (stripDot f',  , sc)) parseSigDef'(f as cons ((_,  , r1),  , _),  , sc) let let rec finish(sigdef,  , f' as cons ((_,  , r2),  , _)) cons ((sigDef sigdef,  , join (r1,  , r2)),  , parseStream (stripDot f',  , sc)) in recParse' (f,  , parseSigDef',  , parseStream,  , finish) parseStructDec'(f as cons ((_,  , r1),  , _),  , sc) let let rec finish(structdec,  , f' as cons ((_,  , r2),  , _)) cons ((structDec structdec,  , join (r1,  , r2)),  , parseStream (stripDot f',  , sc)) in recParse' (f,  , parseStructDec',  , parseStream,  , finish) parseInclude'(f as cons ((_,  , r1),  , _),  , sc) let let rec finish(sigexp,  , f' as cons ((_,  , r2),  , _)) cons ((include sigexp,  , join (r1,  , r2)),  , parseStream (stripDot f',  , sc)) in recParse' (f,  , parseInclude',  , parseStream,  , finish) parseOpen'(f as cons ((_,  , r1),  , _),  , sc) let let  in in cons ((open strexp,  , join (r1,  , r2)),  , parseStream (stripDot f',  , sc)) parseUse'(cons ((iD (_,  , name),  , r0),  , s),  , sc) let let  inlet  in in cons ((use name,  , r),  , parseStream (stripDot f,  , sc)) parseUse'(cons ((_,  , r),  , _),  , sc) error (r,  , "Constraint solver name expected")let rec parseQ(s) delay (fun () -> parseQ' (expose s)) parseQ'(f) let let  in in cons (query,  , parseQ (stripDot (f')))let rec parseTLStreaminstream let let rec finish(cons ((eOF,  , r),  , s)) empty finish(cons ((rBRACE,  , r),  , s)) error (r,  , "Unmatched `}'") in parseStream (lexStream instream,  , finish)let  inlet rec parseTerminalQprompts parseQ (lexTerminal prompts)(* local ... in *)
end