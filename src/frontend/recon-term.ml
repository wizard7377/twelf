ReconTerm  Names NAMES    Approx APPROX    Whnf WHNF    Unify UNIFY    Abstract ABSTRACT    Print PRINT    StringTree TABLE   Key String    Msg MSG     RECON_TERM  struct (*! structure IntSyn = IntSyn' !*)
(*! structure Paths = Paths' !*)
module module (* Error handling *)
let  inlet rec clearDelayed() (delayedList := nil)let rec addDelayedf (delayedList := f :: (! delayedList))let rec runDelayed() let let rec run'nil () run'(h :: t) (run' t; h ()) in run' (! delayedList)exception let  inlet  inlet  inlet rec exceeds(i,  , nONE) false exceeds(i,  , sOME (j)) i > jlet rec resetErrors(fileName) (errorCount := 0; errorFileName := fileName)let rec die(r) raise (error (wrap (r,  , " " ^ toString (! errorCount) ^ " error" ^ (if ! errorCount > 1 then "s" else "") ^ " found")))let rec checkErrors(r) if ! errorCount > 0 then die (r) else ()(* Since this structure uses a non-standard error reporting mechanism,
     any errors reported here while chatter = 1 will be printed
     in between the "[Loading file ..." message and the closing "]",
     instead of after the closing "]".  If we don't emit a newline
     when chatter = 1, the first such error will appear on the same line
     as "[Loading file ...", terribly confusing the Emacs error parsing code.
   *)
let rec chatterOneNewline() if ! chatter = 1 && ! errorCount = 1 then message "\n" else ()let rec fatalError(r,  , msg) (errorCount := ! errorCount + 1; chatterOneNewline (); message (! errorFileName ^ ":" ^ wrap (r,  , msg) ^ "\n"); die (r))let rec error(r,  , msg) (errorCount := ! errorCount + 1; chatterOneNewline (); message (! errorFileName ^ ":" ^ wrap (r,  , msg) ^ "\n"); if exceeds (! errorCount,  , ! errorThreshold) then die (r) else ())let rec formatExp(g,  , u) try  with (* this is a hack, i know *)
let  inopen IntSyn let rec headConDec(const c) sgnLookup c headConDec(skonst c) sgnLookup c headConDec(def d) sgnLookup d headConDec(nSDef d) sgnLookup d headConDec(fgnConst (_,  , cd)) cd(* others impossible by invariant *)
(* lowerType (G, (V, s)) = (G', a)
     if   G0 |- V : type and G |- s : G0
     and  G |- V[s] = {{G1}} a : type
     then G' = G, G1 *)
let rec lowerTypeW(g,  , (pi ((d,  , _),  , v),  , s)) let let  in in lowerType (decl (g,  , d'),  , (v,  , dot1 s)) lowerTypeW(g,  , vs) (g,  , eClo vs) lowerType(g,  , vs) lowerTypeW (g,  , whnfExpandDef vs)(* raiseType (G, V) = {{G}} V *)
let rec raiseType(null,  , v) v raiseType(decl (g,  , d),  , v) raiseType (g,  , pi ((d,  , maybe),  , v))(* open IntSyn *)
let  inlet  inlet  inlet rec varReset() (clear evarApxTable; clear fvarApxTable; clear fvarTable)let rec getEVarTypeApxname (match lookup evarApxTable name with sOME v -> v nONE -> (match getEVarOpt name with sOME (eVar (_,  , _,  , v,  , _)) -> let let  in in insert evarApxTable (name,  , v')v' nONE -> let let  in in insert evarApxTable (name,  , v)v))let rec getFVarTypeApxname (match lookup fvarApxTable name with sOME v -> v nONE -> let let  in in insert fvarApxTable (name,  , v)v)let rec getEVar(name,  , allowed) (match getEVarOpt name with sOME (x as eVar (_,  , g,  , v,  , _)) -> (x,  , raiseType (g,  , v)) nONE -> let let  inlet  inlet  inlet  in in addEVar (x,  , name)(x,  , v'))let rec getFVarType(name,  , allowed) (match lookup fvarTable name with sOME v -> v nONE -> let let  inlet  in in insert fvarTable (name,  , v')v')(* External syntax of terms *)
type Term Declet rec backarrow(tm1,  , tm2) arrow (tm2,  , tm1)(* for now *)
let rec dec0(nameOpt,  , r) dec (nameOpt,  , omitted (r),  , r)type Joblet rec termRegion(internal (u,  , v,  , r)) r termRegion(constant (h,  , r)) r termRegion(bvar (k,  , r)) r termRegion(evar (name,  , r)) r termRegion(fvar (name,  , r)) r termRegion(typ (r)) r termRegion(arrow (tm1,  , tm2)) join (termRegion tm1,  , termRegion tm2) termRegion(pi (tm1,  , tm2)) join (decRegion tm1,  , termRegion tm2) termRegion(lam (tm1,  , tm2)) join (decRegion tm1,  , termRegion tm2) termRegion(app (tm1,  , tm2)) join (termRegion tm1,  , termRegion tm2) termRegion(hastype (tm1,  , tm2)) join (termRegion tm1,  , termRegion tm2) termRegion(mismatch (tm1,  , tm2,  , _,  , _)) termRegion tm2 termRegion(omitted (r)) r termRegion(lcid (_,  , _,  , r)) r termRegion(ucid (_,  , _,  , r)) r termRegion(quid (_,  , _,  , r)) r termRegion(scon (_,  , r)) r termRegion(omitapx (u,  , v,  , l,  , r)) r termRegion(omitexact (u,  , v,  , r)) r decRegion(dec (name,  , tm,  , r)) rlet rec ctxRegion(null) nONE ctxRegion(decl (g,  , tm)) ctxRegion' (g,  , decRegion tm) ctxRegion'(null,  , r) sOME r ctxRegion'(decl (g,  , tm),  , r) ctxRegion' (g,  , join (r,  , decRegion tm))open Apx  Ctx  Ctx type Dec(* Phase 1:
       Try to determine an approximate type/kind and level for each subterm.
       In cases where there's a mismatch, it's generally better not to report
       it immediately, but rather to wait until after the exact phase, so that
       the error message can mention more precise type information.  So instead
       the bad subterm is wrapped in a `mismatch' constructor, which also
       supplies a replacement (always an `omitted' in the current implementation)
       so that the invariant that the entire term is approximately well-typed
       after phase 1 is satisfied even in the presence of the error.
     *)
(* inferApx (G, tm, false) = (tm', U, V, L)
       pre: G is an approximate context
            tm is an approximate subject
       post: tm' is an approximate subject
             U is an approximate subject
             V is an approximate classifier
             L is an approximate universe
             G |- U ~:~ V ~:~ L
             termToExp tm' = U

       inferApx (G, tm, true) = (tm', U, V, L)
       pre: G is an approximate context
            tm is an approximate classifier
       post: tm' is an approximate classifier
             U is an approximate classifier
             V is an approximate classifier
             L is an approximate universe
             G |- U ~:~ V ~:~ L
             termToExp tm' = U
     *)
let rec filterLevel(tm,  , l,  , max,  , msg) let let  inlet  in in if i > max then fatalError (termRegion tm,  , "Level too high\n" ^ msg) else if notGround then error (termRegion tm,  , "Ambiguous level\n" ^ "The level of this term could not be inferred\n" ^ "Defaulting to " ^ (match i with 1 -> "object" 2 -> "type family" 3 -> "kind") ^ " level") else ()let rec findOmitted(g,  , qid,  , r) (error (r,  , "Undeclared identifier " ^ qidToString (valOf (constUndef qid))); omitted (r))let rec findBVar'(null,  , name,  , k) nONE findBVar'(decl (g,  , dec (nONE,  , _)),  , name,  , k) findBVar' (g,  , name,  , k + 1) findBVar'(decl (g,  , nDec _),  , name,  , k) findBVar' (g,  , name,  , k + 1) findBVar'(decl (g,  , dec (sOME (name'),  , _)),  , name,  , k) if name = name' then sOME (k) else findBVar' (g,  , name,  , k + 1)let rec findBVarfc(g,  , qid,  , r) (match unqualified qid with nONE -> fc (g,  , qid,  , r) sOME name -> (match findBVar' (g,  , name,  , 1) with nONE -> fc (g,  , qid,  , r) sOME k -> bvar (k,  , r)))let rec findConstfc(g,  , qid,  , r) (match constLookup qid with nONE -> fc (g,  , qid,  , r) sOME cid -> (match sgnLookup cid with conDec _ -> constant (const cid,  , r) conDef _ -> constant (def cid,  , r) abbrevDef _ -> constant (nSDef cid,  , r) _ -> (error (r,  , "Invalid identifier\n" ^ "Identifier `" ^ qidToString qid ^ "' is not a constant, definition or abbreviation"); omitted (r))))let rec findCSConstfc(g,  , qid,  , r) (match unqualified qid with nONE -> fc (g,  , qid,  , r) sOME name -> (match parse name with nONE -> fc (g,  , qid,  , r) sOME (cs,  , conDec) -> constant (fgnConst (cs,  , conDec),  , r)))let rec findEFVarfc(g,  , qid,  , r) (match unqualified qid with nONE -> fc (g,  , qid,  , r) sOME name -> (if ! queryMode then evar else fvar) (name,  , r))let rec findLCIDx findBVar (findConst (findCSConst findOmitted)) xlet rec findUCIDx findBVar (findConst (findCSConst (findEFVar findOmitted))) xlet rec findQUIDx findConst (findCSConst findOmitted) xlet rec inferApx(g,  , tm as internal (u,  , v,  , r)) let let  in in (tm,  , u',  , v',  , l') inferApx(g,  , tm as lcid (ids,  , name,  , r)) let let  in in inferApx (g,  , findLCID (g,  , qid,  , r)) inferApx(g,  , tm as ucid (ids,  , name,  , r)) let let  in in inferApx (g,  , findUCID (g,  , qid,  , r)) inferApx(g,  , tm as quid (ids,  , name,  , r)) let let  in in inferApx (g,  , findQUID (g,  , qid,  , r)) inferApx(g,  , tm as scon (name,  , r)) (match parse name with nONE -> (error (r,  , "Strings unsupported in current signature"); inferApx (g,  , omitted (r))) sOME (cs,  , conDec) -> inferApx (g,  , constant (fgnConst (cs,  , conDec),  , r))) inferApx(g,  , tm as constant (h,  , r)) let let  inlet  inlet rec dropImplicit(v,  , 0) v dropImplicit(arrow (_,  , v),  , i) dropImplicit (v,  , i - 1)let  in in (tm,  , u',  , v'',  , l') inferApx(g,  , tm as bvar (k,  , r)) let let  in in (tm,  , undefined,  , v,  , type) inferApx(g,  , tm as evar (name,  , r)) (tm,  , undefined,  , getEVarTypeApx name,  , type) inferApx(g,  , tm as fvar (name,  , r)) (tm,  , undefined,  , getFVarTypeApx name,  , type) inferApx(g,  , tm as typ (r)) (tm,  , uni type,  , uni kind,  , hyperkind) inferApx(g,  , arrow (tm1,  , tm2)) let let  inlet  inlet  in in (arrow (tm1',  , tm2'),  , arrow (v1,  , v2),  , uni l,  , next l) inferApx(g,  , pi (tm1,  , tm2)) let let  inlet  inlet  in in (pi (tm1',  , tm2'),  , arrow (v1,  , v2),  , uni l,  , next l) inferApx(g,  , tm as lam (tm1,  , tm2)) let let  inlet  in in (lam (tm1',  , tm2'),  , u2,  , arrow (v1,  , v2),  , l2) inferApx(g,  , tm as app (tm1,  , tm2)) let let  inlet  inlet  inlet  in(* probably a confusing message if the problem is the level: *)
let  in in (app (tm1',  , tm2'),  , u1,  , vr,  , l) inferApx(g,  , tm as hastype (tm1,  , tm2)) let let  inlet  inlet  inlet  in in (hastype (tm1',  , tm2'),  , u1,  , v2,  , l) inferApx(g,  , omitted (r)) let let  inlet  inlet  in(* guaranteed not to be used if L is type *)
 in (omitapx (u,  , v,  , l,  , r),  , u,  , v,  , l) checkApx(g,  , tm,  , v,  , l,  , location_msg) let let  in in try  with  inferApxDec(g,  , dec (name,  , tm,  , r)) let let  inlet  in in (dec (name,  , tm',  , r),  , d)let rec inferApxJob(g,  , jnothing) jnothing inferApxJob(g,  , jand (j1,  , j2)) jand (inferApxJob (g,  , j1),  , inferApxJob (g,  , j2)) inferApxJob(g,  , jwithctx (g,  , j)) let let rec ia(null) (g,  , null) ia(decl (g,  , tm)) let let  inlet  inlet  inlet  in in (decl (g',  , d),  , decl (g',  , tm'))let  in in jwithctx (g',  , inferApxJob (g',  , j)) inferApxJob(g,  , jterm (tm)) let let  inlet  inlet  inlet  in in jterm (tm') inferApxJob(g,  , jclass (tm)) let let  inlet  inlet  inlet  inlet  in in jclass (tm') inferApxJob(g,  , jof (tm1,  , tm2)) let let  inlet  inlet  inlet  inlet  inlet  in in jof (tm1',  , tm2') inferApxJob(g,  , jof' (tm1,  , v)) let let  inlet  inlet  inlet  inlet  inlet  in in jof' (tm1',  , v)let rec ctxToApxnull null ctxToApx(decl (g,  , nDec x)) decl (ctxToApx g,  , nDec x) ctxToApx(decl (g,  , dec (name,  , v))) let let  in in decl (ctxToApx g,  , dec (name,  , v'))let rec inferApxJob'(g,  , t) inferApxJob (ctxToApx g,  , t)(* open Apx *)
open IntSyn (* Final reconstruction job syntax *)
type Job(* This little datatype makes it easier to work with eta-expanded terms
     The idea is that Elim E represents a term U if
       E (s, S) = U[s] @ S *)
type Bidilet rec elimSub(e,  , s) (fun (s',  , s) -> e (comp (s,  , s'),  , s))let rec elimApp(e,  , u) (fun (s,  , s) -> e (s,  , app (eClo (u,  , s),  , s)))let rec bvarElim(n) (fun (s,  , s) -> (match bvarSub (n,  , s) with idx (n') -> root (bVar n',  , s) exp (u) -> redex (u,  , s)))let rec fvarElim(name,  , v,  , s) (fun (s',  , s) -> root (fVar (name,  , v,  , comp (s,  , s')),  , s))let rec redexElim(u) (fun (s,  , s) -> redex (eClo (u,  , s),  , s))(* headElim (H) = E
     assumes H not Proj _ *)
let rec headElim(bVar n) bvarElim n headElim(fVar fv) fvarElim fv headElim(nSDef d) redexElim (constDef d) headElim(h) (match conDecStatus (headConDec h) with foreign (csid,  , f) -> (fun (s,  , s) -> f s) _ -> (fun (s,  , s) -> root (h,  , s)))(* although internally EVars are lowered intro forms, externally they're
     raised elim forms.
     this conforms to the external interpretation:
     the type of the returned elim form is ([[G]] V) *)
let rec evarElim(x as eVar _) (fun (s,  , s) -> eClo (x,  , spineToSub (s,  , s)))let rec etaExpandW(e,  , (pi ((d as dec (_,  , va),  , _),  , vr),  , s)) let let  inlet  in in lam (d',  , etaExpand (elimApp (elimSub (e,  , shift),  , u1),  , (vr,  , dot1 s))) etaExpandW(e,  , _) e (id,  , nil) etaExpand(e,  , vs) etaExpandW (e,  , whnfExpandDef vs)(* preserves redices *)
let rec toElim(elim e) e toElim(intro u) redexElim ulet rec toIntro(elim e,  , vs) etaExpand (e,  , vs) toIntro(intro u,  , vs) ulet rec addImplicit1W(g,  , e,  , (pi ((dec (_,  , va),  , _),  , vr),  , s),  , i, (* >= 1 *)
) let let  in in addImplicit (g,  , elimApp (e,  , x),  , (vr,  , dotEta (exp (x),  , s)),  , i - 1)(* if no implicit arguments, do not expand Vs!!! *)
 addImplicit(g,  , e,  , vs,  , 0) (e,  , eClo vs) addImplicit(g,  , e,  , vs,  , i) addImplicit1W (g,  , e,  , whnfExpandDef vs,  , i)(* Report mismatches after the entire process finishes -- yields better
     error messages *)
let rec reportConstraints(xnames) try  with let rec reportInst(xnames) try  with let rec delayMismatch(g,  , v1,  , v2,  , r2,  , location_msg,  , problem_msg) addDelayed (fun () -> let let  inlet  inlet  inlet  inlet  inlet  in in error (r2,  , "Type mismatch\n" ^ diff ^ "\n" ^ problem_msg ^ "\n" ^ location_msg))let rec delayAmbiguous(g,  , u,  , r,  , msg) addDelayed (fun () -> let let  inlet  in in error (r,  , "Ambiguous reconstruction\n" ^ makestring_fmt amb ^ "\n" ^ msg))let rec unifyIdemx let (* this reset should be unnecessary -- for safety only *)
let  inlet  inlet  in in ()let rec unifiableIdemx let (* this reset should be unnecessary -- for safety only *)
let  inlet  inlet  in in ok(* tracing code *)
type TraceModelet  inlet  inlet rec reportf match ! traceMode with progressive -> f () omniscient -> addDelayed flet rec reportMismatch(g,  , vs1,  , vs2,  , problem_msg) report (fun () -> let let  inlet  inlet  inlet  inlet  inlet  in in ())let rec reportUnify'(g,  , vs1,  , vs2) let let  inlet  inlet  inlet  inlet  inlet  inlet  in in ()let rec reportUnify(g,  , vs1,  , vs2) (match ! traceMode with progressive -> reportUnify' (g,  , vs1,  , vs2) omniscient -> (try  with ))let rec reportInfer'(g,  , omitexact (_,  , _,  , r),  , u,  , v) let let  inlet  inlet  inlet  inlet  in in () reportInfer'(g,  , mismatch (tm1,  , tm2,  , _,  , _),  , u,  , v) reportInfer' (g,  , tm2,  , u,  , v) reportInfer'(g,  , hastype _,  , u,  , v) () reportInfer'(g,  , tm,  , u,  , v) let let  inlet  inlet  inlet  inlet  in in ()let rec reportInferx report (fun () -> reportInfer' x)(* inferExact (G, tm) = (tm', U, V)
       if  tm is approximately well typed
       and tm contains no subterm above kind level
       and tm ~:~ V1
       then tm = U-
       and  U : V
       and  U, V are most general such
       effect: as for unification *)
let rec inferExactN(g,  , tm as internal (u,  , v,  , r)) (tm,  , intro u,  , v) inferExactN(g,  , tm as constant (h,  , r)) let let  inlet  in in (tm,  , elim e,  , v) inferExactN(g,  , tm as bvar (k,  , r)) let let  in in (tm,  , elim (bvarElim k),  , v) inferExactN(g,  , tm as evar (name,  , r)) let (* externally EVars are raised elim forms *)
let  inlet  in(* necessary? -kw *)
 in (tm,  , elim (elimSub (evarElim x,  , s)),  , eClo (v,  , s)) inferExactN(g,  , tm as fvar (name,  , r)) let let  inlet  in(* necessary? -kw *)
 in (tm,  , elim (fvarElim (name,  , v,  , s)),  , eClo (v,  , s)) inferExactN(g,  , tm as typ (r)) (tm,  , intro (uni type),  , uni kind) inferExactN(g,  , arrow (tm1,  , tm2)) let let  inlet  inlet  inlet  in in (arrow (tm1',  , tm2'),  , intro (pi ((d,  , no),  , eClo (v2,  , shift))),  , l) inferExactN(g,  , pi (tm1,  , tm2)) let let  inlet  inlet  in in (pi (tm1',  , tm2'),  , intro (pi ((d,  , maybe),  , v2)),  , l) inferExactN(g,  , lam (tm1,  , tm2)) let let  inlet  inlet  in in (lam (tm1',  , tm2'),  , intro (lam (d,  , u2)),  , pi ((d,  , maybe),  , v2)) inferExactN(g,  , app (tm1,  , tm2)) let let  inlet  inlet  inlet  inlet  in in (app (tm1',  , tm2'),  , elim (elimApp (e1,  , u2)),  , eClo (vr,  , dotEta (exp u2,  , s))) inferExactN(g,  , hastype (tm1,  , tm2)) let let  inlet  inlet  in in (hastype (tm1',  , tm2'),  , b1,  , v) inferExactN(g,  , mismatch (tm1,  , tm2,  , location_msg,  , problem_msg)) let let  inlet  inlet  inlet  in in (mismatch (tm1',  , tm2',  , location_msg,  , problem_msg),  , b,  , v) inferExactN(g,  , omitapx (u,  , v,  , l,  , r)) let let  inlet  in in (omitexact (u',  , v',  , r),  , intro u',  , v') inferExact(g,  , tm) if not (! trace) then inferExactN (g,  , tm) else let let  in in reportInfer (g,  , tm',  , toIntro (b',  , (v',  , id)),  , v')(tm',  , b',  , v') inferExactDec(g,  , dec (name,  , tm,  , r)) let let  inlet  inlet  in in (dec (name,  , tm',  , r),  , d) checkExact1(g,  , lam (dec (name,  , tm1,  , r),  , tm2),  , vhs) let let  inlet  inlet  inlet  inlet  inlet  in in ((lam (dec (name,  , tm1',  , r),  , tm2'),  , intro (lam (d,  , u2)),  , pi ((d,  , maybe),  , v2)),  , ok2) checkExact1(g,  , hastype (tm1,  , tm2),  , vhs) let let  inlet  inlet  in in ((hastype (tm1',  , tm2'),  , b1,  , v),  , ok2) checkExact1(g,  , mismatch (tm1,  , tm2,  , location_msg,  , problem_msg),  , vhs) let let  inlet  inlet  in in ((mismatch (tm1',  , tm2',  , location_msg,  , problem_msg),  , b,  , v),  , ok2) checkExact1(g,  , omitapx (u,  , v, (* = Vhs *)
,  , l,  , r),  , vhs) let let  inlet  in in ((omitexact (u',  , v',  , r),  , intro u',  , v'),  , true) checkExact1(g,  , tm,  , vhs) let let  in in ((tm',  , b',  , v'),  , unifiableIdem (g,  , vhs,  , (v',  , id))) checkExact(g,  , tm,  , vs,  , location_msg) if not (! trace) then let let  in in if ok then (tm',  , b') else (try  with ) else let let  in in try  with  unifyExact(g,  , arrow (tm1,  , tm2),  , vhs) let let  inlet  inlet  inlet  inlet  inlet  in in ((arrow (tm1',  , tm2'),  , intro (pi ((d,  , no),  , eClo (v2,  , shift))),  , l),  , ok1 && unifiableIdem (decl (g,  , d),  , (vr,  , dot1 s),  , (v2,  , shift))) unifyExact(g,  , pi (dec (name,  , tm1,  , r),  , tm2),  , vhs) let let  inlet  inlet  inlet  inlet  inlet  in in ((pi (dec (name,  , tm1',  , r),  , tm2'),  , intro (pi ((d,  , maybe),  , v2)),  , l),  , ok2) unifyExact(g,  , hastype (tm1,  , tm2),  , vhs) let (* Vh : L by invariant *)
let  inlet  in in ((hastype (tm1',  , tm2'),  , b,  , l),  , ok1) unifyExact(g,  , mismatch (tm1,  , tm2,  , location_msg,  , problem_msg),  , vhs) let let  inlet  inlet  in in ((mismatch (tm1',  , tm2',  , location_msg,  , problem_msg),  , b,  , l),  , ok2) unifyExact(g,  , omitapx (v, (* = Vhs *)
,  , l,  , nL, (* Next L *)
,  , r),  , vhs) let (* cannot raise Ambiguous *)
let  inlet  in in ((omitexact (v',  , l',  , r),  , intro v',  , l'),  , true) unifyExact(g,  , tm,  , vhs) let let  inlet  in in ((tm',  , b',  , l'),  , unifiableIdem (g,  , vhs,  , (v',  , id)))let rec occElim(constant (h,  , r),  , os,  , rs,  , i) let (* should probably treat a constant with Foreign
             attribute as a redex *)
let  in in (root (r',  , leaf r,  , conDecImp (headConDec h),  , i,  , os),  , r') occElim(bvar (k,  , r),  , os,  , rs,  , i) let let  in in (root (r',  , leaf r,  , 0,  , i,  , os),  , r') occElim(fvar (name,  , r),  , os,  , rs,  , i) let let  in in (root (r',  , leaf r,  , 0,  , i,  , os),  , r') occElim(app (tm1,  , tm2),  , os,  , rs,  , i) let let  in in occElim (tm1,  , app (oc2,  , os),  , r2 :: rs,  , i + 1) occElim(hastype (tm1,  , tm2),  , os,  , rs,  , i) occElim (tm1,  , os,  , rs,  , i) occElim(tm,  , os,  , rs,  , i) let let  in in (leaf r',  , r') occIntro(arrow (tm1,  , tm2)) let let  inlet  inlet  in in (bind (r',  , sOME oc1,  , oc2),  , r') occIntro(pi (dec (name,  , tm1,  , r),  , tm2)) let let  inlet  inlet  in in (* not quite consistent with older implementation for dec0 *)
(bind (r',  , sOME oc1,  , oc2),  , r') occIntro(lam (dec (name,  , tm1,  , r),  , tm2)) let let  inlet  inlet  in in (* not quite consistent with older implementation for dec0 *)
(bind (r',  , sOME oc1,  , oc2),  , r') occIntro(hastype (tm1,  , tm2)) occIntro tm1 occIntro(tm) let (* still doesn't work quite right for the location -> occurrence map? *)
let  in in (oc,  , r)let rec inferExactJob(g,  , jnothing) jNothing inferExactJob(g,  , jand (j1,  , j2)) jAnd (inferExactJob (g,  , j1),  , inferExactJob (g,  , j2)) inferExactJob(g,  , jwithctx (g,  , j)) let let rec ie(null) (g,  , null) ie(decl (g,  , tm)) let let  inlet  in in (decl (g',  , d),  , decl (gresult,  , d))let  in in jWithCtx (gresult,  , inferExactJob (g',  , j)) inferExactJob(g,  , jterm (tm)) let let  inlet  inlet  inlet rec iu(uni type) kind iu(pi (_,  , v)) iu v iu(root _) type iu(redex (v,  , _)) iu v iu(lam (_,  , v)) iu v iu(eClo (v,  , _)) iu v(* others impossible *)
 in jTerm ((u,  , oc),  , v,  , iu v) inferExactJob(g,  , jclass (tm)) let let  inlet  inlet  inlet  in in jClass ((v,  , oc),  , l) inferExactJob(g,  , jof (tm1,  , tm2)) let let  inlet  inlet  inlet  inlet  inlet  inlet  in in jOf ((u1,  , oc1),  , (v2,  , oc2),  , l2) inferExactJob(g,  , jof' (tm1,  , v2)) let (*          val (tm2', B2, L2) = inferExact (G, tm2)
          val V2 = toIntro (B2, (L2, id)) *)
let  inlet  in(*          val (oc2, r2) = occIntro tm2' *)
let  in(*          val (Uni L2, _) = Whnf.whnf (L2, id) *)
 in jOf ((u1,  , oc1),  , (v2,  , oc1),  , type)let rec recon'(j) let (* we leave it to the context to call Names.varReset
             reason: this code allows reconstructing terms containing
             existing EVars, and future developments might use that *)
(* context must already have called resetErrors *)
let  inlet  inlet  inlet  inlet  inlet  in(* we leave it to the context to call checkErrors
             reason: the caller may want to do further processing on
             the "best effort" result returned, even if there were
             errors *)
 in j''let rec recon(j) (queryMode := false; recon' j)let rec reconQuery(j) (queryMode := true; recon' j)(* Invariant, G must be named! *)
let rec reconWithCtx'(g,  , j) let (* we leave it to the context to call Names.varReset
             reason: this code allows reconstructing terms containing
             existing EVars, and future developments might use that *)
(* context must already have called resetErrors *)
let  inlet  inlet  inlet  inlet  inlet  in(* we leave it to the context to call checkErrors
             reason: the caller may want to do further processing on
             the "best effort" result returned, even if there were
             errors *)
 in j''let rec reconWithCtx(g,  , j) (queryMode := false; reconWithCtx' (g,  , j))let rec reconQueryWithCtx(g,  , j) (queryMode := true; reconWithCtx' (g,  , j))let rec internalInstx raise (match)let rec externalInstx raise (match)(* open IntSyn *)
end