INTSYN   Cid  Mid  Csid  FgnExp  unexpectedFgnExp FgnExp   FgnCnstr  unexpectedFgnCnstr FgnCnstr   'a Ctx null  decl 'a Ctx * 'a    ctxPop 'a Ctx -> 'a Ctx   ctxLookup 'a Ctx * Int -> 'a   ctxLength 'a Ctx -> Int   Depend no  maybe  meta    Uni kind  type    Exp uni Uni  pi (Dec * Depend) * Exp  root Head * Spine  redex Exp * Spine  lam Dec * Exp  eVar Exp Option Ref * Dec Ctx * Exp *  Cnstr Ref  List Ref  eClo Exp * Sub  aVar Exp Option Ref  fgnExp Csid * FgnExp  nVar Int   Head bVar Int  const Cid  proj Block * Int  skonst Cid  def Cid  nSDef Cid  fVar String * Exp * Sub  fgnConst Csid * ConDec   Spine nil  app Exp * Spine  sClo Spine * Sub   Sub shift Int  dot Front * Sub   Front idx Int  exp Exp  axp Exp  block Block  undef   Dec dec String Option * Exp  bDec String Option * (Cid * Sub)  aDec String Option * Int  nDec String Option   Block bidx Int  lVar Block Option Ref * Sub * (Cid * Sub)  inst Exp List   Cnstr solved  eqn Dec Ctx * Exp * Exp  fgnCnstr Csid * FgnCnstr   Status normal  constraint Csid * (Dec Ctx * Spine * Int -> Exp Option)  foreign Csid * (Spine -> Exp)   FgnUnify succeed FgnUnifyResidual List  fail   FgnUnifyResidual assign Dec Ctx * Exp * Exp * Sub  delay Exp * Cnstr Ref   ConDec conDec String * Mid Option * Int * Status(* a : K : kind  or           *)
 * Exp * Uni  conDef String * Mid Option * Int(* a = A : K : kind  or       *)
 * Exp * Exp * Uni(* d = M : A : type           *)
 * Ancestor  abbrevDef String * Mid Option * Int(* a = A : K : kind  or       *)
 * Exp * Exp * Uni  blockDec String * Mid Option(* %block l : SOME G1 PI G2   *)
 * Dec Ctx * Dec List  blockDef String * Mid Option * Cid List  skoDec String * Mid Option * Int(* sa: K : kind  or           *)
 * Exp * Uni   Ancestor anc Cid Option * Int * Cid Option    StrDec strDec String * Mid Option    ConDecForm fromCS  ordinary  clause    Dctx  Eclo  Bclo  Cnstr  error String   FgnExpStd   ToInternal FGN_OPN   Arg Unit   Result Exp    Map FGN_OPN   Arg Exp -> Exp   Result Exp    App FGN_OPN   Arg Exp -> Unit   Result Unit    EqualTo FGN_OPN   Arg Exp   Result Bool    UnifyWith FGN_OPN   Arg Dec Ctx * Exp   Result FgnUnify    fold (Csid * FgnExp) -> (Exp * 'a -> 'a) -> 'a -> 'a       FgnCnstrStd   ToInternal FGN_OPN   Arg Unit   Result  Dec Ctx * Exp  List    Awake FGN_OPN   Arg Unit   Result Bool    Simplify FGN_OPN   Arg Unit   Result Bool        conDecName ConDec -> String   conDecParent ConDec -> Mid Option   conDecImp ConDec -> Int   conDecStatus ConDec -> Status   conDecType ConDec -> Exp   conDecBlock ConDec -> Dctx * Dec List   conDecUni ConDec -> Uni   strDecName StrDec -> String   strDecParent StrDec -> Mid Option   sgnReset Unit -> Unit   sgnSize Unit -> Cid * Mid   sgnAdd ConDec -> Cid   sgnLookup Cid -> ConDec   sgnApp (Cid -> Unit) -> Unit   sgnStructAdd StrDec -> Mid   sgnStructLookup Mid -> StrDec   constType Cid -> Exp   constDef Cid -> Exp   constImp Cid -> Int   constStatus Cid -> Status   constUni Cid -> Uni   constBlock Cid -> Dctx * Dec List   ctxDec Dctx * Int -> Dec   blockDec Dctx * Block * Int -> Dec   id Sub   shift Sub   invShift Sub   bvarSub Int * Sub -> Front   frontSub Front * Sub -> Front   decSub Dec * Sub -> Dec   blockSub Block * Sub -> Block   comp Sub * Sub -> Sub   dot1 Sub -> Sub   invDot1 Sub -> Sub   newEVar Dctx * Exp -> Exp   newAVar Unit -> Exp   newTypeVar Dctx -> Exp   newLVar Sub * (Cid * Sub) -> Block   headOpt Exp -> Head Option   ancestor Exp -> Ancestor   defAncestor Cid -> Ancestor   targetHeadOpt Exp -> Head Option   targetHead Exp -> Head   targetFamOpt Exp -> Cid Option   targetFam Exp -> Cid   rename Cid * String -> Unit