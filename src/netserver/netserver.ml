NETSERVER   flashServer Int -> Unit   humanServer Int -> Unit   httpServer Int -> String -> Unit   setExamplesDir String -> Unit       NetServer  Timing TIMING    Twelf TWELF    Msg MSG     NETSERVER  struct let rec joindelim[] "" joindelim[x] x joindelim(h :: tl) h ^ delim ^ (join delim tl)type Servertype Protocolmodule let  in(* queue size for waiting connections in listen *)
(* below --- set to some arbitrary high value. *)
(* fun loop f state = loop f (f state) *)
let rec loopf (f (); loop f)let rec vec2strv implode (map (chr o toInt) (foldr  :: nil v))let rec str2vecl fromList (map (fromInt o ord) (explode l))let rec fileTextfname let let  inlet  inlet  in in txtlet rec fileDatafname let let  inlet  inlet  in in vec2str dataexception exception let rec sendconnstr (sendVec (conn,  , str2vec str); ())module let rec parseCmds let let  in in (string c,  , string (dropl isSpace a))let rec quote(string) "`" ^ string ^ "'"let  inlet rec setExamplesDirs examplesDir := sOME s(* exception Error for server errors *)
exception let rec error(msg) raise (error (msg))let rec serveExamplee if (match e with "ccc" -> true "cut-elim" -> true "handbook" -> true "lp-horn" -> true "prop-calc" -> true "units" -> true "church-rosser" -> true "fj" -> true "incll" -> true "mini-ml" -> true "small-step" -> true "alloc-sem" -> true "compile" -> true "fol" -> true "kolm" -> true "modal" -> true "tabled" -> true "arith" -> true "cpsocc" -> true "guide" -> true "lp" -> true "polylam" -> true "tapl-ch13" -> true _ -> false) then (try  with ) else (raise (error ("Unknown example " ^ quote e)))(* Natural numbers *)
let rec getNat(t :: nil) (try  with ) getNat(nil) error "Missing natural number" getNat(ts) error "Extraneous arguments"(* Example specifiers *)
let rec getExample(t :: nil) t getExample(nil) error "Missing example" getExample(ts) error "Extraneous arguments"(* Setting Twelf parameters *)
let rec setParm("chatter" :: ts) chatter := getNat ts setParm(t :: ts) error ("Unknown parameter " ^ quote t) setParm(nil) error ("Missing parameter")let rec exec'conn("quit",  , args) (message "goodbye.\n"; raise (quit)) exec'conn("set",  , args) (setParm (tokens isSpace args); oK) exec'conn("readDecl",  , args) loadString args exec'conn("decl",  , args) decl args exec'conn("example",  , args) serveExample (getExample (tokens isSpace args)) exec'conn(t,  , args) raise (error ("Unrecognized command " ^ quote t))let rec execconnstr (match try  with  with oK -> message "%%% OK %%%\n" aBORT -> message "%%% ABORT %%%\n")let rec stripcrs string (dropr (fun x -> x = '\r') (full s))let rec flashProto() let let  inlet rec isnull'\000' true isnull_ falselet rec recv(u : Server)s let let  inlet  inlet  in in buf := remlet rec send(u : Server)s ( send u) (s ^ "\000") in {init =  (fun () -> message (version ^ "\n%%% OK %%%\n"))(fun () -> message (version ^ "\n%%% OK %%%\n")); reset =  (fun () -> buf := "")(fun () -> buf := ""); send =  sendsend; recv =  recvrecv; done =  (fun () -> ())(fun () -> ())}let rec humanProto() let let  inlet rec isnewl'\n' true isnewl'\r' false isnewl_ falselet rec recv(u : Server)s let let  inlet  inlet  in in buf := remlet rec send(u : Server)s ( send u) ("> " ^ s) in {init =  (fun () -> message (version ^ "\n%%% OK %%%\n"))(fun () -> message (version ^ "\n%%% OK %%%\n")); reset =  (fun () -> buf := "")(fun () -> buf := ""); send =  sendsend; recv =  recvrecv; done =  (fun () -> ())(fun () -> ())}let rec httpProtodir let let  inlet  inlet  inlet  inlet  inlet  inlet  inlet rec isnewl'\n' true isnewl_ falselet rec handlePostRequest(u : Server) let let  inlet  inlet  in in  send u ("HTTP/1.1 200 OK\nContent-Type: text/plain\n" ^ clmsg ^ "\n") send u responseif shouldQuit then raise (quit) else raise (eOF)let rec handleGetRequest(u : Server) let let  inlet  inlet  inlet  inlet  inlet  in in  send u (resp ^ ctmsg ^ clmsg ^ "\r\n") send u contentraise (eOF)()let rec handleRequest(u : Server) if ! method = "GET" then handleGetRequest u else if ! method = "POST" then handlePostRequest u else  send u "HTTP/1.1 500 Server Error\n\n"let rec headerExecs headers := (s :: ! headers)let rec recvContentu (if (size (! ibuf) >= ! contentLength) then handleRequest u else ())let rec parseHeaders() (try  with )let rec interp(u : Server)[] raise (match) interpu[x] ibuf := x interpu(h :: tl) let let  in in if sch = "" then (ibuf := join "\n" tl; parseHeaders (); recvContent u) else (headerExec (stripcr h); interp u tl)let rec recv(u : Server)s (ibuf := ! ibuf ^ s; if ! parsingHeaders then interp u (fields isnewl (! ibuf)) else recvContent u)let rec send(u : Server)s obuf := ! obuf ^ slet rec reset() (parsingHeaders := true; ibuf := ""; obuf := ""; contentLength := 0; headers := []; url := ""; method := "") in {init =  (fun () -> ())(fun () -> ()); reset =  resetreset; send =  sendsend; recv =  recvrecv; done =  (fun () -> ())(fun () -> ())}let rec protoServer(proto : Protocol)portNum let let  inlet  inlet  inlet  inlet rec read_oneconnu() let let  in(* arbitrary buffer size *)
 in if length v = 0 then raise (eOF) else ( recv proto) u (vec2str v)let rec accept_one() let let  inlet  inlet  inlet  inlet  in in try  with  in try  with let rec flashServerport protoServer (flashProto ()) portlet rec humanServerport protoServer (humanProto ()) portlet rec httpServerportdir protoServer (httpProto dir) portend  module