SERVER   server String * String List -> Status       Server  SigINT SIGINT    Timing TIMING    Lexer LEXER    Twelf TWELF     SERVER  struct let  in(* readLine () = (command, args)
     reads a command and and its arguments from the command line.
  *)
let rec readLine() let (* val line = TextIO.inputLine (TextIO.stdIn) *)
(* Fix for MLton, Fri Dec 20 21:50:22 2002 -sweeks (fp) *)
let rec getLine() try  with let  inlet rec trimlss dropl isSpace sslet rec trimrss dropr isSpace sslet  in in if line = "" then ("OS.exit",  , "") else if size (line') = 0 then readLine () else let let  in in (string command',  , string (triml args'))(* tokenize (args) = [token1, token2, ..., tokenn]
     splits the arguments string into a list of space-separated
     tokens
  *)
let rec tokenize(args) tokens isSpace args(* exception Error for server errors *)
exception let rec error(msg) raise (error (msg))let rec quote(string) "`" ^ string ^ "'"(* Print the OK or ABORT messages which are parsed by Emacs *)
let rec issue(oK) print ("%% OK %%\n") issue(aBORT) print ("%% ABORT %%\n")(* Checking if there are no extraneous arguments *)
let rec checkEmpty("") () checkEmpty(args) error "Extraneous arguments"(* Command argument types *)
(* File names, given a default *)
let rec getFile("",  , default) default getFile(fileName,  , default) fileName(* File names, not defaults *)
let rec getFile'("") error "Missing filename" getFile'(fileName) fileName(* Identifiers, used as a constant *)
let rec getId(id :: nil) id getId(nil) error "Missing identifier" getId(ts) error "Extraneous arguments"(* Identifiers, used as a trace specification *)
let rec getIds(ids) ids(* Strategies for %prove, %establish *)
let rec getStrategy("FRS" :: nil) fRS getStrategy("RFS" :: nil) rFS getStrategy(nil) error "Missing strategy" getStrategy(t :: nil) error (quote t ^ " is not a strategy (must be FRS or RFS)") getStrategy(ts) error "Extraneous arguments"let rec strategyToString(fRS) "FRS" strategyToString(rFS) "RFS"(* Booleans *)
let rec getBool("true" :: nil) true getBool("false" :: nil) false getBool(nil) error "Missing boolean value" getBool(t :: nil) error (quote t ^ " is not a boolean") getBool(ts) error "Extraneous arguments"(* Natural numbers *)
let rec getNat(t :: nil) (try  with ) getNat(nil) error "Missing natural number" getNat(ts) error "Extraneous arguments"(* Limits ( *, or natural number) *)
let rec getLimit("*" :: nil) nONE getLimit(t :: ts) sOME (getNat (t :: ts)) getLimit(nil) error "Missing `*' or natural number"let rec limitToString(nONE) "*" limitToString(sOME (i)) toString i(* Tabling strategy *)
let rec getTableStrategy("Variant" :: nil) variant getTableStrategy("Subsumption" :: nil) subsumption getTableStrategy(nil) error "Missing tabling strategy" getTableStrategy(t :: nil) error (quote t ^ " is not a tabling strategy (must be Variant or Subsumption)") getTableStrategy(ts) error "Extraneous arguments"let rec tableStrategyToString(variant) "Variant" tableStrategyToString(subsumption) "Subsumption"(* Tracing mode for term reconstruction *)
let rec getReconTraceMode("Progressive" :: nil) progressive getReconTraceMode("Omniscient" :: nil) omniscient getReconTraceMode(nil) error "Missing tracing reconstruction mode" getReconTraceMode(t :: nil) error (quote t ^ " is not a tracing reconstruction mode\n(must be Progressive or Omniscient)") getReconTraceMode(ts) error "Extraneous arguments"let rec reconTraceModeToString(progressive) "Progressive" reconTraceModeToString(omniscient) "Omniscient"(* Compile options *)
let rec getCompileOpt("No" :: nil) no getCompileOpt("LinearHeads" :: nil) linearHeads getCompileOpt("Indexing" :: nil) indexing getCompileOpt(nil) error "Missing tabling strategy" getCompileOpt(t :: nil) error (quote t ^ " is not a compile option (must be No, LinearHeads, or Indexing ") getCompileOpt(ts) error "Extraneous arguments"let rec compOptToString(no) "No" compOptToString(linearHeads) "LinearHeads" compOptToString(indexing) "Indexing"(* Setting Twelf parameters *)
let rec setParm("chatter" :: ts) chatter := getNat ts setParm("doubleCheck" :: ts) doubleCheck := getBool ts setParm("unsafe" :: ts) unsafe := getBool ts setParm("autoFreeze" :: ts) autoFreeze := getBool ts setParm("Print.implicit" :: ts) implicit := getBool ts setParm("Print.depth" :: ts) depth := getLimit ts setParm("Print.length" :: ts) length := getLimit ts setParm("Print.indent" :: ts) indent := getNat ts setParm("Print.width" :: ts) width := getNat ts setParm("Trace.detail" :: ts) detail := getNat ts setParm("Compile.optimize" :: ts) optimize := getCompileOpt ts setParm("Recon.trace" :: ts) trace := getBool ts setParm("Recon.traceMode" :: ts) traceMode := getReconTraceMode ts setParm("Prover.strategy" :: ts) strategy := getStrategy ts setParm("Prover.maxSplit" :: ts) maxSplit := getNat ts setParm("Prover.maxRecurse" :: ts) maxRecurse := getNat ts setParm("Table.strategy" :: ts) strategy := getTableStrategy ts setParm("Table.strengthen" :: ts) strengthen := getBool ts setParm(t :: ts) error ("Unknown parameter " ^ quote t) setParm(nil) error ("Missing parameter")(* Getting Twelf parameter values *)
let rec getParm("chatter" :: ts) toString (! chatter) getParm("doubleCheck" :: ts) toString (! doubleCheck) getParm("unsafe" :: ts) toString (! unsafe) getParm("autoFreeze" :: ts) toString (! autoFreeze) getParm("Print.implicit" :: ts) toString (! implicit) getParm("Print.depth" :: ts) limitToString (! depth) getParm("Print.length" :: ts) limitToString (! length) getParm("Print.indent" :: ts) toString (! indent) getParm("Print.width" :: ts) toString (! width) getParm("Trace.detail" :: ts) toString (! detail) getParm("Compile.optimize" :: ts) compOptToString (! optimize) getParm("Recon.trace" :: ts) toString (! trace) getParm("Recon.traceMode" :: ts) reconTraceModeToString (! traceMode) getParm("Prover.strategy" :: ts) strategyToString (! strategy) getParm("Prover.maxSplit" :: ts) toString (! maxSplit) getParm("Prover.maxRecurse" :: ts) toString (! maxRecurse) getParm("Table.strategy" :: ts) tableStrategyToString (! strategy) getParm(t :: ts) error ("Unknown parameter " ^ quote t) getParm(nil) error ("Missing parameter")(* extracted from doc/guide/twelf.texi *)
let  in(* serve' (command, args) = ()
     executes the server commands represented by `tokens', 
     issues success or failure and then reads another command line.
     Invariant: tokens must be non-empty.

     All input for one command must be on the same line.
  *)
let rec serve'("set",  , args) (setParm (tokenize args); serve (oK)) serve'("get",  , args) (print (getParm (tokenize args) ^ "\n"); serve (oK)) serve'("Style.check",  , args) (checkEmpty args; check (); serve (oK)) serve'("Print.sgn",  , args) (checkEmpty args; sgn (); serve (oK)) serve'("Print.prog",  , args) (checkEmpty args; prog (); serve (oK)) serve'("Print.subord",  , args) (checkEmpty args; subord (); serve (oK)) serve'("Print.domains",  , args) (checkEmpty args; domains (); serve (oK)) serve'("Print.TeX.sgn",  , args) (checkEmpty args; sgn (); serve (oK)) serve'("Print.TeX.prog",  , args) (checkEmpty args; prog (); serve (oK)) serve'("Trace.trace",  , args) (trace (some (getIds (tokenize args))); serve (oK)) serve'("Trace.traceAll",  , args) (checkEmpty args; trace (all); serve (oK)) serve'("Trace.untrace",  , args) (checkEmpty args; trace (none); serve (oK)) serve'("Trace.break",  , args) (break (some (getIds (tokenize args))); serve (oK)) serve'("Trace.breakAll",  , args) (checkEmpty args; break (all); serve (oK)) serve'("Trace.unbreak",  , args) (checkEmpty args; break (none); serve (oK)) serve'("Trace.show",  , args) (checkEmpty args; show (); serve (oK)) serve'("Trace.reset",  , args) (checkEmpty args; reset (); serve (oK)) serve'("Timers.show",  , args) (checkEmpty args; show (); serve (oK)) serve'("Timers.reset",  , args) (checkEmpty args; reset (); serve (oK)) serve'("Timers.check",  , args) (checkEmpty args; reset (); serve (oK)) serve'("OS.chDir",  , args) (chDir (getFile' args); serve (oK)) serve'("OS.getDir",  , args) (checkEmpty args; print (getDir () ^ "\n"); serve (oK)) serve'("OS.exit",  , args) (checkEmpty args; ()) serve'("quit",  , args) () serve'("Config.read",  , args) let let  in in globalConfig := sOME (read fileName)serve (oK) serve'("Config.load",  , args) (match ! globalConfig with nONE -> (globalConfig := sOME (read "sources.cfg")) _ -> (); serve (load (valOf (! globalConfig)))) serve'("Config.append",  , args) (match ! globalConfig with nONE -> (globalConfig := sOME (read "sources.cfg")) _ -> (); serve (append (valOf (! globalConfig)))) serve'("make",  , args) let let  in in globalConfig := sOME (read fileName)serve (load (valOf (! globalConfig))) serve'("reset",  , args) (checkEmpty args; reset (); serve (oK)) serve'("loadFile",  , args) serve (loadFile (getFile' args)) serve'("readDecl",  , args) (checkEmpty args; serve (readDecl ())) serve'("decl",  , args) serve (decl (getId (tokenize args))) serve'("top",  , args) (checkEmpty args; top (); serve (oK)) serve'("Table.top",  , args) (checkEmpty args; top (); serve (oK)) serve'("version",  , args) (print (version ^ "\n"); serve (oK)) serve'("help",  , args) (print (helpString); serve (oK)) serve'(t,  , args) error ("Unrecognized command " ^ quote t) serveLine() serve' (readLine ()) serve(oK) (issue (oK); serveLine ()) serve(aBORT) (issue (aBORT); serveLine ())let rec serveTop(status) try  with let rec server(name,  , _) (print (version ^ "\n"); init (); (* initialize timers *)
interruptLoop (fun () -> serveTop (oK)); success)end   module