BASIC_STREAM   'a Stream   'a Front empty  cons 'a * 'a Stream    delay (Unit -> 'a Front) -> 'a Stream   expose 'a Stream -> 'a Front   empty 'a Stream   cons 'a * 'a Stream -> 'a Stream       module  module   STREAM   BASIC_STREAM   emptyStream   null 'a Stream -> Bool   hd 'a Stream -> 'a   tl 'a Stream -> 'a Stream   map ('a -> 'b) -> 'a Stream -> 'b Stream   filter ('a -> Bool) -> 'a Stream -> 'a Stream   exists ('a -> Bool) -> 'a Stream -> Bool   take 'a Stream * Int -> 'a List   drop 'a Stream * Int -> 'a Stream   fromList 'a List -> 'a Stream   toList 'a Stream -> 'a List   tabulate (Int -> 'a) -> 'a Stream        Stream  BasicStream BASIC_STREAM     STREAM  struct open BasicStream exception (* functions null, hd, tl, map, filter, exists, take, drop *)
(* parallel the functions in the List structure *)
let rec null(s) null' (expose s) null'(empty) true null'(cons _) falselet rec hd(s) hd' (expose s) hd'(empty) raise (emptyStream) hd'(cons (x,  , s)) xlet rec tl(s) tl' (expose s) tl'(empty) raise (emptyStream) tl'(cons (x,  , s)) slet rec mapfs delay (fun () -> map' f (expose s)) map'f(empty) empty map'f(cons (x,  , s)) cons (f (x),  , map f s)let rec filterps delay (fun () -> filter' p (expose s)) filter'p(empty) empty filter'p(cons (x,  , s)) if p (x) then cons (x,  , filter p s) else filter' p (expose s)let rec existsps exists' p (expose s) exists'p(empty) false exists'p(cons (x,  , s)) p (x) || exists p slet rec takePos(s,  , 0) nil takePos(s,  , n) take' (expose s,  , n) take'(empty,  , _) nil take'(cons (x,  , s),  , n) x :: takePos (s,  , n - 1)let rec take(s,  , n) if n < 0 then raise (subscript) else takePos (s,  , n)let rec fromList(nil) empty fromList(x :: l) cons (x,  , fromList (l))let rec toList(s) toList' (expose s) toList'(empty) nil toList'(cons (x,  , s)) x :: toList (s)let rec dropPos(s,  , 0) s dropPos(s,  , n) drop' (expose s,  , n) drop'(empty,  , _) empty drop'(cons (x,  , s),  , n) dropPos (s,  , n - 1)let rec drop(s,  , n) if n < 0 then raise (subscript) else dropPos (s,  , n)let rec tabulatef delay (fun () -> tabulate' f) tabulate'f cons (f (0),  , tabulate (fun i -> f (i + 1)))end   module  module